#! /bin/bash
#
# stackfuser - generate sharp aligned images from stackshots
#

Version="0.1"

#### Messages, Log

error() {
  echo "stackfuser ERROR: $*" >&2
  showmessage "$(shortpath "$*")"
  showpercent error
}
failure() {
  echo "stackfuser Failure: $*" >&2
  showmessage "$(shortpath "$*")"
}
note() {
  echo "stackfuser: $*"  >&2
  showmessage "$(shortpath "$*")"
}
notify() {
  note "$*"
  notify-send "stackfuser: $*" >/dev/null 2>&1 & 
}
verbose() {
  echo "stackfuser: $*" >&2
}
warning() {
  echo "stackfuser WARNING: $*" >&2
  showmessage "$(shortpath "$*")"
}
historyentry() {
  local Historyfile
  Historyfile="$(storeinfo dump history)"
  [ "$Historyfile" ] && echo "$*" >> "$Historyfile"
}
showmessage() {
  sendkaptain "wizardlog='$(cut -c1-100 <<< "${1:-}")'"
}
shortpath() {
  LC_ALL=C sed "s!$Projecthome!.!g" <<< "${1:-}"
#  echo "${1:-}"
}

#### misc

checkvar() {
  local Arg

  Arg="${1:-}"
  [ "$(cut -c1 <<< "$Arg")" = "-" ] && shift || Arg=""

  [ -z "${3:-}" ] && {
    failure "${1:-}: Variable ${2:-} is empty."
    return 1
  }
  
  case "$Arg" in
    -d) 
      [ -d "${3:-}" ] || {
        failure "${1:-}: ${2:-} is not a directory: ${3:-}"
        return 1
      }
    ;;
    -e) 
      [ -e "${3:-}" ] || {
        failure "${1:-}: ${2:-} does not exist: ${3:-}"
        return 1
      }
    ;;
  esac
  case "$Arg" in
    -D) 
      check_fileglob "${3:-}/*" || {
        failure "${1:-}: ${2:-}: directory is empty: ${3:-}"
        return 1
      }
    ;;
    -E) 
      [ -s "${3:-}" ] || {
        failure "${1:-}: ${2:-}: file is empty: ${3:-}"
        return 1
      }
    ;;
  esac
  return 0
}
freememory() {
  local Freemem Line Zram
  Freemem="$(LC_ALL=C free | grep "Mem:" | awk '{print $7}')"
  while read Line; do
    Zram="$(awk '{print ($3 - $4)}' <<< "$Line")"
    Zram="$((Zram/1000))"
    Freemem="$((Freemem + Zram))"
  done < <(/sbin/swapon --bytes | grep zram)
  Freemem="$((Freemem*100/95))"
  echo $Freemem
}
milisleep() {
  local Time 
  Time="$(awk "BEGIN { print ${1:-1000} / 1000 }")"
  sleep $Time
}
printnum(){
  # print number $1 with leading zeroes.
  # $1 number
  # $2 digits. Default: 3
  printf %0${2:-3}d "${1:-0}"
}
storeinfo() {
  # store and provide pieces of information
  # replace entry if codeword is already present
  # Store as codeword=string:
  #   $1 codeword=string
  # Dump stored string:
  #   $1 dump
  #   #2 codeword
  # Drop stored string:
  #   $1 drop
  #   #2 codeword
  # Test for codeword: (return 1 if not found)
  #   $1 test
  #   $2 codeword
  #
  [ -e "$Storeinfofile" ] || return 1
  case "${1:-}" in
    dump) grep     "^${2:-}="   $Storeinfofile | sed "s/^${2:-}=//" ;;      # dump entry
    drop) sed -i  "/^${2:-}=/d" $Storeinfofile ;;                           # drop entry
    test) grep -q  "^${2:-}="   $Storeinfofile ;;                           # test for entry
    *)                                                                      # store entry
      sed -i "/^$(echo "${1:-}" | cut -d= -f1)=/d"     $Storeinfofile       # drop possible old entry
      echo "${1:-}"                                 >> $Storeinfofile
    ;;
  esac
}
storepid() {
  # store pid and command name. Use in finish() to kill background processes
  echo "$(ps -p ${1:-} -h -o pid -o comm)" >> $Storepidfile
}
zeronumber() {
  printf "%04d" "${1:-}"
}

#### file operations

cut_extension() {
  local Extension
  Extension="$(get_extension "${1:-}")"
  sed "s%\.${Extension}\$%%" <<< "${1:-}"
}
check_dirglob() {
  # check whether directories exist for quoted glob $1
  [ -f "${1:-}" ] && return 1
  [ -n "$(eval find ${1:-} -maxdepth 0 -type d -print -quit 2>/dev/null)" ]
}
check_fileglob() {
  # check whether files exist for quoted glob $1
  [ -n "$(eval find ${1:-} -maxdepth 0 -type f -print -quit 2>/dev/null)" ]
}
check_stackdir() {
  # Check $1 if it is a valid directory containing a subfolder stackshot
  local Stackdir Newstackdir Stackdirvalid Projectname Projecthome
  
  Stackdir="$(storeinfo dump stackshotdir)"
  Newstackdir="${1:-}"
  Newstackdir="${Newstackdir:-$Stackdir}"
  Newstackdir="${Newstackdir%/}"
  
  Projecthome="$(storeinfo dump projecthome)"
  
  [ -z "$Newstackdir" ]   && failure "No stackshot directory given." && return 1
  [ ! -d "$Newstackdir" ] && failure "Not a directory: $Newstackdir" && return 1
  
  [ -d "$Newstackdir/stackshot" ] && Stackdirvalid="yes" || Stackdirvalid="no"

  [ "$Stackdirvalid" = "no" ] && [ "${Newstackdir%/stackshot}" != "$Newstackdir" ] && {
    Newstackdir="${Newstackdir%/stackshot}"
    Stackdirvalid="yes"
  }
    
  storeinfo "stackshotdir=$Newstackdir"
  case "$Stackdirvalid" in
    yes)
      storeinfo "stackshotdir_valid=yes"
      storeinfo "history=$Newstackdir/wizard.history"

      grep -q "$Projecthome" <<< "$Newstackdir" && {
        Projectname="${Newstackdir#$Projecthome/}"
        Projectname="$(dirname "$Projectname")"
        [ "$Projectname" = "$(basename "$Newstackdir")" ] && Projectname=""
        [ "$Projectname" = "." ]                          && Projectname=""
      }
      [ "$Projectname" ] && storeinfo "projectdir=$Projecthome/$Projectname" || storeinfo drop projectdir
      [ -z "$Projecthome" ] && Projectname="np"
      [ -z "$Projectname" ] && Projectname="np"
      storeinfo "projectname=$Projectname"
      return 0
    ;;
    no)
      storeinfo drop stackshotdir_valid
      storeinfo drop history
      storeinfo "projectname=np"
      [ "$(storeinfo dump allow_dir_invalid)" = "yes" ] && return 0 || return 1
    ;;
  esac
}
dirglob() {
  # echos files only for glob $1
  #local Path Glob 
  local Filelist Whitespace
  
  #[ -d "${1:-}" ] && {
  #  Path="${1:-}"
  #  Glob="*"
  #} || {
  #  Path="$(dirname  "${1:-}")"
  #  Glob="$(basename "${1:-}")"
  #}
  #Path="$(realpath "$Path")"
  
  [ "${1:-}" = "-w" ] && Whitespace="yes" && shift
  
  Filelist="$(eval find ${1:-} -maxdepth 0 -type d 2>/dev/null)"
  Filelist="$(sort -V <<< "$Filelist")"
  
  [ "$Whitespace" ] && Filelist="$(echo $Filelist)"
  
  [ "$Filelist" ] && echo "$Filelist" || return 1
}
fileglob() {
  # echos files only for glob $1
  #local Path Glob 
  local Filelist Whitespace
  
  #[ -d "${1:-}" ] && {
  #  Path="${1:-}"
  #  Glob="*"
  #} || {
  #  Path="$(dirname  "${1:-}")"
  #  Glob="$(basename "${1:-}")"
  #}
  #Path="$(realpath "$Path")"
  
  [ "${1:-}" = "-w" ] && Whitespace="yes" && shift
  
  Filelist="$(eval find ${1:-} -maxdepth 0 -type f 2>/dev/null)"
  Filelist="$(sort -V <<< "$Filelist")"
  
  [ "$Whitespace" ] && Filelist="$(echo $Filelist)"
  
  [ "$Filelist" ] && echo "$Filelist" || return 1
}
get_extension() {
  local Filename Extension
  Filename="$(head -n1 <<< "${1:-}")"
  Extension="$(rev <<< "$Filename" | cut -d/ -f1 | cut -d. -s -f1 | rev)"
  echo "$Extension"
}
mycp() {
  # copy quoted glob $1 to directory $2
  check_fileglob "${1:-}" || {
    verbose "cp: Source is empty: ${1:-}"
    return 1
  }
  [ -d "${2:-}" ] || {
    failure "cp: Target is not a directory: ${2:-}"
    return 1
  }
  #verbose "cp: copy ${1:-} to $(basename "${2:-}")"
  cp $(fileglob "${1:-}") "${2:-}"
}
mymv() {
  # move quoted glob $1 to directory $2
  check_fileglob "${1:-}" || {
    verbose "mv: Source is empty: ${1:-}"
    return 1
  }
  [ -d "${2:-}" ] || {
    failure "mv: Target is not a directory: ${2:-}"
    return 1
  }
  #verbose "mv: moving ${1:-} to $(basename "${2:-}")"
  mv -f $(fileglob "${1:-}") "${2:-}"
}
myrm() {
  # remove files
  # $@ quoted globs
  local Line
  for Line in "$@" ; do
    check_fileglob "$Line" && {
      verbose "rm: Deleting $Line"
      rm $(fileglob "$Line")
    }
  done
}
myrmdir() {
  # remove directories and their content
  # $@ quoted globs
  local Line
  for Line in "$@" ; do
    check_dirglob "$Line"  && {
      verbose "rmdir: Deleting $Line"
      rm -rf $Line
    }
  done
}
setup_workdir() {
  # Detect possible source directories in $2 for function $1
  # Set up variables that can be used to call function $1
  # Usage:
  #   setup_workdir Function Targetdir
  # Args:
  #   Function       One of align, sharpen, fuse, median, min, max, mean, set
  #   Targetdir      Target directory [+glob] to check.
  #                  Can already be in an ardustack-structure or an arbitrary one.
  #                  Location of $Destinationdir depends on detected directory structure.
  #   Opt2   Mode of Function
  # Sets variables:
  #   Sourcedir                 Source directory within $Targetdir
  #   Sourcefileglob            Glob to get files. Mostly just "*"
  #   Destinationdir            Recommended directory to store resulting images.
  #                             Often serves as source dir for following functions.
  #   Destinationfile   Possible prefix of destination file(s). Can be "", though.
  #   Targetcachedir            Cache folder
  #
  # Run in a loop to check for next possible source dir in Targetdir.
  # Returns 0 on success and 1 if nothing more is to do.
  #
  # Stores already checked source dirs of $Targetdir in $Sourcedirchecklist. 
  # -> Set Sourcedirchecklist="" before running a loop with setup_workdir().
  # Use local in calling function:
  #   local Sourcedir Sourcefileglob Destinationdir Destinationfile Targetptofile Targetcachedir Sourcedirchecklist

  local Targetnewdir Targetprevdir 
  #local Targetstackshotdir
  #local Targetmagickdir Targetfusedir Targetevaluatedir Targetcomposedir Targetcachedir
  local Projectname
  local Imageformat

  Function="${1:-}"
  Targetdir="${2:-}"
  Sourcefileglob="${3:-*}"
  
  Function="${Function%magick}"
  Destinationdir=""
  Destinationfile=""

  Targetdir="$(realpath "$Targetdir")"
  [ -d "$Targetdir" ] || {
    failure "No target directory found. Please specify a target directory or make a stackshot.
  Wrong Target: $Targetdir"
    return 1
  }
  Projectname="$(storeinfo dump projectname)"
  
  [ -d "$Targetdir/stackshot" ]          && Targetstackshotdir="$Targetdir/stackshot" || Targetstackshotdir="$Targetdir"
  [ -d "$Targetdir/stackshot-median" ]   && Targetstackshotdir="$Targetdir/stackshot-median"
  Targetmagickdir="$Targetdir/magick"
  Targetfusedir="$Targetdir/fuse"
  Targetcomposedir="$Targetdir/compose"
  Targetevaluatedir="$Targetdir/evaluate"
  Targetvideodir="$Targetdir/video"
  
  Targetcachedir="$Targetdir/cache"
  myrmdir     "$Targetcachedir"
  mkdir -p "$Targetcachedir"
  Cachedir="$Targetcachedir"
  
  grep -q -- "fuse" <<< "$Function"      && Targetnewdir="$Targetfusedir"
  grep -q -- "compose" <<< "$Function"   && Targetnewdir="$Targetcomposedir"
  grep -q -- "evaluate" <<< "$Function"  && Targetnewdir="$Targetevaluatedir" 
  grep -q -- "animation" <<< "$Function" && Targetnewdir="$Targetvideodir" 
  grep -q -- "video" <<< "$Function"     && Targetnewdir="$Targetvideodir" 
  [ "$Targetnewdir" ] || Targetnewdir="$Targetmagickdir"
  
  [ "$Targetnewdir" = "$Targetmagickdir" ] && {
    mkdir -p $Targetnewdir
    check_fileglob "$Targetmagickdir/$Sourcefileglob" || {
      Imageformat="$(get_extension "$(fileglob "$Targetstackshotdir/$Sourcefileglob")")"
      grep -q -i -x "$Imageformat" <<< "$Imageformatlist" && {
        mycp "$Targetstackshotdir/$Sourcefileglob" "$Targetmagickdir" || return 1
        :
      } || {
        imageformat -2 "tif" -s "$Targetstackshotdir" -g "$Sourcefileglob" -d "$Targetmagickdir" || return 1
      }
    }
  }
  Targetprevdir="$Targetnewdir.bak"

  # backup for undo, serving also as source for batch operations
  case $Function in
    undo*) ;;
    evaluate*)
      mkdir -p $Targetprevdir
      check_fileglob "$Targetnewdir/*" && mycp "$Targetnewdir/*" "$Targetprevdir/" 
      mkdir -p $Targetcomposedir.bak 
      check_fileglob "$Targetcomposedir/*" && mycp "$Targetcomposedir/*" "$Targetcomposedir.bak/" 
    ;;
    animation*|video*|fuse*)
      mkdir -p $Targetprevdir
      check_fileglob "$Targetnewdir/*" && mycp "$Targetnewdir/*" "$Targetprevdir/" 
    ;;
    *)
      mkdir -p $Targetprevdir
      myrm "$Targetprevdir/*"
      check_fileglob "$Targetnewdir/*" && mymv "$Targetnewdir/*" "$Targetprevdir/"
    ;;
  esac

  case $Function in
    fuse)
      Sourcedir="$Targetmagickdir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir")"
    ;;
      
    evaluate)
      Sourcedir="$Targetmagickdir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir").$(basename "$Sourcedir")"
      mkdir -p $Targetcomposedir
    ;;
    evaluatefuse)
      Sourcedir="$Targetfusedir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir").$(basename "$Sourcedir")"
      mkdir -p $Targetcomposedir
    ;;
    compose)
      Sourcedir="$Targetevaluatedir"
      Destinationdir="$Targetnewdir"
      #Destinationfile="$Projectname.$(basename "$Targetdir").$(basename "$Sourcedir")"
    ;;
    
    align*|brightness*|contrast*|crop*|cuberotate*|imageformat*|lightbalance*|gamma*|level*|orient*|rotate*|ruler*|sharpen*|statistic*|evalstep*|stretch*|wizard*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
      
    whitebalance*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
    
    animation|video)
      Sourcedir="$Targetmagickdir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir")"
    ;;
    
    undo*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
    
    *)
      failure "setup_workdir(): Function not defined: $Function"
      return 1
    ;;
  esac
  
  [ "$Sourcedir" = "$Targetmagickdir" ] && {
    mkdir -p $Targetmagickdir
    check_fileglob "$Targetmagickdir/$Sourcefileglob" || mycp "$Targetstackshotdir/$Sourcefileglob" "$Targetmagickdir"
  }
  check_fileglob "$Sourcedir/$Sourcefileglob" || {
    failure "setup_workdir(): No source found: $Sourcedir/$Sourcefileglob"
    return 1
  }
  
  [ "$Destinationdir" ] || {
    failure "setup_workdir(): Destinationdir not specified"
    return 1
  }
  mkdir -p "$Destinationdir"
  
  return 0
}

#### show images

showimage() {
  local Imagelist Image Shrinkimage
  Imagelist="$(fileglob "${1:-}")" >&2
  case $(grep -c . <<< "$Imagelist") in
    0) 
      failure "showimage: Not found: ${1:-}"
      Image="$(storeinfo dump notfoundimage)"
      [ -e "$Image" ] || $Magickbin -size 300x200 xc:red -fill black -pointsize 20 -gravity center -draw "text 0,0 'image not found'" "$Image"
      geeqie -t -r File:"$Image" 1>&2
      storeinfo drop showimage
      return 1
    ;;
    1) 
      Image="$Imagelist"
      case "$(get_extension "$Image")" in
        gif)
          case $(identify "$Image" | grep -c GIF) in
            1) 
              geeqie -t -r File:"$Image" 1>&2
              storeinfo   "showimage=$Image"
            ;;
            *) showvideo "$Image" ;;
          esac
        ;;
        mp4|webm) 
          showvideo "$Image" 
        ;;
        *)       
          geeqie -t -r File:"$Image" 1>&2
          storeinfo   "showimage=$Image"
        ;;
      esac
    ;;
#    1) geeqie -t -r File:"$Imagelist" ;;
    *) viewnior           $Imagelist 1>&2 & ;;
  esac
  return 0
}
showvideo() {
  ffplay -window_title "$(basename "${1:-}")" -loglevel error -loop 0 "${1:-}" & storepid $!
}

#### batch functions

batch_function() {
  # Apply image processing function $1 on all possible source dirs in target directory $2, options in $3

  local $Batchlocal
  local Return=0
  local Gallerydir Image
  local Startzeit

  parse_batchoptions "$@"                  || return 1
  checkvar -d batch Targetdir "$Targetdir" || return 1
  checkvar    batch Function  "$Function"  || return 1
  check_stackdir "$Targetdir" || {
    failure "batch_function(): Invalid directory: $Targetdir"  
    return 1
  }
  
  ifcmdbreak && return 1
  
  setup_workdir "$Function" "$Targetdir" "$Sourcefileglob" || {
    failure "batch $Function: no source found in $Targetdir
    $@"
    return 1
  }
  cd "$Targetdir"
  
  case $Function in
    compose|fuse|evaluate) ;;
    *)
      Function="${Function%magick}"
      Function="${Function%compose}"
      Function="${Function%evaluate}"
      Function="${Function%fuse}"
    ;;
  esac
  Function="${Function%_}"
  case "$Function" in
    brightness|contrast|gamma|level|orient|prepare|rotate|sharpen|statistic|stretch|wizard)
      Opt2="$Opt1 $Opt2 $Opt3"
      Opt3=""
      Opt2="${Opt2# }"
      Opt2="${Opt2# }"
      Opt2="${Opt2% }"
      Opt2="${Opt2% }"
      Opt1="$Function"
      Function="wizard"
    ;;
  esac

  ### FIXME
  checkvar           -D "$Function" Sourcedir      "$Sourcedir"        || return 1
  checkvar           -d "$Function" Destinationdir "$Destinationdir"   || return 1
  case $Function in
    undo|compose) ;;
    *) checkvar         $Function Sourcefileglob   "$Sourcefileglob"   || return 1 ;;
  esac
  case $Function in
    wizard) checkvar    $Function Opt1     "$Opt1"     || return 1 ;;
  esac
  case $Function in
    align*|crop|undo|whitebalance)
      checkvar       -d $Function Cachedir         "$Cachedir"         || return 1 ;;
  esac
  
  [ -z "$Opt1" ] && case "$Function" in
    compose|evaluate|fuse) Opt1="all" ;;
  esac
  
  note "$Function $Opt1 $Opt2"
  storeinfo "cmd=$@"
  storeinfo "cmd_source=$Sourcedir"
  storeinfo "cmd_destination=$Destinationdir"
  storeinfo "cmd_cache=$Cachedir"
  cd "$Cachedir"
  verbose "batch_function(): $Function -1 '$Opt1' -2 '$Opt2' -3 '$Opt3' -4 '$Opt4' -5 '$Opt5' -6 '$Opt6' -7 '$Opt7' -8 '$Opt8' -9 '$Opt9' -s '$Sourcedir' -g '$Sourcefileglob' -d '$Destinationdir' -b '$Destinationfile' -c '$Cachedir'"
  Startzeit="$(date +%s)"
  $Function -1 "$Opt1" -2 "$Opt2" -3 "$Opt3" -4 "$Opt4" -5 "$Opt5" -6 "$Opt6" -7 "$Opt7" -8 "$Opt8" -9 "$Opt9" -s "$Sourcedir" -g "$Sourcefileglob" -d "$Destinationdir" -b "$Destinationfile" -c "$Cachedir"
  Return=$?
  note "Ready: $Function $Opt1 $Opt2 $Opt3 $Opt4; time: $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")"
  cd "$Targetdir"
  storeinfo drop cmd
  storeinfo drop cmd_source
  storeinfo drop cmd_destination
  storeinfo drop cmd_cache
  
  [ "$Return" = "0" ] || {
    failure "ERROR in $Function $Opt1 $Opt2 $Opt3: $(basename "$Sourcedir") -> $(basename "$Destinationdir")"
    case $Function in
      animation|video) ;;
      evaluate) 
        undo -s "$Destinationdir.bak"   -d "$Destinationdir"   -c "$Cachedir" 
        undo -s "$Targetcomposedir.bak" -d "$Targetcomposedir" -c "$Cachedir" 
      ;;
      compose|fuse) 
        undo -s "$Destinationdir.bak" -d "$Destinationdir" -c "$Cachedir" 
      ;;
      *)                     undo -s "$Sourcedir"          -d "$Destinationdir" -c "$Cachedir" ;;
    esac
  }
  
  storeinfo test rmcache && rm -R "$Cachedir"
  
  [ "$Return" = "0" ] && [ "$(basename "$Destinationdir")" = "evaluate" ] && {
    
    storeinfo test stackshotdir_valid && {
      # link magick.max
      ls $Destinationdir/*magick.max* >/dev/null 2>&1 && {
        ln -f $(fileglob "$Destinationdir/*.magick.max.*") "$Destinationdir/../"
      }
    
      # link fuse.median results
      ls $Destinationdir/*fuse.median* >/dev/null 2>&1 && {
        # link fuse.median result into parent directory
        for Set in $(seq $Fusesetnumber); do
          Image="$(fileglob "$Destinationdir/*.fuse.median.set${Set}.*")"
          [ -e "$Image" ] && ln -f "$Image" "$Destinationdir/../"
        done
        
        # link into project dir
        [ "$(storeinfo dump projectname)" != "np" ] && {
          Image="$(find $Destinationdir/*.fuse.median.set2.* $Destinationdir/*.fuse.median.* -type f | head -n1)"
          [ -e "$Image" ] && ln -f "$Image" "$Destinationdir/../../"
        }
      }
      
      # link fuse.median result into $Gallerydir directory
      Gallerydir="$(storeinfo dump gallerydir)"
      [ -d "$Gallerydir" ] && {
        Image="$(find $Destinationdir/*.fuse.median.set2.* $Destinationdir/*.fuse.median.* -type f | head -n1)"
        ln -f "$Image" "$Gallerydir"
      }
    }
  }
  verbose "batch_function(): $Function: return $Return"
  [ "$Return" = "0" ] && [ "$(basename "$Destinationdir")" = "fuse" ] && storeinfo "refreshgui_fuse=yes"

  return $Return
}
parse_batchoptions() {
  # To be called by batch functions to parse options.
  # Include this local line in the calling function:
  #   local Targetdir Sourcedir Sourcefileglob Destinationdir Destinationfile Cachedir Function Opt1 Opt2

  local Shortoptions Longoptions Parsedoptions
  local Error
  
  Shortoptions="b:c:d:f:g:m:o:s:t:1:2:3:4:5:6:7:8:9:"
  Longoptions=""

  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@" )"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ] ; do
    case "${1:-}" in
      -t) Targetdir="${2:-}" ;;
      -s) Sourcedir="${2:-}" ;;
      -g) Sourcefileglob="${2:-}" ;;
      -d) Destinationdir="${2:-}" ;;
      -b) Destinationfile="${2:-}" ;;
      -c) Cachedir="${2:-}" ;;
      -f) Function="${2:-}" ;;
      -1) Opt1="${2:-}" ;;
      -2) Opt2="${2:-}" ;;
      -3) Opt3="${2:-}" ;;
      -4) Opt4="${2:-}" ;;
      -5) Opt5="${2:-}" ;;
      -6) Opt6="${2:-}" ;;
      -7) Opt7="${2:-}" ;;
      -8) Opt8="${2:-}" ;;
      -9) Opt9="${2:-}" ;;
      --) ;;
      *) 
        failure "Unbekannte Option ${1:-} ($Function)" 
        Error=1
      ;;
    esac
    shift
    shift
  done

  [ "$Sourcefileglob" ] || Sourcefileglob="*"
  #[ ! -d "$Sourcedir" ]      && failure "$Function: source dir not found: $Sourcedir" && return 1
  #[ ! -d "$Destinationdir" ] && failure "$Function: destination dir not found: $Destinationdir"&& return 1
  #! check_fileglob "$Sourcedir/$Sourcefileglob" && failure "$Function: No source files found: $Sourcedir/$Sourcefileglob"  && return 1
  return ${Error:-0}
}
getbatchtwo() {
  local Command= Line Argument
  for Line in rotate gamma level contrast sharpen brightness stretch statistic wizard; do
    Argument="$(askkaptain "$Line")"
    [ "$Argument" ] && case $Line in
      brightness) Line="-brightness-contrast" ;;
      contrast)   Line="-sigmoidal-contrast" ;;
      rotate)     Line="-rotate" ; Argument="$(askkaptain rotateopt1combo)" ;;
      sharpen)    Line="-adaptive-sharpen" ;;
      statistic)  Line="-statistic" ; Argument="$(askkaptain statisticopt1combo) $(askkaptain statisticopt2combo)" ;;
      stretch)    Line="-contrast-stretch" ;;
      wizard)     Line="" ;;
      *)          Line="-$Line" ;;
    esac
    case $Argument in
      "") ;;
      auto) Command="$Command -auto$Line" ;;
      *)    Command="$Command $Line $Argument" ;;
    esac
  done
  echo "$Command"
}
getfunctionsettings() {
  local Function
  Function="${1:-none}"
  Opt1="$(askkaptain -c ${Function}opt1combo)"
  Opt2="$(askkaptain -c ${Function}opt2combo)"
  Opt3="$(askkaptain -c ${Function}opt3combo)"
  Opt4="$(askkaptain -c ${Function}opt4combo)"
  Opt5="$(askkaptain -c ${Function}opt5combo)"
  Opt6="$(askkaptain -c ${Function}opt6combo)"
  Opt7="$(askkaptain -c ${Function}opt7combo)"
  Opt8="$(askkaptain -c ${Function}opt8combo)"
  Opt9="$(askkaptain -c ${Function}opt9combo)"
}
runbatchone() {
  local $Batchlocal
  local Iterate
  for Function in orient crop whitebalance align_vidstab align_hugin align_ais; do
    askkaptain -c $Function > /dev/null && {
      getfunctionsettings $Function
      cmd -f "$Function" -1 "$Opt1" -2 "$Opt2" -3 "$Opt3" -4 "$Opt4" -5 "$Opt5" -6 "$Opt6" -7 "$Opt7" -8 "$Opt8" -9 "$Opt9" -t "$Stackdir"
    }
  done
  return 0
}
runbatchtwo() {
  local $Batchlocal
  Stackdir="${1:-}"
  cmd -f wizard -1 "$(getbatchtwo)" -t "$Stackdir"
}
runbatchthree() {
  askkaptain evaluate1 >/dev/null        && cmd -f evaluatemagick -t "$Stackdir"
  askkaptain fuse >/dev/null             && cmd -f fuse -1 "all" -t "$Stackdir"
  askkaptain evaluate2 >/dev/null        && cmd -f evaluatefuse -t "$Stackdir"
  askkaptain deletebackups2 >/dev/null   && cmd -f deletebackups -t "$Stackdir"
  askkaptain deletemagick2  >/dev/null   && cmd -f deletemagick -t "$Stackdir"
  cmd -f showimage -s "$Stackdir/evaluate" -g "*fuse.median*"
}
setup_imagelist() {
  # Set up often needed image variables
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagenumber="$(grep -c . <<< "$Imagelist")"
  Image="$(head -n1 <<< "$Imagelist")"
  [ -z "$Image" ] && {
    failure "No images found"
    return 1
  }
  Imagewidth=$($Magickbin  -format '%w' "$Image" info:)
  Imageheight=$($Magickbin -format '%h' "$Image" info:)
  Imageformat="$(get_extension        "$Image")"
  Imagememsize="$((Imagewidth*Imageheight*Magickpixelmemory/1000))"
  Imagememsize="$((Imagememsize*125/100))" # by observation. Alpha channel? Meta data?
  Imagelistmemsize="$((Imagememsize*Imagenumber))"
  LC_ALL=C file $Image | grep -q "raw image" && Imageraw="yes" || Imageraw="no"
  Image=""
  Imagecount=0
  Cropgeometry=""
  verbose "setup_imagelist(): $Sourcedir
  Image number:   $Imagenumber
  Image width :   $Imagewidth
  Image height:   $Imageheight
  Image format:   $Imageformat
  Image mem size: $Imagememsize
  List  mem size: $Imagelistmemsize
  Raw image:      $Imageraw"
}

#### image sequence operations

align_ais() {

  local $Batchlocal
  local $Imagelocal
  local Alignlist
  local Aligndir Distortdir
  local Cropminimage Rotate
  local Stackcount Stacklist Firstimage Step Stepsize
  local Startzeit Dauer Restzeit
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  [ "$Opt1" ] && Opt1="-m"
  Stepsize=10

  note "align_ais: Running align_image_stack with $Stepsize images on each iteration.
  "
  Stackcount=0
  Startzeit="$(date +%s)"
  for Step in 0 $(seq $((Imagenumber/$Stepsize)) ); do
    showpercent $((Step*Stepsize)) $Imagenumber
    ifcmdbreak && break
    [ "$Error" ] && break
    Stackcount="$((Stackcount+1))"
    Stacklist="$(tail -n+$((Stepsize*Step+1)) <<< "$Imagelist" | head)"
    [ -z "$Stacklist" ] && break
    Aligndir=$Cachedir/align.$Stackcount
    mkdir $Aligndir
    nice align_image_stack $Opt1 -v -l -g3 --use-given-order -p $Cachedir/ais.$Stackcount.pto -a $Aligndir/align $Firstimage $Stacklist || Error=1
    Firstimage="$(fileglob "$Aligndir/align*" | tail -n1)"
    showimage $Firstimage
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-((Step+1)*Stepsize)) / ((Step+1)*Stepsize) ))"
    [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
    note "align_ais: Duration: $(date -u -d @$Dauer +"%T"); Estimated time left: $(date -u -d @$Restzeit +"%T") ($Restzeit)"
  done
  
  ifcmdbreak   && return 1
  [ "$Error" ] && return 1
  
  Distortdir=$Cachedir/result
  mkdir $Distortdir
  Count=0
  for Aligndir in $(dirglob "$Cachedir/align*"); do
    [ "$Count" = "0" ] || rm $Aligndir/align0000.tif
    for Image in $(fileglob "$Aligndir/*"); do
      ifcmdbreak && break
      Count=$((Count+1))
      mv $Image $Distortdir/align$(zeronumber $Count).tif
    done
  done

  Alignlist="$(fileglob "$Distortdir/*")"

  # crop greatest common inner rectangle of distorted images
  note "align_ais(): Generating min image of aligned images."
  Cropminimage="$Cachedir/distorted.min.tif"
  #$Magickbin $Alignlist -evaluate-sequence min "$Cropminimage" || return 1
  evaluate_split -s $Distortdir -g "*" -1 min -b $Cropminimage -c $Cachedir || return 1
  case $Cropinteractive in
    yes) notify-send "align_ais: Ready for interactive crop"
         Cropgeometry="$(cropgeometry_interactive "$Cropminimage" "$Cachedir")"   || return 1 ;;
    *)   Cropgeometry="$(trim_hard "$Cropminimage" "$Cropgeometry")"              || return 1 ;;
  esac
  
  Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
  Rotate="${Rotate:-0}"
  Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
      
  [ "$Cropgeometry" ] || {
    failure "align_ais: crop geometry is empty"
    return 1
  }
  
  note "align_ais: Cropping images with rotation $Rotate and geometry $Cropgeometry"
  Imagecount=0
  Startzeit="$(date +%s)"
  for Image in $Alignlist; do
    Imagecount="$((Imagecount + 1))"
    Destinationfile="$(head -n$Imagecount <<< "$Imagelist" | tail -n1)"
    Destinationfile="$Destinationdir/$(basename $Destinationfile)"
    multicore "$Magickbin $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && return 1
    showpercent $Imagecount $Imagenumber
    Restzeit="$(( Dauer*(Imagenumber-Imagecount) / Imagecount ))"
    note "align_ais: Cropping to $Cropgeometry. Duration: $(date -u -d @$Dauer +"%T"); Estimated time left: $(date -u -d @$Restzeit +"%T") ($Restzeit)"
  done
  multicore_wait || return 1
  return ${Error:-0}
}
align_ais_ONE() {

  local $Batchlocal
  local $Imagelocal
  local Alignlist
  local Distortdir
  local Cropminimage Rotate
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  [ "$Opt1" ] && Opt1="-m"

  Distortdir=$Cachedir/distort
  mkdir $Distortdir
  
  note "align_ais(): Running align_image_stack now. That will take a while."
#  nice align_image_stack -v -v -v -v -v -l $Opt1 -a $Distortdir/align --use-given-order $Imagelist || return 1
  nice align_image_stack $Opt1 -l --use-given-order -v -v -v -v -v -a $Distortdir/align -p $Cachedir/controlpoints.pto $Imagelist || return 1

  Alignlist="$(fileglob "$Distortdir/*")"

  # crop greatest common inner rectangle of distorted images
  note "align_ais(): Generating min image of aligned images."
  Cropminimage="$Cachedir/distorted.min.mpc"
  $Magickbin $Alignlist -evaluate-sequence min "$Cropminimage" || return 1
  case $Cropinteractive in
    yes) notify-send "align_ais: Ready for interactive crop"
         Cropgeometry="$(cropgeometry_interactive "$Cropminimage" "$Cachedir")"   || return 1 ;;
    *)   Cropgeometry="$(trim_hard "$Cropminimage" "$Cropgeometry")"              || return 1 ;;
  esac
  
  Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
  Rotate="${Rotate:-0}"
  Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
      
  [ "$Cropgeometry" ] || {
    failure "align_ais: crop geometry is empty"
    return 1
  }
  
  note "align_ais: Cropping images with rotation $Rotate and geometry $Cropgeometry"
  Imagecount=0
  for Image in $Alignlist; do
    Imagecount="$((Imagecount + 1))"
    Destinationfile="$(head -n$Imagecount <<< "$Imagelist" | tail -n1)"
    Destinationfile="$Destinationdir/$(basename $Destinationfile)"
    multicore "$Magickbin $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || return 1
    showpercent $Imagecount $Imagenumber
  done
  multicore_wait || return 1
}
align_ais_TWO() {

  local $Batchlocal
  local $Imagelocal
  local Imagelist1 Imagelist2 Alignlist
  local Count Imagehalf
  local Part1dir Part2dir Distortdir
  local Cropminimage Rotate
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  [ "$Opt1" ] && Opt1="-m"
  
  Part1dir=$Cachedir/part1
  Part2dir=$Cachedir/part2
  Distortdir=$Cachedir/distort
  mkdir $Part1dir
  mkdir $Part2dir
  mkdir $Distortdir

  Imagehalf=$((Imagenumber/2 +1))
  Count=0
  for Image in $Imagelist; do
    Count=$((Count + 1))
    [ "$Count" -le "$Imagehalf" ] && Imagelist1="$Image $Imagelist1"
    [ "$Count" -ge "$Imagehalf" ] && Imagelist2="$Imagelist2 $Image"
  done

  echo "List1:
$Imagelist1"
  echo "List2:
$Imagelist2"
  showpercent busy
  multicore "align_image_stack -l $Opt1 --gpu -a $Part1dir/align --use-given-order $Imagelist1" || return 1
  multicore "align_image_stack -l $Opt1 --gpu -a $Part2dir/align --use-given-order $Imagelist2" || return 1
  multicore_wait || return 1

  Alignlist="$(fileglob "$Part1dir/*")"
  Count=0
  for Image in $Alignlist ; do
    Destinationfile="$(head -n$((Imagehalf - Count)) <<< "$Imagelist" | tail -1)"
    Destinationfile="$Distortdir/$(basename "$Destinationfile").tif"
    cp -T "$Image" "$Destinationfile"
    Count=$((Count + 1))
    showimage "$Destinationfile"
  done
  Alignlist="$(fileglob "$Part2dir/*")"
  Count=0
  for Image in $Alignlist ; do
    Destinationfile="$(head -n$((Imagehalf + Count)) <<< "$Imagelist" | tail -1)"
    Destinationfile="$Distortdir/$(basename "$Destinationfile").tif"
    cp "$Image" "$Destinationfile"
    Count=$((Count + 1))
    showimage "$Destinationfile"
  done

  # crop greatest common inner rectangle of distorted images
  Cropminimage="$Cachedir/distorted.min.mpc"
  $Magickbin $(fileglob "$Distortdir/*") -evaluate-sequence min "$Cropminimage" || return 1
  case $Cropinteractive in
    yes) notify-send "align_ais: Ready for interactive crop"
         Cropgeometry="$(cropgeometry_interactive "$Cropminimage" "$Cachedir")"   || return 1 ;;
    *)   Cropgeometry="$(trim_hard "$Cropminimage" "$Cropgeometry")"              || return 1 ;;
  esac
  
  Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
  Rotate="${Rotate:-0}"
  Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
  Cropgeometry="$(calc_evengeometry "$Cropgeometry")"
      
  [ "$Cropgeometry" ] || {
    failure "align_ais: crop geometry is empty"
    return 1
  }
  
  note "align_ais: Cropping images with rotation $Rotate and geometry $Cropgeoemtry"
  Imagelist="$(fileglob "$Distortdir/*")"
  Imagecount=0
  for Image in $Imagelist; do
    Imagecount="$((Imagecount + 1))"
    Destinationfile="$Destinationdir/$(basename $Image)"
    Destinationfile="${Destinationfile%.tif}"
    multicore "$Magickbin $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || return 1
    showpercent $Imagecount $Imagenumber
  done
  multicore_wait || return 1
}
align_hugin() {
  # Align image stack with some panotools. Similar to align_image_stack
  
  local $Batchlocal
  local $Imagelocal
  local Pto_ptogen Pto_cpfind Pto_cpclean Pto_result
  local Logfile Aligndir
  local Count
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Logfile="$Cachedir/align_hugin.log"
  :> $Logfile
  
  Pto_ptogen=$Cachedir/align1.pto_gen.pto
  Pto_cpfind=$Cachedir/align2.cpfind.pto
  Pto_cpclean=$Cachedir/align3.cpclean.pto
  Pto_result=$Cachedir/align4.result.pto
  
  Aligndir=$Cachedir/align
  mkdir $Aligndir
  
  #tail -f "$Logfile" &
    
  echo "########## pto_gen ##########" >> "$Logfile"
  note "align_hugin: Running pto_gen to create list of files"
#  pto_gen -o "$Pto_ptogen" -p 0 -f 40 --crop=0,${Imagewidth},0,${Imageheight} $(fileglob $Sourcefileglob) >> "$Logfile" 2>&1 || {
#  pto_gen -o "$Pto_ptogen" -p 0 -f 40 --crop=0,${Imagewidth},0,${Imageheight} $(echo $Imagelist) >> "$Logfile" 2>&1 || {
  pto_gen -p0 -f50 -o "$Pto_ptogen" $(echo $Imagelist) >> "$Logfile" 2>&1 || {
    failure "align_hugin: Error in pto_gen
$(tail $Logfile)"
    return 1
  }
  
  sed -i '3 s/r:CROP//'                     "$Pto_ptogen"
  sed -i '3 s/\bf[0-9]*\b/f0/'              "$Pto_ptogen"
  sed -i "3 s/\bw[0-9]*\b/w${Imagewidth}/"  "$Pto_ptogen"
  sed -i "3 s/\bh[0-9]*\b/h${Imageheight}/" "$Pto_ptogen"
  sed -i "3 s/\bv[0-9]*\b/v50/"             "$Pto_ptogen"
  sed -i "s/v=0/v50/"             "$Pto_ptogen"
  #sed -i "s/v50/v0/"             "$Pto_ptogen"
    
#    pano_modify --projection=0 $Pto_ptogen
#    pano_modify --canvas=${Imagewidth}x${Imageheight} $Pto_ptogen
#    pano_modify --output-type=FUSEDSTACKS $Pto_ptogen

  ifcmdbreak && return 1
  echo "########## cpfind ##########" >> "$Logfile"
  note "align_hugin: Running cpfind to find control points for alignment. That will take a while."
#  cpfind -o "$Pto_cpfind"  \
#        --fullscale \
#        --minmatches 4 \
#        --linearmatch \
#        --linearmatchlen 10 \
#        --ransacmode rpyv \
#        "$Pto_ptogen" 2>&1 >> "$Logfile" || {
#    failure "Error in cpfind
#$(tail $Logfile)"
#    return 1
#  }
  cpfind -o "$Pto_cpfind"  \
        --ransacmode rpyv \
        --linearmatch \
        --linearmatchlen 3 \
        "$Pto_ptogen" 2>&1 >> "$Logfile" || {
    failure "align_hugin: Error in cpfind
$(tail $Logfile)"
    return 1
  }
  showpercent 40 100
#        --linearmatchlen $Count \

  ifcmdbreak && return 1
  echo "########## cpclean ##########" >> "$Logfile"
  note "align_hugin: Running cpclean to remove wrong control points"
  cpclean -s -o "$Pto_cpclean" --pairwise-checking "$Pto_cpfind" >> "$Logfile" || {
    failure "align_hugin: Error in cpclean
$(tail $Logfile)"
    return 1
  }
  showpercent 45 100

  #pano_modify --fov=AUTO -o $Pto_cpclean $Pto_cpclean
  for Count in $(seq $((Imagenumber-1)) ); do
#    pto_var --modify-opt --opt=v,v$Count -o $Pto_cpfind $Pto_cpfind
    echo "v v$Count" >> $Pto_cpfind
  done
    
  # calculate distortion of images to align control points
  ifcmdbreak && return 1
  echo "########## autooptimiser ##########" >> "$Logfile"
  note "align_hugin: Running autooptimiser to transform control points into image distortion"
#  autooptimiser -p -o "$Pto_result" "$Pto_cpclean" >> "$Logfile" || {
  autooptimiser -n -p -a -o "$Pto_result" "$Pto_cpclean" >> "$Logfile" || {
    failure "Error in autooptimiser
$(tail $Logfile)"
    return 1
  }
  showpercent 60 100
  #pano_modify --crop=AUTO $Pto_result

  grep -q "Strange values may result!" < "$Logfile" && {
    failure "align_hugin: Did not find enough control points!
  Check out log file $Logfile
  Probably source images are distorted too much.
  The result might be unuseable."
#    return 1
  }

  # distort images to align them
  ifcmdbreak && return 1
  echo "########## nona ##########" >> "$Logfile"
  note "align_hugin: Running nona to transform images"
  nona -o "$Aligndir/PTO_ALIGN" "$Pto_result" >> "$Logfile" || {
    failure "align_hugin: Error in nona
$(tail $Logfile)"
    return 1
  }
  showpercent 70 100
  
  ifcmdbreak && return 1
  note "align_hugin: Checking crop coordinates of common area of all aligned images"
  evaluate_split -s $Aligndir -g "*" -1 min -b $Cachedir/align_PTO.min.tif -c $Cachedir 
  #$Magickbin $Aligndir/PTO_ALIGN* -evaluate-sequence min $Cachedir/align_PTO.min.tif
  Cropgeometry="$(trim_hard "$Cachedir/align_PTO.min.tif")"
  showpercent 80 100

  ifcmdbreak && return 1
  note "align_hugin: Cropping images"
  Count=0
  for Image in $(fileglob "$Aligndir/PTO_ALIGN*"); do
    Count=$((Count +1))
    Destinationfile="$(sed "${Count}q;d" <<< "$Imagelist")"
    Destinationfile="$(basename "$Destinationfile")"
    Destinationfile="$Destinationdir/$Destinationfile"
    multicore "$Magickbin $Image -crop $Cropgeometry $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
    showpercent $Count $Imagenumber
  done
  multicore_wait || return 1
  return ${Error:-0}
}
align_vidstab() {

  local $Batchlocal
  local $Imagelocal
  local Framedir Distortdir Distortlogfile Cropminimage Commonareaimage
  local Xoffset Yoffset Degree
  local Iterations Prepare Crop
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Opt1="${Opt1:-crop}"
  Iterations="${Opt2:-3}"
  [ "${Opt3:-}" ] && Prepare="yes" || Prepare="no"
  
  # cache setup
  Framedir="$Cachedir/frames"
  mkdir -p "$Framedir"
  Distortdir="$Cachedir/distorted"
  mkdir -p "$Distortdir"
  Cropminimage="distort.min.mpc"
  Commonareaimage="$Cachedir/distorted.commonarea.mpc"
  Distortlogfile="$Cachedir/align_vidstab.log"
  
  
  case "$Prepare" in
    "no")
      note "align_vidstab: Cropping video frames to even geometry and converting to png"
      Cropgeometry="$(calc_evengeometry "${Imagewidth}x${Imageheight}+0+0")"
      [ "$Cropgeometry" != "${Imagewidth}x${Imageheight}+0+0" ] && Crop="-crop $Cropgeometry" || Crop=""
      Imagecount=0
      for Image in $Imagelist; do
        Imagecount="$((Imagecount + 1))"
        Destinationfile="$Framedir/frame$(zeronumber $Imagecount).png"
        multicore "$Magickbin $Image $Crop $Destinationfile" "$Destinationfile" || Error=1
        [ "$Error" ] && break
        showpercent "$Imagecount" "$Imagenumber"
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
      Cropgeometry=""
      showpercent 10 100
    ;;
    "yes")
      note "align_vidstab: Preparing video frames for alignment"
      imageproperties -s "$Sourcedir" -g "$Sourcefileglob" -c "$Cachedir"
      Cropgeometry="$(calc_evengeometry "${Imagewidth}x${Imageheight}+0+0")"
      Imagecount=0
      for Image in $Imagelist; do
        Imagecount="$((Imagecount + 1))"
        Destinationfile="$Framedir/frame$(zeronumber $Imagecount).png"
        multicore "$Magickbin $Image -crop $Cropgeometry -channel red -level ${Imageminlevelred}%x${Imagemaxlevelred}% -channel green -level ${Imageminlevelgreen}%x${Imagemaxlevelgreen}% -channel blue -level ${Imageminlevelblue}%x${Imagemaxlevelblue}% +channel $Destinationfile" "$Destinationfile" || Error=1
        [ "$Error" ] && break
        showpercent "$Imagecount" "$Imagenumber"
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
      Cropgeometry=""
      showpercent 10 100
  
      note "align_vidstab: Balancing video frame brightness"
      whitebalance -1 "full" -2 "mean" -s "$Framedir" -g "*" -d "$Framedir" -c "$Cachedir" || return 1
      showpercent 20 100
    ;;
  esac
  
  align_vidstab_ffmpeg -2 "10" -s "$Framedir" -g "*" -c "$Cachedir" || return 1
  note "align_vidstab: Distorting frames (Shakiness=10)"
  distort -2 "$Cachedir/align.10.log" -s "$Framedir" -g "*" -d "$Distortdir" -c "$Cachedir" || return 1
  showpercent 30 100
  
  [ "$Iterations" -ge "2" ] && {
    mycp "$Distortdir/*" "$Framedir"
    align_vidstab_ffmpeg -2 "5"  -s "$Framedir" -g "*" -c "$Cachedir" || return 1
    note "align_vidstab: Distorting frames (Shakiness=5)"
    distort -2 "$Cachedir/align.5.log" -s "$Framedir" -g "*" -d "$Distortdir" -c "$Cachedir" || return 1
    showpercent 50 100  
  }
  
  [ "$Iterations" -ge "3" ] && {
    mycp "$Distortdir/*" "$Framedir"
    align_vidstab_ffmpeg -2 "1"  -s "$Framedir" -g "*" -c "$Cachedir" || return 1
    showpercent 60 100
  }
  
  myrm "$Framedir/*"
  case $Imageformat in
    png|tif|tiff)
      mycp "$Sourcedir/$Sourcefileglob" "$Framedir"
    ;;
    *)
      imageformat -1 "tif" -s "$Sourcedir" -g "$Sourcefileglob" -d "$Framedir" -c "$Cachedir"
    ;;
  esac
  showpercent 70 100
  
  echo "# Image | Xoffset | Yoffset | Degree" > $Distortlogfile
  echo "# $Magickbin Image -virtual-pixel transparent -distort SRT '0,0 1 Degree Xoffset,Yoffset' out.png" >> $Distortlogfile
  Imagecount=0
  for Image in $(fileglob "$Framedir/*") ; do
    Imagecount="$((Imagecount+1))"
    Image="$(basename "$Image")"
    Xoffset=0
    Yoffset=0
    Degree=0
    for Logfile in $(find $Cachedir/align.*.log); do
      Line="$(sed "${Imagecount}q;d" "$Logfile")"
      Xoffset="$(awk "BEGIN {print $Xoffset + $(cut -d' ' -f2 <<< "$Line") }" )"
      Yoffset="$(awk "BEGIN {print $Yoffset + $(cut -d' ' -f3 <<< "$Line") }" )"
      Degree="$(awk  "BEGIN {print $Degree  + $(cut -d' ' -f4 <<< "$Line") }" )"
    done
    echo "$Image $Xoffset $Yoffset $Degree" >> "$Distortlogfile"
  done
  
  note "align_vidstab: Distorting source images"
  rm $Distortdir/*
  distort -2 "$Distortlogfile" -s "$Framedir" -g "*" -d "$Distortdir" -c "$Cachedir"
  showpercent 80 100

  case $Opt1 in
    crop|crop_interactive|common_area) 
      note "align_vidstab: Generating min image"
      #$Magickbin $(fileglob "$Distortdir/*") -evaluate-sequence min "$Cropminimage" || return 1
      evaluate_split -s "$Distortdir" -1 min -b "$Cachedir/$Cropminimage" -c $Cachedir || return 1
    ;;
  esac
  
  case $Opt1 in
    crop) 
      Cropgeometry="$(trim_hard "$Cropminimage" "$Cropgeometry")" || return 1 
    ;;
    crop_interactive) 
      notify "align_vidstab: Ready for interactive crop"
      Cropgeometry="$(cropgeometry_interactive "$Cropminimage" "$Cachedir")" || return 1 
    ;;
    distort_only) ;;
    common_area) 
      note "align_vidstab: Generating mask image"
      $Magickbin $Cropminimage -threshold 0% $Commonareaimage || return 1
    ;;
  esac
  
  case $Opt1 in
    crop|crop_interactive) 
      Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
      Rotate="${Rotate:-0}"
      Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
      [ "$Cropgeometry" ] || {
        failure "align_vidstab: crop geometry is empty"
        Cropgeometry="${Imagewidth}x${Imageheight}+0+0"
      }
      note "align_vidstab: Cropping aligned images to $Cropgeometry"
    ;;
    common_area)
      note "align_vidstab: Reducing image content to common area of aligned images"
    ;;
    distort_only) 
      note "align_vidstab: Moving distorted images to destination"
    ;;
  esac
      
  Imagecount=0
  for Image in $(fileglob "$Distortdir/*"); do
    Imagecount="$((Imagecount+1))"
    Destinationfile="$(sed "${Imagecount}q;d" <<< "$Imagelist")"
    Destinationfile="$Destinationdir/$(basename "$Destinationfile")"
    case $Opt1 in
      crop|crop_interactive) 
        multicore "$Magickbin $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || Error=1
      ;;
      common_area)
        multicore "$Magickbin $Image $Commonareaimage -evaluate-sequence min $Destinationfile" "$Destinationfile" || Error=1
      ;;
      distort_only)
        multicore "$Magickbin $Image $Destinationfile" "$Destinationfile" || Error=1
      ;;
    esac
    showpercent "$Imagecount" "$Imagenumber"
    [ "$Error" ] && break
  done
  multicore_wait || return 1

  case $Opt1 in
    crop)             showimage "$Cropminimage.trim_hard.png" ;;
    crop_interactive) showimage "$Cachedir/cropgeometry.gui.tif" ;;
    common_area)      showimage "$Commonareaimage" ;;
  esac
  return ${Error:-0}
}
align_vidstab_ffmpeg() {
  # Align images with ffmpeg/vidstab
  # Generates file $Cachedir/align.$Opt2.log containing the calculated distortion parameters.
  # -o  Shakiness 1-10 (low to high)
  # -s  Sourcedir must contain files of form frame0001.png
  
  local $Batchlocal
  local $Imagelocal
  local $Imagepropertieslocal
  local CropW CropH CropX CropY Cropgeometry Zoom
  local Shakiness Stepsize
  local Xoffset Xoffsetrelative Xoffsetlist Yoffset Yoffsetrelative Yoffsetlist Radians Radiansrelative Radianslist Degree 
  local Motionsfile Distortlogfile

  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  cd $Cachedir
  
  # settings
  Shakiness="${Opt2:-1}"
  Stepsize=6
  
  # cache setup
  Motionsfile="$Cachedir/global_motions.trf"
  Distortlogfile="$Cachedir/align.$Shakiness.log"
  :> $Distortlogfile
  
  
  note "align_vidstab: Generating video (shakiness=$Shakiness)"
  nice ffmpeg -y -hide_banner -nostdin -f image2 -start_number 1 -i $Sourcedir/frame%04d.png -safe "0" -vframes 1000 -vcodec libx264 -crf 25  -pix_fmt rgba "$Cachedir/align.source.mov" || return 1
  ifcmdbreak && return 1

  note "align_vidstab: Analyzing video (shakiness=$Shakiness)"
  nice ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.source.mov" \
         -vf "vidstabdetect=shakiness=$Shakiness:accuracy=15:mincontrast=0.1:stepsize=$Stepsize:show=1:result=$Cachedir/transforms$Shakiness.trf" \
         "$Cachedir/align.vidstab-show.mov" || return 1
  ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.vidstab-show.mov"
  ifcmdbreak && return 1
            
  note "align_vidstab: Transforming video (shakiness=$Shakiness"
  nice ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.source.mov" \
         -vf "vidstabtransform=optzoom=0:smoothing=0:interpol=bilinear:relative=1:crop=black:debug=1:input=$Cachedir/transforms$Shakiness.trf" \
         "$Cachedir/align.result.mov" || return 1
  ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.result.mov"
  ifcmdbreak && return 1
  
  Xoffsetlist="$(cat $Motionsfile | grep -v '#' | awk '{print $2}')"
  Yoffsetlist="$(cat $Motionsfile | grep -v '#' | awk '{print $3}')"
  Radianslist="$(cat $Motionsfile | grep -v '#' | awk '{print $4}')"
  
  note "align_vidstab: Calculating distortion (shakiness=$Shakiness)"
  Imagecount=0
  for Image in $Imagelist; do
    Imagecount="$((Imagecount + 1))"
    Xoffsetrelative="$(sed "${Imagecount}q;d" <<<"$Xoffsetlist")"
    Xoffset="$(awk "BEGIN { print $Xoffset + $Xoffsetrelative }")"
    Yoffsetrelative="$(sed "${Imagecount}q;d" <<<"$Yoffsetlist")"
    Yoffset="$(awk "BEGIN { print $Yoffset + $Yoffsetrelative }")"
    Radiansrelative="$(sed "${Imagecount}q;d" <<<"$Radianslist")"
    Radians="$(awk "BEGIN { print $Radians - $Radiansrelative }")"
    Degree="$(awk  "BEGIN { print $Radians * 180 / 3.141592652}")"
    echo "$(basename "$Image") $Xoffset $Yoffset $Degree" >> $Distortlogfile
  done
  
  return 0
}
animation() {
  # Generate animated GIF from stackshot.
  # Helps to visualize diferent layers and gives some 3D effect
  #
  # -m  Rendermode:Fusemode
  # -o  Distortion
  #
  # Rendermode     quick or smooth
  # Distortion     Distortion between lowest and highest layer.
  # Fusemode       See fuse()
  # Framerate      Framerate between frames
  # Staticlayer    Relative position of static layer that won't move. 0 means lowest layer, 1/2 means middle layer, 1 means top layer
  # Format         File format
  
  local $Batchlocal
  local $Imagelocal
  local Fusemode Distortion Framerate Sequence Staticlayer Format Appendfirstframe
  local Distortdir Distortimage Fusedir Destinationfilebasename Imagebasename
  local Xpos Ypos Offset Border
  local Count Iteration=0 Iterationnumber Convertline
  local Imagelistfile
  local Position Positionlist Positionnumber
  local Sequence Sequencename Sequencenumber
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  # settings
  Rendermode="${Opt1:-quick}"
  Fusemode="${Opt2:-1}"
  Distortion="${Opt3:-25}"
  Staticlayer="1/4"
  Format="${Opt9:-webm}"
  Appendfirstframe="no"
  Destinationfilebasename="${Destinationfile:-animation}"
  
  # Revert image list to work from bottom to top
  Imagelist="$(tac <<< "$Imagelist")"
  
  # Position raster
  #
  # -5x-5 -5x-4 -5x-3 -5x-2 -5x-1  -5x0   -5x1  -5x2  -5x3  -5x4  -5x5
  #
  # -4x-5 -4x-4 -4x-3 -4x-2 -4x-1  -4x0   -4x1  -4x2  -4x3  -4x4  -4x5
  #
  # -3x-5 -3x-4 -3x-3 -3x-2 -3x-1  -3x0   -3x1  -3x2  -3x3  -3x4  -3x5
  #
  # -2x-5 -2x-4 -2x-3 -2x-2 -2x-1  -2x0   -2x1  -2x2  -2x3  -2x4  -2x5
  #
  # -1x-5 -1x-4 -1x-3 -1x-2 -1x-1  -1x0   -1x1  -1x2  -1x3  -1x4  -1x5
  #
  #  0x-5  0x-4  0x-3  0x-2  0x-1   0x0    0x1   0x2   0x3   0x4   0x5
  #
  #  1x-5  1x-4  1x-3  1x-2  1x-1   1x0    1x1   1x2   1x3   1x4   1x5
  #
  #  2x-5  2x-4  2x-3  2x-2  2x-1   2x0    2x1   2x2   2x3   2x4   2x5
  #
  #  3x-5  3x-4  3x-3  3x-2  3x-1   3x0    3x1   3x2   3x3   3x4   3x5
  #
  #  4x-5  4x-4  4x-3  4x-2  4x-1   4x0    4x1   4x2   4x3   4x4   4x5
  #
  #  5x-5  5x-4  5x-3  5x-2  5x-1   5x0    5x1   5x2   5x3   5x4   5x5

  case $Rendermode in
    smooth)
      Raster="3"
      Framerate="8"
      Sequencenumber="6"
                   
      Sequencename[1]="dagaz"
      Sequence[1]="0x0  -1x1 -2x2 -3x3
                  -2x3  -1x3  0x3  1x3   2x3   3x3
                   2x2   1x1  0x0 -1x-1 -2x-2 -3x-3
                  -2x-3 -1x-3 0x-3 1x-3  2x-3  3x-3
                   2x-2  1x-1"
            
      Sequencename[2]="circle_left"
      Sequence[2]="-3x0 -3x1  -2x2  -1x3  0x3  1x3  2x2  3x1  3x0 3x-1 2x-2 1x-3 0x-3 -1x-3 -2x-2 -3x-1"
            
      Sequencename[3]="circle_right"
      Sequence[3]="-3x0 -3x-1 -2x-2 -1x-3 0x-3 1x-3 2x-2 3x-1 3x0 3x1  2x2  1x3  0x3  -1x3  -2x2  -3x1"
      
      Sequencename[4]="left_right"
      Sequence[4]="-5x0  -4x0  -3x0  -2x0  -1x0   0x0    1x0   2x0   3x0   4x0   5x0
                    5x0   4x0   3x0   2x0   1x0   0x0   -1x0  -2x0  -3x0  -4x0  -5x0"
      
      Sequencename[5]="up_down"
      Sequence[5]=" 0x-5  0x-4  0x-3  0x-2  0x-1  0x0    0x1   0x2   0x3   0x4   0x5
                    0x5   0x4   0x3   0x2   0x1   0x0    0x-1  0x-2  0x-3  0x-4  0x-5"
      
      Sequencename[6]="cross"
      Sequence[6]="                               0x0    0x1   0x2   0x3   0x4
                    0x5   0x4   0x3   0x2   0x1   0x0    0x-1  0x-2  0x-3  0x-4
                    0x-5  0x-4  0x-3  0x-2  0x-1  0x0
                                                  0x0    1x0   2x0   3x0   4x0
                    5x0   4x0   3x0   2x0   1x0   0x0   -1x0  -2x0  -3x0  -4x0
                   -5x0  -4x0  -3x0  -2x0  -1x0   0x0"
      
      #disabled
      Sequencename[7]="eight_small"
      Sequence[7]="0x0  -1x0  -1x-1  0x-1  1x-1  1x0
                   0x0  -1x0  -1x1   0x1   1x1   1x0"
      
      Sequencename[8]="eight"
      Sequence[8]="0x0  -1x0  -2x0  -3x-1  -3x-2  -2x-3  -1x-3  0x-3  1x-3  2x-3  3x-2  3x-1  2x0  1x0
                   0x0  -1x0  -2x0  -3x1   -3x2   -2x3   -1x3   0x3   1x3   2x3   3x2   3x1   2x0  1x0"
            
      Sequencename[9]="knot"
      Sequence[9]="0x0 -1x0 -2x0 -3x-1 -3x-2 -2x-3 -1x-3 0x-2 0x-1
                   0x0  0x1  0x2  1x3   2x3   3x2   3x1  2x0  1x0
                   0x0 -1x0 -2x0 -3x1  -3x2  -2x3  -1x3  0x2  0x1
                   0x0  0x-1 0x-2 1x-3  2x-3  3x-2  3x-1 2x0  1x0"
  
      Sequencename[10]="knot_small"
      Sequence[10]="0x0  0x-1 -1x-1 -1x0  
                   0x0  1x0   1x1   0x1
                   0x0  0x-1  1x-1  1x0
                   0x0 -1x0  -1x1   0x1"
    ;;
    quick)
      Raster="1"
      Framerate="4"
      Sequencenumber="3"

      Sequencename[1]="eight_quick"
      Sequence[1]="0x0  -1x0  -1x-1  0x-1  1x-1  1x0
                   0x0  -1x0  -1x1   0x1   1x1   1x0"
                   
      Sequencename[2]="dagaz_quick"
      Sequence[2]="0x0  -1x-1 -1x0 -1x1 0x0 1x-1 1x0 1x1"
      
      Sequencename[3]="square_quick"
      Sequence[3]="-1x-1  -1x0  -1x1  0x1  1x1  1x0  1x-1  0x-1"
      
      #disabled
      Sequencename[4]="knot_quick"
      Sequence[4]="0x0  0x-1 -1x-1 -1x0  
                   0x0  1x0   1x1   0x1
                   0x0  0x-1  1x-1  1x0
                   0x0 -1x0  -1x1   0x1"
    ;;
  esac
  
  # calculate lost borders
  Border="$((Distortion - Distortion * $Staticlayer))"  # wrong result if Staticlayer>1/2 ?
  Cropgeometry="$((Imagewidth - Border * 2 - 1))x$((Imageheight - Border * 2 - 1))"
  
  # offset factor, distortion between neighboured layers
  Offset="$(awk "BEGIN {print $Distortion / ( $Imagenumber * $Raster ) }")"
  
  # get list of needed positions
  for Sequencecount in $(seq $Sequencenumber); do
    for Position in ${Sequence[$Sequencecount]}; do
      Positionlist="$Positionlist
$Position"
    done
  done
  Positionlist="$(grep x      <<< "$Positionlist")"
  Positionlist="$(sort -V     <<< "$Positionlist" | uniq)"
  Positionnumber="$(grep -c . <<< "$Positionlist")"
  
  Iterationnumber=$((Positionnumber*5 + Imagenumber + Sequencenumber))
  
  # Distort images
  note "animation: Distorting images"
  for Position in $Positionlist; do
    Distortdir="$Cachedir/distort.$Position"
    mkdir -p "$Distortdir"
  done
  
  Count=-$((Imagenumber * $Staticlayer))  # negative start value causes movement of lowest layer
  for Image in $Imagelist; do
    Count="$((Count +1))"
    Convertline="$Magickbin $Image -write mpr:image +delete"
    for Position in $Positionlist; do
      Distortdir="$Cachedir/distort.$Position"
      Distortimage="$Distortdir/$(basename $Image)"   
      Xpos="$(cut -dx -f1 <<< "$Position")"
      Ypos="$(cut -dx -f2 <<< "$Position")"   
      Convertline="$Convertline \( mpr:image -gravity center -crop $Cropgeometry+$(awk "BEGIN {print $Count * $Xpos * $Offset}")+$(awk "BEGIN {print $Count * $Ypos * $Offset}") -write $Distortimage \)" 
    done
    
    multicore "$Convertline info: >/dev/null" "$Distortimage" || Error=1
    [ "$Error" ] && break
    
    Iteration=$((Iteration + 1))
    showpercent $Iteration $Iterationnumber
  done
  multicore_wait || return 1
  [ "$Error" ] && return 1
  
  # fuse distorted images
  Showpercentfunc="$(declare -f showpercent)"
  for Position in $Positionlist; do
    Iteration=$((Iteration + 4))
    Distortdir="$Cachedir/distort.$Position"
    Distortcachedir="$Cachedir/distort.$Position/layered"
    mkdir -p $Distortcachedir
    Fusedir="$Distortdir/fuse"
    mkdir -p "$Fusedir"
    Imagebasename="animation.$Position"
    case $Fusemode in
      all|set*) ( showpercent() { : ; } ; fuse -s $Distortdir -g '*' -d $Fusedir -b $Imagebasename -1 $Fusemode -c $Distortcachedir ) || Error=1 ;; 
      *)                       multicore "fuse -s $Distortdir -g '*' -d $Fusedir -b $Imagebasename -1 $Fusemode -c $Distortcachedir" "" "$Imagelistmemsize" || Error=1 ;;
    esac
    showpercent $Iteration $Iterationnumber
    [ "$Error" ] && break
  done
  multicore_wait || return 1
  [ "$Error" ] && return 1

  # Calculate median of fuse images (fuse set* or all)
  for Position in $Positionlist; do
    Iteration=$((Iteration + 1))
    Distortdir="$Cachedir/distort.$Position"
    Fusedir="$Distortdir/fuse"
    Destinationfile="$Cachedir/animation.$Position.median.gif"
    note "animation: Generating $(basename $Destinationfile)"
    #multicore "$Magickbin $Fusedir/* -evaluate-sequence median -gravity center -stroke black -fill black -pointsize 24 -draw 'text 0,0 \"$Position\"' $Destinationfile" "$Destinationfile" || return 1
    #multicore "$Magickbin $Fusedir/* -evaluate-sequence median $Destinationfile" "$Destinationfile" || return 1
    multicore "evaluate_split -s $Fusedir -1 median -b $Destinationfile -c $Cachedir" "$Destinationfile" || Error=1
    showpercent $Iteration $Iterationnumber
    [ "$Error" ] && break
  done
  multicore_wait || return 1
  [ "$Error" ] && return 1

  # Generate videos
  for Count in $(seq $Sequencenumber); do
    Iteration=$((Iteration + 1))
    Imagelistfile="$Cachedir/imagelist.${Sequencename[$Count]}"
    :> $Imagelistfile
    Imagelist=""
    [ "$Appendfirstframe" = "yes" ] && Sequence[$Count]="${Sequence[$Count]} $(cut -d' ' -f1 <<< "${Sequence[$Count]}")"
    
    for Position in ${Sequence[$Count]}; do
      Image="$(fileglob "$Cachedir/*.$Position.median.*")"
      echo "file '$Image'" >> "$Imagelistfile"
      Imagelist="$Imagelist $Image"
    done
    Destinationfile="$Destinationdir/$Destinationfilebasename.${Sequencename[$Count]}.$(fuse_getname $Fusemode shortcut).$Distortion.$Format"

    note "animation: Generating $(basename $Destinationfile)."
    case $Format in
      gif) multicore "gifsicle --lossy --optimize=3 --delay $((100 / $Framerate)) --loopcount=forever --output $Destinationfile $Imagelist" "$Destinationfile" || Error=1 ;;
      *)   multicore "ffmpeg -y -hide_banner -nostdin -safe 0 -r $Framerate -f concat -i $Imagelistfile -c:v libvpx-vp9 -crf 30 -b:v 0 $Destinationfile" "$Destinationfile"  || Error=1 ;;
    esac
    [ "$Error" ] && break
    showpercent $Iteration $Iterationnumber
  done
  multicore_wait || return 1
  return ${Error:-0}
}
crop() {
  # crop area of image sequence
  # -m  even|shrink|geometry|interactive
  # -o   -  |pixel |geometry|geometry
  local $Batchlocal
  local $Imagelocal
  local Newwidth Newheight Shrink
  local Rotate Rotatedir
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1

  # cache setup
  Rotatedir="$Cachedir/rotate"
  mkdir -p $Rotatedir
  
  case $Opt1 in
    even)
      Newwidth=$((Imagewidth/2))
      Newwidth=$((Newwidth*2))
      Newheight=$((Imageheight/2))
      Newheight=$((Newheight*2))
      Cropgeometry="${Newwidth}x${Newheight}+0+0"
    ;;
    shrink) 
      Shrink="$Opt2"
      Cropgeometry="$((Imagewidth - $((Shrink * 2))))x$((Imageheight - $((Shrink * 2))))+$Shrink+$Shrink"
    ;;
    geometry)
      Cropgeometry="$Opt2"
    ;;
    interactive) 
#      Image="$Cachedir/crop.min.jpg"
      Image="$Cachedir/crop.min.mpc"
      note "crop $Opt1: Generating min image"
      #$Magickbin $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence min "$Image"
      evaluate_split -s $Sourcedir -g "$Sourcefileglob" -1 min -b $Image -c $Cachedir || return 1
      Cropgeometry="$(cropgeometry_interactive "$Image" "$Cachedir" "$Opt2")"
      Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
      Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
    ;;
  esac
  
  Rotate="${Rotate:-0}"
  [ "$Cropgeometry" ] || {
    failure "crop $Opt1: crop geometry is empty"
    return 1
  }
  
  [ "$Cropgeometry" = "${Imagewidth}x${Imageheight}+0+0" ] && [ "$Rotate" = "0" ] && {
    note "crop $Opt1: Images already have desired geometry: $Cropgeometry"
    mycp "$Sourcedir/$Sourcefileglob" "$Destinationdir"
    return
  }
  
  note "crop $Opt1: Cropping images with rotation $Rotate and geometry $Cropgeometry"
  Imagecount="0"
  for Image in $Imagelist; do
    Imagecount="$((Imagecount+1))"
    Destinationfile="$Destinationdir/$(basename "$Image")"
    multicore "$Magickbin $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
  [ "$Error" ] && return 1
  Imagelist="$(fileglob "$Rotatedir/*")"
  
  historyentry "# crop geometry: $Cropgeometry rotation: $Rotate"
  return ${Error:-0}
}
cuberotate() {
  local $Batchlocal
  local $Imagelocal
  local Linecount Linenumber
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
    
  case $Opt1 in
    top|bottom) Linenumber="$Imageheight" ;;
    left|right) Linenumber="$Imagewidth" ;;
  esac
  
  case $Opt1 in
    top|bottom|left|right)
      note "cuberotate $Opt1: Splitting images into rows or columns"
      Imagecount=0
      for Image in $Imagelist; do
        Imagecount="$((Imagecount+1))"
        mkdir $Cachedir/split$Imagecount
        case $Opt1 in
          top|bottom) Cropgeometry="0x1" ;;
          left|right) Cropgeometry="1x0" ;;
        esac
        multicore "$Magickbin $Image -crop $Cropgeometry $Cachedir/split$Imagecount/line%d.mpc" || Error=1
        [ "$Error" ] && break
        showpercent $Imagecount $((Imagenumber*2))
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
      
      note "cuberotate $Opt1: Appending lines to rotated image"
      for Linecount in $(seq $Linenumber); do
        Linelist=""
        for Imagecount in $(seq $Imagenumber); do
          case $Opt1 in
            left|top)     Linelist="$Linelist $Cachedir/split$((Imagenumber-Imagecount+1))/line$((Linecount-1)).mpc" ;;
            right|bottom) Linelist="$Linelist $Cachedir/split${Imagecount}/line$((Linenumber-Linecount)).mpc" ;;
          esac
        done
        Destinationfile="$Destinationdir/cube${Opt1}$(printnum $Linecount 4).jpg"
        
        case $Opt1 in
          top|bottom) multicore "$Magickbin $Linelist -append $Destinationfile" "$Destinationfile" || Error=1 ;;
          left|right) multicore "$Magickbin $Linelist +append $Destinationfile" "$Destinationfile" || Error=1 ;;
        esac
        [ "$Error" ] && break
        showpercent $((Linenumber+Linecount)) $((Linenumber*2))
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
    ;;
    back-left|back-top|reverse-order)
      Imagecount=0
      for Image in $Imagelist; do
        Destinationfile="$(head -n $((Imagenumber - Imagecount)) <<< "$Imagelist" | tail -1)"
        Destinationfile="$(basename "$Destinationfile")"
        note "cuberotate $Opt1: Generating $Destinationfile"
        Destinationfile="$Destinationdir/$Destinationfile"
        case $Opt1 in
          reverse-order)
            multicore "cp -T    $Image       $Destinationfile" "$Destinationfile" 16 || Error=1
          ;;
          back-left)
            multicore "$Magickbin $Image -flop $Destinationfile" "$Destinationfile" || Error=1
          ;;
          back-top)
            multicore "$Magickbin $Image -flip $Destinationfile" "$Destinationfile" || Error=1
          ;;
        esac
        [ "$Error" ] && break
        Imagecount="$((Imagecount+1))"
        showpercent $Imagecount $Imagenumber
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
    ;;
    90|180|270)
      Imagecount=0
      for Image in $Imagelist; do
        Imagecount="$((Imagecount+1))"
        Destinationfile="$(basename $Image)"
        note "cuberotate $Opt1: Generating $Destinationfile"
        Destinationfile="$Destinationdir/$Destinationfile"
        multicore "$Magickbin $Image -rotate $Opt1 $Destinationfile" "$Destinationfile" || Error=1
        [ "$Error" ] && break
        showpercent $Imagecount $Imagenumber
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
    ;;
  esac
  return ${Error:-0}
}
distort() {
  # distort images.
  # -o must point to a file contaiing the distortion parameters in the form:
  #    Imagename Xoffset Yoffset Rotation
  
  local $Batchlocal
  local $Imagelocal
  local Xoffset Yoffset Degree
  local Distortfile
  local Error

  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1

  Distortfile="$Opt2"
  
  Imagecount=0
  for Image in $Imagelist; do
    Imagecount="$((Imagecount + 1))"  
    Xoffset=0
    Yoffset=0
    Degree=0
    Line="$(grep "$(basename "$Image")" "$Distortfile")"
    Xoffset="$(cut -d' ' -f2 <<< "$Line")"
    Yoffset="$(cut -d' ' -f3 <<< "$Line")"
    Degree="$(cut  -d' ' -f4 <<< "$Line")"
  
    Destinationfile="$Destinationdir/$(basename "$Image")"
    multicore "$Magickbin $Image -virtual-pixel transparent -distort SRT '0,0 1 $Degree $Xoffset,$Yoffset' $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
  return ${Error:-0}
}
evaluate() {
  local $Batchlocal
  local $Imagelocal
  local Destinationfilebasename Set Mode Showimage
  local Maxfile Minfile
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Destinationfilebasename="$Destinationfile"
  case "$(basename $Sourcedir)" in
    fuse)
      for Set in $(seq $Fusesetnumber); do
        Sourcefileglob="$(fuse_glob set${Set})"
        [ "$Sourcefileglob" ] && {
          note "evaluate set${Set}"
          Imagelist="$(fileglob -w "$Sourcedir/$Sourcefileglob")"
          Imagenumber="$(wc -w <<< "$Imagelist")"
          Imagelistmemsize="$((Imagewidth*Imageheight*Magickpixelmemory*Imagenumber/1000))"
          for Mode in min mean max median; do
            Destinationfile="$Destinationdir/$Destinationfilebasename.${Mode}.set${Set}.${Imageformat}"
            [ "$Mode" = "max" ] && Maxfile="$Destinationfile"
            [ "$Mode" = "min" ] && Minfile="$Destinationfile"
            [ "$Mode" = "median" ] && [ "$Set" = "set2" ] && Showimage="$Destinationfile"
            multicore "evaluate_split -s $Sourcedir -g '$Sourcefileglob' -1 $Mode -c $Cachedir -b $Destinationfile" "$Destinationfile" "$Imagelistmemsize" || Error=1
            [ "$Error" ] && break
          done
          multicore_wait || Error=1
          [ "$Error" ] && break
          compose -1 "$Maxfile" -2 "$Minfile" -9 "$Imageformat" -d "$Targetcomposedir" -b "$Destinationfilebasename.set${Set}" || Error=1
          [ "$Error" ] && break
          showimage "$Showimage"
        }
        [ "$Error" ] && break
        showpercent $Set $Fusesetnumber
      done
      [ "$Error" ] && return 1
    ;;
    magick)
      for Mode in min mean max median; do
        Destinationfile="$Destinationdir/$Destinationfilebasename.${Mode}.${Imageformat}"
        [ "$Mode" = "max" ] && Maxfile="$Destinationfile"
        [ "$Mode" = "min" ] && Minfile="$Destinationfile"
        [ "$Mode" = "max" ] && Showimage="$Destinationfile"
        multicore "evaluate_split -s $Sourcedir -g '$Sourcefileglob' -1 $Mode -c $Cachedir -b $Destinationfile" "$Destinationfile" "$Imagelistmemsize" || Error=1
        [ "$Error" ] && break
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
      compose -1 "$Maxfile" -2 "$Minfile" -9 "$Imageformat" -d "$Targetcomposedir" -b "$Destinationfilebasename" || return 1
      showimage "$Showimage"
      ;;
    *) warning "evaluate(): Undefined handling for source $Sourcedir" ; return 1 ;;
  esac
  return ${Error:-0}
}
evaluate_split() {
  local $Batchlocal
  local $Imagelocal
  local Mode Split Splitpercent Showsplit Splitdir Part Partimage Partimagelist
  local Startzeit Dauer Restzeit Count
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Mode="${Opt1:-min}"
  Stepsize=40
  [ -n "$Destinationfile" ] && Destinationfile="$Destinationdir/$Destinationfile" || Destinationfile="$Cachedir/$Mode.tif"
  Splitdir="$Cachedir/evaluate_split.$RANDOM"
  
  Split="$((Imagelistmemsize/$(freememory) +1))"
  
  case $Split in
    1) 
      $Magickbin $Imagelist -evaluate-sequence $Mode $Destinationfile
    ;;
    *)
      mkdir -p "$Splitdir"
      Startzeit="$(date +%s)"
      Splitpercent="$((100/Split))"
      Showsplit="$(printnum $(( (Split+1)/2 )) 3)"
      Count="0"
      for Image in $Imagelist; do
        Count="$((Count+1))"
        note "Splitting image $Count / $Imagenumber into $Split pieces due to low memory: $(basename $Image)"
        multicore "$Magickbin $Image -crop 100%x${Splitpercent}% $Splitdir/split%03d.$(basename $Image).tif" "$Splitdir/split${Showsplit}.$(basename $Image).tif" || Error=1
        [ "$Error" ] && break
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
        showpercent $Count $Imagenumber
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
      Startzeit="$(date +%s)"
      Count="0"
      for Part in $(seq 0 $((Split-1))) ; do
        Count="$((Count+1))"
        note "Evaluating part $((Part+1)) / $Split"
        Partimage=$Splitdir/$Mode.part$Part.tif
        nice $Magickbin $Splitdir/split$(printnum $Part 3).*.tif -evaluate-sequence $Mode $Partimage || Error=1
        [ "$Error" ] && break
        Partimagelist="$Partimagelist $Partimage"
        showimage $Partimage
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Split-Part+1) / (Part+1) ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
        showpercent $Count $Split
      done
      [ "$Error" ] && return 1
      nice $Magickbin $Partimagelist -append $Destinationfile || return 1
    ;;
  esac
  return ${Error:-0}
}
fuse() {
  # fuse stackshot of images with enfuse
  
  local $Batchlocal 
  local $Imagelocal
  local $Imagepropertieslocal
  local Destinationfilebasename Stretchdir Stretch
  local Fusemode Fuseoption Modelist Modenumber Count
  local Error
  #local Layertif Filesize
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Destinationfilebasename="${Destinationfile:-fuse}"
  Fusemode="${Opt1:-1}"
  Fuseoption="${Opt2:-}"
  Extension="${Opt9:-$Imageformat}"
  Stretch="no" # experimental
  
  Fusedir="$Cachedir/fuse"
  mkdir -p "$Fusedir"
  Stretchdir="$Cachedir/stretch"
  mkdir -p "$Stretchdir"
  Unstretchfile="$Cachedir/unstretch"
  :> $Unstretchfile
  
  [ "$Stretch" = "yes" ] && [ "$Stretchdir" != "$Sourcedir" ] && {
    imageproperties -s "$Sourcedir" -g "$Sourcefileglob" -c "$Cachedir" || return 1
    echo "-channel red +level ${Imageminlevelred}%x${Imagemaxlevelred}% -channel green +level ${Imageminlevelgreen}%x${Imagemaxlevelgreen}% -channel blue +level ${Imageminlevelblue}%x${Imagemaxlevelblue}% +channel" > "$Unstretchfile"
        
    note "fuse: stretching colors to maximal contrast"
    Imagecount=0
    for Image in $Imagelist; do
      Imagecount="$((Imagecount + 1))"
      Destinationfile="$Stretchdir/stretch$(zeronumber $Imagecount).png"
      multicore "$Magickbin $Image -channel red -level ${Imageminlevelred}%x${Imagemaxlevelred}% -channel green -level ${Imageminlevelgreen}%x${Imagemaxlevelgreen}% -channel blue -level ${Imageminlevelblue}%x${Imagemaxlevelblue}% +channel $Destinationfile" "$Destinationfile" || Error=1
      [ "$Error" ] && break
      showpercent "$Imagecount" "$Imagenumber"
    done
    multicore_wait || return 1
    [ "$Error" ] && return 1
  } || {
    [ "$Stretchdir" != "$Sourcedir" ] && mycp "$Sourcedir/$Sourcefileglob" "$Stretchdir"
  }
  
  case $Fusemode in
    all|set*)
      #Layertif="$Cachedir/layer.tif"
      #note "fuse $Fusemode: Generating layered tif image"         ### FIXME Damaging other file formats?
      #$Magickbin $(echo $Imagelist) "$Layertif" || return 1
      #Filesize="$(du -k "$Layertif" | awk '{print $1}')"
      case $Fusemode in
        all) 
          Modelist="$(seq $Fusemodenumber)" 
        ;;
        set*)  
          for Count in $(seq $Fusemodenumber); do
            [ "$(fuse_getvalue $Count $Fusemode value)" ] && Modelist="$Modelist $Count"
          done
        ;;
      esac
      Modenumber="$(wc -w <<< "$Modelist")"
      
      #$Magickbin "$(head -n1 <<< "$Imagelist")" "$Cachedir/stackfuser-test.gif"
      #Imagememsize="$(du -k $Cachedir/memsizetest.gif | awk '{print $1}')"
      Imagememsize="$((Imagewidth*Imageheight*8/1000))" ### FIXME
      Imagelistmemsize="$((Imagememsize*Imagenumber))"
      Imagelistmemsize="$((Imagelistmemsize*11/10))"
      Count=0
      for Fusemode in $Modelist; do
        Count="$((Count+1))"
#        multicore "fuse -s '$(dirname "$Layertif")' -g '$(basename "$Layertif")' -d '$Destinationdir' -b '$Destinationfilebasename' -1 '$Fusemode' -2 '$Fuseoption'" "" "$((Filesize*3))" || return 1
        multicore "fuse -s '$Stretchdir' -g '$Sourcefileglob' -d '$Destinationdir' -c '$Cachedir' -b '$Destinationfilebasename' -1 '$Fusemode' -2 '$Fuseoption' -9 '$Extension'" "" "$Imagelistmemsize" || Error=1
        [ "$Error" ] && break
        showpercent "$Count" "$Modenumber"
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
      return 0
    ;;
    fuse*)
      Fusemode="${Fusemode#fuse}"
      Fusemode="${Fusemode#0}"
    ;;
  esac
  
  Destinationfile="$Destinationfilebasename.$(fuse_getname $Fusemode shortcut).${Extension}"
  case $Fuseoption in
    skip)
      [ -e "$Destinationdir/$Destinationfile" ] && {
        note "fuse: Skipping $Fusemode: already exists: $Destinationfile"
        showimage "$Destinationfile"
        return 0
      }
    ;;
  esac
  note "fuse $Fusemode: Creating $Destinationfile"

  # Collect options
  Enfuseoptions=""
  for Line in $Fuseoptions; do
    Enfuseoptions="$Enfuseoptions $(fuse_getvalue $Fusemode $Line option)"
  done
  verbose "fuse $Fusemode: $Enfuseoptions"
  
  # Fuse
  Fusebackend=enfuse
  case $Fusebackend in
    enfuse)
      { nice enfuse $Enfuseoptions --output="$Fusedir/$Destinationfile" $(echo $Imagelist) 2>&1 || {
          failure "fuse $Fusemode failed"
          return 1  ### FIXME seems not to return!?
        } 
      } | grep -v -E 'assuming all pixels should contribute|alpha channel|loading next image|no usable resolution found'
    ;;
    imfuse)
      mkdir -p $Cachedir/$Fusemode
      imfuse --enfuse="$Enfuseoptions" --output="$Fusedir/$Destinationfile" --save-masks=$Cachedir/$Fusemode $(echo $Imagelist) || return 1
    ;;
  esac
  showimage "$Fusedir/$Destinationfile"
  
  
  # Write enfuse options into EXIF data of image
  exiv2 -M"set Exif.Photo.UserComment Comment charset=Ascii enfuse $(echo $Enfuseoptions)" "$Fusedir/$Destinationfile"  || return 1
  
  $Magickbin  "$Fusedir/$Destinationfile" $(cat $Unstretchfile) "$Destinationdir/$Destinationfile" || return 1
  
  showimage "$Destinationdir/$Destinationfile"
  return 0
}
imageformat() {
  local $Batchlocal
  local $Imagelocal
  local Sourceformat Destinationformat
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Sourceformat="$(head -n1 <<< "$Imagelist" | rev | cut -d. -f1 | rev)"
  Sourceformat="${Sourceformat,,}"
  Destinationformat="${Opt9:-tif}"
  Destinationformat="${Destinationformat,,}"
  
  [ "$Sourceformat" = "$Destinationformat" ] && {
    note "imageformat(): Files already have desired image format $Destinationformat"
    cp $Imagelist $Destinationdir
    showpercent 100 100
    return 0
  }
  
  [ "$Imagenumber" = "1" ] && {
    file -i "$Imagelist" | grep -q video && {
      note "imageformat(): Splitting video into images with format $Destinationformat"
      $Magickbin $Imagelist $Destinationdir/frame%04d.$Destinationformat
      return
    }
  }
    
  note "imageformat(): Converting image format from $Sourceformat to $Destinationformat"
  for Image in $Imagelist; do
    Imagecount=$((Imagecount+1))
    showpercent $Imagecount $Imagenumber
    Destinationfile="$(rev <<< "$Image" | cut -d. -f2- | rev).$Destinationformat"
    Destinationfile="$Destinationdir/$(basename "$Destinationfile")"
    multicore "$Magickbin $Image $Destinationfile" "$Destinationfile" || Error=1 
    [ "$Error" ] && break
#    case $Imageraw in
#      no)  multicore "$Magickbin $Image $Destinationfile" "$Destinationfile" || return 1 ;;
#      yes) multicore "ufraw-batch --wb=camera --black-point=auto --exposure=auto --create-id=no --out-type=$Destinationformat --out-depth=16 --output=$Destinationfile $Image" "$Destinationfile" || return 1 ;;
#    esac
  done
  multicore_wait || return 1
  return ${Error:-0}  
}
lightbalance() {
  # simulate a HDR image with multiple exposures combined to one image with balanced light.
  # To achieve this some brightened and darkened images are generated with IM and combined with enfuse.

  local $Batchlocal
  local $Imagelocal
  local Darkfactor Brightfactor Darkpercent Brightpercent
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Opt1="${Opt1:-level}"
  Opt2="${Opt2:-50%}"
  Opt2="${Opt2%"%"}"
  
  Darkpercent="$(awk   "BEGIN {print  100-$Opt2}")"
  Brightpercent="$(awk "BEGIN {print  100+$Opt2}")"
  Darkfactor="$(awk    "BEGIN {print (100-$Opt2)/100}")"
  Brightfactor="$(awk  "BEGIN {print (100+$Opt2)/100}")"
  #Brightfactor="$(awk  "BEGIN {print  1/$Darkfactor}")"

  for Image in $Imagelist; do
    Imagecount=$((Imagecount+1))
    Destinationfile="$(basename $Image)"
    Convertline="$Magickbin $Image -write mpr:image +delete"  
    Convertline="$Convertline     \( mpr:image                                           -write $Cachedir/$Destinationfile.exp.source.tif \)" 
    case $Opt1 in
      brightness)    
        Convertline="$Convertline \( mpr:image -brightness-contrast  ${Opt2}%  -write $Cachedir/$Destinationfile.exp.bright.tif  \)" 
        Convertline="$Convertline \( mpr:image -brightness-contrast -${Opt2}%  -write $Cachedir/$Destinationfile.exp.dark.tif   \)" 
      ;;
      modulate)    
        Convertline="$Convertline \( mpr:image -modulate ${Brightpercent}%               -write $Cachedir/$Destinationfile.exp.bright.tif  \)" 
        Convertline="$Convertline \( mpr:image -modulate ${Darkpercent}%                 -write $Cachedir/$Destinationfile.exp.dark.tif   \)" 
      ;;
      multiply)    
        Convertline="$Convertline \( mpr:image -evaluate multiply ${Brightfactor}        -write $Cachedir/$Destinationfile.exp.bright.tif  \)" 
        Convertline="$Convertline \( mpr:image -evaluate multiply ${Darkfactor}          -write $Cachedir/$Destinationfile.exp.dark.tif   \)" 
      ;;
      levelgamma)    
        Convertline="$Convertline \( mpr:image -level 0%x${Darkpercent}%,${Brightfactor} -write $Cachedir/$Destinationfile.exp.bright.tif  \)" 
        Convertline="$Convertline \( mpr:image +level 0%x${Darkpercent}%,${Brightfactor} -write $Cachedir/$Destinationfile.exp.dark.tif   \)" 
      ;;
      level)    
        Convertline="$Convertline \( mpr:image -level 0%x${Darkpercent}%                 -write $Cachedir/$Destinationfile.exp.bright.tif  \)" 
        Convertline="$Convertline \( mpr:image +level 0%x${Darkpercent}%                 -write $Cachedir/$Destinationfile.exp.dark.tif   \)" 
      ;;
      gamma)
        Convertline="$Convertline \( mpr:image -gamma ${Brightfactor}                    -write $Cachedir/$Destinationfile.exp.bright.tif  \)" 
        Convertline="$Convertline \( mpr:image -gamma ${Darkfactor}                      -write $Cachedir/$Destinationfile.exp.dark.tif   \)" 
      ;;
    esac
    Convertline="$Convertline info: >/dev/null"
    echo $Convertline
    multicore "$Convertline" || Error=1
    multicore_wait || Error=1
    [ "$Error" ] && break
    multicore "enfuse $(find $Cachedir/${Destinationfile}.exp* | tr "\n" " ") -o $Destinationdir/$Destinationfile --gray-projector=average" "$Destinationdir/$Destinationfile" || Error=1
    [ "$Error" ] && break
    showpercent $Imagecount $Imagenumber
  done
  multicore_wait || return 1
  return ${Error:-0}
}
ruler() {
  local $Batchlocal
  local $Imagelocal
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Imagecount="0"
  for Image in $Imagelist; do
    Imagecount="$((Imagecount+1))"
    Destinationfile="$Destinationdir/$(basename $Image)"
    multicore "$Imgruler -m $Opt1 -t '$Opt2' -c '$Opt3' -n '$Opt4' -o $Destinationfile $Image" "$Destinationfile" || Error=1
    [ "$Error" ] && break
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
  return ${Error:-0}
}
evalstep() {

  local $Batchlocal
  local $Imagelocal
  local Error
  local Medianlist Mediancount Count
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Opt1="${Opt1:-median}"
  Opt2="${Opt2:-5}"
  
  Count=0
  Imagecount=0
  Mediancount="0"
  for Image in $Imagelist; do
    [ "$Error" ] && break
    Imagecount="$((Imagecount+1))"
    Medianlist="$Medianlist $Image"
    Count="$((Count+1))"
    { [ "$Count" = "$Opt2" ] || [ "$Imagecount" = "$Imagenumber" ] ; } && {
      Mediancount="$((Mediancount+1))"
      Destinationfile="$Destinationdir/median$(zeronumber $Mediancount 4).$Imageformat"
      multicore "$Magickbin $Medianlist -evaluate-sequence $Opt1 $Destinationfile" "$Destinationfile" || Error=1
      Count="0"
      Medianlist=""
    }
  done
  multicore_wait || return 1
  return "${Error:-0}"
}
undo() {
  local $Batchlocal
  local Undocache
  
  parse_batchoptions "$@" || return 1

  Undocache="$Cachedir/undo"
  mkdir -p "$Undocache"
  
  mymv "$Sourcedir/*"      "$Undocache"      || return 1
  mymv "$Destinationdir/*" "$Sourcedir" 
  mymv "$Undocache/*"      "$Destinationdir"
  
  myrmdir "$Undocache"
}
video() {
  # Generate video of stackshot showing focus changes
  local $Batchlocal
  local $Imagelocal
  local Imagelistfile
  local Framerate Format Framedir Frame
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1

  Opt1="${Opt1:-in_and_out}"
  Framerate="${Opt2:-10}"
  Format="${Opt9:-webm}"
  
  Destinationfile="$Destinationdir/$Destinationfile.focus.$Opt1.$Framerate.$Format"
  Framedir="$Cachedir/frames"
  mkdir -p $Framedir
  Imagelistfile="$Cachedir/imagelist"
  
  case $Opt1 in
    in) ;;
    out) Imagelist="$(tac <<< "$Imagelist")";;
    in_and_out) 
      Imagelist="$Imagelist
$(tac <<< "$Imagelist")"
      Imagenumber="$((Imagenumber*2))"
    ;;
    *)
      failure "Unknown video mode $Opt1"
      return 1
    ;;
  esac
  
  case $Format in
    gif) Imageformat="gif" ;;
  esac
  
  note "video: Preparing frames"
  Imagecount=0
  for Image in $Imagelist; do
    Imagecount="$((Imagecount+1))"
    #echo "file '$Image'" >> $Imagelistfile
    Frame="$Framedir/frame$(zeronumber $Imagecount).$Imageformat"
    case $Format in
      gif) multicore "$Magickbin $Image $Frame" "$Image" || Error=1 ;;
      *)   multicore "cp -T      $Image $Frame" "$Image" || Error=1 ;;
    esac
    [ "$Error" ] && break
    showpercent $Imagecount $Imagenumber
  done
  multicore_wait || return 1
  [ "$Error" ] && return 1
  
  note "video: Generating $Format video $Opt1"
  showpercent busy
  case $Format in
    gif) nice gifsicle --lossy --optimize=3 --delay $((100 / $Framerate)) --loopcount=forever --output $Destinationfile $(fileglob "$Framedir/*") || return 1 ;;
    *)   nice ffmpeg -y -hide_banner -nostdin  -r $Framerate -f image2 -start_number 1 -i $Framedir/frame%04d.$Imageformat $Destinationfile || return 1 ;;
  esac
  showpercent 100 100
  showimage $Destinationfile
  return ${Error:-0}
}
whitebalance() {
  # whitebalance sequence of images
  # -m  reference geometry
  # -o  reference color or "mean"
  
  local $Batchlocal
  local $Imagelocal
  local Referencecolor Referencecolorimage Meancolorimage 
  local Refred  Refgreen  Refblue
  local Meanred Meangreen Meanblue
  local Partred Partgreen Partblue
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
    
  Opt1="${Opt1:-topleft}"
  Referencecolor="${Opt2:-#BBBBBB}"
  
  Meancolorimage="$Cachedir/meancolor.mpc"
  Referencecolorimage="$Cachedir/referencecolor.mpc"
  
  case $Opt1 in
    topleft)     Cropgeometry="10x10+5+5" ;;
    topright)    Cropgeometry="10x10+$((Imagewidth-15))+5" ;;
    bottomleft)  Cropgeometry="10x10+5+$((Imageheight-15))" ;;
    bottomright) Cropgeometry="10x10+$((Imagewidth-15))+$((Imageheight-15))" ;;
    full)        Cropgeometry="${Imagewidth}x${Imageheight}+0+0" ;;
    interactive) 
#      Image="$Cachedir/whitebalance.min.jpg"
      Image="$Cachedir/whitebalance.min.mpc"
      note "whitebalance: Generating min image"
      $Magickbin $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence min "$Image"
      evaluate_split -s $Sourcedir -g "$Sourcefileglob" -c $Cachedir -1 min $Image || return 1
      Cropgeometry="$(cropgeometry_interactive "$Image" "$Cachedir" "50x50+10+10")"  ### FIXME rotate
      Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")" 
      [ "$Cropgeometry" ] || {
        failure "whitebalance: Got no crop geometry"
        return 1
      }
    ;;
    *) Cropgeometry="$Opt1" ;;
  esac
  
  [ "$Referencecolor" = "mean" ] && {
    Image="$Cachedir/whitebalance.mean.mpc"
    note "whitebalance: Generating mean image"
    $Magickbin $(fileglob "$Sourcedir/$Sourcefileglob") -crop "$Cropgeometry" -evaluate-sequence mean "$Image"  ### FIXME might fail with large sequences
    Referencecolor=$($Magickbin "$Image" -filter box -resize 1x1! -format "%[pixel:u]" info:)
  }
  
  $Magickbin -size 1x1 xc:"$Referencecolor" $Referencecolorimage
  Refred="$($Magickbin   $Referencecolorimage -format "%[fx:255*u.p{0,0}.r]" info:)"
  Refgreen="$($Magickbin $Referencecolorimage -format "%[fx:255*u.p{0,0}.g]" info:)"
  Refblue="$($Magickbin  $Referencecolorimage -format "%[fx:255*u.p{0,0}.b]" info:)"

  historyentry "# whitebalance geometry: $Cropgeometry"

  note "whitebalance: Balancing with reference color $Referencecolor"
  Imagecount=0
  for Image in $Imagelist; do
    Imagecount="$((Imagecount + 1))"
    Destinationfile="$Destinationdir/$(basename "$Image")"
    
    $Magickbin $Image -crop $Cropgeometry -resize 1x1! "$Meancolorimage"
    
    Meanred="$($Magickbin   $Meancolorimage -format "%[fx:255*u.p{0,0}.r]" info:)"
    Meangreen="$($Magickbin $Meancolorimage -format "%[fx:255*u.p{0,0}.g]" info:)"
    Meanblue="$($Magickbin  $Meancolorimage -format "%[fx:255*u.p{0,0}.b]" info:)"
    
    [ "$Meanred"   = "0" ] && Partred=255   || Partred="$(awk   "BEGIN { print $Refred   / $Meanred }")"
    [ "$Meangreen" = "0" ] && Partgreen=255 || Partgreen="$(awk "BEGIN { print $Refgreen / $Meangreen }")"
    [ "$Meanblue"  = "0" ] && Partblue=255  || Partblue="$(awk  "BEGIN { print $Refblue  / $Meanblue }")"
    
    multicore "$Magickbin $Image -color-matrix '$Partred 0 0 0 $Partgreen 0 0 0 $Partblue' $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
  return ${Error:-0}
}
wizard() {
  # Wrapper for ImageMagick convert to work on folders
  # Args:
  #  mandatory:
  #   -m Opt1
  #   -s Sourcedir
  #   -d Destinationdir
  #  optional:
  #   -g Sourcefileglob
  #   -o Opt2
  
  local $Batchlocal
  local $Imagelocal
  local $Imagepropertieslocal
  local Options Compress
  local Startzeit Dauer Restzeit
  local Error

  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  grep -i '\.tif$' <<< "$Outputimage" && Compress="-compress zip"

  [ "$Opt2" ] || case "$Opt1" in
    brightness) Opt2="10x10" ;;
    contrast)   Opt2="3x50%" ;;
    gamma)      Opt2="auto" ;;
    level)      Opt2="auto" ;;
    orient)     Opt2="topleft" ;;
    rotate)     Opt2="90" ;;
    sharpen)    Opt2="6x2" ;;
    statistic)  Opt2="median 5" ;;
    stretch)    Opt2="auto" ;;
  esac

  [ "$Opt1" = "stretch" ] && Opt1="contrast-stretch"
  case "$Opt1" in
    level|gamma|contrast-stretch) 
      case "$Opt2" in
        auto|"") Opt1="-auto-$Opt1" ; Opt2="" ;;
        max) 
          Opt1="-contrast-stretch max"
          Opt2=""
        ;;
        *)       Opt1="-$Opt1" ;;
      esac
    ;;
    brightness)  Opt1="-brightness-contrast" ;;
    contrast)    Opt1="-sigmoidal-contrast" ;;
    sharpen)     Opt1="-adaptive-sharpen" ;;
    orient|rotate|statistic) Opt1="-$Opt1" ;;
    wizard)      Opt1="" ;;
  esac
  Options="$Opt1 $Opt2 $Opt3 +repage"
  
  [ "$Sourcedir" = "$Targetmagickdir" ] && grep -q -E "auto-gamma|auto-level|auto-contrast-stretch|contrast-stretch max" <<< "$Options" && {
    imageproperties -s "$Sourcedir" -g "$Sourcefileglob" -c "$Cachedir" || return 1
    Options="$(sed "s/-auto-gamma/-gamma $Imageautogamma/ ; 
                           s/-auto-contrast-stretch/-contrast-stretch ${Imageminlevel}x${Imagemaxlevel}/ ; 
                           s/-contrast-stretch max/-channel red -contrast-stretch ${Imageminlevelred}x${Imagemaxlevelred} -channel green -contrast-stretch ${Imageminlevelgreen}x${Imagemaxlevelgreen} -channel blue -contrast-stretch ${Imageminlevelblue}x${Imagemaxlevelblue} +channel/ ; 
                           s/-auto-level/-level ${Imageminlevel}%x${Imagemaxlevel}%/"    <<< "$Options")"
  }
  
  note "wizard: $Options"
  Startzeit="$(date +%s)"
  Imagecount=0
  for Image in $Imagelist; do
    Imagecount="$((Imagecount + 1 ))"
    Destinationfile="$Destinationdir/$(basename "$Image")"
    multicore "$Magickbin $Image $Options $Compress $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Imagecount) / Imagecount ))"
    [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
    note "wizard: Duration: $(date -u -d @$Dauer +"%T"); Estimated time left: $(date -u -d @$Restzeit +"%T") ($Restzeit)"
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
  
  return ${Error:-0}
}

#### single image operations

imageproperties() {
  local $Batchlocal
  local $Imagelocal
  local Meanimage Imageproperties
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1

  case $(wc -l <<< "$Imagelist") in
    0)
      failure "imageproperties(): No source file(s)"
      return 1 
    ;;
    1) Meanimage="$Imagelist" ;;
    *)
      note "imageproperties(): Generating mean image"
      Meanimage="$Cachedir/mean.png"
      #$Magickbin $Imagelist -evaluate-sequence mean "$Meanimage" || return 1
      evaluate_split -s $Sourcedir -g "$Sourcefileglob" -c $Cachedir -1 mean -b $Meanimage || return 1
      showimage "$Meanimage"
    ;;
  esac

  Imageproperties="$($Magickbin "$Meanimage" -format '
Imagemean=%[mean]
Imagequantumrange=%[fx:quantumrange]
Imageautogamma=%[fx:log(mean)/log(0.5)]
Imageminlevel=%[fx:minima*100]
Imagemaxlevel=%[fx:maxima*100]
Imageminlevelred=%[fx:minima.r*100]
Imagemaxlevelred=%[fx:maxima.r*100]
Imageminlevelgreen=%[fx:minima.g*100]
Imagemaxlevelgreen=%[fx:maxima.g*100]
Imageminlevelblue=%[fx:minima.b*100]
Imagemaxlevelblue=%[fx:maxima.b*100]
' info:)"

  verbose "Image properties of $Meanimage: 
$Imageproperties"
  eval $Imageproperties
}
calc_evengeometry() {
  local Geometry XY W H
  Geometry="${1:-}"
  W=$(cut -dx -f1 <<< "$Geometry")
  H=$(cut -dx -f2 <<< "$Geometry" | cut -d+ -f1)
  XY="$(cut -d+ -f2- <<< "$Geometry")"
  W=$((W/2))
  W=$((W*2))
  H=$((H/2))
  H=$((H*2))
  Geometry="${W}x${H}+${XY}"
  echo $Geometry
}
compose() {
  local $Batchlocal
  local $Imagelocal
  local Minfile Maxfile Mode
  local Destinationfilebasename
  local Count
  local Error
  
  parse_batchoptions "$@" || return 1
  
  Maxfile="${Opt1:-EMPTY}"
  Minfile="${Opt2:-EMPTY}"
  grep -q "EMPTY" <<< "$Maxfile $Minfile" && {
    failure "compose: No max/min files specified."
    return 1
  }
  Imageformat="${Opt9:-}"
  [ -z "$Imageformat" ] && Imageformat="$(get_extension "$Maxfile")"
  Destinationfilebasename="${Destinationfile:-compose}"
    
  for Mode in bumpmap colorburn linearlight modulate  overlay pegtoplight; do
    Destinationfile="$Destinationdir/$Destinationfilebasename.${Mode}1.$Imageformat"
    multicore "$Magickbin $Maxfile $Minfile -compose $Mode -composite $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
    Destinationfile="$Destinationdir/$Destinationfilebasename.${Mode}2.$Imageformat"
    multicore "$Magickbin $Minfile $Maxfile -compose $Mode -composite $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
  done
  [ "$Error" ] && return 1
  for Mode in linearburn difference multiply; do
    Destinationfile="$Destinationdir/$Destinationfilebasename.${Mode}.$Imageformat"
    multicore "$Magickbin $Maxfile $Minfile -compose $Mode -composite $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
  done
  multicore_wait || return 1
  [ "$Error" ] && return 1
  Destinationfile="$Destinationdir/$Destinationfilebasename.composemean.${Imageformat}"
  $Magickbin  $Destinationdir/$Destinationfilebasename.{*modulate*,*bumpmap*,*pegtoplight*,*overlay*,*difference*} -evaluate-sequence mean $Destinationfile || return 1
  showimage $Destinationfile
  return 0
}
trim_hard() {
  # Function: Trim all border with transparency from image $1
  # Results in a maximal inner rectangle without border color.
  # $1  $Image      image
  # $2  $Trimcolor  color to trim. Default: transparent
  # $3  Geometry seed value (optional)
  # $4  additional command to run on each iteration (optional, special use case for cropgeometry_interactive() )
  # Output: crop geometry
  
  local Imagemask Trimcolor Cropgeometry Addcommand
  local Sourceimage Sourceimagempc Cropgeometryimage Imagewidth Imageheight
  local Left         Right         Top         Bottom
  local Skipleft     Skipright     Skiptop     Skipbottom
  local Permilleleft Permilleright Permilletop Permillebottom Permillemax
  local Return
  local Debugmode Loopcount
  local pid1 pid2 pid3 pid4
  
  Sourceimage="${1:-}"
  Cropgeometry="${2:-}"
  Addcommand="${3:-}"
  
  Trimcolor="#00000000" # to support other colors, creating mask must be fixed FIXME
  
  # check source for mpc format, convert if not
  [ "$Sourceimage" = "${Sourceimage%.mpc}" ] && {
    Sourceimagempc="$Sourceimage.mpc"
    $Magickbin "$Sourceimage" "$Sourceimagempc"
  } || {
    Sourceimagempc="$Sourceimage"
  }
  Cropgeometryimage="$Sourceimage.trim_hard.png"
  
  # Generate alpha mask image in imagemagick memory format for fastest possible access
  Imagemask="$Sourceimage.mask.mpc"
  $Magickbin "$Sourceimagempc" -alpha extract "$Imagemask"
  
  note "trim_hard(): Searching for inner rectangle of $(basename $Sourceimage)"
  
  Imagewidth=$($Magickbin  -format '%w'  $Imagemask info:)
  Imageheight=$($Magickbin -format '%h'  $Imagemask info:)
  Left=0
  Top=0
  Right=$((Imagewidth-1))
  Bottom=$((Imageheight-1))
  
  # First cut with regular trim to save some time.
  # Add a colored border so trim uses the desired color. Afterward remove border from canvas to get correct geometry values. 
  Line="$($Magickbin "$Sourceimagempc" -bordercolor "$Trimcolor" -border 1x1  -trim -set page '%[fx:page.width-2]x%[fx:page.height-2]+%[fx:page.x-1]+%[fx:page.y-1]' info:)"
  Left="$(awk '{print $4}' <<< "$Line" | cut -d+ -f2)"
  Top="$(awk '{print $4}' <<< "$Line" | cut -d+ -f3)"
  Right="$(awk '{print $3}' <<< "$Line" | cut -dx -f1)"
  Right="$((Left+Right-1))"
  Bottom="$(awk '{print $3}' <<< "$Line" | cut -dx -f2)"
  Bottom="$((Top+Bottom-1))"
  
  [ "$Cropgeometry" ] && {
    Left=$(cut -d+ -f2 <<< "$Cropgeometry")
    Top=$(cut -d+ -f3 <<< "$Cropgeometry")
    Right=$(cut -dx -f1 <<< "$Cropgeometry")
    Right=$((Left+Right-1))
    Bottom=$(cut -dx -f2 <<< "$Cropgeometry")
    Bottom=$(cut -d+ -f1 <<< "$Bottom")
    Bottom=$((Top+Bottom-1))
  }
  
  # Workflow:
  # - Get permille amount of $Trimcolor from all sides.
  # - Remove side with greatest permille amount of $Trimcolor.
  # - Repeat check with new geometry
  while :; do
    # Get part of non-$Trimcolor at each side
    
    #Command="$Magickbin $Imagemask -write mpr:imagemask -delete 0"
    #[ "$Skipleft" ]   || Command="$Command ( mpr:imagemask -crop 1x$((Bottom-Top+1))+$Left+$Top    +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info: )"
    #[ "$Skipright" ]  || Command="$Command ( mpr:imagemask -crop 1x$((Bottom-Top+1))+$Right+$Top   +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info: )"
    #[ "$Skiptop" ]    || Command="$Command ( mpr:imagemask -crop $((Right-Left+1))x1+$Left+$Top    +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info: )"
    #[ "$Skipbottom" ] || Command="$Command ( mpr:imagemask -crop $((Right-Left+1))x1+$Left+$Bottom +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info: )"
    
    
    [ "$Skipleft" ]   || $Magickbin $Imagemask -crop 1x$((Bottom-Top+1))+$Left+$Top    +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permilleleft    & pid1=$!
    [ "$Skipright" ]  || $Magickbin $Imagemask -crop 1x$((Bottom-Top+1))+$Right+$Top   +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permilleright   & pid2=$!
    [ "$Skiptop" ]    || $Magickbin $Imagemask -crop $((Right-Left+1))x1+$Left+$Top    +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permilletop     & pid3=$!
    [ "$Skipbottom" ] || $Magickbin $Imagemask -crop $((Right-Left+1))x1+$Left+$Bottom +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permillebottom  & pid4=$!
    wait $pid1
    wait $pid2
    wait $pid3
    wait $pid4
    Permilleleft=$(  LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permilleleft)
    Permilleright=$( LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permilleright)
    Permilletop=$(   LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permilletop)
    Permillebottom=$(LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permillebottom )
    
    # Determine maximal permille value
    Permillemax=$(echo "$Permilleleft
$Permilleright
$Permilletop
$Permillebottom" | sort -n | head -n1)
    showpercent "$(awk "BEGIN {print 1000*$Permillemax}" | cut -d. -f1)" "1000"
    Cropgeometry="$((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top"
    [ "$Permillemax" = "1.0000" ] && break # Ready
    
    # Remove side with maximal permille of $Trimcolor.
    [ "$Permillemax" = "$Permilleleft" ]   && Left=$((Left+1))
    [ "$Permillemax" = "$Permilleright" ]  && Right=$((Right-1))
    [ "$Permillemax" = "$Permilletop" ]    && Top=$((Top+1))
    [ "$Permillemax" = "$Permillebottom" ] && Bottom=$((Bottom-1))
    Cropgeometry="$((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top"
    
    # Skip check for sides without $Trimcolor in future to save some time
    [ "1.0000" = "$Permilleleft" ]   && Skipleft=yes
    [ "1.0000" = "$Permilleright" ]  && Skipright=yes
    [ "1.0000" = "$Permilletop" ]    && Skiptop=yes
    [ "1.0000" = "$Permillebottom" ] && Skipbottom=yes
    
    # break signal of stackfuser
    ifcmdbreak && Return=1
    [ "$Return" = "1" ] && break

    # Out-of-range error
    { [ "$Left" -gt "$Right" ] || [ "$Top" -gt "$Bottom" ] ; } && {
#      echo "Error: Failed to find an inner rectangle. Unuseable result: $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top" >&2
      failure "trim_hard(): Failed to find an inner rectangle. Unuseable result: $Cropgeometry" 
      Return=1
      Left=0
      Top=0
      Right=$((Imagewidth-1))
      Bottom=$((Imageheight-1))
      break
    }
    
    # Debugging: show intermediate results
    Debugmode=yes
    [ "$Debugmode" ] && {
      Loopcount=$((Loopcount+1))
      [ "$Loopcount" = "10" ] && {
        Loopcount=0
        $Magickbin $Sourceimagempc -fill none -stroke red -strokewidth 1 -pointsize 18 -undercolor white -gravity center -draw "rectangle $Left,$Top $Right,$Bottom  text 0,0 '$Cropgeometry'" $Cropgeometryimage
        showimage $Cropgeometryimage
        eval "$Addcommand"
      }
    }
  done
  [ "$Return" = "1" ] && return 1

  # show result
  showpercent 100 100
  $Magickbin $Sourceimagempc -fill none -stroke red -strokewidth 1 -pointsize 18 -undercolor white -gravity center -draw "rectangle $Left,$Top $Right,$Bottom  text 0,0 '$Cropgeometry'" $Cropgeometryimage
  showimage $Cropgeometryimage
  
  # Output of result
  verbose "trim_hard(): $Cropgeometry"
  #echo "$Left,$Top $Right,$Bottom"                     # "-draw rectangle" geometry
  #echo $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top  # "-crop" geometry
  echo "$Cropgeometry"

  return ${Return:-0}
}

#### fuse helpers

fuse_declare() {
  # declare default fuse mode values
  local Count
  
  Fusemodenumber=25
  Fusesetnumber=12
  
  Fuseoptions="exposureweight saturationweight contrastweight entropyweight blendmask grayprojector levels contrastwindowsize contrastmincurvature contrastedgescale"
  Fusearguments="$Fuseoptions lcescale lcefactor"
#  Fuseopt1combo="'all','set$(seq -s "','set" $Fusesetnumber)','$(seq -s "','" $Fusemodenumber)'"
  Fuseopt1combo="'all','set$(seq -s "','set" $Fusesetnumber)'"
  for Count in $(seq $Fusemodenumber); do
    Fuseopt1combo="$Fuseopt1combo,'$(fuse_getname $Count shortcut)'"
  done
}
fuse_getname() {
  local Number Mode
  local Line Value Name

  Number="${1:-}"
  Mode="${2:-}"
  
  case $Mode in
    option)
      for Line in $Fuseoptions; do
        Value="$(fuse_getvalue $Number $Line value)"
        [ "$Value" = "$(fuse_defaultvalue $Line)" ] || {
          case $Line in
            exposureweight)       Name="$Name exp$Value" ;;
            saturationweight)     Name="$Name sat$Value" ;;
            contrastweight)       Name="$Name cont$Value" ;;
            entropyweight)        Name="$Name ent$Value" ;;
            blendmask)            Name="$Name $(tr -d "-" <<< ${Value%mask})" ;;
            grayprojector)        Name="$Name $Value" ;;
            levels)               Name="$Name lev$Value" ;;
            contrastwindowsize)   Name="$Name cws$Value" ;;
            contrastmincurvature) Name="$Name curv$Value" ;;
            contrastedgescale)    Name="$Name edge$(fuse_getvalue $Number $Line option | cut -d= -f2)" ;;
          esac
        }
      done
      [ -z "$Name" ] && Name="default"
    ;;
    shortcut|"")
      case $Number in
        all|set*) echo "$Number" ;;
        *)
          Number="${Number#fuse}"
          Number="${Number#0}"
          echo "fuse$(printf %02d "$Number")" 
        ;;
      esac
    ;;
  esac
  echo  "$Name"
}
fuse_defaultconfig() {
  # set1
  for Count in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22; do
    fuse_storevalue $Count set1 !
  done
  # set2
  for Count in 1 2 3 5 6 13 14 20 21 ; do
    fuse_storevalue $Count set2 !
  done
  # set3
  for Count in 1 2 3 4 5 6 10 12 14 15 17 20 21 ; do
    fuse_storevalue $Count set3 !
  done
  # set4
  for Count in 1 4 9 10 11 12 14 15 17 20 ; do
    fuse_storevalue $Count set4 !
  done
  # set5
  for Count in 7 8 9  11 12 13 14 15 16 17 20 21 22; do
    fuse_storevalue $Count set5 !
  done
  # set6
  for Count in 1 2 3 4 5 6; do
    fuse_storevalue $Count set6 !
  done
  # set7
  for Count in 1 4; do
    fuse_storevalue $Count set7 !
  done
  # set8
  for Count in 2 5; do
    fuse_storevalue $Count set8 !
  done
  # set9
  for Count in 3 6; do
    fuse_storevalue $Count set9 !
  done
  
  # Default fuse modes
  # 1) # default
  # 2)
  fuse_storevalue 2 contrastwindowsize 9
  # 3)
  fuse_storevalue 3 contrastwindowsize 15
  # 4)
  fuse_storevalue 4 saturationweight 0.1
  # 5) 
  fuse_storevalue 5 contrastwindowsize 9
  fuse_storevalue 5 saturationweight 0.1
  # 6)
  fuse_storevalue 6 contrastwindowsize 15
  fuse_storevalue 6 saturationweight 0.1
  # 7) 
  fuse_storevalue 7 contrastedgescale 0.8
  # 8)
  fuse_storevalue 8 contrastedgescale 0.8
  fuse_storevalue 8 lcescale 10
  fuse_storevalue 8 lcefactor 3
  # 9)
  fuse_storevalue 9 contrastedgescale 0.8
  fuse_storevalue 9 lcescale 30
  fuse_storevalue 9 lcefactor 1
  # 10)
  fuse_storevalue 10 contrastedgescale 1.2
  fuse_storevalue 10 lcescale 15
  fuse_storevalue 10 lcefactor 15
  # 11)
  fuse_storevalue 11 contrastedgescale 1.2
  fuse_storevalue 11 lcescale 7
  fuse_storevalue 11 lcefactor 5
  # 12)
  fuse_storevalue 12 contrastedgescale 1.2
  fuse_storevalue 12 lcescale 30
  fuse_storevalue 12 lcefactor 10
  # 13)
  fuse_storevalue 13 contrastedgescale 1.8
  fuse_storevalue 13 lcescale 1
  fuse_storevalue 13 lcefactor 3
  # 14)
  fuse_storevalue 14 contrastedgescale 1.8
  fuse_storevalue 14 lcescale 5
  fuse_storevalue 14 lcefactor 5
  # 15)
  fuse_storevalue 15 contrastedgescale 1.8
  fuse_storevalue 15 lcescale 30
  fuse_storevalue 15 lcefactor 5
  # 16)
  fuse_storevalue 16 contrastedgescale 2.2
  fuse_storevalue 16 lcescale 1
  fuse_storevalue 16 lcefactor 10
  # 17)
  fuse_storevalue 17 contrastedgescale 2.2
  fuse_storevalue 17 lcescale 5
  fuse_storevalue 17 lcefactor 10
  # 18)
  fuse_storevalue 18 contrastedgescale 2.2
  fuse_storevalue 18 lcescale 10
  fuse_storevalue 18 lcefactor 5
  # 19)
  fuse_storevalue 19 contrastedgescale 1.5
  fuse_storevalue 19 lcescale 1
  fuse_storevalue 19 lcefactor 3
  # 20)
  fuse_storevalue 20 contrastedgescale 1.5
  fuse_storevalue 20 lcescale 7
  fuse_storevalue 20 lcefactor 5
  # 21)
  fuse_storevalue 21 contrastedgescale 1.5
  fuse_storevalue 21 lcescale 10
  fuse_storevalue 21 lcefactor 30
  # 22)
  fuse_storevalue 22 contrastedgescale 1.2
  fuse_storevalue 22 lcescale 3
  fuse_storevalue 22 lcefactor 3
  # 23)
  # 24)
  # 25)
}
fuse_defaultvalue() {
  # define default enfuse settings
  local Entry
  Entry="${1:-}"
  Entry="$(tr -d "-" <<< "$Entry")"
  case "${1:-}" in
    exposureweight)       echo "0" ;;
    saturationweight)     echo "0" ;;
    contrastweight)       echo "1" ;;
    entropyweight)        echo "0" ;;
    blendmask)            echo "--hard-mask" ;;
    grayprojector)        echo "" ;;
    levels)               echo "" ;;
    contrastwindowsize)   echo "5" ;;
    contrastmincurvature) echo "" ;;
    contrastedgescale)    echo "" ;;
    lcescale)             echo "" ;;
    lcefactor)            echo "" ;;
    set*)                 echo "" ;;
  esac
}
fuse_getvalue() {
  local Number Entry Mode Entryoption Value Combovalues Combo
  Number="${1:-}"
  Entry="${2:-}"
  Mode="${3:-}"
  
  Entry="$(tr -d "-" <<< "$Entry")"
  case $Entry in
    exposureweight)       Entryoption="--exposure-weight" ;;
    saturationweight)     Entryoption="--saturation-weight" ;;
    contrastweight)       Entryoption="--contrast-weight" ;;
    entropyweight)        Entryoption="--entropy-weight" ;;
    grayprojector)        Entryoption="--gray-projector" ;;
    levels)               Entryoption="--levels" ;;
    contrastwindowsize)   Entryoption="--contrast-window-size" ;;
    contrastmincurvature) Entryoption="--contrast-min-curvature" ;;
    contrastedgescale)    Entryoption="--contrast-edge-scale" ;;
  esac
  
  case $Entry in
    exposureweight|saturationweight|contrastweight|entropyweight) Combovalues="empty 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1" ;;
    blendmask)            Combovalues="--hard-mask --soft-mask" ;;
    grayprojector)        Combovalues="anti-value average l-star lightness luminance pl-star value" ;;
    levels)               Combovalues="empty $(seq 29)" ;;
    contrastwindowsize)   Combovalues="empty 3 5 7 9 11 13 15 17 19 21 23 25 27 29" ;;
    contrastmincurvature) Combovalues="empty 0 0.1 0.5 1 2 3 5 7.5 8 10" ;;
    contrastedgescale)    Combovalues="empty 0 0.1 0.2 0.3 0.4 0.5 0.8 1.0 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.2 2.5 3.0 4.0 5.0" ;;
    lcescale)             Combovalues="empty 0 1 2 3 4 5 6 7 8 9 10 12 15 18 20 25 30 40 50" ;;
    lcefactor)            Combovalues="empty 0 1 2 3 4 5 6 7 8 9 10 12 15 18 20 25 30 40 50" ;;
  esac
  
  
  Value="$(grep "^$Number:$Entry:" $Enfuseconfigfile | cut -d: -f3)"
  [ -z "$Value" ] && Value="$(fuse_defaultvalue "$Entry")"
  
  case $Mode in
    value)     
      echo "$Value" 
    ;;
    
    option)
      [ -z "$Value" ] && echo "" && return 0
      case $Entry in
        blendmask)
          echo "$Value"
        ;;
        contrastedgescale)
          Lcescale=$(fuse_getvalue  $Number lcescale value)
          Lcefactor=$(fuse_getvalue $Number lcefactor value)
          case $Lcescale in
            "") 
              echo "$Entryoption=$Value" 
            ;;
            *)
              case $Lcefactor in
                "") echo "$Entryoption=$Value:$Lcescale" ;;
                *)  echo "$Entryoption=$Value:$Lcescale:$Lcefactor" ;;
              esac
            ;;
          esac
        ;;
        lcescale|lcefactor) echo "" ;;
        contrastwindowsize)
          [ "$Value" = "5" ] || echo "$Entryoption=$Value" 
        ;;
        *) 
          echo "$Entryoption=$Value" 
        ;;
      esac
    ;;
    
    kaptain)
      for Line in $Combovalues; do
        Combo="$Combo,'$Line'"
      done
      Combo="${Combo#,}"
      Combo="$(sed 's/empty//' <<< "$Combo")"
      echo "${Entry}(${Combo})='${Value}'"
    ;;
  esac
}
fuse_storevalue() {
  local Number Entry Value Content
  
  Number="${1:-}"
  Entry="${2:-}"
  Value="${3:-}"
  
  Entry="$(tr -d "-" <<< "$Entry")"
  Content="$(sed "/^$Number:$Entry:/d" $Enfuseconfigfile)"
  [ "$Value" = "$(fuse_defaultvalue "$Entry")" ] && Line="" || Line="$Number:$Entry:$Value"
  [ "$Line" ] && Content="$(sort -V <<< "$Content
$Line")"
  echo "$Content" > $Enfuseconfigfile
  return 0
}
fuse_glob() {
  local Count Glob
  case "${1:-}" in
    all|setall) echo "*" ;;
    set*) 
      for Count in $(seq $Fusemodenumber); do
        [ "$(fuse_getvalue $Count ${1:-} value)" ] && Glob="${Glob},*$(fuse_getname $Count shortcut)*"
      done
      Glob="${Glob#,}"
      [ "$Glob" ] && echo "{${Glob}}" || return 1
    ;;
    *) echo "*$(fuse_getname ${1:-} shortcut)*"
  esac
}

#### run commands on all CPUs

multicore() {
  # Run multiple processes in parallel, but not more than $Multicore_maxprocesses
  # $1 Command
  # $2 Image to show if $1 is finished
  # Run multicore_wait afterwards to wait for the last processes to finish.
  
  local Process Command
  local Mem_needed Zram
  
  [ "$Multicore_processcount" = "$Multicore_maxprocesses" ] && {
    multicore_wait || return 1
  }
  [ "$Multicore_processcount" = "0" ] && Multicore_memorymax="$(freememory)"  
  Mem_needed=0
  for Process in $(seq $Multicore_maxprocesses); do
    Mem_needed="$(awk "BEGIN {print $Mem_needed + ${Multicore_memory[$Process]:-0} }" )"
  done
  Mem_needed="$((Mem_needed+${3:-0}))"
  [ "$Mem_needed" -gt "$Multicore_memorymax" ] && {
    note "multicore: Low memory. Waiting for $Multicore_processcount running processes to finish. Need: $((Mem_needed/1000)) MB, Available: $((Multicore_memorymax/1000)) MB"
    [ "$Mem_needed" -gt "$Multicore_memorymax" ] && [ "$Multicore_processcount" = "0" ] && note "multicore: Likely hard disk cache will be used and slow down the calculation."
    multicore_wait || return 1
  }
  
  storeinfo test cmdbreak && return 1

  Multicore_processcount=$((Multicore_processcount +1))

  Command="$(cut -d ' ' -f1 <<< "${1:-}")"
  case $(type -t "$Command") in
    file) Command="nice ${1:-}" ;;
    *)    Command="${1:-}" ;;
  esac
  
  #verbose "multicore: ${1:-}"
  eval "$Command &"
  
  Multicore_process[Multicore_processcount]=$!
  Multicore_image[Multicore_processcount]="${2:-}"
  Multicore_memory[Multicore_processcount]="${3:-0}"
  
  return 0
}
multicore_wait() {
  local Process Error
  for Process in $(seq $Multicore_maxprocesses); do
    [ "${Multicore_process[$Process]}" ] && {
      multicore_waitprocess "${Multicore_process[$Process]}" || {
        multicore_break
        Error=1
      }
      [ "$Error" ] && break
      [ "${Multicore_image[$Process]}" ] && showimage "${Multicore_image[$Process]}"
    }
    Multicore_process[$Process]=""
    Multicore_image[$Process]=""
    Multicore_memory[$Process]="0"
  done
  [ "$Error" ] && return 1
  Multicore_processcount=0
  return 0
}
multicore_waitprocess() {
  local Error
  while sleep 0.2 ; do
    ps -p "${1:-}" >/dev/null || break
    ifcmdbreak && Error=1
  done
  [ "$Error" ] && return 1
  wait "${1:-}"
  return $?
}
multicore_break() {
  local Process
  for Process in $(seq $Multicore_maxprocesses); do
    [ "${Multicore_process[$Process]}" ] && {
      kill "${Multicore_process[$Process]}"
      wait "${Multicore_process[$Process]}"
      Multicore_process[$Process]=""
      Multicore_image[$Process]=""
      Multicore_memory[$Process]="0"
    }
  done
}

#### GUI

kaptaingrammar() {
  echo '#! /usr/bin/kaptain

start "stackfuser '$Version'"  -> frameset;
  frameset                       -> topframe bottomframe;
    topframe                       -> tabset;
    bottomframe                    -> dirframe statusframe ;
    
  dirframe:beside                    -> choosedirguibutton choosedir refreshbutton;
    choosedirguibutton                 -> @button="Stackshot selector" ;
    choosedir                          -> @directory="'$Projecthome'" ;
    refreshbutton                      -> @button="refresh" ;
  statusframe                        -> wizardstatusline ;
    wizardstatusline:beside            -> cmdpercent wizardlog;
      cmdpercent                         -> @icon ;
      wizardlog                          -> @text="" ;

  tabset:tabbed                     -> batchtab specialtab deletetab configtab showresulttab;
    batchtab "Image batch processing" -> batchoptionframe ;
      batchoptionframe:beside            -> batchframeleft  batchframeright;
        batchframeleft:framed              -> batchblock1 batchblock2 ;
        batchframeright:framed             -> batchblock3 runbatchframe @fill stopframe;
          
      batchblock1 "batch block 1: crop and balance directory magick" -> orientline cropline whitebalanceline align_vidstabline align_huginline align_aisline;
        orientline:beside                                     -> orient orientopt1combo orientmagick;
          orientopt1combo                                       -> @combo("topleft","topright","bottomleft","bottomright")="topleft" ;
          orientmagick                                          -> @button="magick" ;
          orient:beside               "orient (fixate image exif rotation)" -> "on" | "";
        meanbalanceline:beside                                -> meanbalance meanbalanceopt1combo meanbalancemagick meanbalancefuse meanbalanceevaluate;
          meanbalanceopt1combo                                  -> @combo("interactive","topleft","topright","bottomleft","bottomright","full")="full" ;
          meanbalancemagick                                     -> @button="magick" ;
          meanbalanceevaluate                                   -> @button="evaluate" ;
          meanbalancefuse                                       -> @button="fuse" ;
          meanbalance:beside          "meanbalance"             -> "on"  | ! "";
        whitebalanceline:beside                               -> whitebalance whitebalanceopt1combo whitebalanceopt2combo whitebalancemagick whitebalancefuse whitebalanceevaluate;
          whitebalanceopt1combo                                 -> @combo("interactive","topleft","topright","bottomleft","bottomright","full")="topleft" ;
          whitebalanceopt2combo                                 -> @combow("mean","#777777","#888888","#999999","#AAAAAA","#BBBBBB","#CCCCCC","#DDDDDD","#EEEEEE","#FFFFFF")="#CCCCCC" ;
          whitebalancemagick                                    -> @button="magick" ;
          whitebalanceevaluate                                  -> @button="evaluate" ;
          whitebalancefuse                                      -> @button="fuse" ;
          whitebalance:beside         "whitebalance"            ->  "on"  | ! "";
        cropline:beside                                       -> crop cropopt1combo cropopt2combo cropmagick cropfuse cropevaluate;
          cropopt1combo                                         -> @combo("interactive","shrink","even","geometry")="interactive" ;
          cropopt2combo                                         -> @combow("","1","2","5","10","200x200+15+15")="" ;
          cropmagick                                            -> @button="magick" ;
          cropevaluate                                          -> @button="evaluate" ;
          cropfuse                                              -> @button="fuse" ;
          crop:beside                 "crop"                    -> "on" | ! "";
        align_vidstabline:beside                              -> align_vidstab align_vidstabopt1combo align_vidstabopt2combo align_vidstabopt3combo align_vidstabbutton ;
          align_vidstabopt1combo                                -> @combo("distort_only","common_area","crop","crop_interactive")="crop";
          align_vidstabopt2combo:beside   "Iterations:"         -> @combo("1","2","3")="3";
          align_vidstabopt3combo:beside   "prepare"             -> "prepare" | ! "" ;
          align_vidstabbutton                                   -> @button="magick" ;
          align_vidstab:beside        "align with vidstab/ffmpeg"    -> "on" | ! "";
        align_huginline:beside                                  -> align_hugin align_huginbutton ;
          align_huginbutton                                      -> @button="magick" ;
          align_hugin:beside          "align with hugin"         -> "on" | ! "";
        align_aisline:beside                                  -> align_ais align_aisopt1combo align_aisopt2combo align_aisbutton ;
          align_aisopt1combo          "demagnifier (-m)"        -> "m"  | "";
          align_aisopt2combo          "crop interactive"        -> "interactive" | ! "";
          align_aisbutton                                       -> @button="magick" ;
          align_ais:beside            "align with align_image_stack" -> "on" | "";
      
      batchblock2 "batch block 2: imagemagick operations on directory magick" -> rotateline gammaline levelline contrastline sharpenline brightnessline stretchline statisticline wizardline;
        rotateline:beside                                     -> rotate rotateopt1combo rotatemagick rotatefuse rotateevaluate;
          rotateopt1combo                                       -> @combo("90","180","270")="90" ;
          rotatemagick                                          -> @button="magick" ;
          rotateevaluate                                        -> @button="evaluate" ;
          rotatefuse                                            -> @button="fuse" ;
          rotate:beside               "rotate"                  -> "on"  | ! "";
        gammaline:beside                                      -> gamma gammamagick gammafuse gammaevaluate;
          gammaopt1combo                                        -> @combow("auto","0.2","0.3","0.4","0.454545","0.5","0.6","0.7","0.8","0.9","1.2","1.5","2.0","3.0","4.0")="auto" ;
          gammamagick                                           -> @button="magick" ;
          gammaevaluate                                         -> @button="evaluate" ;
          gammafuse                                             -> @button="fuse" ;
          gamma:beside                "gamma"                   -> gammaopt1combo | "";
        levelline:beside                                      -> level levelmagick levelfuse levelevaluate;
          levelopt1combo                                        -> @combow("auto","5%","10%","15%","20%","25%","30%")="auto" ;
          levelmagick                                           -> @button="magick" ;
          levelevaluate                                         -> @button="evaluate" ;
          levelfuse                                             -> @button="fuse" ;
          level:beside                "level"                   -> levelopt1combo | ! "";
        contrastline:beside                                   -> contrast contrastmagick contrastfuse contrastevaluate;
          contrastopt1combo                                     -> @combow("2x50%","3x50%","4x50%","5x50%","3x30%","3x70%")="5x50%" ;
          contrastmagick                                        -> @button="magick" ;
          contrastevaluate                                      -> @button="evaluate" ;
          contrastfuse                                          -> @button="fuse" ;
          contrast:beside             "sigmoidal-contrast"      -> contrastopt1combo | "";
        sharpenline:beside                                    -> sharpen sharpenmagick sharpenfuse sharpenevaluate;
          sharpenopt1combo                                      -> @combow("3x1","6x2","8x4","12x6")="8x4" ;
          sharpenmagick                                         -> @button="magick" ;
          sharpenevaluate                                       -> @button="evaluate" ;
          sharpenfuse                                           -> @button="fuse" ;
          sharpen:beside              "adaptive-sharpen"        -> sharpenopt1combo | "";
        statisticline:beside                                  -> statistic statisticopt1combo statisticopt2combo statisticmagick statisticfuse statisticevaluate;
          statisticopt1combo                                    -> @combow("gradient","maximum","minimum","mean","median","mode","nonpeak","rms","standarddeviation")="median" ;
          statisticopt2combo                                    -> @combow("1","2","3","4","5","6","7","8","9","10")="5" ;
          statisticmagick                                       -> @button="magick" ;
          statisticevaluate                                     -> @button="evaluate" ;
          statisticfuse                                         -> @button="fuse" ;
          statistic:beside            "statistic"               -> "on" | ! "";
        brightnessline:beside                                 -> brightness brightnessmagick brightnessfuse brightnessevaluate;
          brightnessopt1combo                                   -> @combow("0x5","0x10","0x15","5x0","5x5","5x10","5x15","10x0","10x5","10x10","15x15","20x20")="10x10" ;
          brightnessmagick                                      -> @button="magick" ;
          brightnessevaluate                                    -> @button="evaluate" ;
          brightnessfuse                                        -> @button="fuse" ;
          brightness:beside           "brightness-contrast"     -> brightnessopt1combo | ! "";
        stretchline:beside                                    -> stretch stretchmagick stretchfuse stretchevaluate;
          stretchopt1combo                                      -> @combow("auto","2%x1%","1%","2%","3%","4%","5%","10%","15%","20%","max")="max" ;
          stretchmagick                                         -> @button="magick" ;
          stretchevaluate                                       -> @button="evaluate" ;
          stretchfuse                                           -> @button="fuse" ;
          stretch:beside              "stretch-contrast"        -> stretchopt1combo | ! "";
        wizardline:beside                                     -> wizard wizardmagick wizardfuse wizardevaluate;
          wizardopt1combo                                       -> @combow("","-adaptive-blur 6x2","-canny 3","-charcoal 3","-colorspace Gray","-despeckle","-edge 0","-enhance","-equalize","-evaluate cos 0.5","-flip","-flop","-implode 1","-kuwahara 2.0","-magnify","-modulate 90,110","-negate","-sepia-tone 100%","-wavelet-denoise 5%x0.1")="" ;
          wizardmagick                                          -> @button="magick" ;
          wizardevaluate                                        -> @button="evaluate" ;
          wizardfuse                                            -> @button="fuse" ;
          wizard:beside               "(free option typing)"    -> wizardopt1combo | ! "" ;
        
      batchblock3 "batch block 3: combine stackshot images" -> evaluateline1 fuseline evaluateline2 deletebackups2 deletemagick2;
        fuseline:beside                                       -> fuse fuseconfig @fill fusemagick;
          fuseconfig                                            -> @button="config" ;
          fusemagick                                            -> @button="magick";
          fuse:beside                 "fuse"                    -> "on" | "" ;
        evaluateline1:beside                                  -> evaluate1 evaluatemagick ;
          evaluatemagick                                        -> @button="magick" ;
          evaluate1:beside            "evaluate"                -> "on" | "";
        evaluateline2:beside                                  -> evaluate2 evaluatefuse;
          evaluatefuse                                          -> @button="fuse" ;
          evaluate2:beside            "evaluate"                -> "on" | "";
        deletebackups2:beside         "delete"                -> @button="backups + cache" "on" | "";
        deletemagick2:beside          "delete"                -> @button="magick" "on"          | ! "";

      runbatchframe "Batch processing"                      -> batchblockline batchallline;
        batchblockline                                        -> runbatchone runbatchtwo runbatchthree;
          runbatchone:beside          "batch block 1"           -> "batchblock1" | "" @button="run";
          runbatchtwo:beside          "batch block 2"           -> "batchblock2" | "" @button="run";
          runbatchthree:beside        "batch block 3"           -> "batchblock3" | "" @button="run";
        batchallline:beside -> runbatchprocessing ;
          runbatchprocessing                                    -> @button="Run selected batch blocks";
      
      stopframe "Stop actions"                                -> stopline;
        stopline                                                -> cmdbreak killviewnior;
          cmdbreak                                                -> @button="stop current batch" ;
          killviewnior                                            -> @action("killall viewnior ffplay")="killall viewnior ffplay";
                
    specialtab:framed "Special operations" -> specialframe @fill undoframe;
      specialframe "Special operations" -> imageformatline videoline animationline cuberotateline lightbalanceline evalstepline rulerline ;
        rulerline:beside                                      -> ruler rulermagick rulerfuse rulerevaluate;
          ruleropt1combo                                        -> @combo('$Imgrulermodecombo')="100z" ;
          ruleropt2combo:beside       "Title:"                  -> @string ;
          ruleropt3combo:beside       "Color:"                  -> @combo("black","white","red","green","blue")="black" ;
          ruleropt4combo:beside       "Elements:"               -> @combow("10","20","30","40","50","60","70","80","90","100","")="" ;
          rulermagick                                           -> @button="magick" ;
          rulerevaluate                                         -> @button="evaluate" ;
          rulerfuse                                             -> @button="fuse" ;
          ruler:beside                "ruler"                 -> "" ruleropt1combo ruleropt2combo ruleropt3combo ruleropt4combo;
        animationline:beside                                  -> animation animationopt1combo animationopt2combo animationopt3combo animationopt9combo animationmagick;
          animationopt1combo:beside                             -> @combo("quick","smooth")="smooth";
          animationopt2combo:beside   "fuse:"                   -> @combow('$Fuseopt1combo')="fuse01";
          animationopt3combo:beside   "Distortion:"             -> @combow("15","20","25","30","40","50","75","100","150")="30";
          animationopt9combo:beside   "Format:"                 -> @combow("webm","mp4","gif")="webm";
          animationmagick                                       -> @button="magick" ;
          animation:beside            "animated video"          -> "" ;
        videoline:beside                                      -> video videoopt1combo videoopt2combo videoopt9combo videomagick;
          videoopt1combo:beside                                 -> @combo("in","out","in_and_out")="in_and_out";
          videoopt2combo:beside       "Framerate:"              -> @combow("2","3","4","5","7","10","15","20","25","30")="10";
          videoopt9combo:beside       "Format:"                 -> @combow("webm","mp4","gif")="webm";
          videomagick                                           -> @button="magick" ;
          video:beside                "focus video"             -> "" ;
        cuberotateline:beside                                 -> cuberotate cuberotateopt1combo cuberotatemagick;
          cuberotateopt1combo:beside                            -> @combo("90","180","270","reverse-order","back-left","back-top","left","right","top","bottom")="reverse-order";
          cuberotatemagick                                      -> @button="magick" ;
          cuberotate:beside           "cuberotate"              -> "" ;
        lightbalanceline:beside                               -> lightbalance lightbalanceopt1combo lightbalanceopt2combo lightbalancemagick lightbalancefuse lightbalanceevaluate;
          lightbalanceopt1combo                                 -> @combo("brightness","gamma","level","levelgamma","modulate","multiply")="levelgamma" ;
          lightbalanceopt2combo                                 -> @combo("10%","20%","30%","40%","50%","60%","70%","80%")="40%" ;
          lightbalancemagick                                    -> @button="magick" ;
          lightbalanceevaluate                                  -> @button="evaluate" ;
          lightbalancefuse                                      -> @button="fuse" ;
          lightbalance:beside         "lightbalance"            -> "" ;
        imageformatline:beside                                -> imageformat imageformatopt9combo imageformatmagick imageformatfuse imageformatevaluate;
          imageformatopt9combo                                  -> @combow('$Imageformatcombo')="TIF" ;
          imageformatmagick                                     -> @button="magick" ;
          imageformatevaluate                                   -> @button="evaluate" ;
          imageformatfuse                                       -> @button="fuse" ;
          imageformat:beside          "change image format"     -> "";
        evalstepline:beside                                   -> evalstep evalstepopt1combo evalstepopt2combo evalstepmagick;
          evalstepopt1combo                                     -> @combow("max","min","mean","median")="median" ;
          evalstepopt2combo                                     -> @combow("3","5","7","9","15","25")="5" ;
          evalstepmagick                                        -> @button="magick" ;
          evalstep:beside             "Evaluate blocks of N images" -> "";
          
      undoframe                       "undo"                -> undoline;
        undoline:beside                                       -> undo undomagick undofuse undoevaluate;
          undomagick                                            -> @button="magick" ;
          undoevaluate                                          -> @button="evaluate" ;
          undofuse                                              -> @button="fuse" ;
          undo                        "undo last step"          -> "" ;
          
    deletetab:framed                  "Delete"               -> deletedirframe deleterescursiveframe @fill;
      deletedirframe                  "Delete directories of current stack"   -> deletebuttons; 
        deletebuttons:beside                                   -> deletebackups deletemagick deleteevaluate deletecompose deletefuse deletevideo deleteall deleteallbutvideo;
          deletebackups                                          -> @button="backups + cache";
          deleteevaluate                                         -> @button="evaluate";
          deletemagick                                           -> @button="magick";
          deletecompose                                          -> @button="compose";
          deletefuse                                             -> @button="fuse";
          deletevideo                                            -> @button="video";
          deleteall                                              -> @button="all";
          deleteallbutvideo                                      -> @button="all but video";
      deleterescursiveframe           "Delete recursively"     -> recursivedeletedir recursivedeletecache recursivedeletemagick;
        recursivedeletedir            "Base direcortory for recursive deleting" -> @directory"'$(storeinfo dump projecthome)'" ;
        recursivedeletecache                                       -> @button="Delete all cache and backup directories" ;
        recursivedeletemagick                                      -> @button="Delete all magick directories" ;
          
    configtab                         "Configuration"        -> configframe;
      configframe                                              -> storagebasedirtext storagebasedir allownonconformant gallerydir @fill;
        storagebasedirtext                                     -> @text="stackfuser expects a directory structure like the one created by stackshooter. \n\
Basically an otherwise empty parent directory should contain a folder literally called \"stackshot\" that contains the source images.\n\
You can define the storage base dir where all those parent directories are stored. \n\
This is especially useful for the \"stackshot selector\" button you can see at the left bottom.\n\
The directory structure is:\n\
  [storage base dir]\n\
                  [projectname]\n\
                               [stackname]\n\
                                          stackshot\n\
                                                   img001.jpg\n\
                                                   img002.jpg\n\
                                                   ...\n\
                               [stackname2]\n\
                                          stackshot\n\
                                                   img001.jpg\n\
                                                   img002.jpg\n\
                                                   ...\n\
                  [stackname_without_project_above]\n\
                               stackshot\n\
                                        img001.jpg\n\
                                        img002.jpg\n\
                                        ...\n\
" ;
        storagebasedir:beside         "Storage base dir:"                                                                       -> @directory="'$(storeinfo dump projecthome)'";
        allownonconformant:beside     "Allow stackshots outside of Storage base dir and without directory \"stackshot\"."       -> "yes" | '$( [ "$(storeinfo dump allow_dir_invalid)" = "no" ] && echo "!")' "no" ;
        gallerydir:beside             "Gallery directory where one result of each stackshot in the storage base dir is shown:"  -> @directory="'$(storeinfo dump gallerydir)'";

          
    showresulttab:framed              "Show results"     -> showsetframe showcomposeframe showdirvideoframe;
      showsetframe:beside:framed      "Evaluate results of fuse image sets" -> showmaxline showminline showmeanline showmedianline;'
      
  echo -n 'showmaxline:double         "MAX"                  -> '
  for Set in $(seq $Fusesetnumber); do
    echo -n " showmax_set${Set} "
  done
  echo '      showmax_magick showmax_all; '
  for Set in $(seq $Fusesetnumber); do
    echo "showmax_set${Set}                                    -> @button=\"set${Set}\";"
  done
  echo '  showmax_magick                                       -> @button="magick";
          showmax_all                                          -> @button="all";'
      
  echo -n 'showminline:double         "MIN"                  -> '
  for Set in $(seq $Fusesetnumber); do
    echo -n " showmin_set${Set} "
  done
  echo '      showmin_magick showmin_all; '
  for Set in $(seq $Fusesetnumber); do
    echo "showmin_set${Set}                                    -> @button=\"set${Set}\";"
  done
  echo '  showmin_magick                                       -> @button="magick";
          showmin_all                                          -> @button="all";'
      
  echo -n 'showmeanline:double        "MEAN"                 -> '
  for Set in $(seq $Fusesetnumber); do
    echo -n " showmean_set${Set} "
  done
  echo '      showmean_magick showmean_all; '
  for Set in $(seq $Fusesetnumber); do
    echo "showmean_set${Set}                                   -> @button=\"set${Set}\";"
  done
  echo '  showmean_magick                                      -> @button="magick";
          showmean_all                                         -> @button="all";'
  
  echo -n 'showmedianline:double     "MEDIAN"                -> '
  for Set in $(seq $Fusesetnumber); do
    echo -n " showmedian_set${Set} "
  done
  echo '      showmedian_magick showmedian_all; '
  for Set in $(seq $Fusesetnumber); do
    echo "showmedian_set${Set}                                 -> @button=\"set${Set}\";"
  done
  echo '  showmedian_magick                                    -> @button="magick";
          showmedian_all                                       -> @button="all";'
          
  echo '  showcomposeframe      "Composed max+min results" -> showcomposeline1 showcomposeline2;'
  echo '    showcomposeline1:beside                          -> '
  for Mode in $Composemodes1; do
    echo -n " showcompose_${Mode} "
  done
  echo ';'
  echo '   showcomposeline2:beside                           -> '
  for Mode in $Composemodes2; do
    echo -n " showcompose_${Mode} "
  done
  echo ';'
  for Mode in $Composemodes; do
    echo " showcompose_${Mode}                                 -> @button='${Mode}' ;"
  done
        
  echo '
    showdirvideoframe:beside                              -> showdirframe showvideoframe;
      showdirframe                   "Directories"          -> showdirline ;
        showdirline:beside                                    -> showdirfm showdirstackshot showdirmagick showdircompose showdirfuse showdirevaluate ;
          showdirfm                                             -> @button="File Manager";
          showdirstackshot                                      -> @button="stackshot";
          showdirmagick                                         -> @button="magick";
          showdirfuse                                           -> @button="fuse";
          showdircompose                                        -> @button="compose";
          showdirevaluate                                       -> @button="evaluate";
      showvideoframe                 "Videos"               -> show_video;
        show_video:beside                                     -> @combo("--------------------------------------------------");
  '
}
sendkaptain() {
  # send messages to kaptain over its stdin
#  note "Send to kaptain: $1"
  #testvar pidkaptain && echo "$1" >&${Kaptainstdin}
  #testvar pidkaptain || return 1
  echo "${1:-}" >>${Kaptainstdinfile}
}
askkaptain() {
  # ask kaptain for value of $1
  local Wait Answer
  
  #testvar pidkaptain || return 1
  #gui_main_grammar | grep -q "${1:-}" || return 1

  [ "${1:-}" = "-c" ] && {
    # check if entry if present at all
    shift
    kaptaingrammar | grep -q "${1:-}" || return 1
  }
  :> $Kaptainanswerfile
  
  sendkaptain "${1:-}?"
  for Wait in $(seq 15); do
    milisleep $Wait
    Answer="$(cat "$Kaptainanswerfile")"
    [ -n "$Answer" ] && echo "$Answer" && break
  done
  
  :> $Kaptainanswerfile
  [ -z "$Answer" ] && return 1
  return 0
}
pipekaptain() {
  # provide script for interactive kaptain option --pipe
  # Needs containing variables to be set beforehand.
  echo  "#! /bin/bash
$(declare -f storepid)
Storepidfile='$Storepidfile'
tail -f ${Kaptainstdinfile} & Tailpid=\$!
storepid \$Tailpid
cat >> ${Kaptainstdoutfile}
kill \$Tailpid
" >$Kaptainpipefile
  chmod +x $Kaptainpipefile
}

## GUI helpers

kaptain_update() {
  local Stackdir Cmdstatus
  local Line Shortcut Comboline Mode Set
  Stackdir="$(storeinfo dump stackshotdir)"
  
  # update working directory
  sendkaptain "choosedir='$Stackdir'"
  
  # show directory buttons
  [ -d "$Stackdir/stackshot" ]                      && sendkaptain "showdirstackshot='stackshot'"       || sendkaptain "showdirstackshot='-'"
  [ -d "$Stackdir/magick" ]                         && sendkaptain "showdirmagick='magick'"             || sendkaptain "showdirmagick='-'"
  [ -d "$Stackdir/evaluate" ]                       && sendkaptain "showdirevaluate='evaluate'"         || sendkaptain "showdirevaluate='-'"
  [ -d "$Stackdir/compose" ]                        && sendkaptain "showdircompose='compose'"           || sendkaptain "showdircompose='-'"
  [ -d "$Stackdir/fuse" ]                           && sendkaptain "showdirfuse='fuse'"                 || sendkaptain "showdirfuse='-'"
  
  # show delete buttons
  check_dirglob "$Stackdir/*.bak $Stackdir/cache" ] && sendkaptain "deletebackups='backups + cache'"    || sendkaptain "deletebackups='-'"
  check_dirglob "$Stackdir/magick" ]                && sendkaptain "deletemagick='magick'"              || sendkaptain "deletemagick='-'"
  check_dirglob "$Stackdir/evaluate" ]              && sendkaptain "deleteevaluate='evaluate'"          || sendkaptain "deleteevaluate='-'"
  check_dirglob "$Stackdir/compose" ]               && sendkaptain "deletecompose='compose'"            || sendkaptain "deletecompose='-'"
  check_dirglob "$Stackdir/fuse" ]                  && sendkaptain "deletefuse='fuse'"                  || sendkaptain "deletefuse='-'"
  check_dirglob "$Stackdir/video" ]                 && sendkaptain "deletevideo='video'"                || sendkaptain "deletevideo='-'"
  
  # videos
  Comboline=""
  for Line in $(fileglob "$Stackdir/video/*.mp4") $(fileglob "$Stackdir/video/*.gif") $(fileglob "$Stackdir/video/*.webm"); do
    Shortcut="$(rev <<< "$Line" | cut -d. -f1-4 | rev)"
    Comboline="$Comboline,'$Shortcut'"
  done
  Comboline="${Comboline#,}"
  [ -z "$Comboline" ] && Comboline="'-'"
  sendkaptain "show_video($Comboline)=''"
  
  # evaluate results
  for Mode in max min mean median; do
    for Set in $(seq $Fusesetnumber); do
      check_fileglob "$Stackdir/evaluate/*.fuse.${Mode}.set${Set}.*" && sendkaptain "show${Mode}_set${Set}='set${Set}'" || sendkaptain "show${Mode}_set${Set}='-'" 
    done
    check_fileglob "$Stackdir/evaluate/*.magick.${Mode}.*" && sendkaptain "show${Mode}_magick='magick'" || sendkaptain "show${Mode}_magick='-'"
  done
  
  # compose results
  for Mode in $Composemodes; do
    check_fileglob "$Stackdir/compose/*.${Mode}.*" && sendkaptain "showcompose_${Mode}='${Mode}'" || sendkaptain "showcompose_${Mode}='-'"
  done
  
  Cmdstatus="$(storeinfo dump status)"
  case $Cmdstatus in
    error|idle) showpercent $Cmdstatus ;;
  esac
  
  # update preview
  kaptain_update_preview
}
kaptain_update_preview() {
  local Stackdir Currentimage Image Cachedir Imagelist Imagenumber
  
  Stackdir="$(storeinfo dump stackshotdir)"

  # check if currently in valid dir, otherwise clear display
  check_stackdir "$Stackdir" || {
    storeinfo drop showimage
    showimage notfound
    return 0
  }
  
  # check if an image of current stackdir is shown
  Currentimage="$(storeinfo dump showimage)"
  grep -q "$Stackdir" <<< "$Currentimage" && [ -e "$Currentimage" ] && showimage "$Currentimage" && return 0
  
  # check for a result to show
  Image="$(fileglob "$Stackdir/evaluate/*fuse.median.*" | grep 'set2\.' | head -n1)"
  [ -e "$Image" ] && showimage "$Image" && return 0
  
  Image="$(fileglob "$Stackdir/evaluate/*fuse.median.*" | head -n1)"
  [ -e "$Image" ] && showimage "$Image" && return 0
  
  Image="$(fileglob "$Stackdir/*.fuse.median.*" | head -n1)"
  [ -e "$Image" ] && showimage "$Image" && return 0
  
  Image="$(fileglob "$Stackdir/evaluate/*magick.max*")"
  [ -e "$Image" ] && showimage "$Image" && return 0

  Imagelist="$(fileglob "$Stackdir/magick/*")"
  [ "$Imagelist" ] && {
    Imagenumber="$(grep -c . <<< "$Imagelist")"
    Image="$(head -n$((Imagenumber/2)) <<< "$Imagelist" | tail -n1)"
    showimage "$Image"
    return 0
  }
  
  Imagelist="$(fileglob "$Stackdir/stackshot/*")"
  [ "$Imagelist" ] && {
    Imagenumber="$(grep -c . <<< "$Imagelist")"
    Image="$(head -n$((Imagenumber/2)) <<< "$Imagelist" | tail -n1)"
    showimage "$Image"
    return 0
  }
  
  Imagelist="$(fileglob "$Stackdir/*")"
  [ "$Imagelist" ] && {
    Imagenumber="$(grep -c . <<< "$Imagelist")"
    Image="$(head -n$((Imagenumber/2)) <<< "$Imagelist" | tail -n1)"
    showimage "$Image"
    return 0
  }
  return 1
}
showpercent() {
  local Percent Part Full Percentimage
  
  Percentimage="$Maincachedir/percent.png"
  Part="${1:-}"
  Full="${2:-1}"
  
  case "$Part" in
    idle) Percentimage="p_idle.png" ;;
    busy) Percentimage="p_busy.png" ;;
    error) Percentimage="p_error.png" ;;
    *)
      Percent="$(( 100 * Part / Full ))"
      Percentimage="p_$Percent.png" 
    ;;
  esac
  Percentimage="$Percentcachedir/$Percentimage"

  [ -e "$Percentimage" ] || case "$Part" in
    idle)  $Magickbin -size 100x20 xc:transparent -fill black  -pointsize 20 -gravity center -draw "text 0,0 'idle'"     "$Percentimage" ;;
    busy)  $Magickbin -size 100x20 xc:transparent -fill green1 -pointsize 20 -gravity center -draw "text 0,0 '* BUSY *'" "$Percentimage" ;;
    error) $Magickbin -size 100x20 xc:transparent -fill red    -pointsize 20 -gravity center -draw "text 0,0 'ERROR'"    "$Percentimage" ;;
    *)     $Magickbin -size 100x20 xc:transparent -fill green1 -draw "rectangle 0,0,$((Percent * 1)),20" -fill black -pointsize 20 -gravity center -draw "text 0,0 '${Percent}%'" "$Percentimage" ;;
  esac
  sendkaptain "cmdpercent('$Percentimage')=''"
}

## sub GUIs

stackshot_selector() {
  # GUI to choose stackshot. Preview of median images. Sorted by project dirs.
  local Button Argument
  local Dirlist Imagelist Dirarray
  local Allprojects Entrylist Projectimages Projectline
  local Projecthome Projectdir Oldprojectdir Cachedir
  local Count Dircount Dir Image
  local Refresh 
  local Windowwidth Windowheight Windowxpos Windowypos
  
  Cachedir="$(storeinfo dump cache)"

  Projecthome="$(storeinfo dump projecthome)"
  Projecthome="${1:-$Projecthome}"
  cd "$Projecthome"
  
  # check for running instance, raise window if yes
  storeinfo test stackshot_selector && {
    note "stackshot_selector is already running."
    xdotool search --name "stackshot selector" windowraise
    return 0
  }
  storeinfo "stackshot_selector=running"
  
  # generate empty X image for unfused stackshots
  Emptyimage=$Thumbnaildir/empty.png
  [ -e "$Emptyimage" ] || $Magickbin caption:X $Emptyimage
  
  # get list of stackshot dirs and median images
  Dirlist="$(find -name stackshot -type d | sed s%/stackshot%% | sort -V)"
  for Dir in $Dirlist; do
    Image="$(find $Dir/*fuse.median.set* $Dir/*fuse.median* 2>/dev/null | head -n1)"
    Imagelist="$Imagelist
$Image"
  done
  Imagelist="$(tail -n+2 <<< "$Imagelist")"
  Dircount="$(grep -c . <<< "$Dirlist")"

  Count=0
  for Dir in $Dirlist EOL ; do
    Count=$((Count +1))
    showpercent "$Count" "$Dircount"
    Dirarray[$Count]="$Projecthome/$(cut -d/ -f2- <<< "$Dir")"
    
    # generate thumbnail. Check existing thumbnail with md5
    Image="$(sed "${Count}q;d" <<< "$Imagelist")"
    Image="${Image:-$Emptyimage}"
    #Md5="$(md5sum "$Image" | cut -d' ' -f1)"
    Md5="$(md5sum <<< "$(ls --full-time "$Image")" | cut -d' ' -f1)"
    Destinationfile=$Thumbnaildir/$(basename "$Image").$Md5.png
    #[ -e "$Destinationfile" ] || $Magickbin "$Image" -resize 256x256 "$Destinationfile"
    [ -e "$Destinationfile" ] || {
      $Magickbin "$Image" -scale 256x256 "$Destinationfile"
      ### FIXME delete old thumbnail
    }
    
    # Check current project dir
    Projectdir="$(dirname $Dir)"

    # Checking a project dir is ready
    [ "$Projectdir" != "$Oldprojectdir" ] && {
      [ "$Projectline" ] && {
        # montage of all stackshot images in a project dir
        #Projectimages="$(sort <<< "$Projectimages")"
        Md5="$(cat $Projectimages | md5sum | cut -d' ' -f1)"
        Montagefile="$Thumbnaildir/$(basename $Projectdir).$Md5.png"
        [ -e "$Montagefile" ] || montage $Projectimages -tile x1 -geometry 100x100+5+5 $Montagefile
        
        # entry of subtree: montageimage + pjoject directory. Childs are stackshots.        
        Projectline="project$Count:tree '{$Montagefile}$Oldprojectdir' -> $Projectline"
        Allprojects="$Allprojects project$Count"
        Entrylist="$Entrylist
$Projectline ;"
      }
      
      [ "$Dir" = "EOL" ] && break
      
      Oldprojectdir="$Projectdir"
      Projectline=""
      Projectimages=""
      Montagefile=""
    }
    
    # add stackshot to subtree list
    Projectline="$Projectline stackshot$Count"
    
    # add stackshot
    Entrylist="$Entrylist
  stackshot$Count:beside '{$Destinationfile}$Dir' -> @button='Choose this stackshot';"
  
    # add image to montage list
    Projectimages="$Projectimages
$Image"
  done
  showpercent idle
 
  # prepare kaptain
  local Kaptainpid Kaptainsignal Kaptainstdinfile Kaptainstdoutfile Kaptainanswerfile Kaptainpipefile Kaptaingrammarfile
  Kaptaingrammarfile="$Cachedir/gui_selector.kaptain.grammar"
  Kaptainstdinfile="$Cachedir/gui_selector.kaptain.stdin"
  Kaptainstdoutfile="$Cachedir/gui_selector.kaptain.stdout"
  Kaptainanswerfile="$Cachedir/gui_selector.kaptain.reply"
  Kaptainpipefile="$Cachedir/gui_selector.kaptain.pipe.sh"
  
  echo "#! /usr/bin/kaptain
start 'stackfuser stackshot selector' -> frame1 frame2;
  frame1:tree -> $Allprojects ;
$Entrylist
  frame2:beside -> refresh windowpos close ;
    refresh     -> @button='Reload GUI' ;
    windowpos   -> @button='Reset window geometry' ;
    close       -> @button='Close' ;

" > $Kaptaingrammarfile

  pipekaptain
  :>     "$Kaptainstdinfile"
  :>     "$Kaptainstdoutfile"
  tail -f "$Kaptainstdoutfile" >> $Kaptainanswerfile & storepid $!
  kaptain --pipe $Kaptainpipefile $Kaptaingrammarfile & Kaptainpid=$!
  storepid $Kaptainpid
  
  #for Count in $(seq 50); do
  #  read -t1 Line
  #  [ -z "$Line" ] && break
  #done < <(tail -f "$Kaptainstdoutfile")
    
  while ps -p $Kaptainpid >/dev/null; do
    read -t1 Kaptainsignal
    [ "$Kaptainsignal" ] && {
      echo $Kaptainsignal
      Button="$(cut -d: -f1 <<< "$Kaptainsignal")"
      Argument="$(cut -s -d: -f2- <<< "$Kaptainsignal")"
      case $Button in
        stackshot*)
          Count="${Button#stackshot}"
          Dir="${Dirarray[$Count]}"
          storeinfo "stackshotdir=$Dir"
          check_stackdir
          storeinfo "refreshgui_main=yes"
          storeinfo "refreshgui_fuse=yes"
        ;;
        windowpos)
          # check width of main window
          Windowgeometry="$(xdotool search --name "stackfuser $Version" getwindowgeometry)"
          Windowwidth="$(grep  Geometry <<< "$Windowgeometry" | rev | cut -d' ' -f1 | rev | cut -dx -f1)"
          Windowheight="$(grep Geometry <<< "$Windowgeometry"  | rev | cut -d' ' -f1 | rev | cut -dx -f2)"
          Windowxpos="$(grep   Position <<< "$Windowgeometry"| cut -d: -f2 | cut -d' ' -f2 | cut -d, -f1)"
          Windowypos="$(grep   Position <<< "$Windowgeometry"| cut -d: -f2 | cut -d' ' -f2 | cut -d, -f2)"
          xdotool search --sync --name "stackshot selector" windowsize $Windowwidth $Windowheight windowmove $Windowxpos $Windowypos
        ;;
        close) 
          break 
        ;;
        refresh) 
          Refresh="yes" 
          break
        ;;
      esac
    }
  done < <(tail -f "$Kaptainstdoutfile")
  
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
  rm $Cachedir/gui_selector.*
  
  storeinfo drop stackshot_selector
  [ "$Refresh" = "yes" ] && stackshot_selector
}
fuse_config() {
  local Cachedir Stackdir
  local Count Setcount Line Image Imagelist Commentfile Button Argument Currentfuse=1 Fusemode Fuseskip
  local Comment Commentfile
  local Formatline Formatlist Fusetoworkonlist Fusetoworkonline Setline Setlist Setcount
  local Refresh
  
  Cachedir="$(storeinfo dump cache)"
  Commentfile="$Cachedir/exivcomment"
  
  storeinfo test fuse_config && {
    note "fuse_config is already running."
    xdotool search --name "enfuse settings" windowraise
    return 1
  }
  storeinfo "fuse_config=running"
  
  verbose "Preparing fuse GUI"
  
  # Prepare left columns of GUI
  Formatline="formatline ' ' -> "
  Fusetoworkonline="fusetoworkon 'all' -> "
  for Setcount in $(seq $Fusesetnumber); do
    Setline[$Setcount]="set${Setcount} 'set${Setcount}' -> "
  done
  for Count in $(seq $Fusemodenumber); do
    Formatline="$Formatline format$Count"
    Formatlist="$Formatlist
      format$Count -> @text=''; "
    
    Fusetoworkonline="$Fusetoworkonline fuse${Count} |"
    Fusetoworkonlist="$Fusetoworkonlist
      fuse${Count}:beside '$(fuse_getname $Count shortcut)' -> @string='$(fuse_getname $Count option)' ;"
    
    for Setcount in $(seq $Fusesetnumber); do
      Setline[$Setcount]="${Setline[$Setcount]} set${Setcount}_${Count}"
      Setlist[$Setcount]="${Setlist[$Setcount]}
        set${Setcount}_${Count}:beside -> @ | $(fuse_getvalue $Count set${Setcount} value) '' ;"
    done
  done
  Formatline="$Formatline ;"
  Fusetoworkonline="${Fusetoworkonline%"|"} ;"
  for Setcount in $(seq $Fusesetnumber); do
    Setline[$Setcount]="${Setline[$Setcount]} ;"
  done
  
  # prepare kaptain
  local Kaptainpid Kaptainsignal Kaptainstdinfile Kaptainstdoutfile Kaptainanswerfile Kaptainpipefile Kaptaingrammarfile
  Kaptaingrammarfile="$Cachedir/gui_fuse.kaptain.grammar"
  Kaptainstdinfile="$Cachedir/gui_fuse.kaptain.stdin"
  Kaptainstdoutfile="$Cachedir/gui_fuse.kaptain.stdout"
  Kaptainanswerfile="$Cachedir/gui_fuse.kaptain.reply"
  Kaptainpipefile="$Cachedir/gui_fuse.kaptain.pipe.sh"
  
  # grammar
  echo "#! /usr/bin/kaptain
start 'stackfuser enfuse settings' -> frameset;
  frameset:beside     -> leftframe rightframe ;
    leftframe:framed:beside    -> formatline fusetoworkon $(for Setcount in $(seq $Fusesetnumber); do echo set$Setcount; done) ;
    rightframe:framed   -> fusesettings @fill storeconfigframe runfuseframe;
    
    $Formatline
      $Formatlist
    
    $Fusetoworkonline
      $Fusetoworkonlist
      
    $(for Setcount in $(seq $Fusesetnumber); do echo "
    ${Setline[$Setcount]}
      ${Setlist[$Setcount]}"
      done)
      
    fusesettings 'enfuse options' -> exposureweight saturationweight contrastweight entropyweight blendmask grayprojector text2 levels contrastwindowsize contrastmincurvature contrastedgescaleline exivcomment;
    
      exposureweight:beside        '--exposure-weight'            -> @combo('')='';
      saturationweight:beside      '--saturation-weight'          -> @combo('')='';
      contrastweight:beside        '--contrast-weight'            -> @combo('')='';
      entropyweight:beside         '--entropy-weight'             -> @combo('')='';

      blendmask:beside                                            -> @combo('')='' ;
      grayprojector:beside         '--gray-projector'             -> @combo('')='';
      levels:beside                '--levels'                     -> @combo('')='';
      
      text2 -> @text='Following options are most of interest to change.' ;
      contrastwindowsize:beside    '--contrast-window-size'       -> @combow('')='';
      contrastmincurvature:beside  '--contrast-min-curvature (%)' -> @combow('')='' ;
      contrastedgescaleline:beside '--contrast-edge-scale'        -> contrastedgescale lcescale lcefactor ;
        contrastedgescale                                           -> @combow('')='';
        lcescale                                                    -> @combow('')='';
        lcefactor                                                   -> @combow('')='';
      exivcomment                                                 -> @text='' ;
      
    storeconfigframe                                              -> restoredefault;
      restoredefault                                                -> @button='Restore default configuration' ;
        
    runfuseframe 'fuse'  -> runfuseline ;
      runfuseline:beside -> runopt2combo runskip runbutton ;
        runopt2combo                                                    -> @combo('current',$Fuseopt1combo)='current' ;
        runskip                    'fuse only missing'              -> 'skip' | ! '' ;
        runbutton                                                   -> @button='Run enfuse' ;
      
        
" > $Kaptaingrammarfile
  #nl -ba $Kaptaingrammarfile
  
  pipekaptain
  :>     "$Kaptainstdinfile"
  :>     "$Kaptainstdoutfile"
  tail -f "$Kaptainstdoutfile" >> $Kaptainanswerfile & storepid $!
  kaptain --pipe $Kaptainpipefile $Kaptaingrammarfile & Kaptainpid=$!
  storepid $Kaptainpid
  
  #for Count in $(seq 50); do
  #  read -t1 Line
  #  [ -z "$Line" ] && break
  #done < <(tail -f "$Kaptainstdoutfile")

  storeinfo "refreshgui_fuse=yes"
  while ps -p $Kaptainpid >/dev/null; do
    storeinfo test refreshgui_fuse && {
      storeinfo drop refreshgui_fuse
      Projectname="$(storeinfo dump projectname)"
      Stackdir="$(storeinfo dump stackshotdir)"
      Fusebasename="$Projectname.$(basename $Stackdir)"
      
      # Read and show exiv comment (contains enfuse options)
      Image="$(fileglob "$Stackdir/fuse/*$(fuse_getname $Currentfuse shortcut)*")"
      showimage "$Image" && Comment="$(exiv2 "$Image" | grep comment | cut -d: -f2-)" || Comment=""
      :> $Commentfile
      [ -e "$Image" ] && echo "$(basename $Image) was generated with:
        " >> "$Commentfile"
      for Line in $Comment; do
        echo "$Line" >> $Commentfile
      done
      sendkaptain "exivcomment=\`tail -n+1 $Commentfile\`"
      
      # mark existing images
      Imagelist="$(fileglob "$Stackdir/fuse/*fuse*")"
      for Count in $(seq $Fusemodenumber); do
        grep -q "\.$(fuse_getname $Count shortcut)\." <<< "$Imagelist" && sendkaptain "format$Count='x'" || sendkaptain "format$Count=' '"
      done
      
      # show current settings
      for Line in $Fusearguments; do
        sendkaptain "$(fuse_getvalue $Currentfuse $Line kaptain)"
      done
    }
    
    read -t1 Kaptainsignal
    
    [ "$Kaptainsignal" ] && {
      echo $Kaptainsignal
      
      Button="$(cut -d: -f1 <<< "$Kaptainsignal")"
      Argument="$(cut -d: -f2 <<< "$Kaptainsignal")"
      case $Button in
        fuse*)
          Currentfuse="${Kaptainsignal#fuse}"
          Currentfuse="${Currentfuse%:selected}"
          storeinfo "refreshgui_fuse=yes"
        ;;
        runbutton)
          Fusemode="$(askkaptain runopt2combo)"
          [ "$Fusemode" = "current" ] && Fusemode="$Currentfuse"
          Fuseskip="$(askkaptain runskip)"

          sendkaptain "runbutton='*** BUSY ***'"
          parse_cmd -f fuse -1 "$Fusemode" -2 "$Fuseskip" -t "$Stackdir"
          sendkaptain "runbutton='Run enfuse'"
          storeinfo "refreshgui_fuse=yes"
        ;;
        set*)
          case $Argument in
            on)  fuse_storevalue $(cut -d_ -f2 <<< "$Button") $(cut -d_ -f1 <<< "$Button") "!" ;;
            off) fuse_storevalue $(cut -d_ -f2 <<< "$Button") $(cut -d_ -f1 <<< "$Button") ""  ;;
          esac
        ;;
        restoredefault*)
          rm $Enfuseconfigfile
          fuse_defaultconfig
          Refresh="yes"
        ;;
        *)
          fuse_storevalue $Currentfuse $Button $Argument
          sendkaptain "fuse$Currentfuse='$(fuse_getname $Currentfuse option)'"
        ;;
      esac
    }
    [ "$Refresh" ] && break
  done < <(tail -f "$Kaptainstdoutfile")
  
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
  rm $Cachedir/gui_fuse.*
  storeinfo drop fuse_config
  [ "$Refresh" ] && fuse_config
}
cropgeometry_interactive() {
  # Interactive dialog to choose a crop geometry
  #   $1   Image to crop.
  #   $2   Cache folder to store files. Clean up yourself.
  #   $3   Preset crop geometry (optional). Default: entire image
  # Result:
  #   return 0 : echo crop geometry WxH+X+Y
  #   return 1 : no output
  # Dependencies:
  #   imagemagick
  #   kaptain (https://github.com/mviereck/kaptain)

  local Kaptainpid Kaptainsignal Kaptainstdinfile Kaptainstdoutfile Kaptainanswerfile Kaptainpipefile Kaptaingrammarfile
  local Image Imagempc Imagewidth Imageheight
  local CropX CropY CropW CropH Cropgeometry
  local Rotate
  local Refresh Stepsize Return
  local Cachedir Cropgeometryimage Cropimagempc

  Image="${1:-}"
  Cachedir="${2:-}"
  Cropgeometry="${3:-}"
  
  checkvar -e crop_interactive Image    "$Image"    || return 1
  checkvar -d crop_interactive Cachedir "$Cachedir" || return 1
  
  verbose "Interactive choice of crop geometry of $Image"
  
  Cropgeometryimage="$Cachedir/cropgeometry.gui.tif"
  Cropimagempc="$Cachedir/crop.mpc"
  
  # check source for mpc format, convert if not
  [ "$Image" = "${Image%.mpc}" ] && {
    Imagempc="$Cachedir/cropgeometry.source.mpc"
    $Magickbin "$Image" "$Imagempc"
  } || {
    Imagempc="$Image"
  }
  
  Stepsize=50
  Rotate=0
  Refresh="yes"

  Imagewidth=$($Magickbin  -format '%w'  $Imagempc info:)
  Imageheight=$($Magickbin -format '%h'  $Imagempc info:)
    
  grep -q "x" <<< "$Cropgeometry" && grep -q "+" <<< "$Cropgeometry" && {
    CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
    CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
    CropW=$(cut -dx -f1 <<< "$Cropgeometry")
    CropH=$(cut -dx -f2 <<< "$Cropgeometry")
    CropH=$(cut -d+ -f1 <<< "$CropH")
  } || {
    CropX=0
    CropY=0
    CropW=$((Imagewidth-1))
    CropH=$((Imageheight-1))
  }
  
  Kaptaingrammarfile="$Cachedir/gui_crop.kaptain.grammar"
  Kaptainstdinfile="$Cachedir/gui_crop.kaptain.stdin"
  Kaptainstdoutfile="$Cachedir/gui_crop.kaptain.stdout"
  Kaptainanswerfile="$Cachedir/gui_crop.kaptain.reply"
  Kaptainpipefile="$Cachedir/gui_crop.kaptain.pipe.sh"
  
  echo "#! /usr/bin/kaptain
start 'Choose geometry' -> frameset ;
  frameset:beside -> frameleft ;
    frameleft:framed  -> arrowline stepsizeframe rotateline geometryline buttonline cmdpercent;
    
  cmdpercent    -> @icon;
  
  arrowline:beside:framed -> arrowposframe arrowsizeframe ;
    arrowposframe 'Position:' -> arrowpos1 arrowpos2 arrowpos3;
      arrowpos1:beside -> @fill   postop    @fill;
      arrowpos2:beside -> posleft @fill     posright ;
      arrowpos3:beside -> @fill   posbottom @fill;
        posleft          -> @button=' < ';
        posright         -> @button=' > ';
        postop           -> @button=' ^ ';
        posbottom        -> @button=' v ';
    arrowsizeframe 'Size:' -> size1 size2 size3;
      size1:beside     -> @fill    sizetop    @fill;
      size2:beside     -> sizeleft @fill      sizeright ;
      size3:beside     -> @fill    sizebottom @fill;
        sizeleft         -> @button=' < ';
        sizeright        -> @button=' > ';
        sizetop          -> @button=' ^ ';
        sizebottom       -> @button=' v ';
    rotateline:beside 'Rotate:'  -> rotatecombo rotateapply trim;
      rotatecombo       -> @combow('0','0.5','-0.5','1','-1','1.5','-1.5','2','-2','2.5','-2.5','3','-3','5','-5','10','-10','45','-45','90','180','270')='0';
      rotateapply       -> @button='apply';
      trim              -> @button='trim';
  stepsizeframe 'Step size' -> stepsize1 stepsize2;
  stepsize1:beside  -> ss1  ss2   ss5   ss10  ss25 ;
  stepsize2:beside  -> ss50 ss100 ss250 ss500 ss1000 ;
    ss1           -> @button='1';
    ss2           -> @button='2';
    ss5           -> @button='5';
    ss10          -> @button='10';
    ss25          -> @button='25';
    ss50          -> @button='50';
    ss100         -> @button='100';
    ss250         -> @button='250';
    ss500         -> @button='500';
    ss1000        -> @button='1000';
  geometryline:beside -> geometry geometryapply;
    geometry:beside  'Crop geometry:'      -> @string='$Cropgeometry';
    geometryapply                          -> @button='apply';
  buttonline:beside -> ok cancel ;
    ok                                     -> @button=' OK' ;
    cancel                                 -> @close='Cancel';
" >> $Kaptaingrammarfile

  pipekaptain
  :>     "$Kaptainstdinfile"
  :>     "$Kaptainstdoutfile"
  tail -f "$Kaptainstdoutfile" >> $Kaptainanswerfile & storepid $!
  kaptain --pipe $Kaptainpipefile $Kaptaingrammarfile & Kaptainpid=$!
  storepid $Kaptainpid
  
  Refresh="yes"
  while ps -p $Kaptainpid >/dev/null; do

    [ "$Refresh" = "yes" ] && {
      Cropgeometry="${CropW}x${CropH}+$CropX+$CropY"
      showpercent 10 100
      $Magickbin $Imagempc -background '#00000000' -rotate $Rotate +repage -fill none -stroke red -strokewidth 1 -draw "rectangle $CropX,$CropY $((CropX+CropW-1)),$((CropY+CropH-1))" "$Cropgeometryimage"
      showpercent 60 100
      showimage "$Cropgeometryimage"
      #echo "geometry='$Cropgeometry'" >&${Kaptainstdin}
      sendkaptain "geometry='$Cropgeometry'"
      Refresh="no"
      showpercent 100 100
    }

    Imagewidth=$($Magickbin  -format '%w'  $Cropgeometryimage info:)
    Imageheight=$($Magickbin -format '%h'  $Cropgeometryimage info:)
    
    read -t1 Kaptainsignal
    
    ifcmdbreak && Return=1 && break
    
    [ "$Kaptainsignal" ] && {
      Kaptainsignal="${Kaptainsignal%:pressed}"
      case $Kaptainsignal in
        posleft)    CropX=$((CropX-$Stepsize)) ;;
        posright)   CropX=$((CropX+$Stepsize)) ;;
        postop)     CropY=$((CropY-$Stepsize)) ;;
        posbottom)  CropY=$((CropY+$Stepsize)) ;;
        sizeleft)   CropW=$((CropW-$Stepsize)) ;;
        sizeright)  CropW=$((CropW+$Stepsize)) ;;
        sizetop)    CropH=$((CropH-$Stepsize)) ;;
        sizebottom) CropH=$((CropH+$Stepsize)) ;;
        ss*)        Stepsize="$(cut -c3- <<< "$Kaptainsignal")" ;;
        rotatecombo*) Rotate="$(cut -d: -f2 <<< "$Kaptainsignal")" ;;
        rotateapply) 
          #echo "rotatecombo?" >&${Kaptainstdin}
          #read Rotate <&${Kaptainstdout}
          Rotate="$(askkaptain rotatecombo)"
        ;;
        geometryapply)
          #echo "geometry?" >&${Kaptainstdin}
          #read Cropgeometry <&${Kaptainstdout}
          Cropgeometry="$(askkaptain geometry)"
          [ "$Cropgeometry" ] && {
            CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
            CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
            CropW=$(cut -dx -f1 <<< "$Cropgeometry")
            CropH=$(cut -dx -f2 <<< "$Cropgeometry")
            CropH=$(cut -d+ -f1 <<< "$CropH")
          }
        ;;
        trim)
          $Magickbin "$Imagempc" -background '#00000000' -rotate $Rotate +repage "$Cropimagempc"
          Cropgeometry="$(trim_hard "$Cropimagempc" "$Cropgeometry" )"
          [ "$Cropgeometry" ] && {
            CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
            CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
            CropW=$(cut -dx -f1 <<< "$Cropgeometry")
            CropH=$(cut -dx -f2 <<< "$Cropgeometry")
            CropH=$(cut -d+ -f1 <<< "$CropH")
          }
        ;;
        ok)         Return=0; break ;;
      esac
      
      [ "$CropX" -lt "0" ] && CropX=0
      [ "$CropY" -lt "0" ] && CropY=0
      [ "$CropW" -lt "1" ] && CropW=1
      [ "$CropH" -lt "1" ] && CropH=1
      [ "$CropX" -gt "$Imagewidth" ]  && CropX=$Imagewidth
      [ "$CropY" -gt "$Imageheight" ] && CropY=$Imageheight
      [ "$((CropX+CropW-1))" -gt "$Imagewidth" ]  && CropW=$((Imagewidth-CropX))
      [ "$((CropY+CropH-1))" -gt "$Imageheight" ] && CropH=$((Imageheight-CropY))
      
      case $Kaptainsignal in
        ss*) Refresh="no" ;;
        *)   Refresh="yes" ;;
      esac
    }
  done < <(tail -f "$Kaptainstdoutfile")
          
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
  rm $Cachedir/gui_crop.*
  
  [ "$Return" = "0" ] && {
    [ "$Rotate" = "0" ] && echo "$Cropgeometry" || echo "$Cropgeometry:$Rotate"
    return 0
  }
  return 1
}

#### headquarter

parse_kaptainsignal() {
  local Kaptainsignal Kaptainsignalsuffix
  local $Batchlocal
  local Command Argument Stackdir Newstackdir Projecthome
  local Image
  
  Kaptainsignal="${1:-}"
  Kaptainsignalsuffix="$(cut -d: -f2 <<< "$Kaptainsignal")"
  Kaptainsignal="$(cut       -d: -f1 <<< "$Kaptainsignal")"
  #Kaptainsignal="$(tr -d "[:digit:]" <<< "$Kaptainsignal")"
  Kaptainsignal="${Kaptainsignal%button}"
  Stackdir="$(storeinfo dump stackshotdir)"
  Projecthome="$(storeinfo dump projecthome)"
  
  case $Kaptainsignalsuffix in
    on|off)
      case $Kaptainsignal in
        allownonconformant)
          case $Kaptainsignalsuffix in
            on)  storeinfo "allow_dir_invalid=yes" ;;
            off) storeinfo "allow_dir_invalid=no" ;;
          esac
        ;;
      esac
      return 0
    ;;
  esac
  
  case $Kaptainsignal in
    refresh) 
      #kaptain_update
      note "Refreshing GUI and preview"
      storeinfo drop showimage
      storeinfo "refreshgui_main=yes"
    ;;
    cmdbreak)
      note "Sending BREAK to current action"
      storeinfo "cmdbreak=yes"
    ;;
    choosedirgui)
      stackshot_selector &
    ;;
    delete*) 
      cmd -f $(tr -d ":" <<< "$Kaptainsignal") -t "$Stackdir"
    ;;
    showcompose_*)
      Image="${Kaptainsignal#showcompose_}"
      Image="$Stackdir/compose/*.$Image.*"
      showimage "$Image"
      showimage "$(fileglob "$Image" | grep 'magick' | head -n1)"
      #showimage "$(fileglob "$Image")"
    ;;
    show_video*)
      Image="$Kaptainsignalsuffix"
      Image="$Stackdir/video/*.$Image*"
      showimage "$(fileglob "$Image")"
    ;;
    show*_all)
      Image="${Kaptainsignal#show}"
      Image="$(cut -d "_" -f1 <<< "$Image")"
      Image="$(fileglob "$Stackdir/evaluate/*.$Image.*")"
      showimage "$Image"
    ;;
    show*_magick)
      Image="${Kaptainsignal#show}"
      Image="$(cut -d "_" -f1 <<< "$Image")"
      Image="$(fileglob "$Stackdir/evaluate/*.magick.$Image.*")"
      showimage "$Image"
    ;;
    show*_set*)
      Image="${Kaptainsignal#show}"
      Image="$(tr "_" "." <<< "$Image")"
      Image="$(fileglob "$Stackdir/evaluate/*.fuse.${Image}.*")"
      showimage "$Image"
    ;;
    showdirfm)
      xdg-open "${Stackdir:-$Projecthome}" &
    ;;
    showdir*)
      showimage "$Stackdir/${Kaptainsignal#showdir}/*"
    ;;
    
    fuseconfig)
      fuse_config &
    ;;
    
    *magick|*compose|*evaluate|*fuse|evaluatemagick|align_vidstab|align_ais|align_hugin)
      Command="$Kaptainsignal"
      Command="${Command%evaluate}"
      Command="${Command%fuse}"
      Command="${Command%magick}"
      [ -z "$Command" ] && Command="$Kaptainsignal"
      getfunctionsettings $Command
      Command="${Command%_}"
      cmd -f "$Kaptainsignal" -1 "$Opt1" -2 "$Opt2" -3 "$Opt3" -4 "$Opt4" -5 "$Opt5" -6 "$Opt6" -7 "$Opt7" -8 "$Opt8" -9 "$Opt9"  -t "$Stackdir"
    ;;
    
    runbatchone) 
      runbatchone "$Stackdir"
      cmd -f notify -1 "Batch 1 is ready."
    ;;
    runbatchtwo) 
      runbatchtwo "$Stackdir"
      cmd -f notify -1 "Batch 2 is ready."
    ;;
    runbatchthree) 
      runbatchthree "$Stackdir"
      cmd -f notify -1 "Batch 3 is ready."
    ;;
    runbatchprocessing)
      askkaptain "runbatchone" >/dev/null && runbatchone "$Stackdir"
      askkaptain "runbatchtwo" >/dev/null && runbatchtwo "$Stackdir"
      askkaptain "runbatchthree" >/dev/null && runbatchthree "$Stackdir"
      cmd -f notify -1 "Batch all is ready."
    ;;
    *)
      verbose "Unknown signal: $Kaptainsignal"
    ;;
  esac
}
cmd() {
  local Arg Command
  for Arg in "$@"; do
    Command="$Command '$Arg'"
  done
  echo "$Command" >> $Commandstackfile
}
ifcmdbreak() {
  storeinfo test cmdbreak && return 0 || return 1
}
stack_cmd() {
  local Command Commandpid Return
  trap "storeinfo cmdbreak=yes ; storeinfo exit=yes" SIGINT

  while :; do
    read -t1 Command
    storeinfo test cmdbreak && {
      [ "$Command" ] || storeinfo drop cmdbreak
      Command=""
    }
    [ "$Command" ] && {
      eval set -- $Command 
      
      #sendkaptain "wizardcmd=' $*'"
      showpercent busy
      storeinfo "status=work"
      
      parse_cmd "$@"
      Return=$?
      
      case $Return in
        0)
          storeinfo "status=idle"
          showpercent idle
          #sendkaptain "wizardcmd=''"
        ;;
        *)
          storeinfo "status=error"
          showpercent error
          storeinfo "cmdbreak=yes"
        ;;
      esac
    }
  done < <(tail -f $Commandstackfile)
}
parse_cmd() {
  local $Batchlocal
  local Commandline Return= 

  verbose "parse_cmd(): $*"
  parse_batchoptions "$@" || return 1
  Commandline="$@"
  
  Function="$(tr -d "[:digit:]" <<< "$Function")" 
    
  case "$Function" in
    deleteall)         myrmdir "$Targetdir"/*.bak "$Targetdir/cache" "$Targetdir/magick" "$Targetdir/compose" "$Targetdir/evaluate" "$Targetdir/fuse" "$Targetdir/video" ; Return=0 ;;
    deleteallbutvideo) myrmdir "$Targetdir"/*.bak "$Targetdir/cache" "$Targetdir/magick" "$Targetdir/compose" "$Targetdir/evaluate" "$Targetdir/fuse" ; Return=0 ;;
    deletebackups)     myrmdir "$Targetdir/cache" "$Targetdir"/*.bak ; Return=0 ;;
    delete*)           myrmdir "$Targetdir/${Function#delete}" "$Targetdir/${Function#delete}.bak" ; Return=0 ;;
   
    align*|animation*|brightness*|compose*|contrast*|crop*|cuberotate*|evaluate*|fuse*|imageformat*|gamma*|level*|lightbalance*|orient*|prepare*|rotate*|sharpen*|statistic*|evalstep*|stretch*|undo*|whitebalance*|ruler*|video*|wizard*)
      Function="${Function%magick}"
      batch_function -f $Function -1 "$Opt1" -2 "$Opt2" -3 "$Opt3" -4 "$Opt4" -5 "$Opt5" -6 "$Opt6" -7 "$Opt7" -8 "$Opt8" -9 "$Opt9" -g "$Sourcefileglob" -t "$Targetdir"
      Return=$?
    ;;
    note)
      note "$Opt1"
      Return=0
    ;;
    notify)
      notify "$Opt1"
      Return=0
    ;;
    showimage)
      showimage "$Sourcedir/$Sourcefileglob"
      Return=0
    ;;
    *)
      failure "parse_cmd(): Unknown function: $Function"
    ;;
  esac
 
  storeinfo "refreshgui_main=yes"

  case $Return in
    0) 
      historyentry "$Commandline"
      return 0
    ;;
    *) return ${Return:-1} ;;
  esac
}

#### main

declare_variables() {

  Cachebasedir="$HOME/.cache/stackshots"
  Maincachedir="$Cachebasedir/stackfuser"
  Percentcachedir="$Cachebasedir/percent"
  Thumbnaildir="$Cachebasedir/thumbnails"
  Magickcachedir="$Maincachedir/imagemagick.cache"
  export MAGICK_TMPDIR="$Magickcachedir"
  
  Configdir="$HOME/.config/stackshots"
  Enfuseconfigfile="$Configdir/stackfuser.enfuse.cfg"
  
  Projecthome="$HOME/Bilder/stackshots"
  Gallerydir="$HOME/Gallery"
  
  Multicore_maxprocesses="$(nproc)"
  Multicore_maxprocesses="${Multicore_maxprocesses:-1}"
  for i in $Multicore_maxprocesses; do
    Multicore_process[$i]=""
    Multicore_image[$i]=""
    Multicore_memory[$i]="0"
  done
  Multicore_processcount=0
  Multicore_minram=250000
  Multicore_maxprocesses=$Multicore_maxprocesses
  
  Batchlocal="Targetdir Sourcedir Sourcefileglob Destinationdir Destinationfile Cachedir Function Opt1 Opt2 Opt3 Opt4 Opt5 Opt6 Opt7 Opt8 Opt9"
  Imagelocal="Image Imagelist Imagewidth Imageheight Imageformat Imagememsize Imagelistmemsize Imagecount Imagenumber Imageraw Cropgeometry Extension"
  Imagepropertieslocal="Imagemean Imagequantumrange Imageautogamma Imageminlevel Imagemaxlevel Imageminlevelred Imagemaxlevelred Imageminlevelgreen Imagemaxlevelgreen Imageminlevelblue Imagemaxlevelblue"

  #Magickbin="nice convert -quality 100%"
  command -v convert             >/dev/null && Magickbin=convert
 # command -v magick              >/dev/null && Magickbin=magick
  #command -v convert-im6.q16     >/dev/null && Magickbin=convert-im6.q16
  #command -v convert-im6.q16hdri >/dev/null && Magickbin=convert-im6.q16hdri
  Magickversion="$($Magickbin -version)"
  grep -q " Q8 "   <<< "$Magickversion" && Magickpixelmemory="4"
  grep -q " Q16 "  <<< "$Magickversion" && Magickpixelmemory="8"
  grep -q " HDRI " <<< "$Magickversion" && Magickpixelmemory="16"


  Commandstackfile=$Maincachedir/command.stack
  Wizardlogfile=$Maincachedir/stackfuser.log
  Wizardmessagefile=$Maincachedir/stackfuser.message.log
  
  Storeinfofile=$Configdir/stackfuser.cfg
  Storepidfile=$Maincachedir/store.pid
    
  Imgruler="$(command -v imgruler)"
  Imgrulermodes=
  Imgrulermodecombo=
  [ -z "$Imgruler" ] && Imgruler="$(dirname $0)/imgruler"
  Imgrulermodes="$(source $Imgruler >/dev/null ; declare -f imgruler_calibrated | grep -v ";" | grep -v "()" | grep ")" | tr -d ") " )"
  for Line in $Imgrulermodes; do
    Imgrulermodecombo="$Imgrulermodecombo,'$Line'"
  done
  Imgrulermodecombo="${Imgrulermodecombo#,}"
  
  Imageformatlist="$($Magickbin -list format | grep " rw" | grep -v -i "video" | cut -c1-9 | tr -d ' ')
TIF"
  Imageformatlist="$(sort <<< "$Imageformatlist")"
  for Line in $Imageformatlist; do
    Imageformatcombo="$Imageformatcombo,'$Line'"
  done
  Imageformatcombo="${Imageformatcombo#,}"
  
  Composemodes1="bumpmap1 colorburn1 linearlight1 modulate1 overlay1 pegtoplight1 difference linearburn"
  Composemodes2="bumpmap2 colorburn2 linearlight2 modulate2 overlay2 pegtoplight2 multiply   composemean"
  Composemodes="$Composemodes1 $Composemodes2"
}
create_cachefiles() {
  mkdir -p $Maincachedir
  mkdir -p $Thumbnaildir
  mkdir -p $Percentcachedir
  mkdir -p $Configdir
  mkdir -p $Magickcachedir
  
  touch    $Storeinfofile
  
  :>       $Wizardlogfile
  :>       $Commandstackfile
  :>       $Storepidfile
  
  #touch    $Enfuseconfigfile
}
check_dependencies() {
  local Dependency
  for Dependency in kaptain convert enfuse ffmpeg geeqie ufraw-batch viewnior align_image_stack $Imgruler; do
    command -v $Dependency >/dev/null || failure "Dependency $Dependency not found. Please install $Dependency."
  done
  ffmpeg 2>&1 | grep -q libvidstab || failure "Dependency libvidstab in ffmpeg not found. Please install ffmpeg with vidstab."
}
finish() {
  local Line Pid Comm

  trap - SIGINT

  while read Line; do
    Pid="$(awk  '{print $1}' <<< "$Line")"
    Comm="$(awk '{print $2}' <<< "$Line")"
    [ "$(ps -p $Pid -h -o comm)" = "$Comm" ] && kill $Pid
  done <$Storepidfile

  rm -R $Maincachedir
}
main() {
  local Kaptainpid Kaptainsignal Kaptainstdinfile Kaptainstdoutfile Kaptainanswerfile Kaptainpipefile Kaptaingrammarfile
  #trap finish EXIT
  trap "storeinfo cmdbreak=yes ; storeinfo exit=yes" SIGINT
  
  # init
  declare_variables
  create_cachefiles
  check_dependencies
    
  storeinfo "cache=$Maincachedir"
  storeinfo test projecthome       || storeinfo "projecthome=$Projecthome"
  storeinfo test stackshotdir      || storeinfo "stackshotdir=$Projecthome"
  storeinfo test gallerydir        || storeinfo "gallerydir=$Gallerydir"
  storeinfo test allow_dir_invalid || storeinfo "allow_dir_invalid=yes"
  storeinfo "status=idle"
  storeinfo "notfoundimage=$Thumbnaildir/notfound.jpg"
  #storeinfo "rmcache=yes"
  
  storeinfo drop cmdbreak
  storeinfo drop exit
  storeinfo drop stackshot_selector
  storeinfo drop fuse_config
  
  fuse_declare
  [ -e "$Enfuseconfigfile" ] || fuse_defaultconfig

  # start kaptain
  Kaptaingrammarfile="$Maincachedir/gui_main.kaptain.grammar"
  Kaptainstdinfile="$Maincachedir/gui_main.kaptain.stdin" 
  Kaptainstdoutfile="$Maincachedir/gui_main.kaptain.stdout"
  Kaptainanswerfile="$Maincachedir/gui_main.kaptain.reply"
  Kaptainpipefile="$Maincachedir/gui_main.kaptain.pipe.sh"

  kaptaingrammar > $Kaptaingrammarfile
  nl -ba $Kaptaingrammarfile
  :>     "$Kaptainstdinfile"
  :>     "$Kaptainstdoutfile"
  pipekaptain
  
  tail -f "$Kaptainstdoutfile" >> $Kaptainanswerfile & storepid $!
  kaptain --pipe $Kaptainpipefile $Kaptaingrammarfile & Kaptainpid=$!
  storepid $Kaptainpid

  storeinfo "refreshgui_main=yes"
  stack_cmd & storepid $!

  # watch signals of kaptain
  while ps -p $Kaptainpid >/dev/null; do
    storeinfo test exit && break
    storeinfo test refreshgui_main && {
      storeinfo drop refreshgui_main
      kaptain_update
    }
    read -t1 Kaptainsignal
    [ "$Kaptainsignal" ] && {
      echo "Signal from kaptain: $Kaptainsignal"
      grep -q "combo"    <<< "$Kaptainsignal" && Kaptainsignal=""
      grep -q ":pressed" <<< "$Kaptainsignal" && {
        Stackdir="$(askkaptain choosedir)"
        [ "$Stackdir" != "$(storeinfo dump stackshotdir)" ] && {
          check_stackdir "$Stackdir"
          storeinfo "refreshgui_main=yes"
          storeinfo "refreshgui_fuse=yes"
          #kaptain_update
        }
        Gallerydir="$(askkaptain gallerydir)"
        storeinfo "gallerydir=$Gallerydir"
        storeinfo "allow_dir_invalid=$(askkaptain allownonconformant)"
        storeinfo "projecthome=$(askkaptain storagebasedir)"
      }
      Kaptainsignal="${Kaptainsignal%:pressed}"
    }
    [ "$Kaptainsignal" ] && parse_kaptainsignal "$Kaptainsignal"
  done < <(tail -f "$Kaptainstdoutfile")
  
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
  rm $Maincachedir/gui_main.*
  
  trap - SIGINT
  storeinfo cmdbreak=yes
  storeinfo exit=yes
  while [ "$(storeinfo dump status)" = "work" ]; do
    echo "Waiting for current batch to terminate ..."
    sleep 1
  done
}

main "$@"
finish
exit 0

##### ToDo ####
# crop option for align_ais
# align_vidstab: select area for alignment
# improve lightbalance
# check webm quality
# crop: Do not crop if geometry is same as image
# configuration dialog:
#  - number of threads
#  - checkbutton: "keep cache"
# storepid(): store name, too, check in finish()
# cli support
# documentation in all functions
# Features:
#  - clean entire project home: cache, backup, magick (note in history)
