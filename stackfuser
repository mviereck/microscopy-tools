#! /bin/bash
#
# stackfuser - generate sharp aligned images from stackshots
#

Version="0.2"

#### Messages, Logf

error() {
  echo "stackfuser ERROR: $*" >&2
  showmessage "$(shortpath "$*")"
  showpercent error
}
failure() {
  echo "stackfuser Failure: $*" >&2
  showmessage "$(shortpath "$*")"
}
note() {
  echo "stackfuser: $*"  >&2
  showmessage "$(shortpath "$*")"
}
notify() {
  note "$*"
  notify-send "stackfuser: $*" >/dev/null 2>&1 & 
}
verbose() {
  echo "stackfuser: $*" >&2
}
warning() {
  echo "stackfuser WARNING: $*" >&2
  showmessage "$(shortpath "$*")"
}
historyentry() {
  local Historyfile
  Historyfile="$(storeinfo dump history)"
  [ "$Historyfile" ] && echo "$*" >> "$Historyfile"
}
showmessage() {
  sendkaptain "wizardlog='$(cut -c1-100 <<< "${1:-}")'"
}
shortpath() {
  LC_ALL=C sed "s!$Projecthome!.!g" <<< "${1:-}"
#  echo "${1:-}"
}

#### misc

checkvar() {
  local Arg

  Arg="${1:-}"
  [ "$(cut -c1 <<< "$Arg")" = "-" ] && shift || Arg=""

  [ -z "${3:-}" ] && {
    failure "${1:-}: Variable ${2:-} is empty."
    return 1
  }
  
  case "$Arg" in
    -d) 
      [ -d "${3:-}" ] || {
        failure "${1:-}: ${2:-} is not a directory: ${3:-}"
        return 1
      }
    ;;
    -e) 
      [ -e "${3:-}" ] || {
        failure "${1:-}: ${2:-} does not exist: ${3:-}"
        return 1
      }
    ;;
  esac
  case "$Arg" in
    -D) 
      check_fileglob "${3:-}/*" || {
        failure "${1:-}: ${2:-}: directory is empty: ${3:-}"
        return 1
      }
    ;;
    -E) 
      [ -s "${3:-}" ] || {
        failure "${1:-}: ${2:-}: file is empty: ${3:-}"
        return 1
      }
    ;;
  esac
  return 0
}
freememory() {
  local Freemem Line Zram
  Freemem="$(LC_ALL=C free | grep "Mem:" | awk '{print $7}')"
  while read Line; do
    Zram="$(awk '{print ($3 - $4)}' <<< "$Line")"
    Zram="$((Zram/1000))"
    Freemem="$((Freemem + Zram))"
  done < <(/sbin/swapon --bytes | grep zram)
  Freemem="$((Freemem*100/95))"
  echo $Freemem
}
milisleep() {
  local Time 
  Time="$(awk "BEGIN { print ${1:-1000} / 1000 }")"
  sleep $Time
}
printnum(){
  # print number $1 with leading zeroes.
  # $1 number
  # $2 digits. Default: 3
  printf %0${2:-3}d "${1:-0}"
}
storeinfo() {
  # store and provide pieces of information
  # replace entry if codeword is already present
  # Store as codeword=string:
  #   $1 codeword=string
  # Dump stored string:
  #   $1 dump
  #   #2 codeword
  # Drop stored string:
  #   $1 drop
  #   #2 codeword
  # Test for codeword: (return 1 if not found)
  #   $1 test
  #   $2 codeword
  #
  local i Return
  [ -e "$Storeinfofile" ] || return 1
  [ -e "$Storeinfofile.lock" ] && {
    for i in $(seq 20); do
      verbose "storeinfo is locked"
      sleep 0.1
      [ -e "$Storeinfofile.lock" ] || break
    done
  }
  :> "$Storeinfofile.lock"
  case "${1:-}" in
    dump) grep     "^${2:-}="   $Storeinfofile | sed "s/^${2:-}=//" ;;      # dump entry
    drop) sed -i  "/^${2:-}=/d" $Storeinfofile ;;                           # drop entry
    test) grep -q  "^${2:-}="   $Storeinfofile ; Return=$? ;;               # test for entry
    *)                                                                      # store entry
      sed -i "/^$(echo "${1:-}" | cut -d= -f1)=/d"     $Storeinfofile       # drop possible old entry
      echo "${1:-}"                                 >> $Storeinfofile
    ;;
  esac
  rm "$Storeinfofile.lock"
  return ${Return:-0}
}
storepid() {
  # store pid and command name. Use in finish() to kill background processes
  echo "$(ps -p ${1:-} -h -o pid -o comm)" >> $Storepidfile
}
unspecialstring() {             # replace special chars of $1 with -
  # Replace all characters except those described in "a-zA-Z0-9_" with a '-'. 
  # Replace newlines, too.
  # Remove leading and trailing '-'
  # Avoid double '--'
  # Return empty string if only special chars are given.
  printf %s "${1:-}" | LC_ALL=C tr -cs "a-zA-Z0-9._" "-" | sed -e 's/^-// ; s/-$//'
}
zeronumber() {
  printf "%0${2:-4}d" "${1:-}"
}

#### file operations

cut_extension() {
  local Extension
  Extension="$(get_extension "${1:-}")"
  sed "s%\.${Extension}\$%%" <<< "${1:-}"
}
check_dirglob() {
  # check whether directories exist for quoted glob $1
  [ -f "${1:-}" ] && return 1
  [ -n "$(eval find ${1:-} -maxdepth 0 -type d -print -quit 2>/dev/null)" ]
}
check_fileglob() {
  # check whether files exist for quoted glob $1
  [ -n "$(eval find ${1:-} -maxdepth 0 -type f -print -quit 2>/dev/null)" ]
}
check_stackdir() {
  # Check $1 if it is a valid directory containing a subfolder stackshot
  local Stackdir Newstackdir Stackdirvalid Projectname Projecthome
  
  Stackdir="$(storeinfo dump stackshotdir)"
  Newstackdir="${1:-}"
  Newstackdir="${Newstackdir:-$Stackdir}"
  Newstackdir="${Newstackdir%/}"
  
  Projecthome="$(storeinfo dump projecthome)"
  
  [ -z "$Newstackdir" ]   && failure "No stackshot directory given." && return 1
  [ ! -d "$Newstackdir" ] && failure "Not a directory: $Newstackdir" && return 1
  
  [ -d "$Newstackdir/stackshot" ] && Stackdirvalid="yes" || Stackdirvalid="no"

  [ "$Stackdirvalid" = "no" ] && [ "${Newstackdir%/stackshot}" != "$Newstackdir" ] && {
    Newstackdir="${Newstackdir%/stackshot}"
    Stackdirvalid="yes"
  }
    
  storeinfo "stackshotdir=$Newstackdir"
  case "$Stackdirvalid" in
    yes)
      storeinfo "stackshotdir_valid=yes"
      storeinfo "history=$Newstackdir/wizard.history"
      grep -q "$Projecthome" <<< "$Newstackdir" && {
        Projectname="${Newstackdir#$Projecthome}"
        Projectname="$(dirname "$Projectname" | tr "/" ".")"
        Projectname="${Projectname#.}"
        
        [ "$Projectname" = "$(basename "$Newstackdir")" ] && Projectname=""
        [ "$Projectname" = "." ]                          && Projectname=""
      }
      [ "$Projectname" ] && storeinfo "projectdir=$Projecthome/$Projectname" || storeinfo drop projectdir
      [ -z "$Projecthome" ] && Projectname="np"
      [ -z "$Projectname" ] && Projectname="np"
      storeinfo "projectname=$Projectname"
      return 0
    ;;
    no)
      storeinfo drop stackshotdir_valid
      storeinfo drop history
      storeinfo "projectname=np"
      [ "$(storeinfo dump allow_dir_invalid)" = "yes" ] && return 0 || return 1
    ;;
  esac
}
dirglob() {
  # echos files only for glob $1
  #local Path Glob 
  local Filelist Whitespace
  
  #[ -d "${1:-}" ] && {
  #  Path="${1:-}"
  #  Glob="*"
  #} || {
  #  Path="$(dirname  "${1:-}")"
  #  Glob="$(basename "${1:-}")"
  #}
  #Path="$(realpath "$Path")"
  
  [ "${1:-}" = "-w" ] && Whitespace="yes" && shift
  
  Filelist="$(eval find ${1:-} -maxdepth 0 -type d 2>/dev/null)"
  Filelist="$(sort -V <<< "$Filelist")"
  
  [ "$Whitespace" ] && Filelist="$(echo $Filelist)"
  
  [ "$Filelist" ] && echo "$Filelist" || return 1
}
fileglob() {
  # echos files only for glob $1
  #local Path Glob 
  local Filelist Whitespace
  
  #[ -d "${1:-}" ] && {
  #  Path="${1:-}"
  #  Glob="*"
  #} || {
  #  Path="$(dirname  "${1:-}")"
  #  Glob="$(basename "${1:-}")"
  #}
  #Path="$(realpath "$Path")"
  
  [ "${1:-}" = "-w" ] && Whitespace="yes" && shift
  
  Filelist="$(eval find ${1:-} -maxdepth 0 -type f 2>/dev/null)"
  Filelist="$(sort -V <<< "$Filelist")"
  
  [ "$Whitespace" ] && Filelist="$(echo $Filelist)"
  
  [ "$Filelist" ] && echo "$Filelist" || return 1
}
get_extension() {
  local Filename Extension
  Filename="$(head -n1 <<< "${1:-}")"
  Extension="$(rev <<< "$Filename" | cut -d/ -f1 | cut -d. -s -f1 | rev)"
  echo "$Extension"
}
mycp() {
  # copy quoted glob $1 to directory $2
  check_fileglob "${1:-}" || {
    verbose "cp: Source is empty: ${1:-}"
    return 1
  }
  [ -d "${2:-}" ] || {
    failure "cp: Target is not a directory: ${2:-}"
    return 1
  }
  #verbose "cp: copy ${1:-} to $(basename "${2:-}")"
  cp $(fileglob "${1:-}") "${2:-}"
}
mymv() {
  # move quoted glob $1 to directory $2
  check_fileglob "${1:-}" || {
    verbose "mv: Source is empty: ${1:-}"
    return 1
  }
  [ -d "${2:-}" ] || {
    failure "mv: Target is not a directory: ${2:-}"
    return 1
  }
  #verbose "mv: moving ${1:-} to $(basename "${2:-}")"
  mv -f $(fileglob "${1:-}") "${2:-}"
}
myrm() {
  # remove files
  # $@ quoted globs
  local Line
  for Line in "$@" ; do
    check_fileglob "$Line" && {
      verbose "rm: Deleting $Line"
      rm $(fileglob "$Line")
    }
  done
}
myrmdir() {
  # remove directories and their content
  # $@ quoted globs
  local Line
  for Line in "$@" ; do
    check_dirglob "$Line"  && {
      verbose "rmdir: Deleting $Line"
      rm -rf $Line
    }
  done
}
rmrecursive() {
  local Dir
  Dir="${2:-INVALIDDIR}"
  case "${1:-}" in
    bak)
      find "$Dir" -type d -name "*.bak"        -exec rm -r {} +
    ;;
    cache) 
      find "$Dir" -type d -name "cache"        -exec rm -r {} +
      find "$Dir" -type d -name "cache.imfuse" -exec rm -r {} +
    ;;
    prepared) 
      find "$Dir" -type d -name "prepared"       -exec rm -r {} +
      find "$Dir" -type d -name "prepared.bak"   -exec rm -r {} +
    ;;
  esac
}
setup_targetdirnames() {
  local Targetdir
  
  Targetdir="${1:-}"
  Targetdir="$(realpath "$Targetdir")"
  Projectname="$(storeinfo dump projectname)"
  
  [ -d "$Targetdir" ] || {
    failure "No target directory found. Please specify a target directory or make a stackshot.
  Wrong Target: $Targetdir"
    return 1
  }
  
  [ -d "$Targetdir/stackshot" ]          && Targetstackshotdir="$Targetdir/stackshot" || Targetstackshotdir="$Targetdir"
  [ -d "$Targetdir/stackshot-median" ]   && Targetstackshotdir="$Targetdir/stackshot-median"
  Targetbasename="$Projectname.$(basename "$Targetdir")" 
  Targetprepareddir="$Targetdir/prepared"
  Targetfuseddir="$Targetdir/fused"
  Targetcomposeddir="$Targetdir/composed"
  Targetevaluateddir="$Targetdir/evaluated"
  Targetvideodir="$Targetdir/video"
  Targetcachedir="$Targetdir/cache"
}
setup_workdir() {
  # Detect possible source directories in $2 for function $1
  # Set up variables that can be used to call function $1
  # Usage:
  #   setup_workdir Function Targetdir
  # Args:
  #   Function       One of align, sharpen, fuse, median, min, max, mean, set
  #   Targetdir      Target directory [+glob] to check.
  #                  Can already be in an ardustack-structure or an arbitrary one.
  #                  Location of $Destinationdir depends on detected directory structure.
  #   Opt2   Mode of Function
  # Sets variables:
  #   Sourcedir                 Source directory within $Targetdir
  #   Sourcefileglob            Glob to get files. Mostly just "*"
  #   Destinationdir            Recommended directory to store resulting images.
  #                             Often serves as source dir for following functions.
  #   Destinationfile   Possible prefix of destination file(s). Can be "", though.
  #   Targetcachedir            Cache folder
  #
  # Run in a loop to check for next possible source dir in Targetdir.
  # Returns 0 on success and 1 if nothing more is to do.
  #
  # Stores already checked source dirs of $Targetdir in $Sourcedirchecklist. 
  # -> Set Sourcedirchecklist="" before running a loop with setup_workdir().
  # Use local in calling function:
  #   local Sourcedir Sourcefileglob Destinationdir Destinationfile Targetptofile Targetcachedir Sourcedirchecklist

  local Targetnewdir Targetprevdir 
  #local Targetstackshotdir
  #local Targetprepareddir Targetfuseddir Targetevaluateddir Targetcomposeddir Targetcachedir
  local Projectname
  local Imageformat

  Function="${1:-}"
  Targetdir="${2:-}"
  Sourcefileglob="${3:-*}"
  
  Function="${Function%prepared}"
  Destinationdir=""
  Destinationfile=""

  Projectname="$(storeinfo dump projectname)"
  setup_targetdirnames "$Targetdir"
  
  storeinfo test rmcache_before && myrmdir "$Targetcachedir"
  mkdir -p "$Targetcachedir"
  Cachedir="$Targetcachedir"
  
  grep -q -- "fuse" <<< "$Function"      && Targetnewdir="$Targetfuseddir"
  grep -q -- "compose" <<< "$Function"   && Targetnewdir="$Targetcomposeddir"
  grep -q -- "evaluate" <<< "$Function"  && Targetnewdir="$Targetevaluateddir" 
  grep -q -- "animation" <<< "$Function" && Targetnewdir="$Targetvideodir" 
  grep -q -- "video" <<< "$Function"     && Targetnewdir="$Targetvideodir" 
  [ "$Targetnewdir" ] || Targetnewdir="$Targetprepareddir"
  
  [ "$Targetnewdir" = "$Targetprepareddir" ] && {
    mkdir -p $Targetnewdir
    check_fileglob "$Targetprepareddir/$Sourcefileglob" || {
      Imageformat="$(get_extension "$(fileglob "$Targetstackshotdir/$Sourcefileglob")")"
      grep -q -i -x "$Imageformat" <<< "$Imageformatlist" && {
        mycp "$Targetstackshotdir/$Sourcefileglob" "$Targetprepareddir" || return 1
        :
      } || {
        imageformat -2 "tif" -s "$Targetstackshotdir" -g "$Sourcefileglob" -d "$Targetprepareddir" || return 1
      }
    }
  }
  Targetprevdir="$Targetnewdir.bak"

  # backup for undo, serving also as source for batch operations
  case $Function in
    undo*) ;;
    evaluate*)
      mkdir -p $Targetprevdir
      check_fileglob "$Targetnewdir/*" && mycp "$Targetnewdir/*" "$Targetprevdir/" 
      mkdir -p $Targetcomposeddir.bak 
      check_fileglob "$Targetcomposeddir/*" && mycp "$Targetcomposeddir/*" "$Targetcomposeddir.bak/" 
    ;;
    animation*|video*|fuse*)
      mkdir -p $Targetprevdir
      check_fileglob "$Targetnewdir/*" && mycp "$Targetnewdir/*" "$Targetprevdir/" 
    ;;
    *)
      mkdir -p $Targetprevdir
      myrm "$Targetprevdir/*"
      check_fileglob "$Targetnewdir/*" && mymv "$Targetnewdir/*" "$Targetprevdir/"
    ;;
  esac

  case $Function in
    fuse*)
      Sourcedir="$Targetprepareddir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir")"
    ;;
      
    evaluate)
      Sourcedir="$Targetprepareddir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir").$(basename "$Sourcedir")"
      mkdir -p $Targetcomposeddir
    ;;
    evaluatefused)
      Sourcedir="$Targetfuseddir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir").$(basename "$Sourcedir")"
      mkdir -p $Targetcomposeddir
      Sourcefileglob="$(fuse_glob "$Opt1")"
      Sourcefilelist="$(fuse_glob --list "$Opt1")"
      check_filelist $Sourcefilelist || return 1
    ;;
    compose)
      Sourcedir="$Targetevaluateddir"
      Destinationdir="$Targetnewdir"
      #Destinationfile="$Projectname.$(basename "$Targetdir").$(basename "$Sourcedir")"
    ;;
    
    align*|brightness*|contrast*|crop*|cuberotate*|imageformat*|fakehdr*|gamma*|level*|orient*|rotate*|ruler*|sharpen*|statistic*|evalstep*|stretch*|wizard*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
      
    whitebalance*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
    
    animation|video)
      Sourcedir="$Targetprepareddir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir")"
    ;;
    
    undo*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
    
    *)
      failure "setup_workdir(): Function not defined: $Function"
      return 1
    ;;
  esac
  
  [ "$Sourcedir" = "$Targetprepareddir" ] && {
    mkdir -p $Targetprepareddir
    check_fileglob "$Targetprepareddir/$Sourcefileglob" || mycp "$Targetstackshotdir/$Sourcefileglob" "$Targetprepareddir"
  }
  check_fileglob "$Sourcedir/$Sourcefileglob" || {
    failure "setup_workdir(): No source found: $Sourcedir/$Sourcefileglob"
    return 1
  }
  
  [ "$Destinationdir" ] || {
    failure "setup_workdir(): Destinationdir not specified"
    return 1
  }
  mkdir -p "$Destinationdir"
  
  return 0
}

#### show images

showimage() {
  local Imagelist Image Shrinkimage
  case $# in
    0) ;;
    1)
      Imagelist="$(fileglob "${1:-}")" >&2
    ;;
    *)
      while [ "$#" -gt "0" ] ; do
        Imagelist="$Imagelist
${1:-}"
        shift
      done
      Imagelist="$(grep . <<< "$Imagelist")"
    ;;
  esac
    
  case $(grep -c . <<< "$Imagelist") in
    0) 
      failure "showimage: Not found: ${1:-}"
      Image="$(storeinfo dump notfoundimage)"
      [ -e "$Image" ] || $Magickbin -size 300x200 xc:red -fill black -pointsize 20 -gravity center -draw "text 0,0 'image not found'" "$Image"
      geeqie -t -r File:"$Image" 1>&2
      storeinfo drop showimage
      return 1
    ;;
    1) 
      Image="$Imagelist"
      case "$(get_extension "$Image")" in
        gif)
          case $(identify "$Image" | grep -c GIF) in
            1) 
              geeqie -t -r File:"$Image" 1>&2
              storeinfo   "showimage=$Image"
            ;;
            *) showvideo "$Image" ;;
          esac
        ;;
        mp4|webm) 
          showvideo "$Image" 
        ;;
        *)       
          geeqie -t -r File:"$Image" 1>&2
          storeinfo   "showimage=$Image"
        ;;
      esac
    ;;
#    1) geeqie -t -r File:"$Imagelist" ;;
    *) viewnior           $Imagelist 1>&2 & ;;
  esac
  return 0
}
showvideo() {
  ffplay -window_title "$(basename "${1:-}")" -loglevel error -loop 0 "${1:-}" & storepid $!
}

#### batch functions

batch_function() {
  # Apply image processing function $1 on all possible source dirs in target directory $2, options in $3

  local $Batchlocal
  local Return=0
  local Gallerydir Image
  local Startzeit

  parse_batchoptions "$@"                  || return 1
  checkvar -d batch Targetdir "$Targetdir" || return 1
  checkvar    batch Function  "$Function"  || return 1
  check_stackdir "$Targetdir" || {
    failure "batch_function(): Invalid directory: $Targetdir"  
    return 1
  }
  
  ifcmdbreak && return 1
  
  setup_workdir "$Function" "$Targetdir" "$Sourcefileglob" || {
    failure "batch $Function: Source not found in $Targetdir
    $@"
    return 1
  }
  cd "$Targetdir"
  
  case $Function in
    compose|fuse|evaluate) ;;
    *)
      Function="${Function%prepared}"
      Function="${Function%composed}"
      Function="${Function%evaluated}"
      Function="${Function%fused}"
    ;;
  esac
  Function="${Function%_}"
  case "$Function" in
    brightness|contrast|gamma|level|orient|prepare|rotate|sharpen|statistic|stretch|wizard)
      Opt2="$Opt1 $Opt2 $Opt3"
      Opt3=""
      Opt2="${Opt2# }"
      Opt2="${Opt2# }"
      Opt2="${Opt2% }"
      Opt2="${Opt2% }"
      Opt1="$Function"
      Function="wizard"
    ;;
  esac

  ### FIXME
  checkvar           -D "$Function" Sourcedir      "$Sourcedir"        || return 1
  checkvar           -d "$Function" Destinationdir "$Destinationdir"   || return 1
  case $Function in
    undo|compose) ;;
    *) checkvar         $Function Sourcefileglob   "$Sourcefileglob"   || return 1 ;;
  esac
  case $Function in
    wizard) checkvar    $Function Opt1     "$Opt1"     || return 1 ;;
  esac
  case $Function in
    align*|crop|undo|whitebalance)
      checkvar       -d $Function Cachedir         "$Cachedir"         || return 1 ;;
  esac
  
  [ -z "$Opt1" ] && case "$Function" in
    compose|evaluate) Opt1="all" ;;
  esac
  
  note "$Function $Opt1 $Opt2"
  storeinfo "cmd=$@"
  storeinfo "cmd_source=$Sourcedir"
  storeinfo "cmd_destination=$Destinationdir"
  storeinfo "cmd_cache=$Cachedir"
  cd "$Cachedir"
  verbose "batch_function(): $Function -1 '$Opt1' -2 '$Opt2' -3 '$Opt3' -4 '$Opt4' -5 '$Opt5' -6 '$Opt6' -7 '$Opt7' -8 '$Opt8' -9 '$Opt9' -s '$Sourcedir' -g '$Sourcefileglob' -d '$Destinationdir' -b '$Destinationfile' -c '$Cachedir'"
  Startzeit="$(date +%s)"
  $Function -1 "$Opt1" -2 "$Opt2" -3 "$Opt3" -4 "$Opt4" -5 "$Opt5" -6 "$Opt6" -7 "$Opt7" -8 "$Opt8" -9 "$Opt9" -s "$Sourcedir" -g "$Sourcefileglob" -d "$Destinationdir" -b "$Destinationfile" -c "$Cachedir"
  Return=$?
  note "Ready: $Function $Opt1 $Opt2 $Opt3 $Opt4; time: $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")"
  cd "$Targetdir"
  storeinfo drop cmd
  storeinfo drop cmd_source
  storeinfo drop cmd_destination
  storeinfo drop cmd_cache
  
  [ "$Return" = "0" ] || {
    failure "ERROR in $Function $Opt1 $Opt2 $Opt3: $(basename "$Sourcedir") -> $(basename "$Destinationdir")"
    case $Function in
      animation|video) ;;
      evaluate) 
        undo -s "$Destinationdir.bak"   -d "$Destinationdir"   -c "$Cachedir" 
        undo -s "$Targetcomposeddir.bak" -d "$Targetcomposeddir" -c "$Cachedir" 
      ;;
      compose|fuse*) 
        undo -s "$Destinationdir.bak"   -d "$Destinationdir"   -c "$Cachedir" 
      ;;
      *)
        undo -s "$Sourcedir"            -d "$Destinationdir"   -c "$Cachedir"
      ;;
    esac
  }
  
  set -x
  storeinfo test rmcache_after && rm -R "$Cachedir"
  set +x
  
  [ "$Return" = "0" ] && [ "$(basename "$Destinationdir")" = "evaluated" ] && {
    
    storeinfo test stackshotdir_valid && {
      # link prepared.max
      ls $Destinationdir/*prepared.max* >/dev/null 2>&1 && {
        ln -f $(fileglob "$Destinationdir/*.prepared.max.*") "$Targetdir"
      }
    
      # link fused.mean results
      ls $Destinationdir/*fused.mean* >/dev/null 2>&1 && {
        # link fused.median result into parent directory
        while read Line; do
          ln -f "$Line" "$Targetdir"
        done < <(fileglob "$Targetevaluateddir/*fused.mean.*")
        
        ## link into project dir
        #[ "$(storeinfo dump projectname)" != "np" ] && {
        #  Image="$(find $Destinationdir/*.fused.median.set2.* $Destinationdir/*.fused.median.* -type f | head -n1)"
        #  [ -e "$Image" ] && ln -f "$Image" "$Destinationdir/../../"
        #}
      }
      
      ## link fused.median result into $Gallerydir directory
      #Gallerydir="$(storeinfo dump gallerydir)"
      #[ -d "$Gallerydir" ] && {
      #  Image="$(find $Destinationdir/*.fused.median.set2.* $Destinationdir/*.fused.median.* -type f | head -n1)"
      #  ln -f "$Image" "$Gallerydir"
      #}
    }
  }
  verbose "batch_function(): $Function: return $Return"

  return $Return
}
parse_batchoptions() {
  # To be called by batch functions to parse options.
  # Include this local line in the calling function:
  #   local Targetdir Sourcedir Sourcefileglob Destinationdir Destinationfile Cachedir Function Opt1 Opt2

  local Shortoptions Longoptions Parsedoptions
  local Error
  
  Shortoptions="b:c:d:f:g:m:o:s:t:1:2:3:4:5:6:7:8:9:"
  Longoptions=""

  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@" )"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ] ; do
    case "${1:-}" in
      -t) Targetdir="${2:-}" ;;
      -s) Sourcedir="${2:-}" ;;
      -g) Sourcefileglob="${2:-}" ;;
      -d) Destinationdir="${2:-}" ;;
      -b) Destinationfile="${2:-}" ;;
      -c) Cachedir="${2:-}" ;;
      -f) Function="${2:-}" ;;
      -1) Opt1="${2:-}" ;;
      -2) Opt2="${2:-}" ;;
      -3) Opt3="${2:-}" ;;
      -4) Opt4="${2:-}" ;;
      -5) Opt5="${2:-}" ;;
      -6) Opt6="${2:-}" ;;
      -7) Opt7="${2:-}" ;;
      -8) Opt8="${2:-}" ;;
      -9) Opt9="${2:-}" ;;
      --) ;;
      *) 
        failure "Unbekannte Option ${1:-} ($Function)" 
        Error=1
      ;;
    esac
    shift
    shift
  done

  [ "$Sourcefileglob" ] || Sourcefileglob="*"
  #[ ! -d "$Sourcedir" ]      && failure "$Function: source dir not found: $Sourcedir" && return 1
  #[ ! -d "$Destinationdir" ] && failure "$Function: destination dir not found: $Destinationdir"&& return 1
  #! check_fileglob "$Sourcedir/$Sourcefileglob" && failure "$Function: No source files found: $Sourcedir/$Sourcefileglob"  && return 1
  return ${Error:-0}
}
getbatchtwo() {
  local Command= Line Argument
  for Line in rotate gamma level contrast sharpen brightness stretch statistic wizard; do
    Argument="$(askkaptain "$Line")"
    [ "$Argument" ] && case $Line in
      brightness) Line="-brightness-contrast" ;;
      contrast)   Line="-sigmoidal-contrast" ;;
      rotate)     Line="-rotate" ; Argument="$(askkaptain rotateopt1combo)" ;;
      sharpen)    Line="-adaptive-sharpen" ;;
      statistic)  Line="-statistic" ; Argument="$(askkaptain statisticopt1combo) $(askkaptain statisticopt2combo)" ;;
      stretch)    Line="-contrast-stretch" ;;
      wizard)     Line="" ;;
      *)          Line="-$Line" ;;
    esac
    case $Argument in
      "") ;;
      auto) Command="$Command -auto$Line" ;;
      *)    Command="$Command $Line $Argument" ;;
    esac
  done
  echo "$Command"
}
getfunctionsettings() {
  local Function
  Function="${1:-none}"
  Opt1="$(askkaptain -c ${Function}opt1combo)"
  Opt2="$(askkaptain -c ${Function}opt2combo)"
  Opt3="$(askkaptain -c ${Function}opt3combo)"
  Opt4="$(askkaptain -c ${Function}opt4combo)"
  Opt5="$(askkaptain -c ${Function}opt5combo)"
  Opt6="$(askkaptain -c ${Function}opt6combo)"
  Opt7="$(askkaptain -c ${Function}opt7combo)"
  Opt8="$(askkaptain -c ${Function}opt8combo)"
  Opt9="$(askkaptain -c ${Function}opt9combo)"
}
runbatchone() {
  local $Batchlocal
  local Iterate
  for Function in imageformat orient crop align_vidstab align_hugin align_ais align_focusstack; do
    askkaptain -c $Function > /dev/null && {
      getfunctionsettings $Function
      cmd -f "$Function" -1 "$Opt1" -2 "$Opt2" -3 "$Opt3" -4 "$Opt4" -5 "$Opt5" -6 "$Opt6" -7 "$Opt7" -8 "$Opt8" -9 "$Opt9" -t "$Stackdir"
    }
  done
  return 0
}
runbatchtwo() {
  local $Batchlocal
  Stackdir="${1:-}"
  cmd -f wizard -1 "$(getbatchtwo)" -t "$Stackdir"
}
runbatchthree() {
  askkaptain evaluate1 >/dev/null        && cmd -f evaluateprepared -t "$Stackdir"
  askkaptain fuse >/dev/null             && {
    Opt1="$(askkaptain fuseopt1combo)"
    Opt2="$(askkaptain fuseopt2combo)"
                                            cmd -f fuse           -t "$Stackdir" -1 "$Opt1" -2 "$Opt2"
    [ "$Opt2" = "all" ]                  && cmd -f evaluatefused   -t "$Stackdir" -1 "$Opt1"
  }
  askkaptain evaluate2 >/dev/null        && cmd -f evaluatefused   -t "$Stackdir" -1 "$(askkaptain evaluateopt1combo)"
  askkaptain deletebackups2 >/dev/null   && cmd -f deletebackups  -t "$Stackdir"
  askkaptain deleteprepared2  >/dev/null   && cmd -f deleteprepared   -t "$Stackdir"
  #cmd -f showimage -s "$Stackdir/evaluated" -g "*fused.*.mean*"
}
setup_imagelist() {
  # Set up often needed image variables
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagelist2="$(echo $Imagelist)"
  Imagenumber="$(grep -c . <<< "$Imagelist")"
  Image="$(head -n1 <<< "$Imagelist")"
  [ -z "$Image" ] && {
    failure "No images found"
    return 1
  }
  Imagewidth=$($Magickbin  -format '%w' "$Image" info:)
  Imageheight=$($Magickbin -format '%h' "$Image" info:)
  Imageformat="$(get_extension        "$Image")"
  Imagememsize="$((Imagewidth*Imageheight*Magickpixelmemory/1000))"
  Imagememsize="$((Imagememsize*125/100))" # by observation. Alpha channel? Meta data?
  Imagelistmemsize="$((Imagememsize*Imagenumber))"
  LC_ALL=C file $Image | grep -q "raw image" && Imageraw="yes" || Imageraw="no"
  Image=""
  Imagecount=0
  Cropgeometry=""
  verbose "setup_imagelist(): $Sourcedir
  Image number:   $Imagenumber
  Image width :   $Imagewidth
  Image height:   $Imageheight
  Image format:   $Imageformat
  Image mem size: $Imagememsize
  List  mem size: $Imagelistmemsize
  Raw image:      $Imageraw"
}

#### image sequence operations
align_focusstack() {
  local $Batchlocal
  local $Imagelocal
  local Pid Logfile
  local Part Full
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Logfile=$Cachedir/focus-stack.log
  
  focus-stack --verbose --output="$Destinationdir/" --align-only $(fileglob "$Sourcedir/$Sourcefileglob") >$Logfile 2>&1 || storeinfo "cmdbreak=yes" & Pid=$!
#  tail -F -n+1 --pid $Pid $Logfile &
  while ps -p $Pid >/dev/null; do
    sleep 0.1
    ifcmdbreak && {
      kill $Pid
      break
    }
    Line="$(tail $Logfile | head -n9 | tac)"
    
    grep -q "Starting task: Save" <<< "$Line" && {
      Line="$(grep -m1 "Starting task: Save" <<< "$Line")"
      echo "$Line"
      Image="$(sed -n -e 's/^.*Save //p' <<< "$Line")"
      showimage "$Image"
      Line="$(cut -d "[" -f2 <<< "$Line")"
      Line="$(cut -d "]" -f1 <<< "$Line")"
      Part="$(cut -d "/" -f1 <<< "$Line")"
      Full="$(cut -d "/" -f2 <<< "$Line")"
      showpercent $Part $Full
    }
  done
  ifcmdbreak && return 1 || return 0
}
align_ais() {

  local $Batchlocal
  local $Imagelocal
  local Alignlist
  local Aligndir Distortdir
  local Cropminimage Rotate
  local Stackcount Stacklist Firstimage Step Stepsize
  local Startzeit Dauer Restzeit
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  [ "$Opt1" ] && Opt1="-m"
  Stepsize=10

  note "align_ais: Running align_image_stack with $Stepsize images on each iteration.
  "
  Stackcount=0
  Startzeit="$(date +%s)"
  for Step in 0 $(seq $((Imagenumber/$Stepsize)) ); do
    showpercent $((Step*Stepsize)) $Imagenumber
    ifcmdbreak && break
    [ "$Error" ] && break
    Stackcount="$((Stackcount+1))"
    Stacklist="$(tail -n+$((Stepsize*Step+1)) <<< "$Imagelist" | head)"
    [ -z "$Stacklist" ] && break
    Aligndir=$Cachedir/align.$Stackcount
    mkdir $Aligndir
    nice align_image_stack $Opt1 -v -l --use-given-order -p $Cachedir/ais.$Stackcount.pto -a $Aligndir/align $Firstimage $Stacklist || Error=1
    Firstimage="$(fileglob "$Aligndir/align*" | tail -n1)"
    showimage $Firstimage
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-((Step+1)*Stepsize)) / ((Step+1)*Stepsize) ))"
    [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
    note "align_ais: Duration: $(date -u -d @$Dauer +"%T"); Estimated time left: $(date -u -d @$Restzeit +"%T") ($Restzeit)"
  done
  
  ifcmdbreak   && return 1
  [ "$Error" ] && return 1
  
  Distortdir=$Cachedir/result
  mkdir $Distortdir
  Count=0
  for Aligndir in $(dirglob "$Cachedir/align*"); do
    [ "$Count" = "0" ] || rm $Aligndir/align0000.tif
    for Image in $(fileglob "$Aligndir/*"); do
      ifcmdbreak && break
      Count=$((Count+1))
      mv $Image $Distortdir/align$(zeronumber $Count).tif
    done
  done

  Alignlist="$(fileglob "$Distortdir/*")"

  # crop greatest common inner rectangle of distorted images
  note "align_ais(): Generating min image of aligned images."
  Cropminimage="$Cachedir/distorted.min.tif"
  #$Magickbin $Alignlist -evaluate-sequence min "$Cropminimage" || return 1
  evaluate_split -s $Distortdir -g "*" -1 min -b $Cropminimage -c $Cachedir || return 1
  case $Cropinteractive in
    yes) notify-send "align_ais: Ready for interactive crop"
         Cropgeometry="$(cropgeometry_interactive "$Cropminimage" "$Cachedir")"   || return 1 ;;
    *)   Cropgeometry="$(trim_hard "$Cropminimage" "$Cropgeometry")"              || return 1 ;;
  esac
  
  Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
  Rotate="${Rotate:-0}"
  Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
      
  [ "$Cropgeometry" ] || {
    failure "align_ais: crop geometry is empty"
    return 1
  }
  
  note "align_ais: Cropping images with rotation $Rotate and geometry $Cropgeometry"
  Imagecount=0
  Startzeit="$(date +%s)"
  for Image in $Alignlist; do
    ifcmdbreak && break
    Imagecount="$((Imagecount + 1))"
    Destinationfile="$(head -n$Imagecount <<< "$Imagelist" | tail -n1)"
    Destinationfile="$Destinationdir/$(basename $Destinationfile)"
    multicore "$Magickbin $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
    showpercent $Imagecount $Imagenumber
    Restzeit="$(( Dauer*(Imagenumber-Imagecount) / Imagecount ))"
    note "align_ais: Cropping to $Cropgeometry. Duration: $(date -u -d @$Dauer +"%T"); Estimated time left: $(date -u -d @$Restzeit +"%T") ($Restzeit)"
  done
  multicore_wait || return 1
  return ${Error:-0}
}
align_ais_ONE() {

  local $Batchlocal
  local $Imagelocal
  local Alignlist
  local Distortdir
  local Cropminimage Rotate
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  [ "$Opt1" ] && Opt1="-m"

  Distortdir=$Cachedir/distort
  mkdir $Distortdir
  
  note "align_ais(): Running align_image_stack now. That will take a while."
#  nice align_image_stack -v -v -v -v -v -l $Opt1 -a $Distortdir/align --use-given-order $Imagelist || return 1
  nice align_image_stack $Opt1 -l --use-given-order -v -v -v -v -v -a $Distortdir/align -p $Cachedir/controlpoints.pto $Imagelist || return 1

  Alignlist="$(fileglob "$Distortdir/*")"

  # crop greatest common inner rectangle of distorted images
  note "align_ais(): Generating min image of aligned images."
  Cropminimage="$Cachedir/distorted.min.mpc"
  $Magickbin $Alignlist -evaluate-sequence min "$Cropminimage" || return 1
  case $Cropinteractive in
    yes) notify-send "align_ais: Ready for interactive crop"
         Cropgeometry="$(cropgeometry_interactive "$Cropminimage" "$Cachedir")"   || return 1 ;;
    *)   Cropgeometry="$(trim_hard "$Cropminimage" "$Cropgeometry")"              || return 1 ;;
  esac
  
  Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
  Rotate="${Rotate:-0}"
  Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
      
  [ "$Cropgeometry" ] || {
    failure "align_ais: crop geometry is empty"
    return 1
  }
  
  note "align_ais: Cropping images with rotation $Rotate and geometry $Cropgeometry"
  Imagecount=0
  for Image in $Alignlist; do
    ifcmdbreak && break
    Imagecount="$((Imagecount + 1))"
    Destinationfile="$(head -n$Imagecount <<< "$Imagelist" | tail -n1)"
    Destinationfile="$Destinationdir/$(basename $Destinationfile)"
    multicore "$Magickbin $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || return 1
    showpercent $Imagecount $Imagenumber
  done
  multicore_wait || return 1
}
align_ais_TWO() {

  local $Batchlocal
  local $Imagelocal
  local Imagelist1 Imagelist2 Alignlist
  local Count Imagehalf
  local Part1dir Part2dir Distortdir
  local Cropminimage Rotate
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  [ "$Opt1" ] && Opt1="-m"
  
  Part1dir=$Cachedir/part1
  Part2dir=$Cachedir/part2
  Distortdir=$Cachedir/distort
  mkdir $Part1dir
  mkdir $Part2dir
  mkdir $Distortdir

  Imagehalf=$((Imagenumber/2 +1))
  Count=0
  for Image in $Imagelist; do
    Count=$((Count + 1))
    [ "$Count" -le "$Imagehalf" ] && Imagelist1="$Image $Imagelist1"
    [ "$Count" -ge "$Imagehalf" ] && Imagelist2="$Imagelist2 $Image"
  done

  echo "List1:
$Imagelist1"
  echo "List2:
$Imagelist2"
  showpercent busy
  multicore "align_image_stack -l $Opt1 --gpu -a $Part1dir/align --use-given-order $Imagelist1" || return 1
  multicore "align_image_stack -l $Opt1 --gpu -a $Part2dir/align --use-given-order $Imagelist2" || return 1
  multicore_wait || return 1

  Alignlist="$(fileglob "$Part1dir/*")"
  Count=0
  for Image in $Alignlist ; do
    Destinationfile="$(head -n$((Imagehalf - Count)) <<< "$Imagelist" | tail -1)"
    Destinationfile="$Distortdir/$(basename "$Destinationfile").tif"
    cp -T "$Image" "$Destinationfile"
    Count=$((Count + 1))
    showimage "$Destinationfile"
  done
  Alignlist="$(fileglob "$Part2dir/*")"
  Count=0
  for Image in $Alignlist ; do
    Destinationfile="$(head -n$((Imagehalf + Count)) <<< "$Imagelist" | tail -1)"
    Destinationfile="$Distortdir/$(basename "$Destinationfile").tif"
    cp "$Image" "$Destinationfile"
    Count=$((Count + 1))
    showimage "$Destinationfile"
  done

  # crop greatest common inner rectangle of distorted images
  Cropminimage="$Cachedir/distorted.min.mpc"
  $Magickbin $(fileglob "$Distortdir/*") -evaluate-sequence min "$Cropminimage" || return 1
  case $Cropinteractive in
    yes) notify-send "align_ais: Ready for interactive crop"
         Cropgeometry="$(cropgeometry_interactive "$Cropminimage" "$Cachedir")"   || return 1 ;;
    *)   Cropgeometry="$(trim_hard "$Cropminimage" "$Cropgeometry")"              || return 1 ;;
  esac
  
  Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
  Rotate="${Rotate:-0}"
  Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
  Cropgeometry="$(calc_evengeometry "$Cropgeometry")"
      
  [ "$Cropgeometry" ] || {
    failure "align_ais: crop geometry is empty"
    return 1
  }
  
  note "align_ais: Cropping images with rotation $Rotate and geometry $Cropgeoemtry"
  Imagelist="$(fileglob "$Distortdir/*")"
  Imagecount=0
  for Image in $Imagelist; do
    ifcmdbreak && Error=1
    [ "$Error" = "1" ] && break
    Imagecount="$((Imagecount + 1))"
    Destinationfile="$Destinationdir/$(basename $Image)"
    Destinationfile="${Destinationfile%.tif}"
    multicore "$Magickbin $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || Error=1
    showpercent $Imagecount $Imagenumber
  done
  multicore_wait || return 1
  return ${Error:-0}
}
align_hugin() {
  # Align image stack with some panotools. Similar to align_image_stack
  
  local $Batchlocal
  local $Imagelocal
  local Pto_ptogen Pto_cpfind Pto_cpclean Pto_result
  local Logfile Aligndir
  local Count
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Logfile="$Cachedir/align_hugin.log"
  :> $Logfile
  
  Pto_ptogen=$Cachedir/align1.pto_gen.pto
  Pto_cpfind=$Cachedir/align2.cpfind.pto
  Pto_cpclean=$Cachedir/align3.cpclean.pto
  Pto_result=$Cachedir/align4.result.pto
  
  Aligndir=$Cachedir/align
  mkdir $Aligndir
  
  #tail -f "$Logfile" &
    
  echo "########## pto_gen ##########" >> "$Logfile"
  note "align_hugin: Running pto_gen to create list of files"
#  pto_gen -o "$Pto_ptogen" -p 0 -f 40 --crop=0,${Imagewidth},0,${Imageheight} $(fileglob $Sourcefileglob) >> "$Logfile" 2>&1 || {
#  pto_gen -o "$Pto_ptogen" -p 0 -f 40 --crop=0,${Imagewidth},0,${Imageheight} $(echo $Imagelist) >> "$Logfile" 2>&1 || {
  pto_gen -p0 -f50 -o "$Pto_ptogen" $(echo $Imagelist) >> "$Logfile" 2>&1 || {
    failure "align_hugin: Error in pto_gen
$(tail $Logfile)"
    return 1
  }
  
  sed -i '3 s/r:CROP//'                     "$Pto_ptogen"
  sed -i '3 s/\bf[0-9]*\b/f0/'              "$Pto_ptogen"
  sed -i "3 s/\bw[0-9]*\b/w${Imagewidth}/"  "$Pto_ptogen"
  sed -i "3 s/\bh[0-9]*\b/h${Imageheight}/" "$Pto_ptogen"
  sed -i "3 s/\bv[0-9]*\b/v50/"             "$Pto_ptogen"
  sed -i "s/v=0/v50/"             "$Pto_ptogen"
  #sed -i "s/v50/v0/"             "$Pto_ptogen"
    
#    pano_modify --projection=0 $Pto_ptogen
#    pano_modify --canvas=${Imagewidth}x${Imageheight} $Pto_ptogen
#    pano_modify --output-type=FUSEDSTACKS $Pto_ptogen

  ifcmdbreak && return 1
  echo "########## cpfind ##########" >> "$Logfile"
  note "align_hugin: Running cpfind to find control points for alignment. That will take a while."
#  cpfind -o "$Pto_cpfind"  \
#        --fullscale \
#        --minmatches 4 \
#        --linearmatch \
#        --linearmatchlen 10 \
#        --ransacmode rpyv \
#        "$Pto_ptogen" 2>&1 >> "$Logfile" || {
#    failure "Error in cpfind
#$(tail $Logfile)"
#    return 1
#  }
  cpfind -o "$Pto_cpfind"  \
        --ransacmode rpyv \
        --linearmatch \
        --linearmatchlen 3 \
        "$Pto_ptogen" 2>&1 >> "$Logfile" || {
    failure "align_hugin: Error in cpfind
$(tail $Logfile)"
    return 1
  }
  showpercent 40 100
#        --linearmatchlen $Count \

  ifcmdbreak && return 1
  echo "########## cpclean ##########" >> "$Logfile"
  note "align_hugin: Running cpclean to remove wrong control points"
  cpclean -s -o "$Pto_cpclean" --pairwise-checking "$Pto_cpfind" >> "$Logfile" || {
    failure "align_hugin: Error in cpclean
$(tail $Logfile)"
    return 1
  }
  showpercent 45 100

  #pano_modify --fov=AUTO -o $Pto_cpclean $Pto_cpclean
  for Count in $(seq $((Imagenumber-1)) ); do
#    pto_var --modify-opt --opt=v,v$Count -o $Pto_cpfind $Pto_cpfind
    echo "v v$Count" >> $Pto_cpfind
  done
    
  # calculate distortion of images to align control points
  ifcmdbreak && return 1
  echo "########## autooptimiser ##########" >> "$Logfile"
  note "align_hugin: Running autooptimiser to transform control points into image distortion"
#  autooptimiser -p -o "$Pto_result" "$Pto_cpclean" >> "$Logfile" || {
  autooptimiser -n -p -a -o "$Pto_result" "$Pto_cpclean" >> "$Logfile" || {
    failure "Error in autooptimiser
$(tail $Logfile)"
    return 1
  }
  showpercent 60 100
  #pano_modify --crop=AUTO $Pto_result

  grep -q "Strange values may result!" < "$Logfile" && {
    failure "align_hugin: Did not find enough control points!
  Check out log file $Logfile
  Probably source images are distorted too much.
  The result might be unuseable."
#    return 1
  }

  # distort images to align them
  ifcmdbreak && return 1
  echo "########## nona ##########" >> "$Logfile"
  note "align_hugin: Running nona to transform images"
  nona -o "$Aligndir/PTO_ALIGN" "$Pto_result" >> "$Logfile" || {
    failure "align_hugin: Error in nona
$(tail $Logfile)"
    return 1
  }
  showpercent 70 100
  
  ifcmdbreak && return 1
  note "align_hugin: Checking crop coordinates of common area of all aligned images"
  evaluate_split -s $Aligndir -g "*" -1 min -b $Cachedir/align_PTO.min.tif -c $Cachedir 
  #$Magickbin $Aligndir/PTO_ALIGN* -evaluate-sequence min $Cachedir/align_PTO.min.tif
  Cropgeometry="$(trim_hard "$Cachedir/align_PTO.min.tif")"
  showpercent 80 100

  ifcmdbreak && return 1
  note "align_hugin: Cropping images"
  Count=0
  for Image in $(fileglob "$Aligndir/PTO_ALIGN*"); do
    Count=$((Count +1))
    Destinationfile="$(sed "${Count}q;d" <<< "$Imagelist")"
    Destinationfile="$(basename "$Destinationfile")"
    Destinationfile="$Destinationdir/$Destinationfile"
    multicore "$Magickbin $Image -crop $Cropgeometry $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
    showpercent $Count $Imagenumber
  done
  multicore_wait || return 1
  return ${Error:-0}
}
align_vidstab() {

  local $Batchlocal
  local $Imagelocal
  local Framedir Distortdir Distortlogfile Cropminimage Commonareaimage
  local Xoffset Yoffset Degree
  local Iterations Prepare Crop
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Opt1="${Opt1:-crop}"
  Iterations="${Opt2:-3}"
  [ "${Opt3:-}" ] && Prepare="yes" || Prepare="no"
  
  # cache setup
  Framedir="$Cachedir/frames"
  mkdir -p "$Framedir"
  Distortdir="$Cachedir/distorted"
  mkdir -p "$Distortdir"
  Cropminimage="distort.min.mpc"
  Commonareaimage="$Cachedir/distorted.commonarea.mpc"
  Distortlogfile="$Cachedir/align_vidstab.log"
  
  
  case "$Prepare" in
    "no")
      note "align_vidstab: Cropping video frames to even geometry and converting to png"
      Cropgeometry="$(calc_evengeometry "${Imagewidth}x${Imageheight}+0+0")"
      [ "$Cropgeometry" != "${Imagewidth}x${Imageheight}+0+0" ] && Crop="-crop $Cropgeometry" || Crop=""
      Imagecount=0
      for Image in $Imagelist; do
        Imagecount="$((Imagecount + 1))"
        Destinationfile="$Framedir/frame$(zeronumber $Imagecount).png"
        multicore "$Magickbin $Image $Crop $Destinationfile" "$Destinationfile" || Error=1
        [ "$Error" ] && break
        showpercent "$Imagecount" "$Imagenumber"
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
      Cropgeometry=""
      showpercent 10 100
    ;;
    "yes")
      note "align_vidstab: Preparing video frames for alignment"
      imageproperties -s "$Sourcedir" -g "$Sourcefileglob" -c "$Cachedir"
      Cropgeometry="$(calc_evengeometry "${Imagewidth}x${Imageheight}+0+0")"
      Imagecount=0
      for Image in $Imagelist; do
        ifcmdbreak && Error=1
        [ "$Error" ] && break
        Imagecount="$((Imagecount + 1))"
        Destinationfile="$Framedir/frame$(zeronumber $Imagecount).png"
        multicore "$Magickbin $Image -crop $Cropgeometry -channel red -level ${Imageminlevelred}%x${Imagemaxlevelred}% -channel green -level ${Imageminlevelgreen}%x${Imagemaxlevelgreen}% -channel blue -level ${Imageminlevelblue}%x${Imagemaxlevelblue}% +channel $Destinationfile" "$Destinationfile" || Error=1
        showpercent "$Imagecount" "$Imagenumber"
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
      Cropgeometry=""
      showpercent 10 100
  
      note "align_vidstab: Balancing video frame brightness"
      whitebalance -1 "full" -2 "mean" -s "$Framedir" -g "*" -d "$Framedir" -c "$Cachedir" || return 1
      showpercent 20 100
    ;;
  esac
  
  [ "$Error" = "1" ] && return 1
  align_vidstab_ffmpeg -2 "10" -s "$Framedir" -g "*" -c "$Cachedir" || return 1
  note "align_vidstab: Distorting frames (Shakiness=10)"
  distort -2 "$Cachedir/align.10.log" -s "$Framedir" -g "*" -d "$Distortdir" -c "$Cachedir" || return 1
  showpercent 30 100
  
  [ "$Iterations" -ge "2" ] && {
    mycp "$Distortdir/*" "$Framedir"
    align_vidstab_ffmpeg -2 "5"  -s "$Framedir" -g "*" -c "$Cachedir" || return 1
    note "align_vidstab: Distorting frames (Shakiness=5)"
    distort -2 "$Cachedir/align.5.log" -s "$Framedir" -g "*" -d "$Distortdir" -c "$Cachedir" || return 1
    showpercent 50 100  
  }
  
  [ "$Iterations" -ge "3" ] && {
    mycp "$Distortdir/*" "$Framedir"
    align_vidstab_ffmpeg -2 "1"  -s "$Framedir" -g "*" -c "$Cachedir" || return 1
    showpercent 60 100
  }
  
  myrm "$Framedir/*"
  case $Imageformat in
    png|tif|tiff)
      mycp "$Sourcedir/$Sourcefileglob" "$Framedir"
    ;;
    *)
      imageformat -1 "tif" -s "$Sourcedir" -g "$Sourcefileglob" -d "$Framedir" -c "$Cachedir"
    ;;
  esac
  showpercent 70 100
  
  echo "# Image | Xoffset | Yoffset | Degree" > $Distortlogfile
  echo "# $Magickbin Image -virtual-pixel transparent -distort SRT '0,0 1 Degree Xoffset,Yoffset' out.png" >> $Distortlogfile
  Imagecount=0
  for Image in $(fileglob "$Framedir/*") ; do
    Imagecount="$((Imagecount+1))"
    Image="$(basename "$Image")"
    Xoffset=0
    Yoffset=0
    Degree=0
    for Logfile in $(find $Cachedir/align.*.log); do
      Line="$(sed "${Imagecount}q;d" "$Logfile")"
      Xoffset="$(awk "BEGIN {print $Xoffset + $(cut -d' ' -f2 <<< "$Line") }" )"
      Yoffset="$(awk "BEGIN {print $Yoffset + $(cut -d' ' -f3 <<< "$Line") }" )"
      Degree="$(awk  "BEGIN {print $Degree  + $(cut -d' ' -f4 <<< "$Line") }" )"
    done
    echo "$Image $Xoffset $Yoffset $Degree" >> "$Distortlogfile"
  done
  
  note "align_vidstab: Distorting source images"
  rm $Distortdir/*
  distort -2 "$Distortlogfile" -s "$Framedir" -g "*" -d "$Distortdir" -c "$Cachedir"
  showpercent 80 100

  case $Opt1 in
    crop|crop_interactive|common_area) 
      note "align_vidstab: Generating min image"
      #$Magickbin $(fileglob "$Distortdir/*") -evaluate-sequence min "$Cropminimage" || return 1
      evaluate_split -s "$Distortdir" -1 min -b "$Cachedir/$Cropminimage" -c $Cachedir || return 1
    ;;
  esac
  
  case $Opt1 in
    crop) 
      Cropgeometry="$(trim_hard "$Cropminimage" "$Cropgeometry")" || return 1 
    ;;
    crop_interactive) 
      notify "align_vidstab: Ready for interactive crop"
      Cropgeometry="$(cropgeometry_interactive "$Cropminimage" "$Cachedir")" || return 1 
    ;;
    distort_only) ;;
    common_area) 
      note "align_vidstab: Generating mask image"
      $Magickbin $Cropminimage -threshold 0% $Commonareaimage || return 1
    ;;
  esac
  
  case $Opt1 in
    crop|crop_interactive) 
      Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
      Rotate="${Rotate:-0}"
      Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
      [ "$Cropgeometry" ] || {
        failure "align_vidstab: crop geometry is empty"
        Cropgeometry="${Imagewidth}x${Imageheight}+0+0"
      }
      note "align_vidstab: Cropping aligned images to $Cropgeometry"
    ;;
    common_area)
      note "align_vidstab: Reducing image content to common area of aligned images"
    ;;
    distort_only) 
      note "align_vidstab: Moving distorted images to destination"
    ;;
  esac
      
  Imagecount=0
  for Image in $(fileglob "$Distortdir/*"); do
    Imagecount="$((Imagecount+1))"
    Destinationfile="$(sed "${Imagecount}q;d" <<< "$Imagelist")"
    Destinationfile="$Destinationdir/$(basename "$Destinationfile")"
    case $Opt1 in
      crop|crop_interactive) 
        multicore "$Magickbin $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || Error=1
      ;;
      common_area)
        multicore "$Magickbin $Image $Commonareaimage -evaluate-sequence min $Destinationfile" "$Destinationfile" || Error=1
      ;;
      distort_only)
        multicore "$Magickbin $Image $Destinationfile" "$Destinationfile" || Error=1
      ;;
    esac
    showpercent "$Imagecount" "$Imagenumber"
    [ "$Error" ] && break
  done
  multicore_wait || return 1

  case $Opt1 in
    crop)             showimage "$Cropminimage.trim_hard.png" ;;
    crop_interactive) showimage "$Cachedir/cropgeometry.gui.tif" ;;
    common_area)      showimage "$Commonareaimage" ;;
  esac
  return ${Error:-0}
}
align_vidstab_ffmpeg() {
  # Align images with ffmpeg/vidstab
  # Generates file $Cachedir/align.$Opt2.log containing the calculated distortion parameters.
  # -o  Shakiness 1-10 (low to high)
  # -s  Sourcedir must contain files of form frame0001.png
  
  local $Batchlocal
  local $Imagelocal
  local $Imagepropertieslocal
  local CropW CropH CropX CropY Cropgeometry Zoom
  local Shakiness Stepsize
  local Xoffset Xoffsetrelative Xoffsetlist Yoffset Yoffsetrelative Yoffsetlist Radians Radiansrelative Radianslist Degree 
  local Motionsfile Distortlogfile

  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  cd $Cachedir
  
  # settings
  Shakiness="${Opt2:-1}"
  Stepsize=6
  
  # cache setup
  Motionsfile="$Cachedir/global_motions.trf"
  Distortlogfile="$Cachedir/align.$Shakiness.log"
  :> $Distortlogfile
  
  
  note "align_vidstab: Generating video (shakiness=$Shakiness)"
  nice ffmpeg -y -hide_banner -nostdin -f image2 -start_number 1 -i $Sourcedir/frame%04d.png -safe "0" -vframes 1000 -vcodec libx264 -crf 25  -pix_fmt rgba "$Cachedir/align.source.mov" || return 1
  ifcmdbreak && return 1

  note "align_vidstab: Analyzing video (shakiness=$Shakiness)"
  nice ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.source.mov" \
         -vf "vidstabdetect=shakiness=$Shakiness:accuracy=15:mincontrast=0.1:stepsize=$Stepsize:show=1:result=$Cachedir/transforms$Shakiness.trf" \
         "$Cachedir/align.vidstab-show.mov" || return 1
  ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.vidstab-show.mov"
  ifcmdbreak && return 1
            
  note "align_vidstab: Transforming video (shakiness=$Shakiness"
  nice ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.source.mov" \
         -vf "vidstabtransform=optzoom=0:smoothing=0:interpol=bilinear:relative=1:crop=black:debug=1:input=$Cachedir/transforms$Shakiness.trf" \
         "$Cachedir/align.result.mov" || return 1
  ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.result.mov"
  ifcmdbreak && return 1
  
  Xoffsetlist="$(cat $Motionsfile | grep -v '#' | awk '{print $2}')"
  Yoffsetlist="$(cat $Motionsfile | grep -v '#' | awk '{print $3}')"
  Radianslist="$(cat $Motionsfile | grep -v '#' | awk '{print $4}')"
  
  note "align_vidstab: Calculating distortion (shakiness=$Shakiness)"
  Imagecount=0
  for Image in $Imagelist; do
    Imagecount="$((Imagecount + 1))"
    Xoffsetrelative="$(sed "${Imagecount}q;d" <<<"$Xoffsetlist")"
    Xoffset="$(awk "BEGIN { print $Xoffset + $Xoffsetrelative }")"
    Yoffsetrelative="$(sed "${Imagecount}q;d" <<<"$Yoffsetlist")"
    Yoffset="$(awk "BEGIN { print $Yoffset + $Yoffsetrelative }")"
    Radiansrelative="$(sed "${Imagecount}q;d" <<<"$Radianslist")"
    Radians="$(awk "BEGIN { print $Radians - $Radiansrelative }")"
    Degree="$(awk  "BEGIN { print $Radians * 180 / 3.141592652}")"
    echo "$(basename "$Image") $Xoffset $Yoffset $Degree" >> $Distortlogfile
  done
  
  return 0
}
animation() {
  # Generate animated GIF from stackshot.
  # Helps to visualize diferent layers and gives some 3D effect
  #
  # -m  Rendermode:Fusemode
  # -o  Distortion
  #
  # Rendermode     quick or smooth
  # Distortion     Distortion between lowest and highest layer.
  # Fusemode       See fuse()
  # Framerate      Framerate between frames
  # Staticlayer    Relative position of static layer that won't move. 0 means lowest layer, 1/2 means middle layer, 1 means top layer
  # Format         File format
  
  local $Batchlocal
  local $Imagelocal
  local Fusemode Fusenumber Distortion Framerate Sequence Staticlayer Format Appendfirstframe
  local Distortdir Distortimage Fusedir Destinationfilebasename Imagebasename
  local Xpos Ypos Offset Border
  local Count Iteration=0 Iterationnumber Convertline
  local Imagelistfile
  local Position Positionlist Positionnumber
  local Sequence Sequencename Sequencenumber
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  # settings
  Rendermode="${Opt1:-quick}"
  Fusemode="${Opt2:-1}"
  Distortion="${Opt3:-25}"
  Staticlayer="1/4"
  Format="${Opt9:-webm}"
  Appendfirstframe="no"
  Destinationfilebasename="${Destinationfile:-animation}"
  
  Fusenumber="$(fuse_getset "$Fusemode" -n)"

  
  # Revert image list to work from bottom to top
  Imagelist="$(tac <<< "$Imagelist")"
  
  # Position raster
  #
  # -5x-5 -5x-4 -5x-3 -5x-2 -5x-1  -5x0   -5x1  -5x2  -5x3  -5x4  -5x5
  #
  # -4x-5 -4x-4 -4x-3 -4x-2 -4x-1  -4x0   -4x1  -4x2  -4x3  -4x4  -4x5
  #
  # -3x-5 -3x-4 -3x-3 -3x-2 -3x-1  -3x0   -3x1  -3x2  -3x3  -3x4  -3x5
  #
  # -2x-5 -2x-4 -2x-3 -2x-2 -2x-1  -2x0   -2x1  -2x2  -2x3  -2x4  -2x5
  #
  # -1x-5 -1x-4 -1x-3 -1x-2 -1x-1  -1x0   -1x1  -1x2  -1x3  -1x4  -1x5
  #
  #  0x-5  0x-4  0x-3  0x-2  0x-1   0x0    0x1   0x2   0x3   0x4   0x5
  #
  #  1x-5  1x-4  1x-3  1x-2  1x-1   1x0    1x1   1x2   1x3   1x4   1x5
  #
  #  2x-5  2x-4  2x-3  2x-2  2x-1   2x0    2x1   2x2   2x3   2x4   2x5
  #
  #  3x-5  3x-4  3x-3  3x-2  3x-1   3x0    3x1   3x2   3x3   3x4   3x5
  #
  #  4x-5  4x-4  4x-3  4x-2  4x-1   4x0    4x1   4x2   4x3   4x4   4x5
  #
  #  5x-5  5x-4  5x-3  5x-2  5x-1   5x0    5x1   5x2   5x3   5x4   5x5

  case $Rendermode in
    smooth)
      Raster="3"
      Framerate="8"
      Sequencenumber="6"
                   
      Sequencename[1]="dagaz"
      Sequence[1]="0x0  -1x1 -2x2 -3x3
                  -2x3  -1x3  0x3  1x3   2x3   3x3
                   2x2   1x1  0x0 -1x-1 -2x-2 -3x-3
                  -2x-3 -1x-3 0x-3 1x-3  2x-3  3x-3
                   2x-2  1x-1"
            
      Sequencename[2]="circle_left"
      Sequence[2]="-3x0 -3x1  -2x2  -1x3  0x3  1x3  2x2  3x1  3x0 3x-1 2x-2 1x-3 0x-3 -1x-3 -2x-2 -3x-1"
            
      Sequencename[3]="circle_right"
      Sequence[3]="-3x0 -3x-1 -2x-2 -1x-3 0x-3 1x-3 2x-2 3x-1 3x0 3x1  2x2  1x3  0x3  -1x3  -2x2  -3x1"
      
      Sequencename[4]="left_right"
      Sequence[4]="-5x0  -4x0  -3x0  -2x0  -1x0   0x0    1x0   2x0   3x0   4x0   5x0
                    5x0   4x0   3x0   2x0   1x0   0x0   -1x0  -2x0  -3x0  -4x0  -5x0"
      
      Sequencename[5]="up_down"
      Sequence[5]=" 0x-5  0x-4  0x-3  0x-2  0x-1  0x0    0x1   0x2   0x3   0x4   0x5
                    0x5   0x4   0x3   0x2   0x1   0x0    0x-1  0x-2  0x-3  0x-4  0x-5"
      
      Sequencename[6]="cross"
      Sequence[6]="                               0x0    0x1   0x2   0x3   0x4
                    0x5   0x4   0x3   0x2   0x1   0x0    0x-1  0x-2  0x-3  0x-4
                    0x-5  0x-4  0x-3  0x-2  0x-1  0x0
                                                  0x0    1x0   2x0   3x0   4x0
                    5x0   4x0   3x0   2x0   1x0   0x0   -1x0  -2x0  -3x0  -4x0
                   -5x0  -4x0  -3x0  -2x0  -1x0   0x0"
      
      #disabled
      Sequencename[7]="eight_small"
      Sequence[7]="0x0  -1x0  -1x-1  0x-1  1x-1  1x0
                   0x0  -1x0  -1x1   0x1   1x1   1x0"
      
      Sequencename[8]="eight"
      Sequence[8]="0x0  -1x0  -2x0  -3x-1  -3x-2  -2x-3  -1x-3  0x-3  1x-3  2x-3  3x-2  3x-1  2x0  1x0
                   0x0  -1x0  -2x0  -3x1   -3x2   -2x3   -1x3   0x3   1x3   2x3   3x2   3x1   2x0  1x0"
            
      Sequencename[9]="knot"
      Sequence[9]="0x0 -1x0 -2x0 -3x-1 -3x-2 -2x-3 -1x-3 0x-2 0x-1
                   0x0  0x1  0x2  1x3   2x3   3x2   3x1  2x0  1x0
                   0x0 -1x0 -2x0 -3x1  -3x2  -2x3  -1x3  0x2  0x1
                   0x0  0x-1 0x-2 1x-3  2x-3  3x-2  3x-1 2x0  1x0"
  
      Sequencename[10]="knot_small"
      Sequence[10]="0x0  0x-1 -1x-1 -1x0  
                   0x0  1x0   1x1   0x1
                   0x0  0x-1  1x-1  1x0
                   0x0 -1x0  -1x1   0x1"
    ;;
    quick)
      Raster="1"
      Framerate="4"
      Sequencenumber="3"

      Sequencename[1]="eight_quick"
      Sequence[1]="0x0  -1x0  -1x-1  0x-1  1x-1  1x0
                   0x0  -1x0  -1x1   0x1   1x1   1x0"
                   
      Sequencename[2]="dagaz_quick"
      Sequence[2]="0x0  -1x-1 -1x0 -1x1 0x0 1x-1 1x0 1x1"
      
      Sequencename[3]="square_quick"
      Sequence[3]="-1x-1  -1x0  -1x1  0x1  1x1  1x0  1x-1  0x-1"
      
      #disabled
      Sequencename[4]="knot_quick"
      Sequence[4]="0x0  0x-1 -1x-1 -1x0  
                   0x0  1x0   1x1   0x1
                   0x0  0x-1  1x-1  1x0
                   0x0 -1x0  -1x1   0x1"
    ;;
  esac
  
  # calculate lost borders
  Border="$((Distortion - Distortion * $Staticlayer))"  # wrong result if Staticlayer>1/2 ?
  Cropgeometry="$((Imagewidth - Border * 2 - 1))x$((Imageheight - Border * 2 - 1))"
  
  # offset factor, distortion between neighboured layers
  Offset="$(awk "BEGIN {print $Distortion / ( $Imagenumber * $Raster ) }")"
  
  # get list of needed positions
  for Sequencecount in $(seq $Sequencenumber); do
    for Position in ${Sequence[$Sequencecount]}; do
      Positionlist="$Positionlist
$Position"
    done
  done
  Positionlist="$(grep x      <<< "$Positionlist")"
  Positionlist="$(sort -V     <<< "$Positionlist" | uniq)"
  Positionnumber="$(grep -c . <<< "$Positionlist")"
  
  Iterationnumber=$((Positionnumber*5 + Imagenumber + Sequencenumber))
  
  # Distort images
  note "animation: Distorting images"
  for Position in $Positionlist; do
    Distortdir="$Cachedir/distort.$Position"
    mkdir -p "$Distortdir"
  done
  
  Count=-$((Imagenumber * $Staticlayer))  # negative start value causes movement of lowest layer
  for Image in $Imagelist; do
    Count="$((Count +1))"
    Convertline="$Magickbin $Image -write mpr:image +delete"
    for Position in $Positionlist; do
      Distortdir="$Cachedir/distort.$Position"
      Distortimage="$Distortdir/$(basename $Image)"   
      Xpos="$(cut -dx -f1 <<< "$Position")"
      Ypos="$(cut -dx -f2 <<< "$Position")"   
      Convertline="$Convertline \( mpr:image -gravity center -crop $Cropgeometry+$(awk "BEGIN {print $Count * $Xpos * $Offset}")+$(awk "BEGIN {print $Count * $Ypos * $Offset}") -write $Distortimage \)" 
    done
    
    multicore "$Convertline null:" "$Distortimage" || Error=1
    [ "$Error" ] && break
    
    Iteration=$((Iteration + 1))
    showpercent $Iteration $Iterationnumber
  done
  multicore_wait || return 1
  [ "$Error" ] && return 1
  
  # fuse distorted images
  Showpercentfunc="$(declare -f showpercent)"
  for Position in $Positionlist; do
    Iteration=$((Iteration + 4))
    Distortdir="$Cachedir/distort.$Position"
    Distortcachedir="$Cachedir/distort.$Position/layered"
    mkdir -p $Distortcachedir
    Fusedir="$Distortdir/fused"
    mkdir -p "$Fusedir"
    Imagebasename="animation.$Position"
    case $Fusenumber in
      1)                multicore "fuse -s $Distortdir -g '*' -d $Fusedir -b $Imagebasename -1 $Fusemode -c $Distortcachedir" "" "$Imagelistmemsize" || Error=1 ;;
      *) ( showpercent() { : ; } ; fuse -s $Distortdir -g '*' -d $Fusedir -b $Imagebasename -1 $Fusemode -c $Distortcachedir ) || Error=1 ;; 
    esac
    showpercent $Iteration $Iterationnumber
    [ "$Error" ] && break
  done
  multicore_wait || return 1
  [ "$Error" ] && return 1

  # Calculate mean of fuse images (fuse set* or all)
  for Position in $Positionlist; do
    Iteration=$((Iteration + 1))
    Distortdir="$Cachedir/distort.$Position"
    Fusedir="$Distortdir/fused"
    Destinationfile="$Cachedir/animation.$Position.mean.gif"
    note "animation: Generating $(basename $Destinationfile)"
    #multicore "$Magickbin $Fusedir/* -evaluate-sequence mean -gravity center -stroke black -fill black -pointsize 24 -draw 'text 0,0 \"$Position\"' $Destinationfile" "$Destinationfile" || return 1
    #multicore "$Magickbin $Fusedir/* -evaluate-sequence mean $Destinationfile" "$Destinationfile" || return 1
    multicore "evaluate_split -s $Fusedir -1 mean -b $Destinationfile -c $Cachedir" "$Destinationfile" || Error=1
    showpercent $Iteration $Iterationnumber
    [ "$Error" ] && break
  done
  multicore_wait || return 1
  [ "$Error" ] && return 1

  # Generate videos
  for Count in $(seq $Sequencenumber); do
    Iteration=$((Iteration + 1))
    Imagelistfile="$Cachedir/imagelist.${Sequencename[$Count]}"
    :> $Imagelistfile
    Imagelist=""
    [ "$Appendfirstframe" = "yes" ] && Sequence[$Count]="${Sequence[$Count]} $(cut -d' ' -f1 <<< "${Sequence[$Count]}")"
    
    for Position in ${Sequence[$Count]}; do
      Image="$(fileglob "$Cachedir/*.$Position.mean.*")"
      echo "file '$Image'" >> "$Imagelistfile"
      Imagelist="$Imagelist $Image"
    done
    Destinationfile="$Destinationdir/$Destinationfilebasename.$Fusemode.${Sequencename[$Count]}.$Distortion.$Format"

    note "animation: Generating $(basename $Destinationfile)."
    case $Format in
      gif) multicore "gifsicle --lossy --optimize=3 --delay $((100 / $Framerate)) --loopcount=forever --output $Destinationfile $Imagelist" "$Destinationfile" || Error=1 ;;
      *)   multicore "ffmpeg -y -hide_banner -nostdin -safe 0 -r $Framerate -f concat -i $Imagelistfile -c:v libvpx-vp9 -crf 30 -b:v 0 $Destinationfile" "$Destinationfile"  || Error=1 ;;
    esac
    [ "$Error" ] && break
    showpercent $Iteration $Iterationnumber
  done
  multicore_wait || return 1
  return ${Error:-0}
}
crop() {
  # crop area of image sequence
  # -m  even|shrink|geometry|interactive
  # -o   -  |pixel |geometry|geometry
  local $Batchlocal
  local $Imagelocal
  local Newwidth Newheight Shrink
  local Rotate Rotatedir
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1

  # cache setup
  Rotatedir="$Cachedir/rotate"
  mkdir -p $Rotatedir
  
  case $Opt1 in
    even)
      Newwidth=$((Imagewidth/2))
      Newwidth=$((Newwidth*2))
      Newheight=$((Imageheight/2))
      Newheight=$((Newheight*2))
      Cropgeometry="${Newwidth}x${Newheight}+0+0"
    ;;
    shrink) 
      Shrink="$Opt2"
      Cropgeometry="$((Imagewidth - $((Shrink * 2))))x$((Imageheight - $((Shrink * 2))))+$Shrink+$Shrink"
    ;;
    geometry)
      Cropgeometry="$Opt2"
    ;;
    interactive) 
#      Image="$Cachedir/crop.min.jpg"
      Image="$Cachedir/crop.min.mpc"
      note "crop $Opt1: Generating min image"
      #$Magickbin $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence min "$Image"
      evaluate_split -s $Sourcedir -g "$Sourcefileglob" -1 min -b $Image -c $Cachedir || return 1
      Cropgeometry="$(cropgeometry_interactive "$Image" "$Cachedir" "$Opt2")"
      Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
      Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
    ;;
  esac
  
  Rotate="${Rotate:-0}"
  [ "$Cropgeometry" ] || {
    failure "crop $Opt1: crop geometry is empty"
    return 1
  }
  
  [ "$Cropgeometry" = "${Imagewidth}x${Imageheight}+0+0" ] && [ "$Rotate" = "0" ] && {
    note "crop $Opt1: Images already have desired geometry: $Cropgeometry"
    mycp "$Sourcedir/$Sourcefileglob" "$Destinationdir"
    return
  }
  
  note "crop $Opt1: Cropping images with rotation $Rotate and geometry $Cropgeometry"
  Imagecount="0"
  for Image in $Imagelist; do
    Imagecount="$((Imagecount+1))"
    Destinationfile="$Destinationdir/$(basename "$Image")"
    multicore "$Magickbin $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
  [ "$Error" ] && return 1
  Imagelist="$(fileglob "$Rotatedir/*")"
  
  historyentry "# crop geometry: $Cropgeometry rotation: $Rotate"
  return ${Error:-0}
}
cuberotate() {
  local $Batchlocal
  local $Imagelocal
  local Linecount Linenumber
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
    
  case $Opt1 in
    top|bottom) Linenumber="$Imageheight" ;;
    left|right) Linenumber="$Imagewidth" ;;
  esac
  
  case $Opt1 in
    top|bottom|left|right)
      note "cuberotate $Opt1: Splitting images into rows or columns"
      Imagecount=0
      for Image in $Imagelist; do
        Imagecount="$((Imagecount+1))"
        mkdir $Cachedir/split$Imagecount
        case $Opt1 in
          top|bottom) Cropgeometry="0x1" ;;
          left|right) Cropgeometry="1x0" ;;
        esac
        multicore "$Magickbin $Image -crop $Cropgeometry $Cachedir/split$Imagecount/line%d.mpc" || Error=1
        [ "$Error" ] && break
        showpercent $Imagecount $((Imagenumber*2))
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
      
      note "cuberotate $Opt1: Appending lines to rotated image"
      for Linecount in $(seq $Linenumber); do
        Linelist=""
        for Imagecount in $(seq $Imagenumber); do
          case $Opt1 in
            left|top)     Linelist="$Linelist $Cachedir/split$((Imagenumber-Imagecount+1))/line$((Linecount-1)).mpc" ;;
            right|bottom) Linelist="$Linelist $Cachedir/split${Imagecount}/line$((Linenumber-Linecount)).mpc" ;;
          esac
        done
        Destinationfile="$Destinationdir/cube${Opt1}$(printnum $Linecount 4).jpg"
        
        case $Opt1 in
          top|bottom) multicore "$Magickbin $Linelist -append $Destinationfile" "$Destinationfile" || Error=1 ;;
          left|right) multicore "$Magickbin $Linelist +append $Destinationfile" "$Destinationfile" || Error=1 ;;
        esac
        [ "$Error" ] && break
        showpercent $((Linenumber+Linecount)) $((Linenumber*2))
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
    ;;
    back-left|back-top|reverse-order)
      Imagecount=0
      for Image in $Imagelist; do
        Destinationfile="$(head -n $((Imagenumber - Imagecount)) <<< "$Imagelist" | tail -1)"
        Destinationfile="$(basename "$Destinationfile")"
        note "cuberotate $Opt1: Generating $Destinationfile"
        Destinationfile="$Destinationdir/$Destinationfile"
        case $Opt1 in
          reverse-order)
            multicore "cp -T    $Image       $Destinationfile" "$Destinationfile" 16 || Error=1
          ;;
          back-left)
            multicore "$Magickbin $Image -flop $Destinationfile" "$Destinationfile" || Error=1
          ;;
          back-top)
            multicore "$Magickbin $Image -flip $Destinationfile" "$Destinationfile" || Error=1
          ;;
        esac
        [ "$Error" ] && break
        Imagecount="$((Imagecount+1))"
        showpercent $Imagecount $Imagenumber
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
    ;;
    90|180|270)
      Imagecount=0
      for Image in $Imagelist; do
        Imagecount="$((Imagecount+1))"
        Destinationfile="$(basename $Image)"
        note "cuberotate $Opt1: Generating $Destinationfile"
        Destinationfile="$Destinationdir/$Destinationfile"
        multicore "$Magickbin $Image -rotate $Opt1 $Destinationfile" "$Destinationfile" || Error=1
        [ "$Error" ] && break
        showpercent $Imagecount $Imagenumber
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
    ;;
  esac
  return ${Error:-0}
}
distort() {
  # distort images.
  # -o must point to a file contaiing the distortion parameters in the form:
  #    Imagename Xoffset Yoffset Rotation
  
  local $Batchlocal
  local $Imagelocal
  local Xoffset Yoffset Degree
  local Distortfile
  local Error

  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1

  Distortfile="$Opt2"
  
  Imagecount=0
  for Image in $Imagelist; do
    Imagecount="$((Imagecount + 1))"  
    Xoffset=0
    Yoffset=0
    Degree=0
    Line="$(grep "$(basename "$Image")" "$Distortfile")"
    Xoffset="$(cut -d' ' -f2 <<< "$Line")"
    Yoffset="$(cut -d' ' -f3 <<< "$Line")"
    Degree="$(cut  -d' ' -f4 <<< "$Line")"
  
    Destinationfile="$Destinationdir/$(basename "$Image")"
    multicore "$Magickbin $Image -virtual-pixel transparent -distort SRT '0,0 1 $Degree $Xoffset,$Yoffset' $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
  return ${Error:-0}
}
evaluate() {
  local $Batchlocal
  local $Imagelocal
  local Destinationfilebasename Set Mode Showimage
  local Maxfile Minfile
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  verbose "evaluate: Source images
$Imagelist"
  
  Destinationfilebasename="$Destinationfile"
  for Mode in min mean max median; do
    case "$(basename $Sourcedir)" in
      fused)
        Destinationfile="$Destinationdir/$Destinationfilebasename.${Opt1}.${Mode}.${Imageformat}"
        [ "$Mode" = "mean" ] && Showimage="$Destinationfile"
      ;;
      prepared)
        Destinationfile="$Destinationdir/$Destinationfilebasename.${Mode}.${Imageformat}"
        [ "$Mode" = "max" ]  && Showimage="$Destinationfile"
      ;;
    esac
    [ "$Mode" = "max" ] && Maxfile="$Destinationfile"
    [ "$Mode" = "min" ] && Minfile="$Destinationfile"
    
    multicore "evaluate_split -s $Sourcedir -g '$Sourcefileglob' -1 $Mode -c $Cachedir -b $Destinationfile" "$Destinationfile" "$Imagelistmemsize" || Error=1
    [ "$Error" ] && break
  done
  multicore_wait || return 1
  
  case "$(basename $Sourcedir)" in
    prepared)
      compose -1 "$Maxfile" -2 "$Minfile" -9 "$Imageformat" -d "$Targetcomposeddir" -b "$Destinationfilebasename" || return 1
    ;;
  esac
  showimage "$Showimage"
  return ${Error:-0}
}
evaluate_split() {
  local $Batchlocal
  local $Imagelocal
  local Mode Split Splitpercent Showsplit Splitdir Part Partimage Partimagelist
  local Startzeit Dauer Restzeit Count
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Mode="${Opt1:-min}"
  Stepsize=40
  case $Destinationfile in
    "") Destinationfile="$Cachedir/$Mode.tif" ;;
    *)  [ -n "$Destinationdir" ] && Destinationfile="$Destinationdir/$Destinationfile" ;;
  esac
  Splitdir="$Cachedir/evaluate_split.$RANDOM"
  
  Split="$((Imagelistmemsize/$(freememory) +1))"
  
  case $Split in
    1) 
      $Magickbin $Imagelist -evaluate-sequence $Mode $Destinationfile || return 1
    ;;
    *)
      mkdir -p "$Splitdir"
      Startzeit="$(date +%s)"
      Splitpercent="$((100/Split))"
      Showsplit="$(printnum $(( (Split+1)/2 )) 3)"
      Count="0"
      for Image in $Imagelist; do
        Count="$((Count+1))"
        note "Splitting image $Count / $Imagenumber into $Split pieces due to low memory: $(basename $Image)"
        multicore "$Magickbin $Image -crop 100%x${Splitpercent}% $Splitdir/split%03d.$(basename $Image).tif" "$Splitdir/split${Showsplit}.$(basename $Image).tif" || Error=1
        [ "$Error" ] && break
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
        showpercent $Count $Imagenumber
      done
      multicore_wait || return 1
      [ "$Error" ] && return 1
      Startzeit="$(date +%s)"
      Count="0"
      for Part in $(seq 0 $((Split-1))) ; do
        ifcmdbreak && Error=1
        [ "$Error" ] && break
        Count="$((Count+1))"
        note "Evaluating part $((Part+1)) / $Split"
        Partimage=$Splitdir/$Mode.part$Part.tif
        nice $Magickbin $Splitdir/split$(printnum $Part 3).*.tif -evaluate-sequence $Mode $Partimage || Error=1
        Partimagelist="$Partimagelist $Partimage"
        showimage $Partimage
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Split-Part+1) / (Part+1) ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
        showpercent $Count $Split
      done
      [ "$Error" ] && return 1
      nice $Magickbin $Partimagelist -append $Destinationfile || return 1
    ;;
  esac
  return ${Error:-0}
}
fuse() {
  local $Batchlocal 
  local $Imagelocal
  local Error=
  local Line Fusecmd Fuseargs Fuseset Destinationfilebasename
  local Fusenumber Fusecount Command
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Destinationfilebasename="$Destinationfile"
  
  Fuseset="${Opt1:-set1}"
  Fusesetchoice="${Opt2:-all}"
  case "$Fusesetchoice" in
    all)
      Fusenumber="$(fuse_getset "$Fuseset" -n)"
      Fuseset="$(fuse_getset "$Fuseset")"
    ;;
    *)
      Fuseset="$Fusesetchoice"
      Fusenumber="1"
    ;;
  esac
  Fusecount=0
  while read Line; do
    ifcmdbreak   && Error=1
    [ "$Error" ] && break
    Fusecount="$((Fusecount+1))"
    Fusecmd="$(cut -d' ' -f1      <<< "$Line")"
    Fuseargs="$(cut -d' ' -s -f2- <<< "$Line")"
    case $Fusecmd in
      enfuse)
        Destinationfile="$Destinationfilebasename.$(enfuse_name $Fuseargs $Imagelist2).tif"
        note "$Destinationfile"
        Destinationfile="$Destinationdir/$Destinationfile"
        [ -e "$Destinationfile" ] && note "Already exists, skipping: $Destinationfile" && showimage "$Destinationfile" || {
          Command="enfuse --exposure-weight=0 --saturation-weight=0 --contrast-weight=1 --entropy-weight=0 --hard-mask $Fuseargs --output=$Destinationfile $Imagelist2"
          case $Fusenumber in
            1) 
              $Command || Error=1
              #Fusenumber=n 
              #multicore "$Command" "$Destinationfile" || Error=1
              showimage "$Destinationfile"
            ;;
            *) multicore "$Command" "$Destinationfile" "$Imagelistmemsize" || Error=1 ;;
          esac
        }
      ;;
      imfuse)
        Fusecmd="$Fuseargs -vV --cache=$Cachedir --basename=$Destinationdir/$Destinationfilebasename. $Imagelist2"
        Destinationfile="$(imfuse --showname $Fusecmd)"
        Fusecmd="imfuse $Fusecmd"
        note "$Destinationfile"
        [ -e "$Destinationfile" ] && note "Already exists, skipping: $(basename "$Destinationfile")" || {
          nice $Fusecmd || Error=1
          #Fusenumber=n
          #multicore -t1 "$Fusecmd" "$Destinationfile" || error "error while running imfuse"
        }
        showimage "$Destinationfile"
      ;;
    esac
    showpercent $Fusecount $Fusenumber
  done <<< "$Fuseset"
  case $Fusenumber in
    1) ;;
    *) multicore_wait || Error=1 ;;
  esac
  return ${Error:-0}
}
imageformat() {
  local $Batchlocal
  local $Imagelocal
  local Sourceformat Destinationformat
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Sourceformat="$(head -n1 <<< "$Imagelist" | rev | cut -d. -f1 | rev)"
  Sourceformat="${Sourceformat,,}"
  Destinationformat="${Opt9:-tif}"
  Destinationformat="${Destinationformat,,}"
  
  false && [ "$Sourceformat" = "$Destinationformat" ] && {
    note "imageformat(): Files already have desired image format $Destinationformat"
    cp $Imagelist $Destinationdir
    showpercent 100 100
    return 0
  }
  
  [ "$Imagenumber" = "1" ] && {
    file -i "$Imagelist" | grep -q video && {
      note "imageformat(): Splitting video into images with format $Destinationformat"
      $Magickbin $Imagelist $Destinationdir/frame%04d.$Destinationformat
      return
    }
  }
    
  note "imageformat(): Converting image format from $Sourceformat to $Destinationformat"
  for Image in $Imagelist; do
    Imagecount=$((Imagecount+1))
    showpercent $Imagecount $Imagenumber
    Destinationfile="$(rev <<< "$Image" | cut -d. -f2- | rev).$Destinationformat"
    Destinationfile="$Destinationdir/$(basename "$Destinationfile")"
    multicore "$Magickbin $Image +repage -orient topleft -quality 100% $Destinationfile" "$Destinationfile" || Error=1 
    [ "$Error" ] && break
#    case $Imageraw in
#      no)  multicore "$Magickbin $Image $Destinationfile" "$Destinationfile" || return 1 ;;
#      yes) multicore "ufraw-batch --wb=camera --black-point=auto --exposure=auto --create-id=no --out-type=$Destinationformat --out-depth=16 --output=$Destinationfile $Image" "$Destinationfile" || return 1 ;;
#    esac
  done
  multicore_wait || return 1
  return ${Error:-0}  
}
ruler() {
  local $Batchlocal
  local $Imagelocal
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Imagecount="0"
  for Image in $Imagelist; do
    Imagecount="$((Imagecount+1))"
    Destinationfile="$Destinationdir/$(basename $Image)"
    multicore "$Imgruler -m $Opt1 -t '$Opt2' -c '$Opt3' -n '$Opt4' -o $Destinationfile $Image" "$Destinationfile" || Error=1
    [ "$Error" ] && break
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
  return ${Error:-0}
}
evalstep() {

  local $Batchlocal
  local $Imagelocal
  local Error
  local Medianlist Mediancount Count
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Opt1="${Opt1:-median}"
  Opt2="${Opt2:-5}"
  
  Count=0
  Imagecount=0
  Mediancount="0"
  for Image in $Imagelist; do
    [ "$Error" ] && break
    Imagecount="$((Imagecount+1))"
    Medianlist="$Medianlist $Image"
    Count="$((Count+1))"
    { [ "$Count" = "$Opt2" ] || [ "$Imagecount" = "$Imagenumber" ] ; } && {
      Mediancount="$((Mediancount+1))"
      Destinationfile="$Destinationdir/median$(zeronumber $Mediancount 4).$Imageformat"
      multicore "$Magickbin $Medianlist -evaluate-sequence $Opt1 $Destinationfile" "$Destinationfile" || Error=1
      Count="0"
      Medianlist=""
    }
  done
  multicore_wait || return 1
  return "${Error:-0}"
}
undo() {
  local $Batchlocal
  local Undocache
  
  parse_batchoptions "$@" || return 1

  Undocache="$Cachedir/undo"
  mkdir -p "$Undocache"
  
  mymv "$Sourcedir/*"      "$Undocache"      || return 1
  mymv "$Destinationdir/*" "$Sourcedir" 
  mymv "$Undocache/*"      "$Destinationdir"
  
  myrmdir "$Undocache"
}
video() {
  # Generate video of stackshot showing focus changes
  local $Batchlocal
  local $Imagelocal
  local Imagelistfile
  local Framerate Format Framedir Frame
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1

  Opt1="${Opt1:-in_and_out}"
  Framerate="${Opt2:-10}"
  Format="${Opt9:-webm}"
  
  Destinationfile="$Destinationdir/$Destinationfile.focus.$Opt1.$Framerate.$Format"
  Framedir="$Cachedir/frames"
  mkdir -p $Framedir
  Imagelistfile="$Cachedir/imagelist"
  
  case $Opt1 in
    in) ;;
    out) Imagelist="$(tac <<< "$Imagelist")";;
    in_and_out) 
      Imagelist="$Imagelist
$(tac <<< "$Imagelist")"
      Imagenumber="$((Imagenumber*2))"
    ;;
    *)
      failure "Unknown video mode $Opt1"
      return 1
    ;;
  esac
  
  case $Format in
    gif) Imageformat="gif" ;;
  esac
  
  note "video: Preparing frames"
  Imagecount=0
  for Image in $Imagelist; do
    Imagecount="$((Imagecount+1))"
    #echo "file '$Image'" >> $Imagelistfile
    Frame="$Framedir/frame$(zeronumber $Imagecount).$Imageformat"
    case $Format in
      gif) multicore "$Magickbin $Image $Frame" "$Image" || Error=1 ;;
      *)   multicore "cp -T      $Image $Frame" "$Image" || Error=1 ;;
    esac
    [ "$Error" ] && break
    showpercent $Imagecount $Imagenumber
  done
  multicore_wait || return 1
  [ "$Error" ] && return 1
  
  note "video: Generating $Format video $Opt1"
  showpercent busy
  case $Format in
    gif) nice gifsicle --lossy --optimize=3 --delay $((100 / $Framerate)) --loopcount=forever --output $Destinationfile $(fileglob "$Framedir/*") || return 1 ;;
    *)   nice ffmpeg -y -hide_banner -nostdin  -r $Framerate -f image2 -start_number 1 -i $Framedir/frame%04d.$Imageformat $Destinationfile || return 1 ;;
  esac
  showpercent 100 100
  showimage $Destinationfile
  return ${Error:-0}
}
whitebalance() {
  # whitebalance sequence of images
  # -m  reference geometry
  # -o  reference color or "mean"
  
  local $Batchlocal
  local $Imagelocal
  local Referencecolor Referencecolorimage Meancolorimage 
  local Refred  Refgreen  Refblue
  local Meanred Meangreen Meanblue
  local Partred Partgreen Partblue
  local Error
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
    
  Opt1="${Opt1:-topleft}"
  Referencecolor="${Opt2:-#BBBBBB}"
  
  Meancolorimage="$Cachedir/meancolor.mpc"
  Referencecolorimage="$Cachedir/referencecolor.mpc"
  
  case $Opt1 in
    topleft)     Cropgeometry="10x10+5+5" ;;
    topright)    Cropgeometry="10x10+$((Imagewidth-15))+5" ;;
    bottomleft)  Cropgeometry="10x10+5+$((Imageheight-15))" ;;
    bottomright) Cropgeometry="10x10+$((Imagewidth-15))+$((Imageheight-15))" ;;
    full)        Cropgeometry="${Imagewidth}x${Imageheight}+0+0" ;;
    interactive) 
#      Image="$Cachedir/whitebalance.min.jpg"
      Image="$Cachedir/whitebalance.min.mpc"
      note "whitebalance: Generating min image"
      $Magickbin $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence min "$Image"
      evaluate_split -s $Sourcedir -g "$Sourcefileglob" -c $Cachedir -1 min $Image || return 1
      Cropgeometry="$(cropgeometry_interactive "$Image" "$Cachedir" "50x50+10+10")"  ### FIXME rotate
      Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")" 
      [ "$Cropgeometry" ] || {
        failure "whitebalance: Got no crop geometry"
        return 1
      }
    ;;
    *) Cropgeometry="$Opt1" ;;
  esac
  
  [ "$Referencecolor" = "mean" ] && {
    Image="$Cachedir/whitebalance.mean.mpc"
    note "whitebalance: Generating mean image"
    $Magickbin $(fileglob "$Sourcedir/$Sourcefileglob") -crop "$Cropgeometry" -evaluate-sequence mean "$Image"  ### FIXME might fail with large sequences
    Referencecolor=$($Magickbin "$Image" -filter box -resize 1x1! -format "%[pixel:u]" info:)
  }
  
  $Magickbin -size 1x1 xc:"$Referencecolor" $Referencecolorimage
  Refred="$($Magickbin   $Referencecolorimage -format "%[fx:255*u.p{0,0}.r]" info:)"
  Refgreen="$($Magickbin $Referencecolorimage -format "%[fx:255*u.p{0,0}.g]" info:)"
  Refblue="$($Magickbin  $Referencecolorimage -format "%[fx:255*u.p{0,0}.b]" info:)"

  historyentry "# whitebalance geometry: $Cropgeometry"

  note "whitebalance: Balancing with reference color $Referencecolor"
  Imagecount=0
  for Image in $Imagelist; do
    Imagecount="$((Imagecount + 1))"
    Destinationfile="$Destinationdir/$(basename "$Image")"
    
    $Magickbin $Image -crop $Cropgeometry -resize 1x1! "$Meancolorimage"
    
    Meanred="$($Magickbin   $Meancolorimage -format "%[fx:255*u.p{0,0}.r]" info:)"
    Meangreen="$($Magickbin $Meancolorimage -format "%[fx:255*u.p{0,0}.g]" info:)"
    Meanblue="$($Magickbin  $Meancolorimage -format "%[fx:255*u.p{0,0}.b]" info:)"
    
    [ "$Meanred"   = "0" ] && Partred=255   || Partred="$(awk   "BEGIN { print $Refred   / $Meanred }")"
    [ "$Meangreen" = "0" ] && Partgreen=255 || Partgreen="$(awk "BEGIN { print $Refgreen / $Meangreen }")"
    [ "$Meanblue"  = "0" ] && Partblue=255  || Partblue="$(awk  "BEGIN { print $Refblue  / $Meanblue }")"
    
    multicore "$Magickbin $Image -color-matrix '$Partred 0 0 0 $Partgreen 0 0 0 $Partblue' $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
  return ${Error:-0}
}
wizard() {
  # Wrapper for ImageMagick convert to work on folders
  # Args:
  #  mandatory:
  #   -m Opt1
  #   -s Sourcedir
  #   -d Destinationdir
  #  optional:
  #   -g Sourcefileglob
  #   -o Opt2
  
  local $Batchlocal
  local $Imagelocal
  local $Imagepropertieslocal
  local Options Compress
  local Startzeit Dauer Restzeit
  local Error

  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  grep -i '\.tif$' <<< "$Outputimage" && Compress="-compress zip"

  [ "$Opt2" ] || case "$Opt1" in
    brightness) Opt2="10x10" ;;
    contrast)   Opt2="3x50%" ;;
    gamma)      Opt2="auto" ;;
    level)      Opt2="auto" ;;
    orient)     Opt2="topleft" ;;
    rotate)     Opt2="90" ;;
    sharpen)    Opt2="6x2" ;;
    statistic)  Opt2="median 5" ;;
    stretch)    Opt2="auto" ;;
  esac

  [ "$Opt1" = "stretch" ] && Opt1="contrast-stretch"
  case "$Opt1" in
    level|gamma|contrast-stretch) 
      case "$Opt2" in
        auto|"") Opt1="-auto-$Opt1" ; Opt2="" ;;
        max) 
          Opt1="-contrast-stretch max"
          Opt2=""
        ;;
        *)       Opt1="-$Opt1" ;;
      esac
    ;;
    brightness)  Opt1="-brightness-contrast" ;;
    contrast)    Opt1="-sigmoidal-contrast" ;;
    sharpen)     Opt1="-adaptive-sharpen" ;;
    orient|rotate|statistic) Opt1="-$Opt1" ;;
    wizard)      Opt1="" ;;
  esac
  Options="$Opt1 $Opt2 $Opt3 +repage"
  
  [ "$Sourcedir" = "$Targetprepareddir" ] && grep -q -E "auto-gamma|auto-level|auto-contrast-stretch|contrast-stretch max" <<< "$Options" && {
    imageproperties -s "$Sourcedir" -g "$Sourcefileglob" -c "$Cachedir" || return 1
    Options="$(sed "s/-auto-gamma/-gamma $Imageautogamma/ ; 
                           s/-auto-contrast-stretch/-contrast-stretch ${Imageminlevel}x${Imagemaxlevel}/ ; 
                           s/-contrast-stretch max/-channel red -contrast-stretch ${Imageminlevelred}x${Imagemaxlevelred} -channel green -contrast-stretch ${Imageminlevelgreen}x${Imagemaxlevelgreen} -channel blue -contrast-stretch ${Imageminlevelblue}x${Imagemaxlevelblue} +channel/ ; 
                           s/-auto-level/-level ${Imageminlevel}%x${Imagemaxlevel}%/"    <<< "$Options")"
  }
  
  note "wizard: $Options"
  Startzeit="$(date +%s)"
  Imagecount=0
  for Image in $Imagelist; do
    Imagecount="$((Imagecount + 1 ))"
    Destinationfile="$Destinationdir/$(basename "$Image")"
    multicore "$Magickbin $Image $Options $Compress $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Imagecount) / Imagecount ))"
    [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
    note "wizard: Duration: $(date -u -d @$Dauer +"%T"); Estimated time left: $(date -u -d @$Restzeit +"%T") ($Restzeit)"
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
  
  return ${Error:-0}
}

#### single image operations

imageproperties() {
  local $Batchlocal
  local $Imagelocal
  local Meanimage Imageproperties
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1

  case $(wc -l <<< "$Imagelist") in
    0)
      failure "imageproperties(): No source file(s)"
      return 1 
    ;;
    1) Meanimage="$Imagelist" ;;
    *)
      note "imageproperties(): Generating mean image"
      Meanimage="$Cachedir/mean.png"
      #$Magickbin $Imagelist -evaluate-sequence mean "$Meanimage" || return 1
      evaluate_split -s $Sourcedir -g "$Sourcefileglob" -c $Cachedir -1 mean -b $Meanimage || return 1
      showimage "$Meanimage"
    ;;
  esac

  Imageproperties="$($Magickbin "$Meanimage" -format '
Imagemean=%[mean]
Imagequantumrange=%[fx:quantumrange]
Imageautogamma=%[fx:log(mean)/log(0.5)]
Imageminlevel=%[fx:minima*100]
Imagemaxlevel=%[fx:maxima*100]
Imageminlevelred=%[fx:minima.r*100]
Imagemaxlevelred=%[fx:maxima.r*100]
Imageminlevelgreen=%[fx:minima.g*100]
Imagemaxlevelgreen=%[fx:maxima.g*100]
Imageminlevelblue=%[fx:minima.b*100]
Imagemaxlevelblue=%[fx:maxima.b*100]
' info:)"

  verbose "Image properties of $Meanimage: 
$Imageproperties"
  eval $Imageproperties
}
calc_evengeometry() {
  local Geometry XY W H
  Geometry="${1:-}"
  W=$(cut -dx -f1 <<< "$Geometry")
  H=$(cut -dx -f2 <<< "$Geometry" | cut -d+ -f1)
  XY="$(cut -d+ -f2- <<< "$Geometry")"
  W=$((W/2))
  W=$((W*2))
  H=$((H/2))
  H=$((H*2))
  Geometry="${W}x${H}+${XY}"
  echo $Geometry
}
compose() {
  local $Batchlocal
  local $Imagelocal
  local Minfile Maxfile Mode
  local Destinationfilebasename
  local Count
  local Error
  
  parse_batchoptions "$@" || return 1
  
  Maxfile="${Opt1:-EMPTY}"
  Minfile="${Opt2:-EMPTY}"
  grep -q "EMPTY" <<< "$Maxfile $Minfile" && {
    failure "compose: No max/min files specified."
    return 1
  }
  Imageformat="${Opt9:-}"
  [ -z "$Imageformat" ] && Imageformat="$(get_extension "$Maxfile")"
  Destinationfilebasename="${Destinationfile:-composed}"
    
  for Mode in bumpmap colorburn linearlight modulate  overlay pegtoplight; do
    Destinationfile="$Destinationdir/$Destinationfilebasename.${Mode}1.$Imageformat"
    multicore "$Magickbin $Maxfile $Minfile -compose $Mode -composite $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
    Destinationfile="$Destinationdir/$Destinationfilebasename.${Mode}2.$Imageformat"
    multicore "$Magickbin $Minfile $Maxfile -compose $Mode -composite $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
  done
  [ "$Error" ] && return 1
  for Mode in linearburn difference multiply; do
    Destinationfile="$Destinationdir/$Destinationfilebasename.${Mode}.$Imageformat"
    multicore "$Magickbin $Maxfile $Minfile -compose $Mode -composite $Destinationfile" "$Destinationfile" || Error=1
    [ "$Error" ] && break
  done
  multicore_wait || return 1
  [ "$Error" ] && return 1
  Destinationfile="$Destinationdir/$Destinationfilebasename.composedmean.${Imageformat}"
  $Magickbin  $Destinationdir/$Destinationfilebasename.{*modulate*,*bumpmap*,*pegtoplight*,*overlay*,*difference*} -evaluate-sequence mean $Destinationfile || return 1
  showimage $Destinationfile
  return 0
}
trim_hard() {
  # Function: Trim all border with transparency from image $1
  # Results in a maximal inner rectangle without border color.
  # $1  $Image      image
  # $2  $Trimcolor  color to trim. Default: transparent
  # $3  Geometry seed value (optional)
  # $4  additional command to run on each iteration (optional, special use case for cropgeometry_interactive() )
  # Output: crop geometry
  
  local Imagemask Trimcolor Cropgeometry Addcommand
  local Sourceimage Sourceimagempc Cropgeometryimage Imagewidth Imageheight
  local Left         Right         Top         Bottom
  local Skipleft     Skipright     Skiptop     Skipbottom
  local Permilleleft Permilleright Permilletop Permillebottom Permillemax
  local Return
  local Debugmode Loopcount
  local pid1 pid2 pid3 pid4
  
  Sourceimage="${1:-}"
  Cropgeometry="${2:-}"
  Addcommand="${3:-}"
  
  Trimcolor="#00000000" # to support other colors, creating mask must be fixed FIXME
  
  # check source for mpc format, convert if not
  [ "$Sourceimage" = "${Sourceimage%.mpc}" ] && {
    Sourceimagempc="$Sourceimage.mpc"
    $Magickbin "$Sourceimage" "$Sourceimagempc"
  } || {
    Sourceimagempc="$Sourceimage"
  }
  Cropgeometryimage="$Sourceimage.trim_hard.png"
  
  # Generate alpha mask image in imagemagick memory format for fastest possible access
  Imagemask="$Sourceimage.mask.mpc"
  $Magickbin "$Sourceimagempc" -alpha extract "$Imagemask"
  
  note "trim_hard(): Searching for inner rectangle of $(basename $Sourceimage)"
  
  Imagewidth=$($Magickbin  -format '%w'  $Imagemask info:)
  Imageheight=$($Magickbin -format '%h'  $Imagemask info:)
  Left=0
  Top=0
  Right=$((Imagewidth-1))
  Bottom=$((Imageheight-1))
  
  # First cut with regular trim to save some time.
  # Add a colored border so trim uses the desired color. Afterward remove border from canvas to get correct geometry values. 
  Line="$($Magickbin "$Sourceimagempc" -bordercolor "$Trimcolor" -border 1x1  -trim -set page '%[fx:page.width-2]x%[fx:page.height-2]+%[fx:page.x-1]+%[fx:page.y-1]' info:)"
  Left="$(awk '{print $4}' <<< "$Line" | cut -d+ -f2)"
  Top="$(awk '{print $4}' <<< "$Line" | cut -d+ -f3)"
  Right="$(awk '{print $3}' <<< "$Line" | cut -dx -f1)"
  Right="$((Left+Right-1))"
  Bottom="$(awk '{print $3}' <<< "$Line" | cut -dx -f2)"
  Bottom="$((Top+Bottom-1))"
  
  [ "$Cropgeometry" ] && {
    Left=$(cut -d+ -f2 <<< "$Cropgeometry")
    Top=$(cut -d+ -f3 <<< "$Cropgeometry")
    Right=$(cut -dx -f1 <<< "$Cropgeometry")
    Right=$((Left+Right-1))
    Bottom=$(cut -dx -f2 <<< "$Cropgeometry")
    Bottom=$(cut -d+ -f1 <<< "$Bottom")
    Bottom=$((Top+Bottom-1))
  }
  
  # Workflow:
  # - Get permille amount of $Trimcolor from all sides.
  # - Remove side with greatest permille amount of $Trimcolor.
  # - Repeat check with new geometry
  while :; do
    # Get part of non-$Trimcolor at each side
    
    #Command="$Magickbin $Imagemask -write mpr:imagemask -delete 0"
    #[ "$Skipleft" ]   || Command="$Command ( mpr:imagemask -crop 1x$((Bottom-Top+1))+$Left+$Top    +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info: )"
    #[ "$Skipright" ]  || Command="$Command ( mpr:imagemask -crop 1x$((Bottom-Top+1))+$Right+$Top   +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info: )"
    #[ "$Skiptop" ]    || Command="$Command ( mpr:imagemask -crop $((Right-Left+1))x1+$Left+$Top    +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info: )"
    #[ "$Skipbottom" ] || Command="$Command ( mpr:imagemask -crop $((Right-Left+1))x1+$Left+$Bottom +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info: )"
    
    
    [ "$Skipleft" ]   || $Magickbin $Imagemask -crop 1x$((Bottom-Top+1))+$Left+$Top    +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permilleleft    & pid1=$!
    [ "$Skipright" ]  || $Magickbin $Imagemask -crop 1x$((Bottom-Top+1))+$Right+$Top   +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permilleright   & pid2=$!
    [ "$Skiptop" ]    || $Magickbin $Imagemask -crop $((Right-Left+1))x1+$Left+$Top    +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permilletop     & pid3=$!
    [ "$Skipbottom" ] || $Magickbin $Imagemask -crop $((Right-Left+1))x1+$Left+$Bottom +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permillebottom  & pid4=$!
    wait $pid1
    wait $pid2
    wait $pid3
    wait $pid4
    Permilleleft=$(  LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permilleleft)
    Permilleright=$( LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permilleright)
    Permilletop=$(   LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permilletop)
    Permillebottom=$(LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permillebottom )
    
    # Determine maximal permille value
    Permillemax=$(echo "$Permilleleft
$Permilleright
$Permilletop
$Permillebottom" | sort -n | head -n1)
    showpercent "$(awk "BEGIN {print 1000*$Permillemax}" | cut -d. -f1)" "1000"
    Cropgeometry="$((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top"
    [ "$Permillemax" = "1.0000" ] && break # Ready
    
    # Remove side with maximal permille of $Trimcolor.
    [ "$Permillemax" = "$Permilleleft" ]   && Left=$((Left+1))
    [ "$Permillemax" = "$Permilleright" ]  && Right=$((Right-1))
    [ "$Permillemax" = "$Permilletop" ]    && Top=$((Top+1))
    [ "$Permillemax" = "$Permillebottom" ] && Bottom=$((Bottom-1))
    Cropgeometry="$((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top"
    
    # Skip check for sides without $Trimcolor in future to save some time
    [ "1.0000" = "$Permilleleft" ]   && Skipleft=yes
    [ "1.0000" = "$Permilleright" ]  && Skipright=yes
    [ "1.0000" = "$Permilletop" ]    && Skiptop=yes
    [ "1.0000" = "$Permillebottom" ] && Skipbottom=yes
    
    # break signal of stackfuser
    ifcmdbreak && Return=1
    [ "$Return" = "1" ] && break

    # Out-of-range error
    { [ "$Left" -gt "$Right" ] || [ "$Top" -gt "$Bottom" ] ; } && {
#      echo "Error: Failed to find an inner rectangle. Unuseable result: $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top" >&2
      failure "trim_hard(): Failed to find an inner rectangle. Unuseable result: $Cropgeometry" 
      Return=1
      Left=0
      Top=0
      Right=$((Imagewidth-1))
      Bottom=$((Imageheight-1))
      break
    }
    
    # Debugging: show intermediate results
    Debugmode=yes
    [ "$Debugmode" ] && {
      Loopcount=$((Loopcount+1))
      [ "$Loopcount" = "10" ] && {
        Loopcount=0
        $Magickbin $Sourceimagempc -fill none -stroke red -strokewidth 1 -pointsize 18 -undercolor white -gravity center -draw "rectangle $Left,$Top $Right,$Bottom  text 0,0 '$Cropgeometry'" $Cropgeometryimage
        showimage $Cropgeometryimage
        eval "$Addcommand"
      }
    }
  done
  [ "$Return" = "1" ] && return 1

  # show result
  showpercent 100 100
  $Magickbin $Sourceimagempc -fill none -stroke red -strokewidth 1 -pointsize 18 -undercolor white -gravity center -draw "rectangle $Left,$Top $Right,$Bottom  text 0,0 '$Cropgeometry'" $Cropgeometryimage
  showimage $Cropgeometryimage
  
  # Output of result
  verbose "trim_hard(): $Cropgeometry"
  #echo "$Left,$Top $Right,$Bottom"                     # "-draw rectangle" geometry
  #echo $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top  # "-crop" geometry
  echo "$Cropgeometry"

  return ${Return:-0}
}

#### fuse helpers

fuse_glob() {
  local Name Glob= List= Printlist=
  [ "${1:-}" = "--list" ] && {
    Printlist="yes"
    shift
  }
  case "${1:-}" in
    all|'') 
      Glob="*" 
      List="$(fileglob "$Targetfuseddir/$Glob")"
    ;;
    *)
      while read Line; do
        Name="$(fuse_name "$Line")"
        Glob="${Glob},$Name"
        List="$List
$Targetfuseddir/$Name"
      done < <(fuse_getset "${1:-}")
#      done < <(cat "$Fusesetdir/${1:-}")
      Glob="{${Glob#,}}"
    ;;
  esac
  [ "$Printlist" = "yes" ] && {
    List="$(grep . <<< "$List")"
    echo "$List"
    return 0
  }
  echo "$Glob"
}
fuse_getset() {
  local Output Line Setfile Name Set
  Set="${1:-}"
  Setfile="$Fusesetdir/$Set"
  
  [ "$Set" = "enfuse-cws5" ] && {
    [ "${2:-}" = "-n" ] && echo "1"        && return 0
    echo "enfuse --contrast-window-size=5" && return 0
  }

  while read Line; do
    [ "$Line" != "${Line#"#"}" ] && Line=""
    [ -n "$Line" ] && Output="$Output
$Line"
  done < <(cat "$Setfile")
  Output="$(grep . <<< "$Output")"
  
  [ "${2:-}" = "-n" ] && grep -c . <<< "$Output" && return 0
  echo "$Output"
}
check_filelist() {
  local Path= Error=
  echo "$@"
  [ "${1:-}" = "--path" ] && Path="${2:-}" && shift && shift
  [ -n "$Path" ] && Path="$Path/"
  while [ $# -gt 0 ]; do
    [ -f "$Path${1:-}" ] || Error=1
    [ "$Error" ] && {
      verbose "File not found: $Path${1:-}"
      break
    }
    shift
  done
  return ${Error:-0}
}
fuse_name() {
  local Fusecmd Fuseargs Fusename
  Line="$(cut -d] -f2- <<< "$Line" | sed -e 's/^[ \t]*//')"
  Fusecmd="$(cut -d' ' -f1      <<< "$Line")"
  Fuseargs="$(cut -d' ' -s -f2- <<< "$Line")"
  case $Fusecmd in
    enfuse)
      Fusename="$Targetbasename.$(enfuse_name $Fuseargs $(preparedlist) ).tif"
    ;;
    imfuse)
      Fusename="$(imfuse --showname --basename="$Targetbasename." $Fuseargs $(preparedlist) )"
    ;;
  esac
  basename "$Fusename"
}
enfuse_name() {
  local Shortoptions Longoptions Parsererror Parsererrorfile
  local Name Imagelist Fusemd5sum
  local Error

  Longoptions="exposure-weight:,saturation-weight:,contrast-weight:,entropy-weight:"
  Longoptions="$Longoptions,contrast-window-size:,contrast-edge-scale:"
  
  Parsererrorfile="/tmp/imfuse.parserserror.$RANDOM"
  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@" 2>"$Parsererrorfile")"
  [ -e $Parsererrorfile ] && Parsererror="$(cat "$Parsererrorfile")" && rm "$Parsererrorfile"
  [ "$Parsererror" ] && failure "enfuse/imfuse options parsing error:
$Parsererror
in"
  eval set -- "$Parsedoptions"
  
  Name="enfuse."
  while [ $# -gt 0 ]; do
    [ "$Error" ] && break
    case "${1:-}" in
      --exposure-weight)
        [ "${2:-}" = "0" ] || [ "${2:-}" = "0.0" ] || Name="${Name}_exp${2:-}"
        shift
      ;;
      --saturation-weight)
        [ "${2:-}" = "0" ] || [ "${2:-}" = "0.0" ] || Name="${Name}_sat${2:-}"
        shift
      ;;
      --contrast-weight)
        [ "${2:-}" = "1" ] || [ "${2:-}" = "1.0" ] || Name="${Name}_cont${2:-}"
        shift
      ;;
      --entropy-weight)
        [ "${2:-}" = "0" ] || [ "${2:-}" = "0.0" ] || Name="${Name}_ent${2:-}"
        shift
      ;;
      --contrast-window-size)
        Name="${Name}_cws${2:-}"
        shift
      ;;
      --contrast-edge-scale)
        Name="${Name}_edge${2:-}"
        shift
      ;;
      --) ;;
      enfuse) ;;
      *) Imagelist="$Imagelist ${1:-}"
    esac
    shift
  done
  
  Name="$(sed 's/\._/\./' <<< "$Name")"
  
  Parsedoptions="$(sed 's/ -- .*// ; s/  */ /g '  <<< "$Parsedoptions" )"
  Fusemd5sum="$(echo "$(unspecialstring "$Parsedoptions") $(find $Imagelist -ls)" | md5sum | cut -c1-6)"

  Name="${Name}.${Fusemd5sum}"
  echo "$Name"
  return ${Error:-0}
}
preparedlist() {
  fileglob "$Targetprepareddir/*"
}

#### run commands on all CPUs

multicore() {
  # Run multiple processes in parallel, but not more than $Multicore_maxprocesses
  # $1 Command
  # $2 Image to show if $1 is finished
  # Run multicore_wait afterwards to wait for the last processes to finish.
  
  local Process Command
  local Mem_needed Zram
  
  [ "${1:-}" = "-t1" ] && {
    shift
    [ "$Multicore_processcount" -gt 0 ] && {
      multicore_wait || return 1
    }
  }
  
  [ "$Multicore_processcount" = "$Multicore_maxprocesses" ] && {
    multicore_wait || return 1
  }
  [ "$Multicore_processcount" = "0" ] && Multicore_memorymax="$(freememory)"  
  Mem_needed=0
  for Process in $(seq $Multicore_maxprocesses); do
    Mem_needed="$(awk "BEGIN {print $Mem_needed + ${Multicore_memory[$Process]:-0} }" )"
  done
  Mem_needed="$((Mem_needed+${3:-0}))"
  [ "$Mem_needed" -gt "$Multicore_memorymax" ] && {
    note "multicore: Low memory. Waiting for $Multicore_processcount running processes to finish. Need: $((Mem_needed/1000)) MB, Available: $((Multicore_memorymax/1000)) MB"
    [ "$Mem_needed" -gt "$Multicore_memorymax" ] && [ "$Multicore_processcount" = "0" ] && note "multicore: Likely hard disk cache will be used and slow down the calculation."
    multicore_wait || return 1
  }
  
  ifcmdbreak && return 1

  Multicore_processcount=$((Multicore_processcount +1))

  Command="$(cut -d ' ' -f1 <<< "${1:-}")"
  case $(type -t "$Command") in
    file) Command="nice ${1:-}" ;;
    *)    Command="${1:-}" ;;
  esac
  
  #verbose "multicore: ${1:-}"
  eval "$Command &"
  
  Multicore_process[Multicore_processcount]=$!
  Multicore_image[Multicore_processcount]="${2:-}"
  Multicore_memory[Multicore_processcount]="${3:-0}"
  
  return 0
}
multicore_wait() {
  local Process Error
  for Process in $(seq $Multicore_maxprocesses); do
    [ "${Multicore_process[$Process]}" ] && {
      multicore_waitprocess "${Multicore_process[$Process]}" || {
        multicore_break
        Error=1
      }
      [ "$Error" ] && break
      [ "${Multicore_image[$Process]}" ] && showimage "${Multicore_image[$Process]}"
    }
    Multicore_process[$Process]=""
    Multicore_image[$Process]=""
    Multicore_memory[$Process]="0"
  done
  [ "$Error" ] && return 1
  Multicore_processcount=0
  return 0
}
multicore_waitprocess() {
  local Error
  while sleep 0.2 ; do
    ps -p "${1:-}" >/dev/null || break
    ifcmdbreak && Error=1
    [ "$Error" ] && break
  done
  [ "$Error" ] && return 1
  wait "${1:-}"
  return $?
}
multicore_break() {
  local Process
  for Process in $(seq $Multicore_maxprocesses); do
    [ "${Multicore_process[$Process]}" ] && {
      verbose "multicore_break: Sending SIGINT to $(ps -p ${Multicore_process[$Process]})"
      kill "${Multicore_process[$Process]}"
      wait "${Multicore_process[$Process]}"
      Multicore_process[$Process]=""
      Multicore_image[$Process]=""
      Multicore_memory[$Process]="0"
    }
  done
}
multicore_init() {
  # declare global variables
  local Process
  Multicore_maxprocesses="$(nproc)"
  Multicore_maxprocesses="${Multicore_maxprocesses:-1}"
  for Process in $(seq $Multicore_maxprocesses); do
    Multicore_process[$Process]=""
    Multicore_image[$Process]=""
    Multicore_memory[$Process]="0"
  done
  Multicore_processcount=0
  Multicore_minram=250000
  Multicore_maxprocesses=$Multicore_maxprocesses
}

#### GUI

kaptaingrammar() {
  echo '#! /usr/bin/kaptain

start "stackfuser '$Version'"  -> frameset;
  frameset                       -> topframe bottomframe;
    topframe                       -> tabset;
    bottomframe                    -> dirframe statusframe ;
    
  dirframe:beside                    -> choosedirguibutton choosedir refreshbutton;
    choosedirguibutton                 -> @button="Stackshot selector" ;
    choosedir                          -> @directory="'$Projecthome'" ;
    refreshbutton                      -> @button="refresh" ;
  statusframe                        -> wizardstatusline ;
    wizardstatusline:beside            -> cmdpercent wizardlog;
      cmdpercent                         -> @icon ;
      wizardlog                          -> @text="" ;

  tabset:tabbed                     -> batchtab specialtab deletetab configtab showresulttab;
    batchtab "Image batch processing" -> batchoptionframe ;
      batchoptionframe:beside            -> batchframeleft  batchframeright;
        batchframeleft:framed              -> batchblock1 batchblock2 ;
        batchframeright:framed             -> batchblock3 runbatchframe stopframe;
          
      batchblock1 "batch block 1: crop and balance directory prepared" -> imageformatline cropline align_vidstabline align_huginline align_aisline align_focusstackline;
        imageformatline:beside                                -> imageformat imageformatopt9combo imageformatprepared imageformatfused imageformatevaluated;
          imageformatopt9combo                                  -> @combow('$Imageformatcombo')="TIF" ;
          imageformatprepared                                     -> @button="prepared" ;
          imageformatevaluated                                   -> @button="evaluated" ;
          imageformatfused                                       -> @button="fused" ;
          imageformat:beside          "change image format"     -> "on" | ! "" ;
        orientline:beside                                     -> orient orientopt1combo orientprepared;
          orientopt1combo                                       -> @combo("topleft","topright","bottomleft","bottomright")="topleft" ;
          orientprepared                                          -> @button="prepared" ;
          orient:beside               "orient (fixate image exif rotation)" -> "on" | "";
        cropline:beside                                       -> crop cropopt1combo cropopt2combo cropprepared cropfused cropevaluated;
          cropopt1combo                                         -> @combo("interactive","shrink","even","geometry")="interactive" ;
          cropopt2combo                                         -> @combow("","1","2","5","10","200x200+15+15")="" ;
          cropprepared                                            -> @button="prepared" ;
          cropevaluated                                          -> @button="evaluated" ;
          cropfused                                              -> @button="fused" ;
          crop:beside                 "crop"                    -> "on" | ! "";
        align_focusstackline:beside                             -> align_focusstack align_focusstackbutton ;
          align_focusstackbutton                                  -> @button="prepared" ;
          align_focusstack:beside     "align with focus-stack"    -> "on" | ! "";
        align_vidstabline:beside                              -> align_vidstab align_vidstabopt1combo align_vidstabopt2combo align_vidstabopt3combo align_vidstabbutton ;
          align_vidstabopt1combo                                -> @combo("distort_only","common_area","crop","crop_interactive")="crop";
          align_vidstabopt2combo:beside   "Iterations:"         -> @combo("1","2","3")="3";
          align_vidstabopt3combo:beside   "prepare"             -> "prepare" | ! "" ;
          align_vidstabbutton                                   -> @button="prepared" ;
          align_vidstab:beside        "align with vidstab/ffmpeg"    -> "on" | ! "";
        align_huginline:beside                                  -> align_hugin align_huginbutton ;
          align_huginbutton                                      -> @button="prepared" ;
          align_hugin:beside          "align with hugin"         -> "on" | ! "";
        align_aisline:beside                                  -> align_ais align_aisopt1combo align_aisopt2combo align_aisbutton ;
          align_aisopt1combo          "demagnifier (-m)"        -> "m"  | ! "";
          align_aisopt2combo          "crop interactive"        -> "interactive" | ! "";
          align_aisbutton                                       -> @button="prepared" ;
          align_ais:beside            "align with align_image_stack" -> "on" | "";
      
      batchblock2 "batch block 2: imageprepared operations on directory prepared" -> rotateline gammaline levelline contrastline sharpenline brightnessline stretchline statisticline wizardline;
        rotateline:beside                                     -> rotate rotateopt1combo rotateprepared rotatefused rotateevaluated;
          rotateopt1combo                                       -> @combo("90","180","270")="90" ;
          rotateprepared                                          -> @button="prepared" ;
          rotateevaluated                                        -> @button="evaluated" ;
          rotatefused                                            -> @button="fused" ;
          rotate:beside               "rotate"                  -> "on"  | ! "";
        gammaline:beside                                      -> gamma gammaprepared gammafused gammaevaluated;
          gammaopt1combo                                        -> @combow("auto","0.2","0.3","0.4","0.454545","0.5","0.6","0.7","0.8","0.9","1.2","1.5","2.0","3.0","4.0")="auto" ;
          gammaprepared                                           -> @button="prepared" ;
          gammaevaluated                                         -> @button="evaluated" ;
          gammafused                                             -> @button="fused" ;
          gamma:beside                "gamma"                   -> gammaopt1combo | "";
        levelline:beside                                      -> level levelprepared levelfused levelevaluated;
          levelopt1combo                                        -> @combow("auto","5%","10%","15%","20%","25%","30%")="auto" ;
          levelprepared                                           -> @button="prepared" ;
          levelevaluated                                         -> @button="evaluated" ;
          levelfused                                             -> @button="fused" ;
          level:beside                "level"                   -> levelopt1combo | ! "";
        contrastline:beside                                   -> contrast contrastprepared contrastfused contrastevaluated;
          contrastopt1combo                                     -> @combow("2x50%","3x50%","4x50%","5x50%","3x30%","3x70%")="5x50%" ;
          contrastprepared                                        -> @button="prepared" ;
          contrastevaluated                                      -> @button="evaluated" ;
          contrastfused                                          -> @button="fused" ;
          contrast:beside             "sigmoidal-contrast"      -> contrastopt1combo | "";
        sharpenline:beside                                    -> sharpen sharpenprepared sharpenfused sharpenevaluated;
          sharpenopt1combo                                      -> @combow("3x1","6x2","8x4","12x6")="8x4" ;
          sharpenprepared                                         -> @button="prepared" ;
          sharpenevaluated                                       -> @button="evaluated" ;
          sharpenfused                                           -> @button="fused" ;
          sharpen:beside              "adaptive-sharpen"        -> sharpenopt1combo | "";
        statisticline:beside                                  -> statistic statisticopt1combo statisticopt2combo statisticprepared statisticfused statisticevaluated;
          statisticopt1combo                                    -> @combow("gradient","maximum","minimum","mean","median","mode","nonpeak","rms","standarddeviation")="median" ;
          statisticopt2combo                                    -> @combow("1","2","3","4","5","6","7","8","9","10")="5" ;
          statisticprepared                                       -> @button="prepared" ;
          statisticevaluated                                     -> @button="evaluated" ;
          statisticfused                                         -> @button="fused" ;
          statistic:beside            "statistic"               -> "on" | ! "";
        brightnessline:beside                                 -> brightness brightnessprepared brightnessfused brightnessevaluated;
          brightnessopt1combo                                   -> @combow("0x5","0x10","0x15","5x0","5x5","5x10","5x15","10x0","10x5","10x10","15x15","20x20")="10x10" ;
          brightnessprepared                                      -> @button="prepared" ;
          brightnessevaluated                                    -> @button="evaluated" ;
          brightnessfused                                        -> @button="fused" ;
          brightness:beside           "brightness-contrast"     -> brightnessopt1combo | ! "";
        stretchline:beside                                    -> stretch stretchprepared stretchfused stretchevaluated;
          stretchopt1combo                                      -> @combow("auto","2%x1%","1%","2%","3%","4%","5%","10%","15%","20%","max")="max" ;
          stretchprepared                                         -> @button="prepared" ;
          stretchevaluated                                       -> @button="evaluated" ;
          stretchfused                                           -> @button="fused" ;
          stretch:beside              "stretch-contrast"        -> stretchopt1combo | ! "";
        wizardline:beside                                     -> wizard wizardprepared wizardfused wizardevaluated;
          wizardopt1combo                                       -> @combow("","-adaptive-blur 6x2","-canny 3","-charcoal 3","-colorspace Gray","-despeckle","-edge 0","-enhance","-equalize","-evaluate cos 0.5","-flip","-flop","-implode 1","-kuwahara 2.0","-magnify","-modulate 90,110","-negate","-sepia-tone 100%","-wavelet-denoise 5%x0.1")="" ;
          wizardprepared                                          -> @button="prepared" ;
          wizardevaluated                                        -> @button="evaluated" ;
          wizardfused                                            -> @button="fused" ;
          wizard:beside               "(free option typing)"    -> wizardopt1combo | ! "" ;
        
      batchblock3 "batch block 3: combine stackshot images" -> evaluateline1 fuseline evaluateline2 deletebackups2 deleteprepared2;
        evaluateline1:beside                                  -> evaluate1 evaluateprepared ;
          evaluateprepared                                        -> @button="prepared" ;
          evaluate1:beside            "evaluate"                -> "on" | "";
        fuseline                                              -> fuseline1 fuseopt2combo;
          fuseline1:beside                                    -> fuse fuseopt1combo fuseprepared;
          fuseopt1combo                                         -> @combo('$Fusesetcombo')="enfuse-cws5" ;
          fuseopt2combo                                         -> @combo("-") ;
          fuseprepared                                            -> @button="prepared";
          fuse:beside                    "fuse"                 -> "on" | "" ;
        evaluateline2:beside                                  -> evaluate2 evaluateopt1combo evaluatefused;
          evaluateopt1combo                                     -> @combo("all",'$Fusesetcombo');
          evaluatefused                                          -> @button="fused" ;
          evaluate2:beside            "evaluate"                -> "on" | ! "";
        deletebackups2:beside         "delete"                -> @button="backups + cache" "on" | "";
        deleteprepared2:beside          "delete"                -> @button="prepared" "on"          | ! "";

      runbatchframe "Batch processing"                      -> batchblockline batchallline;
        batchblockline                                        -> runbatchone runbatchtwo runbatchthree;
          runbatchone:beside          "batch block 1"           -> "batchblock1" | "" @button="run";
          runbatchtwo:beside          "batch block 2"           -> "batchblock2" | "" @button="run";
          runbatchthree:beside        "batch block 3"           -> "batchblock3" | "" @button="run";
        batchallline:beside -> runbatchprocessing ;
          runbatchprocessing                                    -> @button="Run selected batch blocks";
      
      stopframe "Stop actions"                                -> stopline;
        stopline                                                -> cmdbreak killviewnior;
          cmdbreak                                                -> @button="stop current batch" ;
          killviewnior                                            -> @action("killall viewnior ffplay")="killall viewnior ffplay";
                
    specialtab:framed "Special operations" -> specialframe @fill undoframe;
      specialframe "Special operations" -> videoline animationline cuberotateline whitebalanceline fakehdrline evalstepline rulerline ;
        rulerline:beside                                      -> ruler rulerprepared rulerfused rulerevaluated;
          ruleropt1combo                                        -> @combo('$Imgrulermodecombo')="100z" ;
          ruleropt2combo:beside       "Title:"                  -> @string ;
          ruleropt3combo:beside       "Color:"                  -> @combo("black","white","red","green","blue")="black" ;
          ruleropt4combo:beside       "Elements:"               -> @combow("10","20","30","40","50","60","70","80","90","100","")="" ;
          rulerprepared                                           -> @button="prepared" ;
          rulerevaluated                                         -> @button="evaluated" ;
          rulerfused                                             -> @button="fused" ;
          ruler:beside                "ruler"                 -> "" ruleropt1combo ruleropt2combo ruleropt3combo ruleropt4combo;
        animationline:beside                                  -> animation animationopt1combo animationopt2combo animationopt3combo animationopt9combo animationprepared;
          animationopt1combo:beside                             -> @combo("quick","smooth")="smooth";
          animationopt2combo:beside   "fuse:"                   -> @combow('$Fusesetcombo');
          animationopt3combo:beside   "Distortion:"             -> @combow("15","20","25","30","40","50","75","100","150")="30";
          animationopt9combo:beside   "Format:"                 -> @combow("webm","mp4","gif")="webm";
          animationprepared                                       -> @button="prepared" ;
          animation:beside            "animated video"          -> "" ;
        videoline:beside                                      -> video videoopt1combo videoopt2combo videoopt9combo videoprepared;
          videoopt1combo:beside                                 -> @combo("in","out","in_and_out")="in_and_out";
          videoopt2combo:beside       "Framerate:"              -> @combow("2","3","4","5","7","10","15","20","25","30")="10";
          videoopt9combo:beside       "Format:"                 -> @combow("webm","mp4","gif")="webm";
          videoprepared                                           -> @button="prepared" ;
          video:beside                "focus video"             -> "" ;
        cuberotateline:beside                                 -> cuberotate cuberotateopt1combo cuberotateprepared;
          cuberotateopt1combo:beside                            -> @combo("90","180","270","reverse-order","back-left","back-top","left","right","top","bottom")="reverse-order";
          cuberotateprepared                                      -> @button="prepared" ;
          cuberotate:beside           "cuberotate"              -> "" ;
        meanbalanceline:beside                                -> meanbalance meanbalanceopt1combo meanbalanceprepared meanbalancefused meanbalanceevaluated;
          meanbalanceopt1combo                                  -> @combo("interactive","topleft","topright","bottomleft","bottomright","full")="full" ;
          meanbalanceprepared                                     -> @button="prepared" ;
          meanbalanceevaluated                                   -> @button="evaluated" ;
          meanbalancefused                                       -> @button="fused" ;
          meanbalance:beside          "meanbalance"             -> "";
        whitebalanceline:beside                               -> whitebalance whitebalanceopt1combo whitebalanceopt2combo whitebalanceprepared whitebalancefused whitebalanceevaluated;
          whitebalanceopt1combo                                 -> @combo("interactive","topleft","topright","bottomleft","bottomright","full")="topleft" ;
          whitebalanceopt2combo                                 -> @combow("mean","#777777","#888888","#999999","#AAAAAA","#BBBBBB","#CCCCCC","#DDDDDD","#EEEEEE","#FFFFFF")="#CCCCCC" ;
          whitebalanceprepared                                    -> @button="prepared" ;
          whitebalanceevaluated                                  -> @button="evaluated" ;
          whitebalancefused                                      -> @button="fused" ;
          whitebalance:beside         "whitebalance"            ->  "";
        fakehdrline:beside                               -> fakehdr fakehdropt1combo fakehdropt2combo fakehdrprepared fakehdrfused fakehdrevaluated;
          fakehdropt1combo                                 -> @combo("brightness","gamma","level","levelgamma","modulate","multiply")="levelgamma" ;
          fakehdropt2combo                                 -> @combo("10%","20%","30%","40%","50%","60%","70%","80%")="40%" ;
          fakehdrprepared                                    -> @button="prepared" ;
          fakehdrevaluated                                  -> @button="evaluated" ;
          fakehdrfused                                      -> @button="fused" ;
          fakehdr:beside         "fakehdr"            -> "" ;
        evalstepline:beside                                   -> evalstep evalstepopt1combo evalstepopt2combo evalstepprepared;
          evalstepopt1combo                                     -> @combow("max","min","mean","median")="median" ;
          evalstepopt2combo                                     -> @combow("3","5","7","9","15","25")="5" ;
          evalstepprepared                                        -> @button="prepared" ;
          evalstep:beside             "Evaluate blocks of N images" -> "";
          
      undoframe                       "undo"                -> undoline;
        undoline:beside                                       -> undo undoprepared undofused undoevaluated;
          undoprepared                                            -> @button="prepared" ;
          undoevaluated                                          -> @button="evaluated" ;
          undofused                                              -> @button="fused" ;
          undo                        "undo last step"          -> "" ;
          
    deletetab:framed                  "Delete"               -> deletedirframe deletefusedframe deleterescursiveframe @fill;
      deletedirframe                  "Delete directories of current stack"   -> deletebuttons; 
        deletebuttons:beside                                   -> deletebackups deleteprepared deleteevaluated deletecomposed deletefused deletevideo deleteall deleteallbutvideo;
          deletebackups                                          -> @button="backups + cache";
          deleteevaluated                                         -> @button="evaluated";
          deleteprepared                                           -> @button="prepared";
          deletecomposed                                          -> @button="composed";
          deletefused                                             -> @button="fused";
          deletevideo                                            -> @button="video";
          deleteall                                              -> @button="all";
          deleteallbutvideo                                      -> @button="all but video";
      deletefusedframe                 "Delete fused results (beta)"      -> deletefusedline;
        deletefusedline:beside                                      -> deletefusedsetcombo deletefusedsetbutton deletefusedchoicecombo deletefusedchoicebutton;
          deletefusedsetcombo:beside                                  -> @combo('$Fusesetcombo');
          deletefusedsetbutton                                        -> @button="delete all fused results+evaluated" ;
          deletefusedchoicecombo                                      -> @combo("-");
          deletefusedchoicebutton                                     -> @button="delete fused result" ;
      deleterescursiveframe           "Delete recursively"     -> recursivedeletedir recursivedeletecache;
        recursivedeletedir            "Base directory for recursive deletion" -> @directory="'$Projecthome'" ;
        recursivedeletecache                                       -> @button="Recursively delete all cache and backup directories" ;
        recursivedeleteprepared                                      -> @button="Recursively delete all prepared directories" ;
          
    configtab                         "Configuration"        -> configframe;
      configframe                                              -> storagebasedirtext storagebasedir allownonconformant gallerydir @fill;
        storagebasedirtext                                     -> @text="stackfuser expects a directory structure like the one created by stackshooter. \n\
Basically an otherwise empty parent directory should contain a folder literally called \"stackshot\" that contains the source images.\n\
You can define the storage base dir where all those parent directories are stored. \n\
This is especially useful for the \"stackshot selector\" button you can see at the left bottom.\n\
The directory structure is:\n\
  [storage base dir]\n\
                  [projectname]\n\
                               [stackname]\n\
                                          stackshot\n\
                                                   img001.jpg\n\
                                                   img002.jpg\n\
                                                   ...\n\
                               [stackname2]\n\
                                          stackshot\n\
                                                   img001.jpg\n\
                                                   img002.jpg\n\
                                                   ...\n\
                  [stackname_without_project_above]\n\
                               stackshot\n\
                                        img001.jpg\n\
                                        img002.jpg\n\
                                        ...\n\
" ;
        storagebasedir:beside         "Storage base dir:"                                                                       -> @directory="'$(storeinfo dump projecthome)'";
        allownonconformant:beside     "Allow stackshots outside of Storage base dir and without directory \"stackshot\"."       -> "yes" | '$( [ "$(storeinfo dump allow_dir_invalid)" = "no" ] && echo "!")' "no" ;
        gallerydir:beside             "Gallery directory where one result of each stackshot in the storage base dir is shown:"  -> @directory="'$(storeinfo dump gallerydir)'";

    showresulttab:framed              "Show results"     -> showevaluatedframe showsetframe showcomposedframe showdirframe showvideoframe;
      
      showevaluatedframe               "Evaluate results"         ->  showevaluatedfusedline showevaluatedpreparedline;
        showevaluatedfusedline:beside                                -> showevaluatedfusedmax showevaluatedfusedmin showevaluatedfusedmean showevaluatedfusedmedian ;
          showevaluatedfusedmax                                        -> @button="fused.max" ;
          showevaluatedfusedmin                                        -> @button="fused.min" ;
          showevaluatedfusedmean                                       -> @button="fused.mean" ;
          showevaluatedfusedmedian                                     -> @button="fused.median" ;
        showevaluatedpreparedline:beside                              -> showevaluatedpreparedmax showevaluatedpreparedmin showevaluatedpreparedmean showevaluatedpreparedmedian ;
          showevaluatedpreparedmax                                      -> @button="prepared.max" ;
          showevaluatedpreparedmin                                      -> @button="prepared.min" ;
          showevaluatedpreparedmean                                     -> @button="prepared.mean" ;
          showevaluatedpreparedmedian                                   -> @button="prepared.median" ;
          
      showsetframe                    "Fuse set results"         -> showsetline;
        showsetline:beside                                         -> showfusesetcombo showfusedresults showfusesetevaluated;
          showfusesetcombo:beside     "Fuse set"                     -> @combo("all",'$Fusesetcombo');
          showfusedresults                                            -> @button="Fuse results";
          showfusesetevaluated:beside  "Evaluate results:"            -> showfusesetbuttonmean showfusesetbuttonmedian showfusesetbuttonmin showfusesetbuttonmax showfusesetbuttonall;
            showfusesetbuttonmean                                      -> @button="mean";
            showfusesetbuttonmedian                                    -> @button="median";
            showfusesetbuttonmin                                       -> @button="min";
            showfusesetbuttonmax                                       -> @button="max";
            showfusesetbuttonall                                       -> @button="all";
      '
       
  echo '  showcomposedframe      "Composed max+min results" -> showcomposedline1 showcomposedline2;'
  echo '    showcomposedline1:beside                          -> '
  for Mode in $Composemodes1; do
    echo -n " showcomposed_${Mode} "
  done
  echo ';'
  echo '   showcomposedline2:beside                           -> '
  for Mode in $Composemodes2; do
    echo -n " showcomposed_${Mode} "
  done
  echo ';'
  for Mode in $Composemodes; do
    echo " showcomposed_${Mode}                                 -> @button='${Mode}' ;"
  done
        
  echo '
    showdirvideoframe:beside                              -> showdirframe showvideoframe;
      showdirframe                   "Directories"          -> showdirline ;
        showdirline:beside                                    -> showdirfm showdirstackshot showdirprepared showdircomposed showdirfused showdirevaluated ;
          showdirfm                                             -> @button="File Manager";
          showdirstackshot                                      -> @button="stackshot";
          showdirprepared                                         -> @button="prepared";
          showdirfused                                           -> @button="fused";
          showdircomposed                                        -> @button="composed";
          showdirevaluated                                       -> @button="evaluated";
      showvideoframe                 "Videos"               -> show_video;
        show_video:beside                                     -> @combo("--------------------------------------------------");
  '
}
sendkaptain() {
  # send messages to kaptain over its stdin
#  note "Send to kaptain: $1"
  #testvar pidkaptain && echo "$1" >&${Kaptainstdin}
  #testvar pidkaptain || return 1
  echo "${1:-}" >>${Kaptainstdinfile}
}
askkaptain() {
  # ask kaptain for value of $1
  local Wait Answer
  
  #testvar pidkaptain || return 1
  #gui_main_grammar | grep -q "${1:-}" || return 1

  [ "${1:-}" = "-c" ] && {
    # check if entry if present at all
    shift
    kaptaingrammar | grep -q "${1:-}" || return 1
  }
  :> $Kaptainanswerfile
  
  storeinfo "askkaptain=yes"
  
  sendkaptain "${1:-}?"
  for Wait in $(seq 15); do
    milisleep $Wait
    Answer="$(cat "$Kaptainanswerfile")"
    [ -n "$Answer" ] && echo "$Answer" && break
  done
  
  :> $Kaptainanswerfile
  
  storeinfo drop askkaptain
  
  [ -z "$Answer" ] && return 1
  return 0
}
pipekaptain() {
  # provide script for interactive kaptain option --pipe
  # Needs containing variables to be set beforehand.
  echo  "#! /bin/bash
$(declare -f storepid)
Storepidfile='$Storepidfile'
tail -f ${Kaptainstdinfile} & Tailpid=\$!
storepid \$Tailpid
cat >> ${Kaptainstdoutfile}
kill \$Tailpid
" >$Kaptainpipefile
  chmod +x $Kaptainpipefile
}

## GUI helpers

kaptain_update() {
  local Stackdir Cmdstatus
  local Line Shortcut Comboline Mode Set Count Choice
  
  Stackdir="$(storeinfo dump stackshotdir)"
  setup_targetdirnames "$Stackdir"

  # update working directory
  sendkaptain "choosedir='$Stackdir'"
  
  Set="$(askkaptain fuseopt1combo)"
  Choice="$(askkaptain fuseopt2combo)"
  Comboline=""
  Count=0
  while read Line; do
    #Line="$(cut -d'#' -f1 <<< "$Line" | grep .)"
    [ "$Line" ] && Comboline="$Comboline,'$Line'" && Count="$((Count+1))"
  done < <(fuse_getset "$Set")
  case $Count in
    0) Comboline="'-'" ;;
    1) Comboline="${Comboline#,}" ;;
    *) Comboline="'all'${Comboline}" ;;
  esac
  sendkaptain "fuseopt2combo($Comboline)='$Choice'"
  
  
  # show directory buttons
  [ -d "$Targetstackshotdir" ]                      && sendkaptain "showdirstackshot='stackshot'"       || sendkaptain "showdirstackshot='-'"
  [ -d "$Targetprepareddir" ]                         && sendkaptain "showdirprepared='prepared'"             || sendkaptain "showdirprepared='-'"
  [ -d "$Targetevaluateddir" ]                       && sendkaptain "showdirevaluated='evaluated'"         || sendkaptain "showdirevaluated='-'"
  [ -d "$Targetcomposeddir" ]                        && sendkaptain "showdircomposed='composed'"           || sendkaptain "showdircomposed='-'"
  [ -d "$Targetfuseddir" ]                           && sendkaptain "showdirfused='fused'"                 || sendkaptain "showdirfused='-'"
  
  # show delete buttons
  check_dirglob "$Stackdir/*.bak $Stackdir/cache" ] && sendkaptain "deletebackups='backups + cache'"    || sendkaptain "deletebackups='-'"
  [ -d "$Targetprepareddir" ]                && sendkaptain "deleteprepared='prepared'"              || sendkaptain "deleteprepared='-'"
  [ -d "$Targetevaluateddir" ]              && sendkaptain "deleteevaluated='evaluated'"          || sendkaptain "deleteevaluated='-'"
  [ -d "$Targetcomposeddir" ]               && sendkaptain "deletecomposed='composed'"            || sendkaptain "deletecomposed='-'"
  [ -d "$Targetfuseddir" ]                  && sendkaptain "deletefused='fused'"                  || sendkaptain "deletefused='-'"
  [ -d "$Targetvideodir" ]                 && sendkaptain "deletevideo='video'"                || sendkaptain "deletevideo='-'"
  
  # videos
  Comboline=""
  for Line in $(fileglob "$Targetvideodir/*.mp4") $(fileglob "$Targetvideodir/*.gif") $(fileglob "$Targetvideodir/*.webm"); do
    Shortcut="$(rev <<< "$Line" | cut -d. -f1-4 | rev)"
    Comboline="$Comboline,'$Shortcut'"
  done
  Comboline="${Comboline#,}"
  [ -z "$Comboline" ] && Comboline="'-'"
  sendkaptain "show_video($Comboline)=''"
  
  # evaluated results
  for Mode in max min mean median; do
    check_fileglob "$Targetevaluateddir/*.fused*.${Mode}.*"   && sendkaptain "showevaluatedfused${Mode}='fused.${Mode}'"     || sendkaptain "showevaluatedfused${Mode}='-'" 
    check_fileglob "$Targetevaluateddir/*.prepared.${Mode}.*"  && sendkaptain "showevaluatedprepared${Mode}='prepared.${Mode}'" || sendkaptain "showevaluatedprepared${Mode}='-'" 
  done
  
  # fuse sets
  Comboline=""
  for Line in $(fileglob "$Targetevaluateddir/*fused.*.mean.tif"); do
    Line="$(basename "$Line")"
    Line="${Line#$Targetbasename.fused.}"
    Line="${Line%.mean.tif}"
    Comboline="$Comboline,'$Line'"
  done
  Comboline="${Comboline#,}"
  [ -z "$Comboline" ] && Comboline="'-'"
  sendkaptain "showfusesetcombo($Comboline)=''"
  # fuse set delete
  Set="$(askkaptain deletefusesetcombo)"
  Comboline="${Comboline#"'all',"}"
  sendkaptain "deletefusesetcombo($Comboline)='$Set'"
  Comboline=""
  Count=0
  while read Line; do
    #[ "$Line" ] && [ -e "$Targetfuseddir/$(fuse_name "$Line")" ] && {
      Comboline="$Comboline,'$Line'"
      Count="$((Count+1))"
    #}
  done < <(fuse_getset "$Set")
  case $Count in
    0) Comboline="'-'" ;;
    1) Comboline="${Comboline#,}" ;;
    *) Comboline="'all'${Comboline}" ;;
  esac
  sendkaptain "deletefusechoicecombo($Comboline)='$Choice'"
  
  
  # composed results
  for Mode in $Composemodes; do
    check_fileglob "$Targetcomposeddir/*.${Mode}.*" && sendkaptain "showcomposed_${Mode}='${Mode}'" || sendkaptain "showcomposed_${Mode}='-'"
  done
  
  Cmdstatus="$(storeinfo dump status)"
  case $Cmdstatus in
    error|idle) showpercent $Cmdstatus ;;
  esac
  
  # update preview
  kaptain_update_preview
}
kaptain_update_preview() {
  local Stackdir Currentimage Image Cachedir Imagelist Imagenumber
  
  Stackdir="$(storeinfo dump stackshotdir)"

  # check if currently in valid dir, otherwise clear display
  check_stackdir "$Stackdir" || {
    storeinfo drop showimage
    showimage notfound
    return 0
  }
  
  # check if an image of current stackdir is shown
  Currentimage="$(storeinfo dump showimage)"
  grep -q "$Stackdir" <<< "$Currentimage" && [ -e "$Currentimage" ] && showimage "$Currentimage" && return 0
  
  # check for a result to show
  Image="$(fileglob "$Stackdir/evaluated/*fused.median.*" | grep 'set2\.' | head -n1)"
  [ -e "$Image" ] && showimage "$Image" && return 0
  
  Image="$(fileglob "$Stackdir/evaluated/*.fused.*.mean.*" | head -n1)"
  [ -e "$Image" ] && showimage "$Image" && return 0
  
  Image="$(fileglob "$Stackdir/*.fused.*.mean.*" | head -n1)"
  [ -e "$Image" ] && showimage "$Image" && return 0
  
  Image="$(fileglob "$Stackdir/*.fused.median.*" | head -n1)"
  [ -e "$Image" ] && showimage "$Image" && return 0
  
  Image="$(fileglob "$Stackdir/evaluated/*prepared.max*")"
  [ -e "$Image" ] && showimage "$Image" && return 0

  Imagelist="$(fileglob "$Stackdir/prepared/*")"
  [ "$Imagelist" ] && {
    Imagenumber="$(grep -c . <<< "$Imagelist")"
    Image="$(head -n$((Imagenumber/2)) <<< "$Imagelist" | tail -n1)"
    showimage "$Image"
    return 0
  }
  
  Imagelist="$(fileglob "$Stackdir/stackshot/*")"
  [ "$Imagelist" ] && {
    Imagenumber="$(grep -c . <<< "$Imagelist")"
    Image="$(head -n$((Imagenumber/2)) <<< "$Imagelist" | tail -n1)"
    showimage "$Image"
    return 0
  }
  
  Imagelist="$(fileglob "$Stackdir/*")"
  [ "$Imagelist" ] && {
    Imagenumber="$(grep -c . <<< "$Imagelist")"
    Image="$(head -n$((Imagenumber/2)) <<< "$Imagelist" | tail -n1)"
    showimage "$Image"
    return 0
  }
  return 1
}
showpercent() {
  local Percent Part Full Percentimage
  
  Percentimage="$Maincachedir/percent.png"
  Part="${1:-}"
  Full="${2:-1}"
  
  case "$Part" in
    idle) Percentimage="p_idle.png" ;;
    busy) Percentimage="p_busy.png" ;;
    error) Percentimage="p_error.png" ;;
    *)
      Percent="$(( 100 * Part / Full ))"
      Percentimage="p_$Percent.png" 
    ;;
  esac
  Percentimage="$Percentcachedir/$Percentimage"

  [ -e "$Percentimage" ] || case "$Part" in
    idle)  $Magickbin -size 100x20 xc:transparent -fill black  -pointsize 20 -gravity center -draw "text 0,0 'idle'"     "$Percentimage" ;;
    busy)  $Magickbin -size 100x20 xc:transparent -fill green1 -pointsize 20 -gravity center -draw "text 0,0 '* BUSY *'" "$Percentimage" ;;
    error) $Magickbin -size 100x20 xc:transparent -fill red    -pointsize 20 -gravity center -draw "text 0,0 'ERROR'"    "$Percentimage" ;;
    *)     $Magickbin -size 100x20 xc:transparent -fill green1 -draw "rectangle 0,0,$((Percent * 1)),20" -fill black -pointsize 20 -gravity center -draw "text 0,0 '${Percent}%'" "$Percentimage" ;;
  esac
  sendkaptain "cmdpercent('$Percentimage')=''"
}

## sub GUIs

stackshot_selector() {
  # GUI to choose stackshot. Preview of median images. Sorted by project dirs.
  local Button Argument
  local Dirlist Imagelist Dirarray
  local Allprojects Entrylist Projectimages Projectline
  local Projecthome Projectdir Oldprojectdir Cachedir
  local Count Dircount Dir Image
  local Refresh 
  local Windowwidth Windowheight Windowxpos Windowypos
  
  Cachedir="$(storeinfo dump cache)"
  mkdir -p "$Thumbnaildir"

  Projecthome="$(storeinfo dump projecthome)"
  Projecthome="${1:-$Projecthome}"
  cd "$Projecthome"
  
  # check for running instance, raise window if yes
  storeinfo test stackshot_selector && {
    note "stackshot_selector is already running."
    xdotool search --name "stackshot selector" windowraise
    return 0
  }
  storeinfo "stackshot_selector=running"
  
  # generate empty X image for unfused stackshots
  Emptyimage=$Thumbnaildir/empty.png
  [ -e "$Emptyimage" ] || $Magickbin caption:X $Emptyimage
  
  # get list of stackshot dirs and median images
  Dirlist="$(find -name stackshot -type d | sed s%/stackshot%% | sort -V)"
  for Dir in $Dirlist; do
    Image="$(find $Dir/*fused.*.mean* $Dir/evaluated/*fused.*.mean* $Dir/*fused.median* 2>/dev/null | grep -v "layered" |head -n1)"
    [ -z "$Image" ] && {
      find $Dir/stackshot/* | grep -i -v -E "mov|mp4|mpeg|layered" > $Cachedir/list
      #Image="$(split -n 2/2 $Cachedir/list | head -n2 | tail -n1)"
      #verbose "$Dir XX $Image"
      Image="$(head -n1 < "$Cachedir/list")"
    }
    Imagelist="$Imagelist
$Image"
  done
  Imagelist="$(tail -n+2 <<< "$Imagelist")"
  Dircount="$(grep -c . <<< "$Dirlist")"

  Count=0
  for Dir in $Dirlist EOL ; do
    Count=$((Count +1))
    showpercent "$Count" "$Dircount"
    Dirarray[$Count]="$Projecthome/$(cut -d/ -f2- <<< "$Dir")"
    
    ifterminating && break
    
    # generate thumbnail. Check existing thumbnail with md5
    Image="$(sed "${Count}q;d" <<< "$Imagelist")"
    Image="${Image:-$Emptyimage}"
    #Md5="$(md5sum "$Image" | cut -d' ' -f1)"
    Md5="$(md5sum <<< "$(ls --full-time "$Image")" | cut -d' ' -f1)"
    Destinationfile=$Thumbnaildir/$(basename "$Image").$Md5.png
    #[ -e "$Destinationfile" ] || $Magickbin "$Image" -resize 256x256 "$Destinationfile"
    [ -e "$Destinationfile" ] || {
      $Magickbin "$Image" -scale 256x256 "$Destinationfile"
      ### FIXME delete old thumbnail
    }
    
    # Check current project dir
    Projectdir="$(dirname $Dir)"

    # Checking a project dir is ready
    [ "$Projectdir" != "$Oldprojectdir" ] && {
      [ "$Projectline" ] && {
        # montage of all stackshot images in a project dir
        #Projectimages="$(sort <<< "$Projectimages")"
        Md5="$(cat $Projectimages | md5sum | cut -d' ' -f1)"
        Montagefile="$Thumbnaildir/$(basename $Projectdir).$Md5.png"
        [ -e "$Montagefile" ] || montage $Projectimages -tile x1 -geometry 100x100+5+5 $Montagefile
        
        # entry of subtree: montageimage + pjoject directory. Childs are stackshots.        
        Projectline="project$Count:tree '{$Montagefile}$Oldprojectdir' -> $Projectline"
        Allprojects="$Allprojects project$Count"
        Entrylist="$Entrylist
$Projectline ;"
      }
      
      [ "$Dir" = "EOL" ] && break
      
      Oldprojectdir="$Projectdir"
      Projectline=""
      Projectimages=""
      Montagefile=""
    }
    
    # add stackshot to subtree list
    Projectline="$Projectline stackshot$Count"
    
    # add stackshot
    Entrylist="$Entrylist
  stackshot$Count:beside '{$Destinationfile}$Dir' -> @button='Choose this stackshot';"
  
    # add image to montage list
    Projectimages="$Projectimages
$Image"
  done
  showpercent idle
  ifterminating && return 1
 
  # prepare kaptain
  local Kaptainpid Kaptainsignal Kaptainstdinfile Kaptainstdoutfile Kaptainanswerfile Kaptainpipefile Kaptaingrammarfile
  Kaptaingrammarfile="$Cachedir/gui_selector.kaptain.grammar"
  Kaptainstdinfile="$Cachedir/gui_selector.kaptain.stdin"
  Kaptainstdoutfile="$Cachedir/gui_selector.kaptain.stdout"
  Kaptainanswerfile="$Cachedir/gui_selector.kaptain.reply"
  Kaptainpipefile="$Cachedir/gui_selector.kaptain.pipe.sh"
  
  echo "#! /usr/bin/kaptain
start 'stackfuser stackshot selector' -> frame1 frame2;
  frame1:tree -> $Allprojects ;
$Entrylist
  frame2:beside -> refresh windowpos close ;
    refresh     -> @button='Reload GUI' ;
    windowpos   -> @button='Reset window geometry' ;
    close       -> @button='Close' ;

" > $Kaptaingrammarfile

  pipekaptain
  :>     "$Kaptainstdinfile"
  :>     "$Kaptainstdoutfile"
  tail -f "$Kaptainstdoutfile" >> $Kaptainanswerfile & storepid $!
  kaptain --pipe $Kaptainpipefile $Kaptaingrammarfile & Kaptainpid=$!
  storepid $Kaptainpid
  
  #for Count in $(seq 50); do
  #  read -t1 Line
  #  [ -z "$Line" ] && break
  #done < <(tail -f "$Kaptainstdoutfile")
    
  while ps -p $Kaptainpid >/dev/null; do
    read -t1 Kaptainsignal
    ifterminating && break
    [ "$Kaptainsignal" ] && {
      echo $Kaptainsignal
      Button="$(cut -d: -f1 <<< "$Kaptainsignal")"
      Argument="$(cut -s -d: -f2- <<< "$Kaptainsignal")"
      case $Button in
        stackshot*)
          Count="${Button#stackshot}"
          Dir="${Dirarray[$Count]}"
          storeinfo "stackshotdir=$Dir"
          check_stackdir
          storeinfo "refreshgui_main=yes"
          storeinfo "refreshgui_fuse=yes"
        ;;
        windowpos)
          # check width of main window
          Windowgeometry="$(xdotool search --name "stackfuser $Version" getwindowgeometry)"
          Windowwidth="$(grep  Geometry <<< "$Windowgeometry" | rev | cut -d' ' -f1 | rev | cut -dx -f1)"
          Windowheight="$(grep Geometry <<< "$Windowgeometry"  | rev | cut -d' ' -f1 | rev | cut -dx -f2)"
          Windowxpos="$(grep   Position <<< "$Windowgeometry"| cut -d: -f2 | cut -d' ' -f2 | cut -d, -f1)"
          Windowypos="$(grep   Position <<< "$Windowgeometry"| cut -d: -f2 | cut -d' ' -f2 | cut -d, -f2)"
          xdotool search --sync --name "stackshot selector" windowsize $Windowwidth $Windowheight windowmove $Windowxpos $Windowypos
        ;;
        close) 
          break 
        ;;
        refresh) 
          Refresh="yes" 
          break
        ;;
      esac
    }
  done < <(tail -f "$Kaptainstdoutfile")
  
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
  rm $Cachedir/gui_selector.*
  
  storeinfo drop stackshot_selector
  [ "$Refresh" = "yes" ] && stackshot_selector
}
cropgeometry_interactive() {
  # Interactive dialog to choose a crop geometry
  #   $1   Image to crop.
  #   $2   Cache folder to store files. Clean up yourself.
  #   $3   Preset crop geometry (optional). Default: entire image
  # Result:
  #   return 0 : echo crop geometry WxH+X+Y
  #   return 1 : no output
  # Dependencies:
  #   imagemagick
  #   kaptain (https://github.com/mviereck/kaptain)

  local Kaptainpid Kaptainsignal Kaptainstdinfile Kaptainstdoutfile Kaptainanswerfile Kaptainpipefile Kaptaingrammarfile
  local Image Imagempc Imagewidth Imageheight
  local CropX CropY CropW CropH Cropgeometry
  local Rotate
  local Refresh Stepsize Return
  local Cachedir Cropgeometryimage Cropimagempc

  Image="${1:-}"
  Cachedir="${2:-}"
  Cropgeometry="${3:-}"
  
  checkvar -e crop_interactive Image    "$Image"    || return 1
  checkvar -d crop_interactive Cachedir "$Cachedir" || return 1
  
  verbose "Interactive choice of crop geometry of $Image"
  
  Cropgeometryimage="$Cachedir/cropgeometry.gui.tif"
  Cropimagempc="$Cachedir/crop.mpc"
  
  # check source for mpc format, convert if not
  [ "$Image" = "${Image%.mpc}" ] && {
    Imagempc="$Cachedir/cropgeometry.source.mpc"
    $Magickbin "$Image" "$Imagempc"
  } || {
    Imagempc="$Image"
  }
  
  Stepsize=50
  Rotate=0
  Refresh="yes"

  Imagewidth=$($Magickbin  -format '%w'  $Imagempc info:)
  Imageheight=$($Magickbin -format '%h'  $Imagempc info:)
    
  grep -q "x" <<< "$Cropgeometry" && grep -q "+" <<< "$Cropgeometry" && {
    CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
    CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
    CropW=$(cut -dx -f1 <<< "$Cropgeometry")
    CropH=$(cut -dx -f2 <<< "$Cropgeometry")
    CropH=$(cut -d+ -f1 <<< "$CropH")
  } || {
    CropX=0
    CropY=0
    CropW=$((Imagewidth-1))
    CropH=$((Imageheight-1))
  }
  
  Kaptaingrammarfile="$Cachedir/gui_crop.kaptain.grammar"
  Kaptainstdinfile="$Cachedir/gui_crop.kaptain.stdin"
  Kaptainstdoutfile="$Cachedir/gui_crop.kaptain.stdout"
  Kaptainanswerfile="$Cachedir/gui_crop.kaptain.reply"
  Kaptainpipefile="$Cachedir/gui_crop.kaptain.pipe.sh"
  
  echo "#! /usr/bin/kaptain
start 'Choose geometry' -> frameset ;
  frameset:beside -> frameleft ;
    frameleft:framed  -> arrowline stepsizeframe rotateline geometryline buttonline cmdpercent;
    
  cmdpercent    -> @icon;
  
  arrowline:beside:framed -> arrowposframe arrowsizeframe ;
    arrowposframe 'Position:' -> arrowpos1 arrowpos2 arrowpos3;
      arrowpos1:beside -> @fill   postop    @fill;
      arrowpos2:beside -> posleft @fill     posright ;
      arrowpos3:beside -> @fill   posbottom @fill;
        posleft          -> @button=' < ';
        posright         -> @button=' > ';
        postop           -> @button=' ^ ';
        posbottom        -> @button=' v ';
    arrowsizeframe 'Size:' -> size1 size2 size3;
      size1:beside     -> @fill    sizetop    @fill;
      size2:beside     -> sizeleft @fill      sizeright ;
      size3:beside     -> @fill    sizebottom @fill;
        sizeleft         -> @button=' < ';
        sizeright        -> @button=' > ';
        sizetop          -> @button=' ^ ';
        sizebottom       -> @button=' v ';
    rotateline:beside 'Rotate:'  -> rotatecombo rotateapply trim;
      rotatecombo       -> @combow('0','0.5','-0.5','1','-1','1.5','-1.5','2','-2','2.5','-2.5','3','-3','5','-5','10','-10','45','-45','90','180','270')='0';
      rotateapply       -> @button='apply';
      trim              -> @button='trim';
  stepsizeframe 'Step size' -> stepsize1 stepsize2;
  stepsize1:beside  -> ss1  ss2   ss5   ss10  ss25 ;
  stepsize2:beside  -> ss50 ss100 ss250 ss500 ss1000 ;
    ss1           -> @button='1';
    ss2           -> @button='2';
    ss5           -> @button='5';
    ss10          -> @button='10';
    ss25          -> @button='25';
    ss50          -> @button='50';
    ss100         -> @button='100';
    ss250         -> @button='250';
    ss500         -> @button='500';
    ss1000        -> @button='1000';
  geometryline:beside -> geometry geometryapply;
    geometry:beside  'Crop geometry:'      -> @string='$Cropgeometry';
    geometryapply                          -> @button='apply';
  buttonline:beside -> ok cancel ;
    ok                                     -> @button=' OK' ;
    cancel                                 -> @close='Cancel';
" >> $Kaptaingrammarfile

  pipekaptain
  :>     "$Kaptainstdinfile"
  :>     "$Kaptainstdoutfile"
  tail -f "$Kaptainstdoutfile" >> $Kaptainanswerfile & storepid $!
  kaptain --pipe $Kaptainpipefile $Kaptaingrammarfile & Kaptainpid=$!
  storepid $Kaptainpid
  
  Refresh="yes"
  while ps -p $Kaptainpid >/dev/null; do

    [ "$Refresh" = "yes" ] && {
      Cropgeometry="${CropW}x${CropH}+$CropX+$CropY"
      showpercent 10 100
      $Magickbin $Imagempc -background '#00000000' -rotate $Rotate +repage -fill none -stroke red -strokewidth 1 -draw "rectangle $CropX,$CropY $((CropX+CropW-1)),$((CropY+CropH-1))" "$Cropgeometryimage"
      showpercent 60 100
      showimage "$Cropgeometryimage"
      #echo "geometry='$Cropgeometry'" >&${Kaptainstdin}
      sendkaptain "geometry='$Cropgeometry'"
      Refresh="no"
      showpercent 100 100
    }

    Imagewidth=$($Magickbin  -format '%w'  $Cropgeometryimage info:)
    Imageheight=$($Magickbin -format '%h'  $Cropgeometryimage info:)
    
    read -t1 Kaptainsignal
    
    ifcmdbreak && Return=1 && break
    
    [ "$Kaptainsignal" ] && {
      Kaptainsignal="${Kaptainsignal%:pressed}"
      case $Kaptainsignal in
        posleft)    CropX=$((CropX-$Stepsize)) ;;
        posright)   CropX=$((CropX+$Stepsize)) ;;
        postop)     CropY=$((CropY-$Stepsize)) ;;
        posbottom)  CropY=$((CropY+$Stepsize)) ;;
        sizeleft)   CropW=$((CropW-$Stepsize)) ;;
        sizeright)  CropW=$((CropW+$Stepsize)) ;;
        sizetop)    CropH=$((CropH-$Stepsize)) ;;
        sizebottom) CropH=$((CropH+$Stepsize)) ;;
        ss*)        Stepsize="$(cut -c3- <<< "$Kaptainsignal")" ;;
        rotatecombo*) Rotate="$(cut -d: -f2 <<< "$Kaptainsignal")" ;;
        rotateapply) 
          #echo "rotatecombo?" >&${Kaptainstdin}
          #read Rotate <&${Kaptainstdout}
          Rotate="$(askkaptain rotatecombo)"
        ;;
        geometryapply)
          #echo "geometry?" >&${Kaptainstdin}
          #read Cropgeometry <&${Kaptainstdout}
          Cropgeometry="$(askkaptain geometry)"
          [ "$Cropgeometry" ] && {
            CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
            CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
            CropW=$(cut -dx -f1 <<< "$Cropgeometry")
            CropH=$(cut -dx -f2 <<< "$Cropgeometry")
            CropH=$(cut -d+ -f1 <<< "$CropH")
          }
        ;;
        trim)
          $Magickbin "$Imagempc" -background '#00000000' -rotate $Rotate +repage "$Cropimagempc"
          Cropgeometry="$(trim_hard "$Cropimagempc" "$Cropgeometry" )"
          [ "$Cropgeometry" ] && {
            CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
            CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
            CropW=$(cut -dx -f1 <<< "$Cropgeometry")
            CropH=$(cut -dx -f2 <<< "$Cropgeometry")
            CropH=$(cut -d+ -f1 <<< "$CropH")
          }
        ;;
        ok)         Return=0; break ;;
      esac
      
      [ "$CropX" -lt "0" ] && CropX=0
      [ "$CropY" -lt "0" ] && CropY=0
      [ "$CropW" -lt "1" ] && CropW=1
      [ "$CropH" -lt "1" ] && CropH=1
      [ "$CropX" -gt "$Imagewidth" ]  && CropX=$Imagewidth
      [ "$CropY" -gt "$Imageheight" ] && CropY=$Imageheight
      [ "$((CropX+CropW-1))" -gt "$Imagewidth" ]  && CropW=$((Imagewidth-CropX))
      [ "$((CropY+CropH-1))" -gt "$Imageheight" ] && CropH=$((Imageheight-CropY))
      
      case $Kaptainsignal in
        ss*) Refresh="no" ;;
        *)   Refresh="yes" ;;
      esac
    }
  done < <(tail -f "$Kaptainstdoutfile")
          
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
  rm $Cachedir/gui_crop.*
  
  [ "$Return" = "0" ] && {
    [ "$Rotate" = "0" ] && echo "$Cropgeometry" || echo "$Cropgeometry:$Rotate"
    return 0
  }
  return 1
}

#### headquarter

parse_kaptainsignal() {
  local Kaptainsignal Kaptainsignalsuffix
  local $Batchlocal
  local Command Argument Stackdir Newstackdir Projecthome
  local Image Dir
  
  Kaptainsignal="${1:-}"
  Kaptainsignalsuffix="$(cut -d: -f2 <<< "$Kaptainsignal")"
  Kaptainsignal="$(cut       -d: -f1 <<< "$Kaptainsignal")"
  #Kaptainsignal="$(tr -d "[:digit:]" <<< "$Kaptainsignal")"
  Kaptainsignal="${Kaptainsignal%button}"
  Stackdir="$(storeinfo dump stackshotdir)"
  Projecthome="$(storeinfo dump projecthome)"
  
  case $Kaptainsignalsuffix in
    on|off)
      case $Kaptainsignal in
        allownonconformant)
          case $Kaptainsignalsuffix in
            on)  storeinfo "allow_dir_invalid=yes" ;;
            off) storeinfo "allow_dir_invalid=no" ;;
          esac
        ;;
      esac
      return 0
    ;;
  esac
  
  case $Kaptainsignal in
    refresh) 
      #kaptain_update
      note "Refreshing GUI and preview"
      storeinfo drop showimage
      storeinfo "refreshgui_main=yes"
    ;;
    fuseopt1combo|deletefusesetcombo)
      storeinfo "refreshgui_main=yes"    
    ;;
    cmdbreak)
      note "Sending BREAK to current action"
      multicore_break
      storeinfo "cmdbreak=yes"
    ;;
    choosedirgui)
      stackshot_selector &
    ;;
    delete*) 
      cmd -f $(tr -d ":" <<< "$Kaptainsignal") -t "$Stackdir"
    ;;
    recursivedeletecache)
      Dir="$(askkaptain recursivedeletedir)"
      [ -d "$Dir" ] && {
        rmrecursive cache "$Dir"
        rmrecursive bak "$Dir"
      } || failure "Base dir not valid: $Dir"
    ;;
    recursivedeleteprepared)
      Dir="$(askkaptain recursivedeletedir)"
      [ -d "$Dir" ] && {
        rmrecursive prepared "$Dir"
      } || failure "Base dir not valid: $Dir"
    ;;
    showevaluatedfused*)
      Image="${Kaptainsignal#showevaluatedfused}"
      Image="$(fileglob "$Stackdir/evaluated/*.fused*.$Image.*")"
      showimage "$Image"
    ;;
    showevaluatedprepared*)
      Image="${Kaptainsignal#showevaluatedprepared}"
      Image="$(fileglob "$Stackdir/evaluated/*.prepared.$Image.*")"
      showimage "$Image"
    ;;
    showcomposed_*)
      Image="${Kaptainsignal#showcomposed_}"
      Image="$Stackdir/composed/*.$Image.*"
      showimage "$Image"
      showimage "$(fileglob "$Image" | grep 'prepared' | head -n1)"
      #showimage "$(fileglob "$Image")"
    ;;
    show_video*)
      Image="$Kaptainsignalsuffix"
      Image="$Stackdir/video/*.$Image*"
      showimage "$(fileglob "$Image")"
    ;;
    showdirfm)
      xdg-open "${Stackdir:-$Projecthome}" &
    ;;
    showdir*)
      showimage "$Stackdir/${Kaptainsignal#showdir}/*"
    ;;
    showfusesetbutton*)
      Line="$(askkaptain "showfusesetcombo")"
      Mode="${Kaptainsignal#showfusesetbutton}"
      case $Mode in
        all) showimage "$Stackdir/evaluated/*.$Line.*" ;;
        *) showimage "$Stackdir/evaluated/*.$Line.$Mode.*" ;;
      esac
    ;;
    showfusedresults)
      Line="$(askkaptain "showfusesetcombo")"
      setup_targetdirnames "$Stackdir"
      showimage $(fuse_glob --list "$Line")
    ;;
    
    *prepared|*composed|*evaluated|*fused|evaluateprepared|align_vidstab|align_ais|align_hugin|align_focusstack)
      Command="$Kaptainsignal"
      Command="${Command%evaluated}"
      Command="${Command%fused}"
      Command="${Command%prepared}"
      [ -z "$Command" ] && Command="$Kaptainsignal"
      getfunctionsettings $Command
      Command="${Command%_}"
      cmd -f "$Kaptainsignal" -1 "$Opt1" -2 "$Opt2" -3 "$Opt3" -4 "$Opt4" -5 "$Opt5" -6 "$Opt6" -7 "$Opt7" -8 "$Opt8" -9 "$Opt9"  -t "$Stackdir"
    ;;
    
    runbatchone) 
      runbatchone "$Stackdir"
      cmd -f notify -1 "Batch 1 is ready."
    ;;
    runbatchtwo) 
      runbatchtwo "$Stackdir"
      cmd -f notify -1 "Batch 2 is ready."
    ;;
    runbatchthree) 
      runbatchthree "$Stackdir"
      cmd -f notify -1 "Batch 3 is ready."
    ;;
    runbatchprocessing)
      askkaptain "runbatchone" >/dev/null   && runbatchone "$Stackdir"
      askkaptain "runbatchtwo" >/dev/null   && runbatchtwo "$Stackdir"
      askkaptain "runbatchthree" >/dev/null && runbatchthree "$Stackdir"
      cmd -f notify -1 "Batch all is ready."
    ;;
    *)
      verbose "Unknown signal: $Kaptainsignal"
    ;;
  esac
}
cmd() {
  local Arg Command
  for Arg in "$@"; do
    Command="$Command '$Arg'"
  done
  echo "$Command" >> $Commandstackfile
}
ifcmdbreak() {
  ifterminating           && return 0
  storeinfo test cmdbreak && return 0 || return 1
}
stack_cmd() {
  local Command Commandpid Return
  trap terminate SIGINT

  while :; do
    read -t1 Command
   
    ifcmdbreak && {
      [ "$Command" ] || storeinfo drop cmdbreak
      Command=""
    }
    ifterminating && break
    [ "$Command" ] && {
      eval set -- $Command 
      
      #sendkaptain "wizardcmd=' $*'"
      showpercent busy
      storeinfo "status=work"
      
      parse_cmd "$@"
      Return=$?
      
      case $Return in
        0)
          storeinfo "status=idle"
          showpercent idle
          #sendkaptain "wizardcmd=''"
        ;;
        *)
          storeinfo "status=error"
          showpercent error
          storeinfo "cmdbreak=yes"
        ;;
      esac
    }
  done < <(tail -f $Commandstackfile)
}
parse_cmd() {
  local $Batchlocal
  local Commandline Return= 

  verbose "parse_cmd(): $*"
  parse_batchoptions "$@" || return 1
  Commandline="$@"
  setup_targetdirnames "$Targetdir"
  
  Function="$(tr -d "[:digit:]" <<< "$Function")" 
    
  case "$Function" in
    deleteall)         myrmdir "$Targetcachedir" "$Targetdir"/*.bak "$Targetprepareddir" "$Targetcomposeddir" "$Targetevaluateddir" "$Targetfuseddir" "$Targetvideodir" ; Return=0 ;;
    deleteallbutvideo) myrmdir "$Targetcachedir" "$Targetdir"/*.bak "$Targetprepareddir" "$Targetcomposeddir" "$Targetevaluateddir" "$Targetfuseddir"                   ; Return=0 ;;
    deletebackups)     myrmdir "$Targetcachedir" "$Targetdir"/*.bak ; Return=0 ;;
    deletefuseset)   
      Set="$(askkaptain "deletefusesetcombo")"
      rm -v $(fuse_glob --list "$Set") 
      rm -v $Stackdir/evaluated/*.$Set.*
    ;;
    deletefusechoice)
      Set="$(askkaptain "deletefusesetcombo")"
      Line="$(askkaptain "deletefusechoicecombo")"
      case $Line in
        all) rm -v $(fuse_glob --list "$Set") ;;
        *)   rm -v $Targetfuseddir/$(fuse_name "$Line") ;;
      esac
    ;;
    delete*)           myrmdir "$Targetdir/${Function#delete}" "$Targetdir/${Function#delete}.bak" ; Return=0 ;;
   
    align*|animation*|brightness*|compose*|contrast*|crop*|cuberotate*|evaluate*|imageformat*|gamma*|level*|fakehdr*|orient*|prepare*|rotate*|sharpen*|statistic*|evalstep*|stretch*|undo*|whitebalance*|ruler*|video*|wizard*)
      Function="${Function%prepared}"
      batch_function -f $Function -1 "$Opt1" -2 "$Opt2" -3 "$Opt3" -4 "$Opt4" -5 "$Opt5" -6 "$Opt6" -7 "$Opt7" -8 "$Opt8" -9 "$Opt9" -g "$Sourcefileglob" -t "$Targetdir"
      Return=$?
    ;;
    fuse*)
      Function="${Function%prepared}"
      batch_function -f $Function -1 "$Opt1" -2 "$Opt2" -3 "$Opt3" -4 "$Opt4" -5 "$Opt5" -6 "$Opt6" -7 "$Opt7" -8 "$Opt8" -9 "$Opt9" -g "$Sourcefileglob" -t "$Targetdir"
      Return=$?
      [ "$Return" = "0" ] && [ "${Opt2}" = "all" ] && {
        batch_function -f evaluatefused -1 "$Opt1" -t "$Targetdir"
        Return=$?
      }
    ;;
    note)
      note "$Opt1"
      Return=0
    ;;
    notify)
      notify "$Opt1"
      Return=0
    ;;
    showimage)
      showimage "$Sourcedir/$Sourcefileglob"
      Return=0
    ;;
    *)
      failure "parse_cmd(): Unknown function: $Function"
    ;;
  esac
 
  storeinfo "refreshgui_main=yes"

  case $Return in
    0) 
      historyentry "$Commandline"
      return 0
    ;;
    *) return ${Return:-1} ;;
  esac
}

#### main

declare_variables() {

  Cachebasedir="$HOME/.cache/stackshots"
  Maincachedir="$Cachebasedir/stackfuser"
  Percentcachedir="$Cachebasedir/percent"
  Thumbnaildir="$Cachebasedir/thumbnails"
  Magickcachedir="$Maincachedir/imagemagick.cache"
  export MAGICK_TMPDIR="$Magickcachedir"
  
  Configdir="$HOME/.config/stackshots"
  
  Fusesetdir="$Configdir/fusesets"
  [ -e "$Fusesetdir" ] || Fusesetdir="$(dirname $0)/fusesets"
  Fusesetcombo=""
  while read Line; do
    Fusesetcombo="$Fusesetcombo,'$(basename "$Line")'"
  done < <(find $Fusesetdir/* -type f)
  #Fusesetcombo="${Fusesetcombo#,}"
  Fusesetcombo="'enfuse-cws5'$Fusesetcombo"
  
  Projecthome="$HOME/Bilder/stackshots"
  Gallerydir="$HOME/Gallery"
  
  Batchlocal="Targetdir Sourcedir Sourcefileglob Destinationdir Destinationfile Cachedir Function Opt1 Opt2 Opt3 Opt4 Opt5 Opt6 Opt7 Opt8 Opt9"
  Imagelocal="Image Imagelist Imagelist2 Imagewidth Imageheight Imageformat Imagememsize Imagelistmemsize Imagecount Imagenumber Imageraw Cropgeometry Extension"
  Imagepropertieslocal="Imagemean Imagequantumrange Imageautogamma Imageminlevel Imagemaxlevel Imageminlevelred Imagemaxlevelred Imageminlevelgreen Imagemaxlevelgreen Imageminlevelblue Imagemaxlevelblue"

  #Magickbin="nice convert -quality 100%"
  command -v convert             >/dev/null && Magickbin=convert
  command -v magick              >/dev/null && Magickbin=magick
  #command -v convert-im6.q16     >/dev/null && Magickbin=convert-im6.q16
  #command -v convert-im6.q16hdri >/dev/null && Magickbin=convert-im6.q16hdri
  Magickversion="$($Magickbin -version)"
  grep -q " Q8 "   <<< "$Magickversion" && Magickpixelmemory="4"
  grep -q " Q16 "  <<< "$Magickversion" && Magickpixelmemory="8"
  grep -q " HDRI " <<< "$Magickversion" && Magickpixelmemory="16"


  Commandstackfile=$Maincachedir/command.stack
  Wizardlogfile=$Maincachedir/stackfuser.log
  Wizardmessagefile=$Maincachedir/stackfuser.message.log
  
  Storeinfofile=$Configdir/stackfuser.cfg
  Storepidfile=$Maincachedir/store.pid
    
  Imgruler="$(command -v imgruler)"
  Imgrulermodes=
  Imgrulermodecombo=
  [ -z "$Imgruler" ] && Imgruler="$(dirname $0)/imgruler"
  Imgrulermodes="$(source $Imgruler >/dev/null ; declare -f imgruler_calibrated | grep -v ";" | grep -v "()" | grep ")" | tr -d ") " )"
  for Line in $Imgrulermodes; do
    Imgrulermodecombo="$Imgrulermodecombo,'$Line'"
  done
  Imgrulermodecombo="${Imgrulermodecombo#,}"
  
  Imageformatlist="$($Magickbin -list format | grep " rw" | grep -v -i "video" | cut -c1-9 | tr -d ' ')
TIF"
  Imageformatlist="$(sort <<< "$Imageformatlist")"
  for Line in $Imageformatlist; do
    Imageformatcombo="$Imageformatcombo,'$Line'"
  done
  Imageformatcombo="${Imageformatcombo#,}"
  
  Composemodes1="bumpmap1 colorburn1 linearlight1 modulate1 overlay1 pegtoplight1 difference linearburn"
  Composemodes2="bumpmap2 colorburn2 linearlight2 modulate2 overlay2 pegtoplight2 multiply   composedmean"
  Composemodes="$Composemodes1 $Composemodes2"
  
  Imfusecfg=""
  Imfusecfgnumber=""
}
create_cachefiles() {
  mkdir -p $Maincachedir
  mkdir -p $Thumbnaildir
  mkdir -p $Percentcachedir
  mkdir -p $Configdir
  mkdir -p $Magickcachedir
  
  touch    $Storeinfofile
  
  :>       $Wizardlogfile
  :>       $Commandstackfile
  :>       $Storepidfile
  
  #touch    $Enfuseconfigfile
}
check_dependencies() {
  local Dependency
  for Dependency in kaptain convert enfuse ffmpeg geeqie ufraw-batch viewnior align_image_stack $Imgruler; do
    command -v $Dependency >/dev/null || failure "Dependency $Dependency not found. Please install $Dependency."
  done
  ffmpeg 2>&1 | grep -q libvidstab || failure "Dependency libvidstab in ffmpeg not found. Please install ffmpeg with vidstab."
}
terminate() {
  storeinfo cmdbreak=yes
  multicore_break
  rm "$Maincachedir/run"
}
ifterminating() {
  [ ! -e "$Maincachedir/run" ]
}
finish() {
  local Line Pid Comm
  
  trap - SIGINT
  terminate
  
  while [ "$(storeinfo dump status)" = "work" ]; do
    echo "Waiting for current batch to terminate ..."
    sleep 1
  done
      
  while read Line; do
    Pid="$(awk  '{print $1}' <<< "$Line")"
    Comm="$(awk '{print $2}' <<< "$Line")"
    [ "$(ps -p $Pid -h -o comm)" = "$Comm" ] && kill $Pid
  done <$Storepidfile
  rm -R $Maincachedir
  pstree -p $$
}
main() {
  local Kaptainpid Kaptainsignal Kaptainstdinfile Kaptainstdoutfile Kaptainanswerfile Kaptainpipefile Kaptaingrammarfile
  local Projecthome
  local Exit
  #trap finish EXIT
  trap terminate SIGINT
  
  # init
  declare_variables
  multicore_init
  create_cachefiles
  check_dependencies
    
  storeinfo "cache=$Maincachedir"
  storeinfo test projecthome       || storeinfo "projecthome=$Projecthome"
  storeinfo test stackshotdir      || storeinfo "stackshotdir=$Projecthome"
  storeinfo test gallerydir        || storeinfo "gallerydir=$Gallerydir"
  storeinfo test allow_dir_invalid || storeinfo "allow_dir_invalid=yes"
  storeinfo "status=idle"
  storeinfo "notfoundimage=$Thumbnaildir/notfound.jpg"
  storeinfo "rmcache_after=yes"
  storeinfo "rmcache_before=yes"
  
  storeinfo drop cmdbreak
  storeinfo drop stackshot_selector
  
  case $(hostname) in
    debianlaptop|debianmikro)
      storeinfo drop rmcache_after
      storeinfo drop rmcache_before
    ;;
  esac
  
  date > $Maincachedir/run

  # start kaptain
  Kaptaingrammarfile="$Maincachedir/gui_main.kaptain.grammar"
  Kaptainstdinfile="$Maincachedir/gui_main.kaptain.stdin" 
  Kaptainstdoutfile="$Maincachedir/gui_main.kaptain.stdout"
  Kaptainanswerfile="$Maincachedir/gui_main.kaptain.reply"
  Kaptainpipefile="$Maincachedir/gui_main.kaptain.pipe.sh"

  kaptaingrammar > $Kaptaingrammarfile
  nl -ba $Kaptaingrammarfile
  :>     "$Kaptainstdinfile"
  :>     "$Kaptainstdoutfile"
  pipekaptain
  
  tail --pid=$$ -f "$Kaptainstdoutfile" >> $Kaptainanswerfile & storepid $!
  kaptain --pipe $Kaptainpipefile $Kaptaingrammarfile & Kaptainpid=$!
  #storepid $Kaptainpid

  storeinfo "refreshgui_main=yes"
  storeinfo "status='idle'"
  sendkaptain "storagebasedir='$Projecthome'"
  sendkaptain "stackshotdir='$(storeinfo dump stackshotdir)'"
  stack_cmd & storepid $!

  # watch signals of kaptain
  while :; do
    ps -p $Kaptainpid >/dev/null || Exit=yes
    ifterminating                && Exit=yes
    [ "$Exit" = "yes" ] && {
      ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
      finish
      break
    }
    
    storeinfo test refreshgui_main && {
      storeinfo drop refreshgui_main
      kaptain_update
    }
    
    read -t1 Kaptainsignal
    
    storeinfo test askkaptain && Kaptainsignal=""
    
    [ "$Kaptainsignal" ] && {
      echo "Signal from kaptain: $Kaptainsignal"
      #grep -q "combo"    <<< "$Kaptainsignal" && Kaptainsignal=""
      grep -q ":pressed" <<< "$Kaptainsignal" && {
        Stackdir="$(askkaptain choosedir)"
        [ "$Stackdir" != "$(storeinfo dump stackshotdir)" ] && {
          check_stackdir "$Stackdir"
          storeinfo "refreshgui_main=yes"
        }
        Gallerydir="$(askkaptain gallerydir)"
        storeinfo "gallerydir=$Gallerydir"
        storeinfo "allow_dir_invalid=$(askkaptain allownonconformant)"
        #storeinfo "projecthome=$(askkaptain storagebasedir)"
        Projecthome="$(askkaptain storagebasedir)"
        Projecthome="${Projecthome%/}"
        storeinfo "projecthome=$Projecthome"
        Kaptainsignal="${Kaptainsignal%:pressed}"
      }
    }
    [ "$Kaptainsignal" ] && parse_kaptainsignal "$Kaptainsignal"
  done < <(tail --pid $$ -f "$Kaptainstdoutfile")
  set -x  
}

main "$@"
exit 0

##### ToDo ####
# crop option for align_ais
# align_vidstab: select area for alignment
# improve fakehdr
# check webm quality
# crop: Do not crop if geometry is same as image
# configuration dialog:
#  - number of threads
#  - checkbutton: "keep cache"
# storepid(): store name, too, check in finish()
# cli support
# documentation in all functions
# Features:
#  - clean entire project home: cache, backup, prepared (note in history)
