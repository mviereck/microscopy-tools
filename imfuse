#! /bin/bash

# imfuse
Version="0.2"

usage() {
  echo "imfuse v$Version - combine focus stackshot images to an overall sharp image.
Aims to be similar to enfuse, but with the help of ImageMagick.

Dependencies:
  imagemagick      Mandatory (command 'convert' or 'magick').
  geeqie           Optional, used by option -V, --showimage.
  enfuse           Optional, used by option --enfuse.

Usage:
  imfuse [OPTIONS] -- image1 image2 image3 ...

General options:
     --cachedir=DIR          Specify a cache folder.
 -h, --help                  Show this help and exit.
     --layers [=NUMBER]      Additonally store two layered TIFF images
                             with segregated source part and sharpness layers.
                             NUMBER is number of sharpness layers. Default: 32
                             Does not work with --compose or --evaluate.
 -o, --output=FILE           Specify result image.
 -v, --verbose               Show verbose output.
     --version               Show imfuse version and exit.
 -V, --showimage             Show intermediate results with geeqie.
 
imfuse provides two basic ways to get overall sharp results.
 - The traditional way is mask comparision with the mask generating methods below.
Use --saturation-weight to reduce possible contrast mask artefacts.
 - Another, faster attempt compares max and min images and combines them
with the compositing methods.                            
Default method: Mask comparision with --diffstat

Compositing methods:
     --compose [=MODE]       Composes a result with mode MODE based on a max
                             and a min calculation of the source images.
                             Compare IM option -compose. 
                             MODE can be one of '$(basename $Magickbin) -list compose'
                             Some MODEs of interest:
                               bumpmap colorburn difference linearburn 
                               linearlight modulate multiply overlay pegtoplight
                             Takes options:
                               --swap       
                             Hint: Generate max+min images with --evaluate and
                             provide only them to --compose to speed it up.
                                                         Default MODE: overlay
     --evaluate [=MODE]      Evaluates a result of all source images with
                             mode MODE.                  
                             MODE can be one of '$(basename $Magickbin) -list evaluate'
                             Compare IM option -evaluate-sequence.
                             Most of interest:
                               max      Brightest pixels in sequence. 
                                        Fast and pretty result.
                               mean     Average pixel values in sequence. 
                                        Useful to combine imfuse results.
                               median   Middle pixel values in sequence. 
                                        Useful to combine imfuse results.
                               min      Darkest pixels in sequence.
                                                         Default MODE: max
                             
Mask generating methods:
     --blur                  Blur edge detection. Takes options: 
                               --radius                  Default: 0
                               --sigma                   Default: 0.75
                             Two-mask difference calculation with options:
                               --radius2                 Default: 0
                               --sigma2                  Default: 1.6*sigma1
     --compass               Compass edge detection. 
     --diffstat [=STAT1[,STAT2]]  Compares two local statistics of source. 
                             Uses IM option -statistic. Compare --statistic.
                             Possible STAT1 and STAT2:
                               1|gradient|grad
                               2|maximum|max
                               3|mean
                               4|median
                               5|minimum|min
                               6|mode
                               7|nonpeak
                               8|9|rms|rootmeansquare
                               10|standarddeviation|dev
                             Default for STAT1: median. Default for STAT2: mean
                             Takes options: 
                               --radius                  Default: 5
                             Two-mask difference calculation with option:
                               --radius2                 Default: radius1*3/2
     --enfuse [=ENFUSEARGS]  Uses external binary enfuse for mask generation.
                             Takes options: 
                               --radius                  Default: 5
                             The radius must be an odd value of at least 3.
                             Optionally add custom enfuse options ENFUSEARGS.
                             One of interest is '--hard-mask'.
                             Option --radius sets --contrast-window-size=RADIUS.
     --free='IMOPTION'       Custom ImageMagick option IMOPTION 
                             for mask generation.        Default: '-edge 2'
     --freichen              Frei-Chen edge detection.
     --gaussian              Gaussian blur edge detection.
                             Takes options: 
                               --radius                  Default: 0
                               --sigma                   Default: 0.75
                             Two-mask difference calculation (DoG) with options:
                               --sigma2                  Default: sigma1*1.6
     --kirsch                Kirsch edge detection. 
     --laplacian [=MODE]     Laplacian edge detection.
                             MODE is the kernel number to use.
     --log                   Laplacian of Gaussian.
                             Takes options: 
                               --radius                  Default: 0
                               --sigma1                  Default: 0.75
                             Two-mask difference calculation with options:
                               --radius2                 Default: 0
                               --sigma2                  Default: sigma1*1.6
     --prewitt               Prewitt edge detection. 
     --roberts               Roberts edge detection. 
     --sobel                 Sobel edge detection. 
     --statistic [=STAT]     IM option -statistic result compared with source.
                             Takes options:
                               --radius                  Default: 2
                             Two-mask difference calculation with options:
                               --radius2                 Default: radius1*3/2
                             Argument STAT is one of (number or name):
                               1|gradient|grad
                               2|maximum|max
                               3|mean
                               4|median
                               5|minimum|min
                               6|mode
                               7|nonpeak
                               8|9|rms|rootmeansquare
                               10|standarddeviation|dev
                             Default: standarddeviation
     --unsharp               Difference of -unsharp.
                             Takes options: 
                               --radius                  Default: 0
                               --sigma1                  Default: 5
                             Two-mask difference calculation with options:
                               --sigma2                  Default: 1.6*sigma1
                                      
Compositing adjustments:
     --swap                  Invert order of max/min in --compose.
                             Changes result of some but not all compose modes.
                             
Method depending mask generation adjustments:
 -r, --radius=RADIUS1        Automatically chooses a radius if RADIUS=0
 -R, --radius2=RADIUS2       Second radius for difference masks.  
 -s, --sigma=SIGMA1          Sigma for some mask generating methods.
 -S, --sigma2=SIGMA2         Second sigma for difference masks. 

General mask generation adjustments:
     --downweight [=PERCENT] Reduce weight of sharpness masks of lower layers.
                             Helps to strengthen weak objects in foreground.
                             A negative PERCENT reduces weight of upper layers.
                                                         Default PERCENT: 50
 -f, --fusemode MODE         Choose fuse mode to combine source images.
                             MODE can be 1 or 2.         Default MODE: 1
                             Fuse mode 1 compares sharpness of source images
                             and generates the result of the sharpest 
                             topmost areas.
                             Fuse mode 2 compares sharpness of source and result
                             in each iteration and overwrites parts of result.
     --grayscale=ARG         Grayscale converting method before mask generation.
                             ARG is one of: (number or name)
                   0 none
                   1 Rec601Luma       0.298839R' + 0.586811G' + 0.114350B'
                   2 Rec601Luminance  0.298839R  + 0.586811G  + 0.114350B
                   3 Rec709Luma       0.212656R' + 0.715158G' + 0.072186B'
                   4 Rec709Luminance  0.212656R  + 0.715158G  + 0.072186B
                   5 Brightness       max(R', G', B')
                   6 Lightness        (min(R', G', B') + max(R', G', B')) / 2.0
                   7 Average          (R' + G' + B') / 3.0
                   8 MS               (R'^2 + G'^2 + B'^2) / 3.0
                   9 RMS              sqrt( (R'^2 + G'^2 + B'^2) / 3.0 )
                             Compare IM options -grayscale and -intensity.
     --negate                Invert the mask to achieve very diffuse result.
     --noise [=ARG]          Mask noise filter.          Default ARG: 3
 -t, --threshold [=PERCENT]  Do not use pixels less significant than PERCENT%.
                             You might prefer --layers.  Default PERCENT: 5

Mask weighting options:
Imfuse can add other masks to the contrast mask to reduce stacking artefacts.
They are extracted from image colorspace calculations. (HSB, HCL and CieLAB).
The different masks are combined with a customizable weight. (0..100)
     --contrast-weight PERCENT      Contrast mask weight.          Default: 100
     --saturation-weight PERCENT    Saturation weight. (HSB)       Default: 10
     --chroma-weight PERCENT        Color intensity weight. (HCL)  Default: 0
     --lightness-weight PERCENT     Lightness weight.  (CieLAB L)  Default: 0
                                    (Similar to --evaluate=max)
     --rg-weight PERCENT            Red-green weight   (CieLAB A)  Default: 0
     --by-weight PERCENT            Blue-yellow weight (CieLAB B)  Default: 0
     --darkness-weight PERCENT      Negated Lightness. (CieLAB L)  Default: 0
                                    (Similar to --evaluate=min)

Method independent adjustments:
 -g, --gamma [=GAMMA]        Adjust gamma of result. GAMMA>1 brightens,
                             GAMMA<1 darkens the image.  Default GAMMA: auto
"
}

### Messages

error() {
  [ -z "$Error" ] && echo "imfuse ERROR: $*
" >&2
  Error=1
  #exit 1
}
note() {
  [ -z "$Error" ] && echo "imfuse note: $*"
  return 0
}
verbose() {
  [ "$Verbose" = "yes" ] && echo "imfuse: $*"
  return 0
}
showimage() {
  [ "$Showimageprocessing" = "yes" ] && geeqie -t -r File:"${1:-}" &
  return 0
}

### Misc

freememory() {
  local Freemem Line Zram
  Freemem="$(LC_ALL=C free | grep "Mem:" | awk '{print $7}')"
  while read Line; do
    Zram="$(awk '{print ($3 - $4)}' <<< "$Line")"
    Zram="$((Zram/1000))"
    Freemem="$((Freemem + Zram))"
  done < <(/sbin/swapon --bytes | grep zram)
  Freemem="$((Freemem*100/95))"
  echo $Freemem
}
lowercase() {
    # Usage: lowercase "string"
    printf '%s\n' "${1,,}"
}
printnum(){
  # print number $1 with leading zeroes.
  # $1 number
  # $2 digits. Default: 3
  printf %0${2:-3}d "${1:-0}"
}
trap_sigint() {
  error "Received SIGINT"
}
unspecialstring() {             # replace special chars of $1 with -
  # Replace all characters except those described in "a-zA-Z0-9_" with a '-'. 
  # Replace newlines, too.
  # Remove leading and trailing '-'
  # Avoid double '--'
  # Return empty string if only special chars are given.
  printf %s "${1:-}" | LC_ALL=C tr -cs "a-zA-Z0-9_" "-" | sed -e 's/^-// ; s/-$//'
}

### Image processing

compose_stepx() {
  local Stacklist Imagenumber Stackcount Stackdir Step Image1 Image2 Image3
  Stacklist="$Sourceimagelist"
  Imagenumber="$(grep -c . <<< "$Stacklist")"
  while :; do
    [ "$Error" ] && break
    Stackcount="$((Stackcount+1))"
    echo $Stackcount
    Stackdir=$Cachedir/stack$Stackcount
    mkdir -p $Stackdir
    Imagenumber="$(grep -c . <<< "$Stacklist")"
    [ "$Imagenumber" -lt "2" ] && break
    for Step in $(seq $((Imagenumber/2)) ); do
      [ "$Error" ] && break
      Image1="$(head -n+$Step       <<< "$Stacklist" | tail -n1)"
      Image2="$(head -n+$((Step+1)) <<< "$Stacklist" | tail -n1)"
      [ -z "$Image2" ] && break
      Image3="$(head -n+$((Step+2)) <<< "$Stacklist" | tail -n1)"
      [ "$((Step*2+1))" = "$Imagenumber" ] || Image3=""
      $Magickbin \
        $Image1 $Image2 $Image3 \
          \( -clone 0--1 -evaluate-sequence max -write mpr:max \) \
          \( -clone 0--1 -evaluate-sequence max -write mpr:min \) \
          -delete 0--1 \
        mpr:max mpr:min $Swapcompose \
          -compose multiply -composite -gamma 2 \
        $Tifstore \
        $Stackdir/composite.$Step.tif
      showimage $Stackdir/composite.$Step.tif
    done
    Stacklist="$(ls $Stackdir/* | sort -V)"
  done
}
compose_step2() {

  Stackcount=0
  Startzeit="$(date +%s)"
  for Step in 0 $(seq $((Imagenumber/$Stepsize)) ); do
    [ "$Error" ] && break
    Stackcount="$((Stackcount+1))"
    Stacklist="$(tail -n+$((Stepsize*Step+1)) <<< "$Sourceimagelist" | head)"
    [ -z "$Stacklist" ] && break
    $Magickbin $Stacklist -evaluate-sequence max $Cachedir/max.$Stackcount.tif
    $Magickbin $Stacklist -evaluate-sequence min $Cachedir/min.$Stackcount.tif
    $Magickbin $Cachedir/max.$Stackcount.tif $Cachedir/min.$Stackcount.tif -compose overlay -composite $Cachedir/overlay.$Stackcount.tif
    showimage $Cachedir/overlay.$Stackcount.tif
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-((Step+1)*Stepsize)) / ((Step+1)*Stepsize) ))"
    [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
    note "compose: Duration: $(date -u -d @$Dauer +"%T"); Estimated time left: $(date -u -d @$Restzeit +"%T") ($Restzeit)"
  done
  $Magickbin $Cachedir/overlay* -evaluate-sequence max $Cachedir/max.overlay.tif
  $Magickbin $Cachedir/overlay* -evaluate-sequence max $Cachedir/min.overlay.tif
  $Magickbin $Cachedir/max.overlay.tif $Cachedir/min.overlay.tif -compose overlay -composite $Cachedir/overlay.overlay.tif
  showimage $Cachedir/overlay.overlay.tif
}

evaluate_split() {

  local Sourceimagelist Resultimage Mode
  local Startzeit Dauer Restzeit
  local Image Split Splitpercent Showsplit Part Partimage Partimagelist
  local Startzeit Dauer Restzeit Count
  
  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  while [ $# -gt 0 ]; do
    Sourceimagelist="$Sourceimagelist
${1:-}"
    shift
  done
  Sourceimagelist="$(tail -n+2 <<< "$Sourceimagelist")"
  
  Split="$((Imagelistmemsize/Freemem +1))"
  
  verbose "Generating $Mode image $(basename "$Resultimage") in $Split parts."
  case $Split in
    1) 
      Startzeit="$(date +%s)"
      $Magickbin $Sourceimagelist -evaluate-sequence $Mode $Tifstore $Resultimage || error "Error in evaluate_split / $Mode"
      Dauer="$(( $(date +%s)-Startzeit))"
      verbose "Duration: $(date -u -d @$Dauer +"%T")"
    ;;
    *)
      Startzeit="$(date +%s)"
      Splitpercent="$((100/Split))"
      Showsplit="$(printnum $(( (Split+1)/2 )) 3)"
      Count="0"
      for Sourceimage in $Sourceimagelist; do
        [ "$Error" ] && break
        Count="$((Count+1))"
        verbose "Splitting image $Count / $Imagenumber into $Split pieces due to low memory: $(basename $Sourceimage)"
        $Magickbin $Sourceimage -crop 100%x${Splitpercent}% $Tifstore $Cachedir/split%03d.$(basename $Sourceimage).tif || error "Error in evaluate_split / crop"
        showimage $Cachedir/split${Showsplit}.$(basename $Sourceimage).tif
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
      done
      Startzeit="$(date +%s)"
      for Part in $(seq 0 $((Split-1))) ; do
        [ "$Error" ] && break
        verbose "Evaluating part $((Part+1)) / $Split"
        Partimage=$Cachedir/$Mode.part$Part.tif
        $Magickbin $Cachedir/split$(printnum $Part 3).*.tif -evaluate-sequence $Mode $Tifstore $Partimage || error "Error in evaluate_split / evaluating parts"
        Partimagelist="$Partimagelist $Partimage"
        showimage $Partimage
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Split-Part+1) / (Part+1) ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
      done
      [ "$Error" ] && return 1
      $Magickbin $Partimagelist -append $Tifstore $Resultimage  || error "Error in evaluate_split / appending parts"
    ;;
  esac
  showimage $Resultimage
  return "${Error:-0}"
}
fuse_focus_stackshot()  {
  # fuse focus image stackshot.
  # Based on snibgo's focus stacking script at http://im.snibgo.com/focstack.htm
  
  local Count Number Line Showimage
  local Sourcemasklist Enfusemasklist
  local Sourcemask Chromamask Saturationmask Darknessmask Lightnessmask Cielabamask Cielabbmask
  local Maskmax Contrastminlevel Contrastmaxlevel
  local Maskgenerator Downweightoption
  local Startzeit Dauer Restzeit
  local Color Pixelnumber Pixelcount Layerimage Layerimagelist Colornumber Histogramm
  
  Maskmax="$Cachedir/mask.max.tif"
      
  Maskgenerator="$(maskfilter)"
  
  # --negate
  [ "$Negate" = "yes" ] && {
    Maskgenerator="$Maskgenerator \
-negate"
  }

  Maskgenerator="$Grayscaleconverter
$Maskgenerator"

  [ "$Noise" ] && Maskgenerator="$Maskgenerator
-statistic nonpeak $Noise"
    
  # Generate masks
  Startzeit="$(date +%s)"
  Count=0
  case $Method in
    load-masks)
      Imagenumberlength=4
      $Magickbin $Loadmaskfile $Cachedir/mask.%0${Imagenumberlength}d.tif
      mv $Cachedir/mask.$(printnum 0 $Imagenumberlength).tif $Maskmax
      Sourcemasklist="$(find $Cachedir/mask.*.tif | sort -V)"
    ;;
    enfuse)
      enfuse --contrast-weight=1 --saturation-weight=0 --exposure-weight=0 \
               --save-masks="$Cachedir/enfuse-softmask-%n.tif":"$Cachedir/enfuse-hardmask-%n.tif" \
               --contrast-window-size=$Radius1 \
               --output=enfuse-out.tif \
               --verbose \
               $Maskgeneratorargument \
               $Sourceimagelist \
               2>&1 | grep -v -E 'no usable resolution|loading next image|will assume 300 dpi|assuming all pixels|does not have an alpha channel' #|| error "Error in enfuse"
               
      grep -q "hard-mask" <<< "$Maskgeneratorargument" && {
        Enfusemasklist="$(find $Cachedir/enfuse-hardmask* | sort -V)"
      } || {
        Enfusemasklist="$(find $Cachedir/enfuse-softmask* | sort -V)"
      }
      Count="0"
      while read Line; do
        [ "$Error" ] && break
        Count="$((Count+1))"
        Number="$(printnum $Count $Imagenumberlength)"
        Sourcemask="$Cachedir/mask.${Number}.tif"
        $Magickbin "$Line" -depth 16 $Tifstore "$Sourcemask"
        Sourcemasklist="$Sourcemasklist $Sourcemask"
      done <<< "$Enfusemasklist"
    ;;
    *)
      verbose "Generating contrast masks with:
$Maskgenerator
"
      for Sourceimage in $Sourceimagelist; do
        [ "$Error" ] && break
        Count="$((Count+1))"
        Number="$(printnum $Count $Imagenumberlength)"
        Sourcemask="$Cachedir/mask.${Number}.tif"
        Saturationmask="$Cachedir/saturation.${Number}.tif"
        Chromamask="$Cachedir/chroma.${Number}.tif"
        Darknessmask="$Cachedir/darkness.${Number}.tif"      
        Lightnessmask="$Cachedir/lightness.${Number}.tif"      
        Cielabamask="$Cachedir/cielab_a.${Number}.tif"      
        Cielabbmask="$Cachedir/cielab_b.${Number}.tif"      
        Showimage="$Sourcemask"
        Sourcemasklist="$Sourcemasklist $Sourcemask"
        
        Command="$Magickbin \
          $Sourceimage \
            -depth 16 \
            -write mpr:sourceimage \
            -delete 0"
        [ "$Saturationweight" -gt "0" ] && {
          Command="$Command \
          mpr:sourceimage \
            -colorspace HSB -channel G -separate \
            $Tifstore -write $Saturationmask \
            -delete 0"
          Showimage="$Saturationmask"
        }
        [ "$Chromaweight" -gt "0" ] && {
          Command="$Command \
          mpr:sourceimage \
            -colorspace HCL -channel G -separate \
            $Tifstore -write $Chromamask \
            -delete 0"
          Showimage="$Chromamask"
        }
        [ "$Darknessweight" -gt "0" ] && {
          Command="$Command \
          mpr:sourceimage \
            -colorspace LAB -channel R -separate \
            -negate \
            $Tifstore -write $Darknessmask \
            -delete 0"
          Showimage="$Darknessmask"
        }
        [ "$Lightnessweight" -gt "0" ] && {
          Command="$Command \
          mpr:sourceimage \
            -colorspace LAB -channel R -separate \
            $Tifstore -write $Lightnessmask \
            -delete 0"
          Showimage="$Lightnessmask"
        }
        [ "$Cielabaweight" -gt "0" ] && {
          Command="$Command \
          mpr:sourceimage \
            -colorspace LAB -channel G -separate \
            $Tifstore -write $Cielabamask \
            -delete 0"
          Showimage="$Cielabamask"
        }
        [ "$Cielabbweight" -gt "0" ] && {
          Command="$Command \
          mpr:sourceimage \
            -colorspace LAB -channel B -separate \
            $Tifstore -write $Cielabbmask \
            -delete 0"
          Showimage="$Cielabbmask"
        }
        Command="$Command \
          mpr:sourceimage \
            $Maskgenerator \
            -alpha off \
            $Tifstore $Sourcemask"
            
        $Command
        showimage "$Showimage"
    
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
        verbose "$Method: Generating masks $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
      done
    ;;
  esac
  [ "$Error" ] && return "${Error:-0}"
  
  
  case $Method in
    load-masks) ;;
    *)
      # max of masks to level single masks
      evaluate_split max $Maskmax $Sourcemasklist || return 1
      Imageproperties="$($Magickbin "$Maskmax" -format '
Contrastminlevel=%[fx:minima*100]
Contrastmaxlevel=%[fx:maxima*100]
' info:)"
      eval $Imageproperties

      # Level contrast mask into visible range. Merge --weight-xxx masks.
      Startzeit="$(date +%s)"
      Count=0
      for Sourceimage in $Sourceimagelist; do
        [ "$Error" ] && break
        Count="$((Count+1))"
        Number="$(printnum $Count $Imagenumberlength)"
        Sourcemask="$Cachedir/mask.${Number}.tif"
        Saturationmask="$Cachedir/saturation.${Number}.tif"
        Chromamask="$Cachedir/chroma.${Number}.tif"
        Darknessmask="$Cachedir/darkness.${Number}.tif"     
        Lightnessmask="$Cachedir/lightness.${Number}.tif"     
        Cielabamask="$Cachedir/cielab_a.${Number}.tif"      
        Cielabbmask="$Cachedir/cielab_b.${Number}.tif"  
        
        # -downweight
        [ "${Downweight:-0}" -gt "0" ] && Downweightoption="+level 0,$(awk "BEGIN { print 100 - $Downweight*$Count/$Imagenumber }")%"
        [ "${Downweight:-0}" -lt "0" ] && Downweightoption="+level 0,$(awk "BEGIN { print 100 + $Downweight*$((Imagenumber-Count))/$Imagenumber }")%"
       
        Command="$Magickbin \
          $Sourcemask \
            -level ${Contrastminlevel}%,${Contrastmaxlevel}%"
        [ "$Threshold" ] && Command="$Command \
            -black-threshold ${Threshold:-0}%"
        Command="$Command    +level 0%,${Contrastweight}%"
        [ "$Saturationweight" -gt "0" ] && Command="$Command \
          ( $Saturationmask  +level 0%,${Saturationweight}% ) -compose screen -composite"
        [ "$Chromaweight" -gt "0" ] && Command="$Command \
          ( $Chromamask      +level 0%,${Chromaweight}% )     -compose screen -composite"
        [ "$Darknessweight" -gt "0" ] && Command="$Command \
          ( $Darknessmask  +level 0%,${Darknessweight}% ) -compose screen -composite"
        [ "$Lightnessweight" -gt "0" ] && Command="$Command \
          ( $Lightnessmask  +level 0%,${Lightnessweight}% ) -compose screen -composite"
        [ "$Cielabaweight" -gt "0" ] && Command="$Command \
          ( $Cielabamask  +level 0%,${Cielabaweight}% )       -compose screen -composite"
        [ "$Cielabbweight" -gt "0" ] && Command="$Command \
          ( $Cielabbmask  +level 0%,${Cielabbweight}% )       -compose screen -composite"
        Command="$Command \
            $Downweightoption \
          $Tifstore $Sourcemask"
          
        $Command
      
        showimage "$Sourcemask"
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
        verbose "Leveling $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
      done
      [ "$Error" ] && return "${Error:-0}"
      
      # max of masks to compare single masks
      evaluate_split max $Maskmax $Sourcemasklist || return 1
    ;;
  esac
  
  # copy of max mask to remove already fused areas from it
  cp $Maskmax $Maskmax.strip.tif

  # --save-masks
  [ "$Savemask" = "yes" ] && {
    verbose "Storing layered masks in $Savemaskfile"
    $Magickbin $Maskmax $Sourcemasklist "$Savemaskfile"
  }
  
  # Fuse images
  Startzeit="$(date +%s)"
  Count=0
  case $Fusemode in
    1)
      # Default fuse mode: Find sharpest area in source (brightest in maskmax). First source image wins if it shares same sharpness with later source images.
      for Sourceimage in $Sourceimagelist; do
        [ "$Error" ] && break
        Count="$((Count+1))"
        Number="$(printnum $Count $Imagenumberlength)"
        Sourcemask="$Cachedir/mask.${Number}.tif"
    
        # Load maskmax, sourcemask and sourceimage into memory. Apply threshold if given.
        Command="$Magickbin \
          $Maskmax.strip.tif \
            -write mpr:maskmax \
            -delete 0 \
          $Sourcemask \
            -write mpr:sourcemask \
            -delete 0
          $Sourceimage \
            -write mpr:sourceimage \
            -delete 0"
        # keep only parts of source mask that fit maskmax (greatest sharpness in stack)
        # remove source mask from maskmax to avoid overwrite by later masks with same sharpness areas.
        [ "$Stripmask" = "yes" ] && Command="$Command \
          mpr:sourcemask mpr:maskmax \
            -compose MinusDst -composite -fill white +opaque black -negate \
            -write mpr:sourcepartmask \
            -delete 0
          mpr:sourcepartmask mpr:maskmax \
            -evaluate-sequence max \
            -write $Maskmax.strip.tif \
            -delete 0"
        # get part of source image
        # clean transparent area 
        Command="$Command \
          mpr:sourceimage mpr:sourcepartmask \
            -alpha Off -compose CopyOpacity -composite \
            -write mpr:sourcepart \
            -delete 0 \
          mpr:sourcepart \
            -background blue -alpha background \
            -write mpr:sourcepart \
            -delete 0"
        # save source image parts for layered tif
        [ "$Storelayers" ] && Command="$Command \
          mpr:sourcepart \
            -type TrueColorAlpha \
            $Tifstore -write $Sourcemask \
            -delete 0"
        # add source image part to result
        Command="$Command \
          $Resultimage mpr:sourcepart \
            -compose Over -composite \
            -type TrueColorAlpha \
          $Tifstore $Resultimage"
        $Command
            
        showimage $Resultimage
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
        verbose "$Method $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
      done
      
      false && for Mode in $($Magickbin -list compose); do
        [ "$Error" ] && break
        Alphaimage="$Cachedir/alpha.$Mode.tif"
        $Magickbin -size ${Imagewidth}x${Imageheight} xc:none -alpha transparent -type TrueColorAlpha $Tifstore $Alphaimage
        for Image in $(ls $Cachedir/alpha* | sort -V | tac); do
          [ "$Error" ] && break
          $Magickbin $Alphaimage $Image -compose $Mode -composite $Alphaimage
          showimage $Alphaimage
        done
      done
      
      false && $Magickbin \
        $Resultimage $Maskmax \
          -alpha off -compose copy_opacity -composite \
          $Tifstore $Cachedir/$Basename.alpha.tif
       
      [ "$Storelayers" ] && {
        verbose "Creating layered result with parts in use of source images"
        Image="$(rev <<< "$Outputimage" | cut -d. -f2- | rev).layered_parts.tif"
        $Magickbin -type TrueColorAlpha $Maskmax $Backgroundimage $Sourcemasklist $Tifstore "$Image" || note "Failed to create layered parts result image."
      }
    ;;
    2)
      # fuse mode 2: Compare on each step if source or result seem to be more sharp
      for Sourceimage in $Sourceimagelist; do
        [ "$Error" ] && break
        Count="$((Count+1))"
        Number="$(printnum $Count $Imagenumberlength)"
        Sourcemask="$Cachedir/mask.${Number}.tif"
    
        $Magickbin \
          $Resultimage \
            -write mpr:resultimage \
            $Maskgenerator \
            -level ${Contrastminlevel}%,${Contrastmaxlevel}% +level 1%,99% \
            -write mpr:resultmask \
            -delete 0 \
          $Sourcemask mpr:resultmask \
            -compose MinusDst -composite -fill white +opaque black -write mpr:diffmask \
            -delete 0 \
          $Sourceimage mpr:resultimage mpr:diffmask \
            -alpha off -compose Over -composite \
            "$Resultimage" || error "Error in fuse mode 2"

        showimage $Resultimage
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
        verbose "$Method $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
      done
    ;;
  esac
  
  [ "$Storelayers" ] && {
    Histogramm="$($Magickbin $Maskmax -depth 16 -define histogram:unique-colors=true -format %c histogram:info:-)"
    Colornumber="$(awk '{print $3}' <<< "$Histogramm" | wc -l)"
    Layerminpixel="$(( Imagewidth*Imageheight/(Layernumber-1) ))"
    verbose "Creating $Layernumber layers of sharpness areas"
    Count=0
    Layercount=0
    Startzeit="$(date +%s)"
    Pixelcount=0
    Pixelnumber=0
    while read Line; do
      Count=$((Count+1))
      [ "$Error" ] && break
      Color="$(awk '{print $3}' <<< "$Line")"
      Pixelnumber="$(awk '{print $1}' <<< "$Line")"
      Pixelnumber="${Pixelnumber%:}"
      Pixelcount="$((Pixelcount+Pixelnumber))"
      [ "$Pixelcount" -lt "$Layerminpixel" ] && {
        Color1="${Color1:-$Color}"
      }
      { [ "$Pixelcount" -gt "$Layerminpixel" ] || [ "$Count" = "$Colornumber" ] ; } && {
        Layercount="$((Layercount+1))"
        Layerimage="$Cachedir/layer_sharpness.$(printnum $Layercount).tif"
        Color2="${Color2:-$Color}"
        $Magickbin \
          $Maskmax \
            -depth 16 \
            -color-threshold "${Color1:-$Color2}"-"$Color" \
            -write mpr:layermask \
            -delete 0 \
          $Resultimage mpr:layermask \
            -colorspace sRGB \
            -alpha Off -compose CopyOpacity -composite \
            -background blue -alpha background \
          $Tifstore $Layerimage || {
            note "Error in generating sharpness layers"
            break
        }
        Layerimagelist="$Layerimagelist $Layerimage"
        [ "$Color2" = "$Color" ] && {
          Color1=""
          Pixelcount="0"
        } || {
          Color1="$Color"
          Pixelcount="$Pixelnumber"
        }
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Colornumber-Count) / Count ))"
        verbose "Layer $Layercount/$Layernumber. Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
        showimage $Layerimage
      }
      Color2="$Color"
    done <<< "$Histogramm"
    
    [ "$Error" ] && return $Error
    verbose "Creating layered result of sharpness areas"
    Image="$(rev <<< "$Outputimage" | cut -d. -f2- | rev).layered_sharpness.tif"
    $Magickbin -type TrueColorAlpha $Maskmax $Backgroundimage $Layerimagelist $Tifstore "$Image" || note "Failed to create layered sharpness result image."
  }
  
  return "${Error:-0}"
}
maskfilter() {
    # Mask generating ImageMagick options
    # Most of them are based on edge detection: http://www.imagemagick.org/Usage/convolve/#edgedet
    Maskgenerator=""
    Maskgenerator2=""
    case $Method in
      blur)
        # Compare two blurred images with different sigma.
        # Concept and result is similar to Difference of Gaussian (DoG). Using -gaussian-blur gives same as DoG.
        # Code based on https://im.snibgo.com/simpalign.htm#twoBlrDiff.bat
        Maskgenerator="
( -clone 0
-blur ${Radius1}x${Sigma1} 
)"
        [ "$Radius2$Sigma2" ] && Maskgenerator="$Maskgenerator
( -clone 0
-blur ${Radius2:-$Radius1}x${Sigma2:-$Sigma1} 
)
-delete 0"
        Maskgenerator="$Maskgenerator
-compose Difference -composite"
# -compose Mathematics -define compose:args=0,-4,4,0.5 -composite
# -grayscale RMS"
      ;;
      compass)
        Maskgenerator="
( -clone 0
-define convolve:scale=50%!
-define convolve:bias=50%
-morphology Convolve Compass
)
-delete 0"
#-compose Difference -composite" # sort of interesting.
      ;;
      diffstat)
        Maskgenerator="
-write mpr:source
-delete 0
( mpr:source -statistic $Diffstat1 ${Radius1} )
( mpr:source -statistic $Diffstat2 ${Radius1} )
-compose Difference -composite
-write mpr:diff1"
        [ "$Radius2" ] && Maskgenerator="$Maskgenerator
-delete 0
( mpr:source -statistic $Diffstat1 ${Radius2} )
( mpr:source -statistic $Diffstat2 ${Radius2} )
-compose Difference -composite
-write mpr:diff2
-delete 0
mpr:diff1 mpr:diff2
-compose Difference -composite"
      ;;
      experimental)
        Maskgenerator="
( -clone 0
-statistic $Maskgeneratorargument ${Radius1}x${Radius1}
-write mpr:stat1
)
( -clone 0
-statistic $Maskgeneratorargument $((Radius1*2))x$((Radius1*2))
-write mpr:stat2
)
( -clone 0
-statistic $Maskgeneratorargument $((Radius1*3))x$((Radius1*3))
-write mpr:stat3
)
-delete 0
mpr:stat1 mpr:stat2
-compose screen -composite
mpr:stat3
-compose screen -composite"
#mpr:stat1 mpr:stat2 mpr:stat3 -evaluate-sequence mean"
      ;;
      free)
        Maskgenerator="$Maskgeneratorargument"
      ;;
      freichen)
        Maskgenerator="-define convolve:scale=50%!
                       -define morphology:compose=Lighten
                       -define convolve:bias=50%
                       -morphology Convolve FreiChen:>" ### FIXME allow more modes
      ;;
      gaussian) 
        case $Sigma2 in
          "")
            Maskgenerator="
( -clone 0
-gaussian-blur ${Radius1}x${Sigma1} 
)
-compose Difference -composite"
          ;;
          *) # DoG: Difference of Gaussian
        # This will generate a 'DoG' or "Difference of Gaussians" kernel in which 
        # the gaussian generated by 'sigma1' will have the gaussian generated by 'sigma2' subtracted from it. 
        # Normally 'sigma2' is the larger so that the 'central peak' of the kernel is positive. 
        # Reversing the two numbers will effectivally negate the resulting kernel. 
        # By generating two 'Gaussian' kernels of slightly different sigma values (in a ratio of approximatally 1.6), 
        # and subtracting them from each other you can actually generate a close approximation of a Laplacian of a Gaussian.
            Maskgenerator="-define convolve:bias=50%
-morphology Convolve DoG:$Radius1,$Sigma1,$Sigma2"
          ;;
        esac
      ;;
      kirsch)
        Maskgenerator="
-define convolve:scale=50%!
-define convolve:bias=50%
-morphology Convolve Kirsch" ### FIXME
      ;;
      laplacian)
        Maskgenerator="
-define convolve:bias=50%
-define convolve:scale=!
-morphology Convolve Laplacian:$Maskgeneratorargument"
      ;;
      log)  # LoG: Laplacian of Gaussian
        Maskgenerator="
( -clone 0
-define convolve:bias=50%
-morphology Convolve LoG:${Radius1}x${Sigma1}
)"
        [ "$Radius2$Sigma2" ] && Maskgenerator="$Maskgenerator
( -clone 0
-define convolve:bias=50%
-morphology Convolve LoG:${Radius2:-$Radius1}x${Sigma2:-$Sigma1}
)
-delete 0
-compose Difference -composite"
        [ -z "$Radius2$Sigma2" ] && Maskgenerator="$Maskgenerator
-delete 0"
      ;;
      none)
        Maskgenerator=""
      ;;
      prewitt)
        Maskgenerator="
-define convolve:scale=50%!
-define convolve:bias=50%
-morphology Convolve Prewitt"
      ;;
      roberts)
        Maskgenerator="
-define morphology:compose=Lighten
-define convolve:bias=50%
-morphology Convolve Roberts:@"
      ;;
      sobel)
        Maskgenerator="
-define convolve:scale=!
-define convolve:bias=50%
-define morphology:compose=Lighten
-morphology Convolve Sobel:>"
      ;;
      statistic)
        Maskgenerator="
( -clone 0
-statistic $Maskgeneratorargument ${Radius1}x${Radius1}
)"
        [ "$Radius2" ] && Maskgenerator="$Maskgenerator
( -clone 0
-statistic $Maskgeneratorargument ${Radius2}x${Radius2}
)"
        Maskgenerator="$Maskgenerator
-delete 0"
        [ "$Radius2" ] && Maskgenerator="$Maskgenerator
-compose Difference -composite"
      ;;
      unsharp)
        Maskgenerator="( -clone 0 -unsharp ${Radius1}x${Sigma1} )
                       -compose Difference -composite"
      ;;
      unsharp2)
        Maskgenerator="-unsharp ${Radius1}x${Sigma1}"
      ;;
      unsharpXXX)
        Maskgenerator="( -clone 0 -unsharp ${Radius1}x${Sigma1} )
                       ( -clone 0 -unsharp ${Radius1}x${Sigma2} )
                       -delete 0
                       -compose Difference -composite
                       -grayscale RMS"
      ;;
    esac
  grep . <<< "$Maskgenerator"
}

### main

declare_variables() {
  Background=""
  Backgroundimage=""
  Basename=""
  Lightnessweight=""
  Cachedir=""
  Compress=""
  Cielabaweight=""
  Cielabbweight=""
  Contrastweight=""
  Darknessweight=""
  Diffstat1=""
  Diffstat2=""
  Downweight=""
  Error=""
  Freemem=""
  Fusemode=""
  Gamma=""
  Grayscale=""
  Grayscaleconverter=""
  Grayscalenumber=""
  Image=""
  Imageformat="tif"
  Imageheight=""
  Imagelistmemsize=""
  Imagememsize=""
  Imagenumber=""
  Imagewidth=""
  Chromaweight=""
  Layernumber=""
  Layerminpixel=""
  Layers=""
  Loadmaskfile=""
  Magickbin=""
  Magickpixelmemory=""
  Magickversion=""
  Method=""
  Maskgeneratorargument=""
  Mode=""
  Negate="no"
  Noise=""
  Outputimage=""
  Revertimagelist="no"
  Preservecache="no"
  Saturationweight=""
  Savemaskfile=""
  Showimageprocessing="no"
  Sourceimage=""
  Sourceimagelist=""
  Startzeit="$(date +%s)"
  Stepsize=""
  Storelayers=""
  Stripmask="yes"
  Swapcompose=""
  Threshold=
  Tifstore="+repage -quality 100% -compress lzw"
  Radius1=""
  Radius2=""
  Sigma1=""
  Sigma2=""
  Verbose="no"
  return 0
}
parse_options() {
  local Shortoptions Longoptions Parsedoptions Parsererror Parsererrorfile
  
  Shortoptions="b::f:g::hn::o:r:R::s:S::t::vV"
  Longoptions="basename::,cachedir:,help,verbose,version,output:,save-masks::,showimage"
  Longoptions="$Longoptions,darkness-weight:,lightness-weight:,contrast-weight:,saturation-weight:,chroma-weight:,rg-weight:,by-weight:"
  Longoptions="$Longoptions,background::,downweight::,fusemode:,grayscale:,gamma::,layers::,negate,noise::,radius:,radius1:,radius2::,revert,sigma:,sigma1:,sigma2::,swap,threshold::"
  Longoptions="$Longoptions,blur::,compass::,compose::,diffstat::,gaussian::,enfuse::,evaluate::,experimental::,free::,freichen::,kirsch::,laplacian::,load-masks::,log::,none::,prewitt::,roberts::,sobel::,statistic::,unsharp::"  

  Parsererrorfile="/tmp/imfuse.parserserror.$RANDOM"
  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@" 2>"$Parsererrorfile")"
  [ -e $Parsererrorfile ] && Parsererror="$(cat "$Parsererrorfile")" && rm "$Parsererrorfile"
  [ "$Parsererror" ] && error "$Parsererror"
  eval set -- "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    [ "$Error" ] && break
    case "${1:-}" in
      -h|--help)              usage ; exit 0 ;;
         --rg-weight)          Cielabaweight="${2:-auto}" ; shift ;;
         --by-weight)          Cielabbweight="${2:-auto}" ; shift ;;
      -b|--background)        Background="${2:-auto}" ; shift ;;
         --basename)          Basename="${2:-auto}" ; shift ;;
         --lightness-weight) Lightnessweight="${2:-auto}" ; shift ;;
         --cachedir)          Cachedir="${2:-}" ; Preservecache="yes" ; shift ;;
         --contrast-weight)   Contrastweight="${2:-auto}" ; shift ;;
         --darkness-weight)   Darknessweight="${2:-auto}" ; shift ;;
         --downweight)        Downweight="${2:-auto}" ; shift ;;
      -f|--fusemode)          Fusemode="${2:-auto}" ; shift ;;
      -g|--gamma)             Gamma="${2:-auto}" ; shift ;;
         --grayscale)         Grayscale="${2:-auto}" ; shift ;;
         --chroma-weight)     Chromaweight="${2:-auto}" ; shift ;;
         --layers)            Storelayers="yes" ; Layernumber="${2:-auto}" ; shift ;;
         --negate)            Negate="yes" ;;
      -n|--noise)             Noise="${2:-auto}" ; shift ;;
      -o|--output)            Outputimage="${2:-}" ; shift ;;
      -r|--radius|--radius1)  Radius1="${2:-}" ; shift ;;
      -R|--radius2)           Radius2="${2:-auto}" ; shift ;;
         --revert)            Revertimagelist="yes" ;;
         --saturation-weight) Saturationweight="${2:-auto}" ; shift ;;
         --save-masks)        Savemask="yes" ; Savemaskfile="${2:-$Basename.mask.tif}" ; shift;;
      -s|--sigma|--sigma1)    Sigma1="${2:-}" ; shift ;;
      -S|--sigma2)            Sigma2="${2:-auto}" ; shift ;;
         --swap)              Swapcompose="-swap 0,1" ;;
      -t|--threshold)         Threshold="${2:-auto}" ; shift ;;
      -v|--verbose)           Verbose="yes" ;;
         --version)           echo "imfuse v$Version"; exit 0 ;;
      -V|--showimage)         Showimageprocessing="yes" ;;
         --blur|--compass|--compose|--diffstat|--gaussian|--enfuse|--evaluate|--experimental|--free|--freichen|--kirsch|--laplacian|--load-masks|--log|--none|--prewitt|--roberts|--sobel|--statistic|--unsharp)
        Method="${1#--}"
        Maskgeneratorargument="${2:-}"  && shift
      ;;  
      --) ;;
      *)
        Sourceimagelist="$Sourceimagelist
$(realpath "${1:-}")" 
        [ -f "${1:-}" ] || error "File not found: ${1:-}"
      ;;
    esac
    shift
  done
  return ${Error:-0}
}
check_options() {
  
  # --fusemode
  case $Method in
    evaluate|compose) 
      [ "$Fusemode" ] && error "--fusemode has no effect with --$Method" ;;
    *)
      case $Fusemode in
        ""|"1"|"auto") 
          Fusemode="1" 
        ;;
        "2") 
          [ -z "${Method}${Radius1}" ] && {
            Method="statistic"
            Maskgeneratorargument="standarddeviation"
            Radius1="10"
            note "--fusemode=$Fusemode: Setting --$Method=$Maskgeneratorargument --radius1=$Radius1"
          } || {
            note "--fusemode=$Fusemode needs manual setting of parameters
  like --radius and --sigma.
  Default values are often less useable and optimized for --fusemode=1."
          }
        ;;
        *) error "--fusemode: Unknown mode $Fusemode" ;;
      esac
    ;;
  esac
  
  # Method
  case $Method in
    enfuse)
      #error "--enfuse: Not implemented yet"
      command -v enfuse >/dev/null || error "--enfuse: command enfuse not found. Please install enfuse."
      [ "$Fusemode" = "2" ]        && error "Option --enfuse does not work with --fusemode=2"
    ;;
    "")
      Method="diffstat"
      note "Setting --$Method"
    ;;
  esac  
  
  # Method argument
  case $Method in
    compose)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="overlay"
        note "Setting --$Method=$Maskgeneratorargument"
      }
      grep -q -x -i "$Maskgeneratorargument" <<< "$($Magickbin -list compose)" || {
        error "--$Method=$Maskgeneratorargument: unknown argument.
  Please choose one out of '$Magickbin -list compose'
  or compare IM option -compose."
      }
      Maskgeneratorargument="$(lowercase "$Maskgeneratorargument")"
    ;;
    diffstat)
      Diffstat1="$(cut -d, -f1    <<< "$Maskgeneratorargument")"
      Diffstat2="$(cut -d, -f2 -s <<< "$Maskgeneratorargument")"
      case ${Diffstat1,,} in
        ""|auto)                Diffstat1="median" ;;
        1|gradient|grad)        Diffstat1="gradient" ;;
        2|maximum|max)          Diffstat1="maximum" ;;
        3|mean)                 Diffstat1="mean" ;;
        4|median)               Diffstat1="median" ;;
        5|minimum|min)          Diffstat1="minimum" ;;
        6|mode)                 Diffstat1="mode" ;;
        7|nonpeak)              Diffstat1="nonpeak" ;;
        8|9|rms|rootmeansquare) Diffstat1="rms" ;;
        10|standarddeviation|standard_deviation|standard-deviation|dev) 
                                Diffstat1="standarddeviation" ;;
        *) error "--diffstat: Unknown STAT $Diffstat1" ;;
      esac
      case ${Diffstat2,,} in
        ""|auto)                Diffstat2="mean" ;;
        1|gradient|grad)        Diffstat2="gradient" ;;
        2|maximum|max)          Diffstat2="maximum" ;;
        3|mean)                 Diffstat2="mean" ;;
        4|median)               Diffstat2="median" ;;
        5|minimum|min)          Diffstat2="minimum" ;;
        6|mode)                 Diffstat2="mode" ;;
        7|nonpeak)              Diffstat2="nonpeak" ;;
        8|9|rms|rootmeansquare) Diffstat2="rms" ;;
        10|standarddeviation|standard_deviation|standard-deviation|dev)
                                Diffstat2="standarddeviation" ;;
        *) error "--diffstat: Unknown STAT $Diffstat2" ;;
      esac
      [ "$Diffstat1" = "$Diffstat2" ] && note "--diffstat: Method 1 und 2 are the same: $Diffstat1
  This is likely not what you want."
      Maskgeneratorargument="${Diffstat1},${Diffstat2}"
    ;;
    enfuse) ;;
    evaluate)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="max"
        note "Setting --$Method=$Maskgeneratorargument"
      }
      grep -q -x -i "$Maskgeneratorargument" <<< "$($Magickbin -list evaluate)" || {
        error "--$Method=$Maskgeneratorargument: unknown argument.
  Please choose one out of '$Magickbin -list evaluate'
  or compare IM option -evaluate-sequence."
      }
      Maskgeneratorargument="$(lowercase "$Maskgeneratorargument")"
    ;;
    experimental) ;;
    laplacian)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="0"
        note "Setting --$Method=$Maskgeneratorargument"
      }
    ;;
    load-masks)
      Loadmaskfile="${Maskgeneratorargument:-$Basename.mask.tif}"
      [ -e "$Loadmaskfile" ] || error "--load-masks: File not found: $Loadmaskfile"
    ;;
    free)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="-edge 2"
        note "Setting --$Method='$Maskgeneratorargument'"
      }
    ;;
    statistic)
      case $Maskgeneratorargument in
        ""|auto)                Maskgeneratorargument="standarddeviation" 
          note "Setting --$Method=$Maskgeneratorargument" ;;
        1|gradient|grad)        Maskgeneratorargument="gradient" ;;
        2|maximum|max)          Maskgeneratorargument="maximum" ;;
        3|mean)                 Maskgeneratorargument="mean" ;;
        4|median)               Maskgeneratorargument="median" ;;
        5|minimum|min)          Maskgeneratorargument="minimum" ;;
        6|mode)                 Maskgeneratorargument="mode" ;;
        7|nonpeak)              Maskgeneratorargument="nonpeak" ;;
        8|9|rms|rootmeansquare) Maskgeneratorargument="rms" ;;
        10|standarddeviation|standard_deviation|standard-deviation|dev) 
                                Maskgeneratorargument="standarddeviation" ;;
        *) error "--statistic: Unknown STAT $Maskgeneratorargument" ;;
      esac
    ;;
    *) [ -n "$Maskgeneratorargument" ] && error "Arguments not used in --$Method=$Maskgeneratorargument" ;;
  esac
  
  # --background
  case $Method in
    evaluate|compose) [ "$Background" ] error "--background has no effect with --$Method" ;;
    *)
      case $Background in
        "")   [ "$Threshold" ] && Background="transparent" || Background="darkgreen" ;;
        auto) Background="mean" ;;
        none) Background="transparent" ;;
      esac
    ;;
  esac
  
  # --downweight
  case $Method in
    evaluate|compose) [ "$Downweight" ] && error "--downweight has no effect with --$Method" ;;
    *)
      case $Downweight in
        "")   ;;
        auto) Downweight="50" ;;
        *)    Downweight="$(sed s/%// <<< "$Downweight")" ;;
      esac
    ;;
  esac
    
  # --grayscale
  case $Method in
    evaluate|compose) [ "$Grayscale" ] && error "--grayscale has no effect with --$Method" ;;
    *)
      case ${Grayscale,,} in
        ""|auto)           Grayscale="RMS" ;;
      esac
      case ${Grayscale,,} in
        0|none)            Grayscalenumber=0 ; Grayscale="none" ;;
        1|rec601luma)      Grayscalenumber=1 ; Grayscale="Rec601Luma" ;;
        2|rec601luminance) Grayscalenumber=2 ; Grayscale="Rec601Luminance" ;;
        3|rec709luma)      Grayscalenumber=3 ; Grayscale="Rec709Luma" ;;
        4|rec709luminance) Grayscalenumber=4 ; Grayscale="Rec709Luminance" ;;
        5|brightness)      Grayscalenumber=5 ; Grayscale="Brightness" ;;
        6|lightness)       Grayscalenumber=6 ; Grayscale="Lightness" ;;
        7|average)         Grayscalenumber=7 ; Grayscale="Average" ;;
        8|ms)              Grayscalenumber=8 ; Grayscale="MS" ;;
        9|rms)             Grayscalenumber=9 ; Grayscale="RMS" ;;
        *)
          error "--grayscale: Unknown argument: $Grayscale"
        ;;
      esac
      case $Grayscale in
        ""|none) Grayscaleconverter="" ;;
        *)       Grayscaleconverter="-grayscale $Grayscale" ;;
      esac
    ;;
  esac
  
  # --layers
  case $Method in
    evaluate|compose) [ "$Layernumber" ] && error "--layers has no effect with --$Method" ;;
    *)
      case $Layernumber in
        auto) Layernumber="32" ;;
      esac
    ;;
  esac
  
  # --noise
  case $Method in
    evaluate|compose) [ "$Noise" ] && error "--noise has no effect with --$Method" ;;
    *)
      case $Noise in
        auto) Noise="3" ;;
      esac
    ;;
  esac
  
  [ "${Radius1}${Radius2}${Sigma1}${Sigma2}" ] && case $Method in
    evaluate|compose) error "Options --radius, --radius2, --sigma, --sigma2
  have no effect for method --${Method}." ;;
  esac
  
  # --radius1
  [ -z "$Radius1" ] && case $Method in
    blur|gaussian|log|unsharp)
      Radius1="0"
    ;;
    enfuse)
      Radius1="5"
      note "Setting --radius=$Radius1"
    ;;
    diffstat)
      Radius1="5"
      note "Setting --radius=$Radius1"
    ;;
    statistic)
      Radius1="2"
      note "Setting --radius=$Radius1"
    ;;
  esac
  case $Method in
    enfuse)
      [ "$Radius1" -lt "3" ]     && error "--enfuse needs a radius of at least 3."
      [ "$((Radius1%2))" -eq 0 ] && error "--enfuse needs an odd value for --radius."
    ;;
  esac
  
  # --radius2
  [ "$Radius2" ] && case $Method in
    statistic|diffstat)
      [ "$Radius2" = "$Radius1" ] && {
        error "--radius2=$Radius2 is same as --radius1=$Radius1."
      }
    ;;
    compose|evaluate|freichen|kirsch|laplacian|prewitt|roberts|sobel)
      error "--radius2 is not supported by --$Method"
    ;;
  esac
  [ "$Radius2" = "auto" ] && case $Method in
    statistic|diffstat)
      Radius2="$((Radius1*3/2))"
      note "Setting --radius2=$Radius2"
    ;;
    blur|gaussian|log|unsharp)
      Radius2="$Radius1"
      note "Setting --radius2=$Radius2"
    ;;
  esac
  
  # --sigma1
  case $Method in
    experimental) ;;
    blur|gaussian|log)
      [ -z "$Sigma1" ] && {
        Sigma1="0.75"
        note "Setting --sigma=$Sigma1"
      }
    ;;
    unsharp)
      [ -z "$Sigma1" ] && {
        Sigma1="5"
        note "Setting --sigma=$Sigma1"
      }
    ;;
    *)
      [ -n "$Sigma1" ] && error "Not used with --method=$Method: --sigma=$Sigma1"
    ;;
  esac
  
  # --sigma2
  case $Method in
    experimental) ;;
    blur|gaussian|log|unsharp)
      [ "$Sigma2" = "auto" ] && {
        Sigma2="$(awk "BEGIN {print $Sigma1 * 1.6}")"
        note "Setting --sigma2=$Sigma2"
      }
      [ "$Sigma1" = "$Sigma2" ] && note "--sigma2 is same as --sigma1.
  This is likely wrong."
    ;;
    *)
      [ -n "$Sigma2" ] && {
        error "Not used with --method=$Method: --sigma2=$Sigma2"
      }
    ;;
  esac
  
  # --threshold
  [ "$Threshold" ] && case $Method in
    evaluate|compose) 
      error "--threshold has no effect with --$Method"
      Threshold=""
    ;;
    *)
      case $Threshold in
        "") ;;
        auto)
          Threshold="5"
          note "Setting --threshold=$Threshold"
        ;;
        *) Threshold="$(sed s/%// <<< "$Threshold")" ;;
      esac
    ;;
  esac
  
  # --contrast-weight --saturation-weight --chroma-weight --lightness-weight
  case $Method in
    compose|evaluate) [ "${Darknessweight}${Lightnessweight}${Contrastweight}${Saturationweight}${Chromaweight}${Cielabaweight}${Cielabbweight}" ] && error "--$Method does not support options
  --contrast-weight --saturation-weight --chroma-weight 
  --darkness-weight --lightness-weight --rg-weight --by-weight" ;;
    *)
      Contrastweight="$(sed   s/%// <<< "$Contrastweight")"
      Saturationweight="$(sed s/%// <<< "$Saturationweight")"
      Chromaweight="$(sed     s/%// <<< "$Chromaweight")"
      Darknessweight="$(sed   s/%// <<< "$Darknessweight")"
      Lightnessweight="$(sed  s/%// <<< "$Lightnessweight")"
      Cielabaweight="$(sed    s/%// <<< "$Cielabaweight")"
      Cielabbweight="$(sed    s/%// <<< "$Cielabbweight")"
      case $Contrastweight in
        ""|auto) Contrastweight="100" ;;
      esac
      case $Saturationweight in
        "")   Saturationweight="10" ;;
        auto) Saturationweight="10" ;;
      esac
      case $Chromaweight in
        "")   Chromaweight="0" ;;
        auto) Chromaweight="0" ;;
      esac
      case $Darknessweight in
        "")   Darknessweight="0" ;;
        auto) Darknessweight="0" ;;
      esac
      case $Lightnessweight in
        "")   Lightnessweight="0" ;;
        auto) Lightnessweight="0" ;;
      esac
      case $Cielabaweight in
        "")   Cielabaweight="0" ;;
        auto) Cielabaweight="0" ;;
      esac
      case $Cielabbweight in
        "")   Cielabbweight="0" ;;
        auto) Cielabbweight="0" ;;
      esac
      [ "$Contrastweight" = "0" ] && Method="none"
    ;;
  esac
  
  # --cachedir
  [ -z "$Cachedir" ] && Cachedir="$(pwd)/imfuse.$RANDOM"
  Cachedir="$(sed s%'~'%$HOME% <<< "$Cachedir")"
  Cachedir="$(realpath -m "$Cachedir")"
  
  #### Files ####
  
  [ -z "$Sourceimagelist" ] && error "No images specified"
  Sourceimagelist="$(grep .  <<< "$Sourceimagelist")"
  Sourceimagelist="$(sort -V <<< "$Sourceimagelist")"
  
  # --revert
  [ "$Revertimagelist" = "yes" ] && Sourceimagelist="$(tac <<< "$Sourceimagelist")"
  
  # --basename
  case $Basename in
    "")   Basename="imfuse" ;;
    auto) Basename="$(basename "$(pwd)")" ;;
  esac
  [ "$Basename" != "$(unspecialstring "$Basename")" ] && error "--basename: Name must not contain special chars or whitespace: '$Basename'"
  
  # --output
    case $Method in
      blur|gaussian|log|unsharp)    Resultimage="$Basename.${Method}.${Radius1}x${Sigma1}"
        [ "$Radius2$Sigma2" ] &&    Resultimage="${Resultimage}-${Radius2:-$Radius1}x${Sigma2:-$Sigma2}" ;;
      compose|evaluate|laplacian)   Resultimage="$Basename.${Method}.${Maskgeneratorargument}" ;;
      diffstat)                     Resultimage="$Basename.${Method}.${Diffstat1}-${Diffstat2}.r${Radius1}"
        [ "$Radius2" ] &&           Resultimage="${Resultimage}-r${Radius2}" ;;
      enfuse)                       Resultimage="$Basename.${Method}.r${Radius1}";;
      "load-masks")                 Resultimage="$Basename.loadmask" ;;
      statistic)                    Resultimage="$Basename.${Method}.${Maskgeneratorargument}.r${Radius1}" 
        [ "$Radius2" ] &&           Resultimage="${Resultimage}-r${Radius2}" ;;
      *)                            Resultimage="$Basename.${Method}" ;;
    esac
    case $Method in
      compose) [ "$Swapcompose" ] && Resultimage="${Resultimage}.swap";;
      evaluate) ;;
      #*) Resultimage="${Resultimage}.m${Mode}" ;;
    esac
    case $Method in
      compose|evaluate) ;;
      *)
        case $Fusemode in
          1) ;;
          *) Resultimage="${Resultimage}.m$Fusemode" ;;
        esac
        [ "${Contrastweight}${Saturationweight}${Chromaweight}${Darknessweight}${Lightnessweight}${Cielabaweight}${Cielabbweight}" != "100000000" ] && {
          Resultimage="${Resultimage}."
          [ "$Contrastweight"   != "100" ] && Resultimage="${Resultimage}c${Contrastweight}"
          [ "$Saturationweight" != "0" ]   && Resultimage="${Resultimage}s${Saturationweight}"
          [ "$Chromaweight"  != "0" ]      && Resultimage="${Resultimage}cr${Chromaweight}"
          [ "$Darknessweight" != "0" ]     && Resultimage="${Resultimage}d${Darknessweight}"
          [ "$Lightnessweight" != "0" ]    && Resultimage="${Resultimage}l${Lightnessweight}"
          [ "$Cielabaweight" != "0" ]      && Resultimage="${Resultimage}a${Cielabaweight}"
          [ "$Cielabbweight" != "0" ]      && Resultimage="${Resultimage}b${Cielabaweight}"
        }
        case $Threshold in
          0|"") ;;
          *) Resultimage="${Resultimage}.t$Threshold" ;;
        esac
        case $Grayscalenumber in
          9) ;;
          *) Resultimage="${Resultimage}.g$Grayscalenumber" ;;
        esac
        case $Noise in
          "") ;;
          *) Resultimage="${Resultimage}.n$Noise" ;;
        esac
        case $Downweight in
          ""|0) ;;
          *) Resultimage="${Resultimage}.D$Downweight" ;;
        esac
        [ "$Revertimagelist" = "yes" ] && Resultimage="${Resultimage}.rev"
      ;;
    esac
    case $Gamma in
      "") ;;
      auto) Resultimage="${Resultimage}.G" ;;
      *)    Resultimage="${Resultimage}.G$Gamma" ;;
    esac
    Resultimage="${Resultimage}.${Imageformat}"
    
  [ -z "$Outputimage" ] && {
    Outputimage="$(realpath -m "./$Resultimage")" 
    note "Setting --output=$Outputimage"
  }
  Outputimage="$(realpath "$Outputimage")"
  Resultimage="$Cachedir/$Resultimage"
    
  verbose "--$Method=$Maskgeneratorargument
--cachedir=$Cachedir
--fusemode=$Fusemode
--downweight=$Downweight
--gamma=$Gamma
--grayscale=$Grayscale
--layers=$Layernumber
--load-masks=$Loadmaskfile
--mode=$Mode
--noise=$Noise
--output=$Outputimage
--radius=$Radius1
--radius2=$Radius2
--save-masks=$Savemaskfile
--sigma=$Sigma1
--sigma2=$Sigma2
--threshold=$Threshold
--contrast-weight=$Contrastweight
--saturation-weight=$Saturationweight
--chroma-weight=$Chromaweight
--lightness-weight=$Lightnessweight
--rg-weight=$Cielabaweight
--by-weight=$Cielabbweight
"
  return ${Error:-0}
}
main() {
  #set -eu
  trap trap_sigint SIGINT
  
  declare_variables
  
  command -v convert >/dev/null && Magickbin="convert"
  command -v magick  >/dev/null && Magickbin="magick"
  [ -z "$Magickbin" ] && error "Neither command convert nor magick found. Please install ImageMagick."
  Magickversion="$($Magickbin -version)"
  grep -q " Q8 "   <<< "$Magickversion" && Magickpixelmemory="4"
  grep -q " Q16 "  <<< "$Magickversion" && Magickpixelmemory="8"
  grep -q " HDRI " <<< "$Magickversion" && Magickpixelmemory="16"
  [ "$Error" ] && return 1
  
  Freemem="$(freememory)"
  [ -z "$Freemem" ] && {
    note "WARNING: failed to estimate free memory.
  Blindly guessing 1000 MB."
    Freemem="1000000"
  }
  
  parse_options "$@"
  check_options
  [ "$Error" ] && return 1
  
  Sourceimagelist="$(grep -v -x "" <<< "$Sourceimagelist")"
  Imagenumber="$(grep -c "." <<< "$Sourceimagelist")"
  Imagenumberlength="${#Imagenumber}"
  
  Image="$(head -n1 <<< "$Sourceimagelist")"
  Imagewidth="$($Magickbin  -format '%w' "$Image" info:)"
  Imageheight="$($Magickbin -format '%h' "$Image" info:)"
  Imagememsize="$((Imagewidth*Imageheight*Magickpixelmemory/1000))"
  Imagememsize="$((Imagememsize*125/100))" # by observation. Alpha channel? Meta data?
  Imagelistmemsize="$((Imagenumber*Imagememsize))"
  Image=""
  
  verbose "Image number: $Imagenumber
  Image width:  $Imagewidth
  Image height: $Imageheight
  Image memory size:      $Imagememsize kb
  Image list memory size: $Imagelistmemsize kb
  Free Memory:            $Freemem kb"
  
  Backgroundimage="$Cachedir/background.tif"
  
  mkdir -p $Cachedir || error "Error creating cache folder $Cachedir"
  rm $Cachedir/*
  [ "$Error" ] && return 1
 
  case $Method in
    evaluate)
      evaluate_split $Maskgeneratorargument $Resultimage $Sourceimagelist || error "Error in --$Method=$Maskgeneratorargument"
    ;;
    compose)
      case $Stepsize in
        ""|0|all)
          [ "$Freemem" -lt "$Imagelistmemsize" ] && {
            verbose "--compose: Generating max image"
            evaluate_split max $Cachedir/max.tif $Sourceimagelist
            verbose "--compose: Generating min image"
            evaluate_split min $Cachedir/min.tif $Sourceimagelist
            verbose "--compose: compositing $Maskgeneratorargument"
           $Magickbin \
             $Cachedir/max.tif $Cachedir/min.tif $Swapcompose \
               -compose $Maskgeneratorargument -composite \
             $Tifstore \
             $Resultimage || error "Error in --$Method=$Maskgeneratorargument"
          } || {
            $Magickbin \
              $(echo $Sourceimagelist) \
                \( -clone 0--1 -evaluate-sequence max -write mpr:max -delete 0--1 \) \
                \( -clone 0--1 -evaluate-sequence min -write mpr:min -delete 0--1 \) \
                -delete 0--1 \
              mpr:max mpr:min $Swapcompose \
                -compose $Maskgeneratorargument -composite \
              $Tifstore \
              $Resultimage || error "Error in --$Method=$Maskgeneratorargument"
          }
        ;;
        *)
          compose_step
        ;;
      esac
    ;;
    *)
      case $Background in
        max|min|mean|median)
          evaluate_split $Background $Backgroundimage $Sourceimagelist || return 1
        ;;
        transparent|none)
          $Magickbin -size ${Imagewidth}x${Imageheight} xc:blue -transparent blue +level-colors black -type TrueColorAlpha $Tifstore $Backgroundimage || error "Failed to create transparent background image."
          #$Magickbin $(head -n1 <<< "$Sourceimagelist") -alpha Transparent +level-colors "black"  -colorspace sRGB  $Resultimage || error "Failed to create transparent background image."
        ;;
        *)
          #$Magickbin $(head -n1 <<< "$Sourceimagelist") -alpha Opaque +level-colors "$Background" -colorspace sRGB  $Resultimage || error "Failed to create background image with color $Background."
          $Magickbin -size ${Imagewidth}x${Imageheight} xc:"$Background" -type TrueColorAlpha $Tifstore $Backgroundimage
        ;;
      esac
      cp "$Backgroundimage" "$Resultimage"
      case $Background in
        transparent|none|"") Backgroundimage="" ;;
      esac
      #showimage "$Resultimage"
      fuse_focus_stackshot  || error "Error while fusing stackshot"
    ;;
  esac
  [ "$Error" ] && return 1
  
  # --gamma
  case $Gamma in
    "") ;;
    auto) $Magickbin "$Resultimage" -auto-gamma     $Tifstore "$Resultimage" || error "Error in --gamma=$Gamma" ;;
    *)    $Magickbin "$Resultimage" -gamma "$Gamma" $Tifstore "$Resultimage" || error "Error in --gamma=$Gamma" ;;
  esac
  [ "$Error" ] && return 1
  
  $Magickbin "$Resultimage" $Tifstore "$Outputimage"  || error "Error storing result in $Outputimage"
  showimage "$Outputimage"
  note "Ready after $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")
$Outputimage"
    
  return "${Error:-0}"
}

main "$@"
[ "$Preservecache" = "no" ] && [ -d "$Cachedir" ] && rm -R "$Cachedir"
exit "${Error:-0}"
