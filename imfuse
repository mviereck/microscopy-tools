#! /bin/bash

# imfuse
Version="0.8.3-beta"

# ToDo:
# improve error&sigint handling
# check if --level is set
# merge: do not separate channel,comparision? ->level
# mkclut_uniform() fails with b&w masks -> clut and result black
# check --kirsch
# drop --unsharp?
# drop --halo?

usage() {
  echo "imfuse v$Version
Combines focus stackshot images to one overall sharp image.

Usage:
  imfuse [OPTIONS] -- image1 image2 image3 ...

imfuse assumes that the alphanumerical order of the input images goes
from front to back; for the other way around use option --revert.

Dependencies:
  ImageMagick 7       Mandatory (command 'magick').
  enfuse              Optional, needed for options --enfuse and --bg=enfuse.
  geeqie              Optional, needed for option -V, --showimage.
  viewnior            Optional, needed for option -W to show result image.
  exiftool            Optional, needed for option --exif to transfer metadata.
  focus-stack         Optional, needed for option --align.
                        https://github.com/PetteriAimonen/focus-stack
  xclip               Optional, to send result file name to clipboard.

General options:
     --align              Align images.
     --basename [=NAME]   Base name [+path] for output image. 
     --cache [=DIR]       Store generated masks and images in directory DIR.
                          They can be reused in later runs of imfuse.
                          Default DIR: ./cache.imfuse
     --exif [=IMAGE]      Transfer exif meta data from IMAGE or first image.
 -h, --help               Show this help and exit.
     --layered            Store backgrounds and single slabs in layered TIF.
     --limit-memory=ARG   Limit amount of used memory. Default: 80%
                          ARG can be a % value or an absolute value for MB.
 -o, --output=FILE        Result image file name. See also --basename.
     --revert             Revert order of source images.
     --savemask [=FILE]   Store contrast mask in file FILE.
     --version            Show imfuse version and exit.
 -V, --showimage          Show intermediate results with image viewer geeqie.
     --video              Generate a video of shown intermediate images.
 -W                       Show result with image viewer viewnior.

The options below can take additionally arguments [=ARG].
Multiple arguments are comma-separated. Example: --morphology=r3,blur
Arguments taken by all mask generating options:
  w         Mask weight. Percent value from 0 to 100.
            Of interest if specifying more than one mask generation method.
            Example: --morphology --saturation=w25
            This will generate two masks. The saturation mask will only have
            noteable effect where the morphology mask strength is below 25%.
  blur      Compare option --maskblur, here applied for single mask only.
  wave      Compare option --maskwave, here applied for single mask only.
  neg       Negate/invert the mask. Rarely needed.
  t         Threshold (removal) of low contrast areas.
  T         Threshold (removal) of high contrast areas.
  C=        Colorspace channel to use instead of full source image.
            Example: C=HSL-1 for saturation channel. Rarely needed.
Arguments additionally taken by some options:
  r         Radius. Must be an integer value.
            Increased radius mostly causes less noise, less details and
            more contrast. Smaller radius causes more details and more noise.
  R         Second radius.
  s         Sigma. Takes also non-integer values like 0.75.
            Increased sigma mostly causes less noise, less details and
            more contrast. Smaller sigma causes more details and more noise.
  S         Second Sigma.
  p         A percent value.
  P         Second percent value
  n         An integer value.
  N         Second integer value.
  (word)    Some options take one or two word arguments.

Step 1: Color conversion
  By default imfuse uses colorspace sRGB and does not convert to grayscale.
  Normally you don't need to adjust these options.

     --colorspace [=ARG]  Define the colorspace from where to generate the
                      masks. Experimental option, less useful yet.
                      ARG takes arguments:
                        (word1) colorspace          Default: sRGB
                        (word2) channel
                      Of interest (all channels together): sRGB, RGB
                      Single channels of interest:   LAB,0 HSL,1  HCL,1
                      For further colorspaces and their channels see:
                      https://legacy.imagemagick.org/Usage/color_basics
     --grayscale [=ARG]  Convert images to grayscale before mask generation.
                      Compare ImageMagick options -grayscale and -intensity. 
                      ARG takes argument:
                        (word)  mode                Default: Rec709Luma
                      mode is one of: (number or name)
                        0 none
                        1 Rec601Luma
                        2 Rec601Luminance
                        3 Rec709Luma
                        4 Rec709Luminance
                        5 Brightness
                        6 Lightness
                        7 Average
                        8 MS
                        9 RMS
                      Converting to grayscale for mask generation can speed up
                      image processing, but the result might be less accurate.

Step 2a: Mask generation - contrast masks
  Options can be specified multiple times. The order does not matter.
  Most of interest: --morphology, --statistic, --wavelet

 --blur [=ARG]        Blur edge detection. 
                      Similar to --gaussian, but faster and less accurate.
                      ARG additionally takes argument: 
                        s       sigma               Default: 0.75
 --comet [=ARG]       Comet edge detection. Compares rotated mean areas.
                      ARG additionally takes arguments: 
                        s       sigma               Default: 5
                        (word)  mode                Default: Lighten
                      mode can be one of 'magick -list compose'
                      Recommended: Lighten, Darken.
 --compass [=ARG]     Compass edge detection. 
 --dog [=ARG]         Difference of Gaussian. 
                      ARG additionally takes arguments: 
                        s       sigma               Default: 0.4
                        S       sigma2              Default: 1.6*sigma1
 --diffstat [=ARG]    Compares two local statistics of source images. 
                      Uses ImageMagick option -statistic. Compare --statistic.
                      ARG additionally takes arguments: 
                        r       radius              Default: 3
                        (word)  mode1               Default: median
                        (word)  mode2               Default: mean
                      Possible mode1 and mode2:
                        0|none|source
                        1|gradient|grad
                        2|maximum|max
                        3|mean
                        4|median
                        5|minimum|min
                        6|mode
                        7|nonpeak
                        8|9|rms|rootmeansquare
                        10|standarddeviation|dev
                      Most interesting alternative is a max,min difference.
 --free [=ARG]        Custom ImageMagick option for mask generation.
                      ARG is an arbitrary ImageMagick command, but must not
                      contain a comma.              Default: '-sharpen 0x3'
 --freediff [=ARG]    Custom ImageMagick option for mask generation.
                      The resulting mask  will be a '-compose Difference' 
                      comparision with the source image.
                      ARG is an arbitrary ImageMagick command, but must not
                      contain a , comma.
 --freichen [=ARG]    Frei-Chen edge detection. 
                      ARG additionally takes arguments: 
                        (word)  modenumber
                      Possible modenumbers at:
                      http://www.imagemagick.org/Usage/convolve/#freichen
                      Default: A combination of modes 1 and 2.
 --gaussian [=ARG]    Gaussian blur edge detection. 
                      Similar to --blur, but slower and more accurate.
                      ARG additionally takes argument: 
                        s       sigma               Default: 0.3
 --kirsch [=ARG]      Kirsch edge detection. 
 --laplacian [=ARG]   Laplacian edge detection.
                      ARG additionally takes argument: 
                        (word)  modenumber          Default: 3
                      Possible modenumbers at:
                      http://www.imagemagick.org/Usage/convolve/#laplacian
 --log [=ARG]         Laplacian of Gaussian.
                      ARG additionally takes argument: 
                        s       sigma               Default: 0.2
 --morphology [=ARG]  Morphology edge detection.
                      ARG additionally takes arguments: 
                        r       radius              Default: 2
                        R       kernel iteration    Default: 1
                        (word)  mode                Default: edgeout
                      mode can be one of 'magick -list morphology'
                      Some modes of interest:
                        tophat, edge, dilateintensity, smooth
 --prewitt [=ARG]     Prewitt edge detection. 
 --roberts [=ARG]     Roberts edge detection. 
 --sobel [=ARG]       Sobel edge detection. 
 --statistic [=ARG]   ImageMagick option -statistic.
                      ARG additionally takes arguments: 
                        r       radius              Default: 2
                        (word)  mode                Default: standarddeviation
                      Argument mode is one of (number or name):
                        1|gradient|grad
                        2|maximum|max
                        3|mean
                        4|median
                        5|minimum|min
                        6|mode
                        7|nonpeak
                        8|9|rms|rootmeansquare
                        10|standarddeviation|dev
                      Get an impressive strong contrast with a high radius.
 --unsharp [=ARG]     Difference of -unsharp.
                      ARG additionally takes argument: 
                        s       sigma               Default: 2
 --wavelet [=ARG]     Based on ImageMagick option -wavelet-denoise.
                      ARG additionally takes argument:
                        p       percent             Default: 10

Step 2b: Mask generation - image comparision masks
  Options can be specified multiple times. The order does not matter.
  Most of interest: --enfuse

 --compose [=ARG]     Composes evaluated min,max of source images with MODE.
                      ARG additionally takes argument:
                        (word)   mode               Default: overlay
                      Adding a '2', e.g. '--compose=overlay2' swaps min,max
                      to max,min and can give a different result.
                      mode can be one of 'magick -list compose'
                      Some modes of interest:
                        overlay interpolate colordodge hardlight reflect 
                        softburn softlight linearlight pegtoplight
 --enfuse [=ARG]      Image comparision with a basic enfuse result.
 --evaluate [=ARG]    Evaluates from all source images with mode MODE and
                      compares the result with each source image.
                      ARG additionally takes arguments:
                        (word)   mode               Default: max
                      mode can be one of 'magick -list evaluate'
                      Compare --max, --min, --mean, --median.
 --halo [=ARG]        Remove light halo of white background (overexposure).
                      ARG additionally takes arguments:
                        p        percent            Default: 25
                        r        radius             Default: 2
                        s        sigma              Default: 5
                      Greater percent removes more light.
                      sigma is a -blur sigma for a soft cut.
                      radius is a kernel radius.
                      Needs high 'weight' values even greater than 100.
                      Well to combine with --darkness.
 --image [=ARG]       Loads an image and generates masks based on 
                      similarity with source images.
                      ARG additionally takes arguments:
                        (word)   An image file name
 --max [=ARG]         Same as --evaluate=max. Brightest pixels of stack.
                      Result is similar to --lightness.
 --mean [=ARG]        Same as --evaluate=mean. Average of pixels in stack.
 --median [=ARG]      Same as --evaluate=median. Median pixel of stack.
 --min [=ARG]         Same as --evaluate=min. Darkest pixels of stack.
                      Result is similar to --darkness.

Step 2c: Mask generation - colorspace channel masks
  Options can be specified multiple times. The order does not matter.
  All options are variations of --channel. Most of interest: --saturation

 --channel [=ARG]     Use a colorspace channel as mask.
                      ARG additionally takes arguments:
                        (word)   colorspace         Default: HSL
                        (word)   color channel      Default: 1
                      Colorspace can be one of 'magick -list colorspace'
                      The color channel is a number from 0..31.
 --chroma [=ARG]      Chroma channel from HCL colorspace.
 --darkness [=ARG]    Negated lightness channel from HSL colorspace.
                      Dark result, similar to --min.
 --lightness [=ARG]   Lightness channel from HSL colorspace. 
                      Bright result, similar to --max.
 --saturation [=ARG]  Saturation channel from HSL colorspace.
                      Adding this with low weight, e.g. --saturation=w5,
                      can soften the image so it looks more natural.

Step 3: Mask merging
  The contrast masks generated in step 2 are merged into one per image.
  Furthermore they can be adjusted with --mask* options.
  Options beginning with --mask* can be specified multiple times.
  The order matters, prefer to use in the order shown here.

 --maskstat [=ARG]    Apply a statistic method for each mask pixel
                      to adjust it according to its neighborhood.
                      Option is applied to contrast masks only.
                      ARG takes arguments:
                        r        radius             Default: 6
                        (word)   statistic mode     Default: mean
                      word1 can be one of 'magick -list statistic'.
                      Modes of interest: mean, median, gradient.
 --maskblur [=ARG]    Blur masks to enhance contrast and close minor gaps.
                      Applied to contrast masks only.
                      ARG takes arguments:
                        s        sigma              Default: 2
 --maskwave [=ARG]    Remove noise in masks. Can close gaps, but can also
                      create artefacts in very low contrast areas.
                      Applied to contrast masks only.
                      ARG takes arguments:
                        p        percent            Default: 50%
                      For percent value compare option -wavelet-denoise.
 --maskmorph [=ARG]   Closes gaps between nearby contrast lines setting the 
                      area in between to the same contrast weight.
                      Applied to contrast masks only.
                      ARG takes arguments:
                        r        radius             Default: 2
                        R        kernel iteration   Default: 2
                        t        threshold          Default: 0%
                        (word1)  mode               Default: close
                        (word2)  kernel shape       Default: Octagon
                      radius is the kernel radius.
                      kernel iteration multiplies the kernel radius.
                      mode can be one of open, close, erode, dilate, smooth.
                      See: https://imagemagick.org/Usage/morphology/#basic
                      threshold excludes low contrast areas.
                      For possible kernel shapes see:
                      https://imagemagick.org/Usage/morphology/#kernel
                      CPU costly option. Iterating the kernel is cheaper
                      than using a greater radius.
 --merge [=ARG]       Compose mode to merge multiple masks.
                      ARG takes arguments:
                        (word)   mode               Default: Screen
                      mode can be one of 'magick -list compose'.
                      Of interest: Plus Interpolate Multiply Exclusion Blend
 --level [=ARG]       Levels merged masks into visible spectrum from 0%..100%
                      to provide the following focus and postprocessing
                      option arguments a full range from 0%..100%.
                      This option is enabled by default.
                      ARG takes argument:
                        (word)   mode               Default: all
                      mode can be one of:
                        all:  Level all masks
                        slab: Level only merged masks in current slab
                        off:  Do not level merged masks.
                      mode 'slab' should only be used to speed up test runs
                      with different mask merging options within one single
                      slab. Only mode 'all' reliably provides valid values.
                      mode 'off' will make no difference in only few cases.

Step 4: Stack fusion
  The source images are processed with the merged masks,
  the overall sharp image will be generated.

 --cutblur [=ARG]     Blur cut masks in final focus montage.
                      ARG takes argument:
                        s        sigma              Default: 2
 --cutsoft [=ARG]     Similar to --cutblur, but paint default sharp cut mask
                      over blurred cut mask.
                      ARG takes argument:
                        s        sigma              Default: 2
 --less [=ARG]        Strenghtens less contrasted objects in front of strong
                      contrasted background objects.
                      ARG takes argument:
                        p        percent            Default: 50%
                      Percent is the minimal intermediate contrast
                      difference between background and foreground object.
                      If unsharp areas appear, use a greater percent value.
                      If the foreground object still has holes, use a lower 
                      percent value or try some of the --mask* options.
 --slabs [=ARG]       Split stack into different stacks (called slabs)
                      and fuse them separately. Can be specified multiple times.
                      ARG takes arguments:
                        r        radius             Default: 5%
                        p        percent1           Default: 14%
                        P        percent2
                        n        number1
                        N        number2
                        (word)   kurt
                      You can specify single slabs or generate a set of slabs.
                      Please specify either percents or numbers, not both.
                      - Given only one of percent or number, imfuse will
                        generate a set of slabs accordingly.
                         - set word to 'kurt' to start all slabs with image 1.
                      - If you specify two of percents or numbers, imfuse will
                        generate a single slab within the given range of images.
                      - radius specifies how many images neigboured slabs should
                        share. A percent value for radius is allowed.
                      Use --threshold or --alpha to make the slabs transparent.
                      The slabs will be composed over each other onto
                      a background (to specify with --background).
                      See also --layered to store the single slabs as layers.
                      That allows manual rework of the results in gimp.
 --soft [=ARG]        Enable soft fusion mode. Different concept than 
                      default maximum contrast montage. Images are multiplied 
                      with their contrast masks and added altogether as a whole.
                      ARG takes arguments:
                        p        percent1          Default: 2%
                        P        percent2          Default: 100%
                        (word)   mode              Default: Plus
                      Increasing percent1 increases softness of low contrast.
                      Increasing percent2 increases sharpness of high contrast.
                      mode can be one of 'magick -list compose'. Of interest:
                        Plus Screen
                      Does not support --less, --cutblur, --cutsoft.

Step 5: Post processing
  The order of the options on cli matters. Noteably --alpha with percent values
  different from =0%,100% affects the following percent arguments.
  All options can be specified multiple times if that makes sense.

 --alpha [=ARG]       Generate transparent image using the contrast mask as 
                      alpha channel (=transparency channel).
                      Good method to reduce noise in low contrast areas.
                      The semitransparent result is composed over --background.
                      ARG takes arguments:
                        p        percent1          Default: 0%
                        P        percent2          Default: 100%
                      percent1 affects the low contrast areas with
                       a useful range of -100%..+50%.
                      percent2 affects the high contrast areas with
                       a useful range of +100%..+200%.
                      Higher values make less transparent.
                      The percent values are applied as '+level p%xP%'
                      on the transparency alpha channel.
 --finalblur [=ARG]   Soft blur of bokeh in low contrast areas.
                      ARG takes arguments:
                        t        threshold         Default: 50%
                        s        sigma1            Default: 3
                        S        sigma2            Default: 2
                      Blurs low contrast areas below threshold with sigma1.
                      If sigma2 is given, the cut border between bokeh and 
                      foreground is blurred for a soft transition.
 --finalblur2 [=ARG]  Soft blur of bokeh in low contrast areas.
                      Other than --finalblur it blurs according to the contrast
                      mask strengh. Low contrast is blurred more than high.
                      ARG takes arguments:
                        r        radius            Default: 4
                        t        threshold         Default: 50
 --threshold [=ARG]   Make low (or high) contrast area transparent.
                      ARG takes arguments:
                        t        threshold1        Default: 50%
                        T        threshold2        Default: 100%
                        s        sigma             Default: 0
                      threshold1 removes low contrast areas below a percent.
                      threshold2 removes high contrast areas above a percent.
                      sigma blurs the cut border.

Step 6: Background
  Background for transparent images.
  Can be specified multiple times for option --layered.

 --bg, --background [=ARG]  Specify a background to paint on.
                      ARG takes argument:
                        (word)   background        Default: enfuse
                      background can be an image name or one out of:
                        enfuse
                        transparent
                        magick -list color
                        magick -list evaluate (compare --evaluate)
                        magick -list compose  (compare --compose)
                      Recommendations: enfuse mean max min
                                       colorize colorize2 pinlight pinlight2
                      Interesting: interpolate overlay pegtoplight reflect

Basics:
Fusing a focus stack aims to generate an overall sharp image of several single
captures that only show partial sharp areas.
Sharp areas show more contrast and detail than blurry unsharp areas.

So one important part is to find areas with a lot of contrast and detail.
This is done with the contrast mask options. From each source image the area
with more contrast than all other source images will be part of the result.

Artefacts / stack failures:
The attempt to get the strongest contrast areas out of the source images
has some weaknesses and can lead to artefacts.

 - Low contrast noise artefacts:
  All contrast mask methods give unsatisfying results in areas that have low 
  contrast on all source images of the stack.
  Possibilities:
   - Option --alpha --bg=enfuse paints high contrast on soft enfuse background.
     Example: '--diffstat --alpha --bg=enfuse'
   - Another possibility to soften the noise is option --finalblur.
     Example: '--diffstat --finalblur'

 - Objects in foreground with background artefacts:
  Sometimes objects in background result in a stronger contrast mask than
  objects in foreground. The foreground object will be incomplete.
  This can be fixed with option --less, additionally --cutblur or --maskmorph.

Examples:
Have a folder 'stackshot' containing all but nothing than stack source images.
Go to the folder above 'stackshot'.
  Run imfuse with:
    imfuse -VW --align --diffstat                            stackshot/*
  You might be unsatisfied with low contrast areas. Try:
    imfuse -VW --align --diffstat --maskblur                 stackshot/*
    imfuse -VW --align --diffstat --maskblur --soft          stackshot/*
    imfuse -VW --align --diffstat --maskblur --alpha         stackshot/*
  You might have incomplete foreground objects. Try:
    imfuse -VW --align --diffstat --maskblur --alpha --less  stackshot/*

  Try also other mask options instead of (or additionally to) --diffstat,
  e.g. --wavelet or --morphology. Play with radius/sigma of mask options,
  e.g. --diffstat=r5. Try different percent values for --less,
  e.g. --less=p30 or --less=p80.
  Think of radius or sigma like brush sizes.
  Small values create small brushes painting more details and more noise.
  Great values create big brushes painting less details and less noise.
"
}

### Messages

error() {
  echo "
imfuse ERROR: $*
" >&2
  [ -d "$Cachedir" ] && :> "$Exitnotefile"
  Error=1
}
note() {
  [ -z "${Error:-}" ] && echo "imfuse: $*" >&2
  return 0
}
verbose() {
  [ "$Verbose" = "yes" ] && echo "imfuse: $*" >&2
  return 0
}
showimage() {
  local Frame
  [ "$Showimageprocessing" = "yes" ] && geeqie -t -r --File:"${1:-}" 2>/dev/null &
  #[ "$Showimageprocessing" ] && bash imgview "${1:-}"
  [ "$Video" ] && {
#    Videoframecount="$((Videoframecount+1))"
    Videoframecount="$(ls $Cachedir/videoframe????.* | sort -V | tail -n1)"
    Videoframecount="$(basename "$Videoframecount")"
    Videoframecount="${Videoframecount//[^0-9]/}"
    Videoframecount="$(sed "s/^0*//" <<< "$Videoframecount")"
    Videoframecount="$(calc "$Videoframecount+1")"
    Frame="$Cachedir/videoframe$(printnum "$Videoframecount").tif"
    #ln -s "${1:-}" "$Frame"
    cp "${1:-}" "$Frame" ### FIXME ln -s where possible
  }
  return 0
}

### Misc

calc() {
  LC_ALL=C awk "BEGIN {print $* }"
}
comma2whitespace() {
  #sed "s/,/ /g" <<< "${1:-}"
  echo "${1//,/ /}"
}
compare() {
  # compare floating number with < > =
  local Arg1 Arg2 Operator
  Arg1="${1:-}"
  Operator="${2}"
  Arg2="${3:-}"
  case "$Operator" in
    "<"|"lt"|"-lt") Operator="<" ;;
    ">"|"gt"|"-gt") Operator=">" ;;
    "="|"eq"|"-eq") Operator="=" ;;
  esac
  (( $(echo "$Arg1 $Operator $Arg2" | bc -l) ))
}
digitonly() {
  #sed "s/[^0-9.]//g" <<< "${1:-}"
  echo "${1//[^0-9.]/}"
}
digitrm() {
  #sed "s/[0-9.]//g" <<< "${1:-}"
  echo "${1//[0-9.-]/}"
}
generate_key() {
  # generate a unique key value from current time and nanoseconds
  date +%s.%N
}
levelparse() {
  local String Part1 Part2
  String="${1:-}"
  String="$(tr -d '%' <<< "$String")"
  grep -q "x" <<< "$String" && {
    Part1="$(cut -dx    -f1 <<< "$String")"
    Part2="$(cut -dx -s -f2 <<< "$String")"
    :
  } || {
    Part1="$((0-String))"
    Part2="$((100-String))"
  }
  echo "${Part1}x${Part2}"
}
levelpercent() {
  local String Part1 Part2
  String="${1:-}"
  String="$(tr -d '%' <<< "$String")"
  Part1="$(cut -dx    -f1 <<< "$String")"
  Part2="$(cut -dx -s -f2 <<< "$String")"
  echo "${Part1}%x${Part2}%"
}
lowercase() {
    # Usage: lowercase "string"
    printf '%s\n' "${1,,}"
}
md5cut() {
  # print last 6 digits
  tr "\n" " " <<< "${1:-}" | md5sum | cut -c27-32
}
numberofpercent() {
  Number="${1:-}"
  Number="${Number//%}"
  Number="$((Number*Sourceimagenumber/100))"
  [ "$Number" -lt "1" ]            && Number=1
  [ "$Number" -gt "$Sourceimagenumber" ] && Number="$Sourceimagenumber"
  echo "$Number"
}
parse_percent() {
  local Percent
  Percent="${1:-}"
  Percent="$(tr -d 'p%' <<< "$Percent")"
  [ "$Percent" = "$(digitonly "$Percent")" ] || {
    error "Invalid percent value: ${1:}"
    return 1
  }
  echo "$Percent"
}
percentrm() {
  # remove % from string
  #sed s/%//g <<< "${1:-}"
  echo "${1//%/}"
}
printnum(){
  # print number $1 with leading zeroes.
  # $1 number
  # $2 digits. Default: 4
  [ "${1:-}" = "NUMBER" ] && echo "NUMBER" && return 0 
  printf %0${2:-4}d "${1:-0}"
}
printsameline() {
  # print $1 without newline at begin of current line
  echo -ne "${1:-}\033[0K\r" >&2
}
printtotalmemory() {
  # print total memory including zram
  local Memory Line Zram
  Memory="$(LC_ALL=C free | grep "Mem:" | LC_ALL=C awk '{print $2}')"
  while read Line; do
    Zram="$(LC_ALL=C awk 'BEGIN {OFMT = "%.0f"} {print $3}' <<< "$Line")"
    Zram="$(LC_ALL=C awk 'BEGIN {OFMT = "%.0f"} {print $1 / 1000}' <<< "$Zram")"
    Memory="$((Memory + Zram))"
  done < <(/sbin/swapon --bytes | grep zram)
  echo $Memory
}
unspecialstring() {
  # Replace all characters except those described in tr string with a '-'.
  printf %s "${1:-}" | LC_ALL=C tr -c "a-zA-Z0-9.,=-_" "-"
}

### Debugging helpers

forcemask() {
  note "Forcing mask generation"
  rm $Cachedir/mask.${1:-}*
  forcelevel
}
forcelevel() {
  note "Forcing leveling"
  rm $Cachedir/level.${1:-}*
  forcemerge
}
forcemerge() {
  note "Forcing merge"
  rm $Cachedir/*merge*
  forcefocus
}
forcefocus() {
  note "forcing focus"
  rm $Cachedir/focus*
  rm $Cachedir/slabresult*
}
forcepost() {
  note "forcing focus postprocessing"
  rm $Cachedir/slabresult*-post*
}

#### run commands on all CPUs

multicore() {
  # Run multiple processes in parallel, but not more than $Multicore_maxprocesses
  # $1 Command
  # $2 Image to show if $1 is finished
  # $3 Memory needed by the process
  # Run multicore_wait afterwards to wait for the last processes to finish.

  local Process Command
  local Mem_needed Zram

  [ "${1:-}" = "-t1" ] && {
    shift
    [ "$Multicore_processcount" -gt 0 ] && {
      multicore_wait || return 1
    }
  }

  [ "$Multicore_processcount" = "$Multicore_maxprocesses" ] && {
    multicore_wait || return 1
  }
  [ "$Multicore_processcount" = "0" ] && {
    Multicore_memorymax="$(printfreememory)"
    Multicore_memorymax="$((Multicore_memorymax*8/10))"
  }
  Mem_needed=0
  for Process in $(seq $Multicore_maxprocesses); do
    Mem_needed="$(awk "BEGIN {print $Mem_needed + ${Multicore_memory[$Process]:-0} }" )"
  done
  Mem_needed="$((Mem_needed+${3:-0}))"
  [ "$Mem_needed" -gt "$Multicore_memorymax" ] && {
    note "multicore: Low memory. Waiting for $Multicore_processcount running processes to finish. Need: $(( ${3:-0}/1000 )) (overall $((Mem_needed/1000))) MB, Available: $((Multicore_memorymax/1000)) MB"
    [ "$Mem_needed" -gt "$Multicore_memorymax" ] && [ "$Multicore_processcount" = "0" ] && note "multicore: Likely hard disk cache will be used and slow down the calculation."
    multicore_wait || return 1
  }

  ifcmdbreak && return 1

  Multicore_processcount=$((Multicore_processcount +1))

  Command="$(cut -d ' ' -f1 <<< "${1:-}")"
  case $(type -t "$Command") in
    file) Command="nice ${1:-}" ;;
    *)    Command="${1:-}" ;;
  esac

  #verbose "multicore: ${1:-}"
  eval "$Command &"

  Multicore_process[Multicore_processcount]=$!
  Multicore_image[Multicore_processcount]="${2:-}"
  Multicore_memory[Multicore_processcount]="${3:-0}"

  return 0
}
multicore_wait() {
  local Process Error=
  for Process in $(seq ${Multicore_maxprocesses:-0}); do
    [ "${Multicore_process[$Process]}" ] && {
      multicore_waitprocess "${Multicore_process[$Process]}" || {
        multicore_break
        Error=1
      }
      [ "$Error" ] && break
      [ "${Multicore_image[$Process]}" ] && showimage "${Multicore_image[$Process]}"
    }
    Multicore_process[$Process]=""
    Multicore_image[$Process]=""
    Multicore_memory[$Process]="0"
  done
  [ "$Error" ] && return 1
  Multicore_processcount=0
  return 0
}
multicore_waitprocess() {
  local Error=
  while sleep 0.2 ; do
    ps -p "${1:-}" >/dev/null || break
    ifcmdbreak && Error=1
    [ "$Error" ] && break
  done
  [ "$Error" ] && return 1
  wait "${1:-}"
  return $?
}
multicore_break() {
  local Process
  for Process in $(seq ${Multicore_maxprocesses:-0}); do
    [ "${Multicore_process[$Process]}" ] && {
      verbose "multicore_break: Sending SIGINT to $(ps -p ${Multicore_process[$Process]})"
      kill "${Multicore_process[$Process]}"
      wait "${Multicore_process[$Process]}"
      Multicore_process[$Process]=""
      Multicore_image[$Process]=""
      Multicore_memory[$Process]="0"
    }
  done
}
multicore_init() {
  # declare global variables
  local Process
  Multicore_maxprocesses="$(nproc)"
  Multicore_maxprocesses="${Multicore_maxprocesses:-1}"
  Multicore_maxprocesses="$((Multicore_maxprocesses * 2))"
  for Process in $(seq $Multicore_maxprocesses); do
    Multicore_process[$Process]=""
    Multicore_image[$Process]=""
    Multicore_memory[$Process]="0"
  done
  Multicore_processcount=0
  Multicore_minram=250000
  Multicore_maxprocesses=$Multicore_maxprocesses
}
ifcmdbreak() {
  [ -e "$Cachedir/exit" ]
  #return 1
}
printfreememory() {
  # print current free memory including zram
  local Memory Line Zram
  Memory="$(LC_ALL=C free | grep "Mem:" | LC_ALL=C awk '{print $7}')"
  while read Line; do
    Zram="$(LC_ALL=C awk 'BEGIN {OFMT = "%.0f"} {print ($3 - $4)}' <<< "$Line")"
    Zram="$(LC_ALL=C awk 'BEGIN {OFMT = "%.0f"} {print $1 / 1000}' <<< "$Zram")"
    #Memory="$((Memory + Zram))"
  done < <(/sbin/swapon --bytes | grep zram)
  echo $Memory
}

### Files

checkmagicklist() {
  ### FIXME
  magick -list "${1:-}" | grep -q -w -i "^${2:-XXX}"
}
check_outputname() {
  # Generate a unique output name showing options

  Resultbasename=""
  [ "$Align" = "yes" ] && Resultbasename="${Resultbasename}--align"

  # step colorspace
  maskarg_single "colorspace" && Resultbasename="${Resultbasename}--col=${Imarguments[$Argcount]%TYPE*}"
  # step grayscale
  maskarg_single "grayscale" && Resultbasename="${Resultbasename}--gray=${Imarguments[$Argcount]%TYPE*}"

  # step mask generation
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      contrast|channel|comparision)
        Resultbasename="${Resultbasename}--${Argmethod}=${Imarguments[$Count]%TYPE*}"
      ;;
    esac
  done

  # step merge
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      merge)
        Resultbasename="${Resultbasename}--${Argmethod}=${Imarguments[$Count]%TYPE*}"
      ;;
    esac
  done
  maskarg_single "merge"   && Resultbasename="${Resultbasename}--merge=${Imarguments[$Argcount]%TYPE*}"
  maskarg_single "level"   && Resultbasename="${Resultbasename}--level=${Imarguments[$Argcount]%TYPE*}"

  # step focus
  maskarg_single "soft"    && Resultbasename="${Resultbasename}--soft=${Imarguments[$Argcount]%TYPE*}"
  maskarg_single "less"    && Resultbasename="${Resultbasename}--less=${Imarguments[$Argcount]%TYPE*}"
  maskarg_single "cutsoft" && Resultbasename="${Resultbasename}_cutsoft=${Imarguments[$Argcount]%TYPE*}"
  maskarg_single "cutblur" && Resultbasename="${Resultbasename}_cutblur=${Imarguments[$Argcount]%TYPE*}"

  # step slabs
  [ "$Slabautoall" = "no" ] && for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      slab)
        Resultbasename="${Resultbasename}--${Argmethod}=${Imarguments[$Count]%TYPE*}"
      ;;
    esac
  done

  # step postprocessing
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      postfocus)
        Resultbasename="${Resultbasename}--${Argmethod}=${Imarguments[$Count]%TYPE*}"
      ;;
    esac
  done

  # step background
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      background)
        Resultbasename="${Resultbasename}--bg=${Imarguments[$Count]%TYPE*}"
      ;;
    esac
  done

  # misc
  [ -n "$Revertimagelist" ]   && Resultbasename="${Resultbasename}--rev"
  [ "$Storelayered" = "yes" ] && Resultbasename="${Resultbasename}--layered"
  [ -n "$Testsetup" ]         && Resultbasename="${Resultbasename}--test$Testarg"

  Fusemd5sum="$(md5cut "$Sourcemd5 ${Imoptions[@]} ${Imarguments[@]} $Testsetup$Testarg" )"

  Resultbasename="${Resultbasename#,}_md${Fusemd5sum}"
  Resultbasename="$(unspecialstring "$Resultbasename")"
  Resultbasename="$(sed "s/w100,//g ; s/w100//g ; s/,--/--/g ; s/,_/_/g ; s/=--/--/g ; s/=,/,/g ; s/=_/_/g ; s/=\./\./g" <<< "$Resultbasename")"

  [ -z "${Outputdir:-}" ] && Outputdir="./"
  case $Outputimage in
    "") Outputimage="$Outputdir/${Outputbasename:-"imfuse"}${Resultbasename}.${Imageformat}" ;;
    *) [ "$(basename "$Outputimage")" = "$Outputimage" ] && Outputimage="${Outputdir}/{$Outputimage}" ;;
  esac
  [ "$Video" ] && Video="$Outputimage.webm"

  # --savemask
  [ "$Savemask" = "auto" ] && Savemask="$Outputimage.mask.tif"

  return ${Error:-0}
}
load_sourceimages() {
  # Load source images into imagemagick registry
  # (Can also happen in align())
  local Sourceimage Count Number Command
  local Firstimage Lastimage

  Firstimage="${1:-1}"
  Lastimage="${2:-$Sourceimagenumber}"

  for Count in $(seq $Firstimage $Lastimage); do
    Number="$(printnum "$Count")"

    Command=""
    case "$Loadsourceimages" in
      yes)
        [ -z "${Imsourceimagelist[$Count]:-}" ] && {
          Imsourceimagelist[$Count]="mpr:sourceimage.$(printnum $Count)"

          sendmagickmessage "PROGRESS:Loading source image $Count / $Sourceimagenumber"
          Command="$Command
  ${Sourceimagelist[$Count]}
    -alpha off
    -depth 16
    -write $(sourceimagename $Count)
    $(showimagecode "$(sourceimagename $Count)")
    -delete 0"
          cmd "$Command"
        }
      ;;
      no)
        Imsourceimagelist[$Count]="${Sourceimagelist[$Count]}"
      ;;
    esac
  done
  [ "$Loadsourceimages" = "yes" ] && sendmagickmessage "/PROGRESS"
  cmd_waitforready

  return 0
}
masklist() {
  local Basename List=
  local Firstimage Lastimage
  Firstimage="${2:-1}"
  Lastimage="${3:-$Sourceimagenumber}"
  Basename="${1:-}"
  for Count in $(seq $Sourceimagenumber); do
    List="$List
$(maskname "$Basename" $Count)"
  done
  grep . <<< "$List" | sed -n "${Firstimage},${Lastimage}p" | tac
}
sourceimagename() {
  # print source image name number $1.
  # might be an mpr: or a file depending on $Loadsourceimages.
  #sed "${1:-}q;d" <<< "$Imsourceimagelist"
  echo "${Imsourceimagelist[${1:-}]}"
}
sourceimagelist() {
  local Count
  local Firstimage Lastimage
  Firstimage="${1:-1}"
  Lastimage="${2:-$Sourceimagenumber}"
  case "${3:-}" in
    --nompr)
      for Count in $(seq $Firstimage $Lastimage); do
        echo "${Sourceimagelist[$Count]}"
      done
    ;;
    "")
      for Count in $(seq $Firstimage $Lastimage); do
        sourceimagename $Count
      done
    ;;
  esac
}
maskexist() {
  local Count
  local Firstimage Lastimage=

  Firstimage="${2:-1}"
  [ -n "${2:-}" ] && [ -z "${3:-}" ] && Lastimage="$Firstimage"
  [ -z "$Lastimage" ]                && Lastimage="${3:-$Sourceimagenumber}"

  case "$Masktocache" in
    yes)
      for Count in $(seq $Firstimage $Lastimage); do
        [ -e $Cachedir/mask.${1:-}.$(printnum "$Count").${Masksuffix} ] || return 1
      done
      return 0
    ;;
    no)
      return 1
    ;;
  esac
}
maskname() {
  [ -z "${1:-}" ] && error "maskname(): maskbasename is empty: ${1:-} ${2:-}"
  [ -z "${2:-}" ] && error "maskname(): number not given: ${1:-} ${2:-}"
  case "$Masktocache" in
    yes)
      echo "$Cachedir/mask.${1:-}.$(printnum "${2:-}").${Masksuffix}"
    ;;
    no)
      echo "mpr:${1:-}.$(printnum "${2:-}")"
    ;;
  esac
}

### image processing helpers

align() {
  # align with focus-stack
  # https://github.com/PetteriAimonen/focus-stack

  local Log Line Image Count Command
  local X Y W H Lmax=0 Tmax=0 Rmin=10000000 Bmin=10000000
  local Aligndir

  Log="$Cachedir/align.log"
  Aligndir="$Cachedir/aligned.$Sourcemd5"
  mkdir -p "$Aligndir"

  note "Aligning source images with external tool focus-stack."
  focus-stack --verbose --output="$Aligndir/" --align-only --no-contrast --no-whitebalance ${Sourceimagelist[@]} >"$Log" || return 1

  # calculate smallest valid area common to all aligned images
  while read Line; do
    Line="$(cut -d' ' -f4- <<< "$Line")"
    X="$(digitonly "$(cut -d, -f1 <<< "$Line")" )"
    Y="$(digitonly "$(cut -d, -f2 <<< "$Line")" )"
    W="$(digitonly "$(cut -d, -f3 <<< "$Line")" )"
    H="$(digitonly "$(cut -d, -f4 <<< "$Line")" )"
    [ "$X" -gt "$Lmax" ] && Lmax="$X"
    [ "$Y" -gt "$Tmax" ] && Tmax="$Y"
    [ "$((X+W))" -lt "$Rmin" ] && Rmin="$((X+W))"
    [ "$((Y+H))" -lt "$Bmin" ] && Bmin="$((X+W))"
  done < <(grep "valid area" "$Log" ||:)
  X="$Lmax"
  Y="$Tmax"
  W="$((Rmin-Lmax-1))"
  H="$((Bmin-Tmax-1))"

  # crop aligned images to valid area, store as mpr source images
  for Count in $(seq $Sourceimagenumber); do
    Image="${Sourceimagelist[$Count]}"
    Command=""
    Number="$(printnum "$Count")"
    Image="$Aligndir/$(basename "$Image")"
    Sourceimagelist[$Count]="$Image"
    case "$Loadsourceimages" in
      yes)
        Imsourceimagelist[$Count]="mpr:sourceimage.$(printnum $Count)"
      ;;
      no)
        Imsourceimagelist[$Count]="$Image"
      ;;
    esac
    Command="$Command
  $(sendmagickmessage "PROGRESS:Cropping aligned images ${W}x${H}+${X}+${Y} $Count / $Sourceimagenumber")"
    Command="$Command
  $Image
    -crop ${W}x${H}+${X}+${Y}
    -write $(sourceimagename $Count)
    $(showimagecode "$(sourceimagename $Count)")
    -delete 0"
    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"
  cmd_waitforready

  Sourcemd5="$(md5cut "$(ls -f -l --full-time ${Sourceimagelist[@]})" )"

  case "$Loadsourceimages" in
    yes)
      Sourceimagesalreadyloaded="yes"
      #rm -r "$Aligndir" # enfuse would need it
    ;;
  esac

  return 0
}
alphalevel() {
  local Command Image Mask Level Clut= Clutimage
  local Longoptions Parsedoptions

  Longoptions="image:,mask:,level:,clut:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --image)        Image="${2:-}" ; shift ;;
      --mask)         Mask="${2:-}"  ; shift ;;
      --level)        Level="${2:-}" ; shift ;;
      --clut)         Clut="${2:-}"  ; shift ;;
    esac
    shift
  done

  [ -z "$Image" ] && return 1
  Level="${Level:-0x100}"
  Level="$(levelparse "$Level")"
  Level="$(levelpercent "$Level")"

  Command="
  ## alphalevel()
  '$Image'
    -write mpr:al_image
    -delete 0"
  case "$Mask" in
    "")
      Command="$Command
  mpr:al_image
    -channel alpha
    -separate
    -write mpr:al_mask
    -delete 0"
    ;;
    *)
      Command="$Command
  $Mask
    -write mpr:al_mask
    -delete 0"
    ;;
  esac

  [ "$Clut" ] && {
    Command="$Command
  -size 256x256
  gradient:
    -rotate 90
    -depth 16
    -sigmoidal-contrast ${Clut}%
    -write mpr:al_clut
    -delete 0
  mpr:al_mask
  mpr:al_clut
    -clut
    -write mpr:al_mask
    -delete 0"
  }

  Command="$Command
  mpr:al_mask
    +level $Level
    -write mpr:al_mask
    -delete 0"

  case "$Mask" in
    "") ;;
    *)
      Command="$Command
  mpr:al_mask
    -write $Mask
    -delete 0"
    ;;
  esac

  Command="$Command
  mpr:al_image
  mpr:al_mask
    -alpha off
    -compose CopyOpacity -composite
    $Tifstorealpha
    -write $Image
    -delete 0"

  Command="$Command
  +set registry:al_clut
  +set registry:al_image
  +set registry:al_mask"

  Command="$Command
  ## /alphalevel()"

  cmd "$Command"
  cmd_waitforready
  return 0
}
clut_gaussian() {
  # create gaussian clut image $1 with sigma $2
  local Command Clutimage Sigma
  Clutimage="${1:-}"
  Sigma="${2:-1}"
  Command="
  -size 1x1
  xc:white
    -bordercolor Black
    -border 2x0
    -filter gaussian
    -define filter:sigma=$Sigma
    -resize 512x256!
    -crop 50%x100%+0+0
    -auto-level
    -write $Clutimage
    -delete -1"
  cmd "$Command"
  cmd_waitforready
}
enfuse_split() {
  local Resultimage Enfuseoptions
  local Command Count
  local Firstimage Lastimage
  local Mem_free Mem_needed
  local Splitimagelist= Splitimagename Splitresult= Splitcache Split Splits Splitwidth

  Resultimage="${1:-}"
  Firstimage="${2:-1}"
  Lastimage="${3:-$Sourceimagenumber}"

  Mem_free="$(printfreememory)"
  Mem_needed="$(( (Lastimage-Firstimage+1) * Imagewidth*Imageheight * 2 * 32 / (8*1024)))"
  Enfuseoptions="--contrast-weight=1 --saturation-weight=0 --exposure-weight=0 --hard-mask"

  sendmagickmessage "NOTE:Generating image with external tool enfuse"

  ### Single run attempt
  [ "$Mem_needed" -lt "$Mem_free" ] && {
    nice enfuse $Enfuseoptions -o "$Resultimage" $(sourceimagelist $Firstimage $Lastimage --nompr) 2>&1 | grep -v -E "loading next image|assuming all pixels should contribute|does not have an alpha channel|TIFFDecoder" || error "Failed to generate enfuse image"
    return "${Error:-0}"
  }

  ### Splitting attempt
  note "enfuse: Splitting source images due to low memory."

  Splits="$((Mem_needed / Mem_free +1))"
  Splitwidth=$((Imagewidth/Splits))
  Splitcache="$Cachedir/enfuse.split"
  mkdir -p "$Splitcache"

  for Split in $(seq $Splits); do
    Splitgeometry[$Split]="$((Splitwidth + $([ "$Split" -lt "$Splits" ] && echo 20 || echo 0) ))x${Imageheight}+$(( (Split -1) * Splitwidth ))+0"
  done

  load_sourceimages $Firstimage $Lastimage
  for Count in $(seq $Firstimage $Lastimage); do
    sendmagickmessage "PROGRESS:enfuse: Splitting source images into $Splits parts step $Count / $Lastimage"
    Command="
  ${Sourceimagelist[$Count]}
    -write mpr:sourceimage
    -delete 0"
    for Split in $(seq $Splits); do
      Splitimagename="$Splitcache/split.$(printnum $Count).${Split}.png"
      Command="$Command
  mpr:sourceimage
    -crop ${Splitgeometry[$Split]}
    -write ${Splitimagename}
    -delete 0"
      Splitimagelist[$Split]="${Splitimagelist[$Split]:-} $Splitimagename"
    done
    #cmd "$Command"
    multicore "$Magickbin $(tr -d "\n" <<< "$Command") -exit"
  done
  multicore_wait
  sendmagickmessage "/PROGRESS"
  #cmd_waitforready

  for Split in $(seq $Splits); do
    note "Running enfuse step $Split / $Splits"
    Splitresult[$Split]="$Splitcache/splitresult${Split}.png"
    nice enfuse $Enfuseoptions -o "${Splitresult[$Split]}" ${Splitimagelist[$Split]} 2>&1 | grep -v -E "loading next image|assuming all pixels should contribute|does not have an alpha channel|TIFFDecoder" || error "Failed to generate enfuse image"
    showimage "$Splitresult[$Split]"
  done

  sendmagickmessage "NOTE:enfuse: Appending splits to result"
  Command="
  mpr:black
    -write mpr:resultimage
    -delete 0"
  for Split in $(seq $Splits); do
    Command="$Command
  mpr:resultimage
    ${Splitresult[$Split]}
    -geometry +$(( (Split -1) * Splitwidth ))+0
    -composite
    -write mpr:resultimage
    -delete 0"
  done
  Command="$Command
  mpr:resultimage
    $Tifstore
    -write $Resultimage
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  rm -r "$Splitcache"

  return 0
}
evaluate() {
  local Imagelist Imagenumber=0 Resultimage Mode
  local Command

  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  while [ $# -gt 0 ]; do
    Imagenumber="$((Imagenumber+1))"
    Imagelist[$Imagenumber]="${1:-}"
    shift
  done

  sendmagickmessage "NOTE:Evaluating $Mode: $Resultimage"

  [ "$Loadsourceimages" = "no" ] && {
    case "$Mode" in
      max|min|mean)
        #evaluate_splitlist "$Mode" "$Resultimage" "${Imagelist[@]}"
        evaluate_iterative "$Mode" "$Resultimage" "${Imagelist[@]}"
        return 0
      ;;
    esac
  }

  Command="
  # evaluate() $Mode: $Resultimage
  ${Imagelist[@]}
    -alpha off
    -evaluate-sequence $Mode
    $Tifstore
    -write $Resultimage
    $(showimagecode "$Resultimage")
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  return 0
}
evaluate_iterative() {
  # supports min, max, mean
  # loads images one by one instead all of them

  local Imagelist Imagenumber=0 Resultimage Mode
  local Command

  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  while [ $# -gt 0 ]; do
    Imagenumber="$((Imagenumber+1))"
    Imagelist[$Imagenumber]="${1:-}"
    shift
  done
  case "$Mode" in
    max) Mode="lighten" ;;
    min) Mode="darken" ;;
  esac

  Command="
  ${Imagelist[1]}"
  case "$Mode" in
    darken|lighten)
      for Count in $(seq 2 $Imagenumber); do
        Command="$Command
  ${Imagelist[$Count]}
    -format 'PROGRESS:Composing $Count / $Imagenumber\n'
    -write info:
    -compose $Mode -composite
    $(showimagecode)"
      done
    ;;
    mean)
      for Count in $(seq 2 $Imagenumber); do
        Command="$Command
  ${Imagelist[$Count]}
    -alpha off
    -format 'PROGRESS:Composing $Count / $Imagenumber\n'
    -write info:
    -compose blend
    -set option:compose:args $(calc 100/$Count)
    -composite
    $(showimagecode)"
      done
    ;;
    *)
      error "evaluate_iterative(): Unsupported mode: $Mode"
    ;;
  esac
  Command="$Command
    -write $Resultimage
    -delete 0"
  cmd "$Command"
  cmd_waitforready
  sendmagickmessage "/PROGRESS"

  return 0
}
evaluate_stepwise() {
  # same as evaluate-sequence max or min,
  # but loads images one by one into ram instead of altogether.
  # $1 mode. Supported: max min 
  # $2 result image
  # $@ source images
  
  local Mode Composemode Resultimage Sourceimagelist Command Line Firstimage Count
  local Startzeit Dauer

  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  Firstimage="${1:-}" ; shift
  Sourceimagelist=""
  while [ $# -gt 0 ]; do
    Sourceimagelist="$Sourceimagelist
${1:-}"
    shift
  done
  Sourceimagelist="$(grep . <<< "$Sourceimagelist")"
  
  case $Mode in
    max) Composemode="Lighten" ;;
    min) Composemode="Darken" ;;
    mean) ;;
    *) 
      error "evaluate_stepwise(): Unsupported mode: $Mode"
      return 1
    ;;
  esac
  
  case $Mode in
    min|max)
      Command="$Magickbin
  $Firstimage"
      while read Line; do
        Command="$Command
  $Line
    -alpha off
    -compose $Composemode -composite"
      done <<< "$Sourceimagelist"
      Command="$Command 
  $Resultimage"
    ;;
    mean)
      Command="$Magickbin
  $Firstimage"
      Count=1
      while read Line; do
        Count="$((Count+1))"
        Command="$Command
  $Line
    -alpha off
    -compose blend
    -set option:compose:args $(calc 100/$Count)
    -composite"
      done <<< "$Sourceimagelist"
      Command="$Command
  $Resultimage"
    ;;
  esac

  Startzeit="$(date +%s)"
  verbose "evaluate_stepwise(): $Mode $Resultimage"
  $Command || {
    error "Error in evaluate_stepwise():
$Command"
  return 1
  }
  Dauer="$(( $(date +%s)-Startzeit))"
  verbose "Duration: $(date -u -d @$Dauer +"%T")"
  showimage "$Resultimage"
}
evaluate_splitlist() {

  local Imagelist Imagenumber=0 Resultimage Mode
  local Command
  local Split Splits Splitresult Splitfirstimage Splitlastimage
  local Mem_free Mem_needed

  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  while [ $# -gt 0 ]; do
    Imagenumber="$((Imagenumber+1))"
    Imagelist[$Imagenumber]="${1:-}"
    shift
  done

  Splits="$(nproc)"
  Mem_free="$(printfreememory)"
  Mem_free="$((Mem_free * 8/10))"
  Mem_needed="$((Imagenumber * Imagememsize))"

  while [ "$((Mem_needed / Splits))" -gt "$Mem_free" ]; do
    Splits="$((Splits +1))"
  done
  [ "$Splits" -lt "1" ] && Splits=1
  Splits="$((Splits+1))"

  for Split in $(seq $Splits); do
    Splitfirstimage[$Split]="$(( (Split-1)*Imagenumber/Splits +1))"
    Splitlastimage[$Split]="$(( (Split)*Imagenumber/Splits +1))"
    [ "${Splitlastimage[$Split]}" -gt "$Imagenumber" ] && Splitlastimage[$Split]="$Imagenumber"
    Splitresult[$Split]="$Cachedir/evalsplit_$Mode.$Split.mpc"
  done

  sendmagickmessage "NOTE:evaluating in $Splits tasks outside of script"

  for Split in $(seq $Splits); do
#  -limit memory ${Mem_free}KB
#  -define registry:temporary-path=$Cachedir
    Command="$Magickbin
  ${Imagelist[@]:${Splitfirstimage[$Split]}:${Splitlastimage[$Split]}}
    -evaluate-sequence $Mode
    -write ${Splitresult[$Split]}
    -delete 0
    -exit"
    multicore "$(tr -d "\n" <<< "$Command")" "${Splitresult[$Split]}" "$(( Imagememsize * (${Splitlastimage[$Split]}-${Splitfirstimage[$Split]}+1) ))"
  done
  multicore_wait

  Command="
  ${Splitresult[@]}
    -evaluate-sequence $Mode
    -write $Resultimage
    -delete 0"
  cmd "$Command"
  cmd_waitforready
}
exiftransfer() {
  # Transfer exif data from image $1 to image $2
  # Does not transfer image size information.
  # Sets orientation tag to horizontal / no rotation.
  # Several warnings are supressed.
  local Sourceimage Destinationimage Exifargs
  
  Sourceimage="${1:-}"
  Destinationimage="${2:-}"
  Exifargs="$(exiftool -a -u -g1 -args "$Sourceimage")"
  Exifargs="$(LC_ALL=C grep -v -E -- \
    '-ExifTool|-System:|-File:|ImageWidth|ImageHeight|ImageSize|Compression|Orientation|Resolution' <<< "$Exifargs" \
    | sed "s/'/'\"'\"'/g ; s/=/='/ ; s/\$/'/" )"
  eval exiftool -ignoreMinorErrors -overwrite_original_in_place $Exifargs -Orientation=Horizontal "$Destinationimage" 2>&1 | grep -v -E 'Warning|files updated'
}
finalblur() {
  local Image Mask Percent Sigma1 Sigma2 Command Error
  local Longoptions Parsedoptions

  Longoptions="image:,mask:,percent:,sigma1:,sigma2:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --image)   Image="${2:-}" ;;
      --mask)    Mask="${2:-}" ;;
      --percent) Percent="${2:-}" ;;
      --sigma1)  Sigma1="${2:-}" ;;
      --sigma2)  Sigma2="${2:-}" ;;
    esac
    shift
    shift
  done
  Sigma1="${Sigma1:-1}"
  Sigma2="${Sigma2:-0}"
  Percent="${Percent:-50}"

  Command="
  # --finalblur
  $Image
    -write mpr:image
    -delete 0
  $Mask
    -write mpr:maxmask
    -delete 0
  mpr:maxmask
    -threshold ${Percent:-10}%
    -negate
    -write mpr:cutmask
    -delete 0"
    Command="$Command
  mpr:image
    -alpha off
    -blur 0x$Sigma1
    -write mpr:bokeh
    -delete 0
  mpr:bokeh
  ( mpr:cutmask -blur 0x$Sigma2 )
    -alpha off
    -compose CopyOpacity -composite
    -write mpr:partsource_blurred
    -delete 0
  mpr:image
  mpr:partsource_blurred
    -compose Over -composite
    -write $Image
    $(showimagecode)
    -delete 0
  +set registry:bokeh
  +set registry:cutmask
  +set registry:image
  +set registry:maxmask
  +set registry:partsource_blurred"

  cmd "$Command"
  cmd_waitforready
  return 0
}
finalblur2() {
  # --finalblur2

  local Longoptions Parsedoptions
  local Image Threshold Blur Mask
  local Command

  Longoptions="image:,mask:,percent:,blur:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --blur)    Blur="${2:-}" ;;
      --image)   Image="${2:-}" ;;
      --mask)    Mask="${2:-}" ;;
      --percent) Threshold="${2:-}" ;;
    esac
    shift
    shift
  done

  Command="
  # --finalblur
  $Image
    -write mpr:image
    -delete 0
  $Mask
    -write mpr:mask
    -delete 0
  mpr:mask
    -white-threshold ${Threshold}%
    -negate
    -write mpr:mask
    -delete 0
  mpr:image
  mpr:mask
    -compose Blur
    -set option:compose:args ${Blur}x${Blur}
    -composite
    -write $Image
    $(showimagecode "$Image")
    -delete 0
"
  cmd "$Command"
  cmd_waitforready
}
generate_image() {
  local Mode Imagename= Swap Imagetype Showname= Command Size 
  local Generalimage= Skip=
  local Longoptions Parsedoptions
  local Firstimage Lastimage

  Longoptions="first:,last:,mode:,name:,showname"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --first)    Firstimage="${2:-}" ; shift ;;
      --last)     Lastimage="${2:-}" ; shift ;;
      --mode)     Mode="${2:-}" ; shift ;;
      --name)     Imagename="${2:-}" ; shift ;;
      --showname) Showname="yes" ;;
    esac
    shift
  done

  Firstimage="${Firstimage:-1}"
  Lastimage="${Lastimage:-$Sourceimagenumber}"
  Size="${Imagewidth}x${Imageheight}"

  checkmagicklist color                     "$Mode"   && Imagetype="color"
  checkmagicklist evaluate                  "$Mode"   && Imagetype="evaluate"
  checkmagicklist compose  "$(tr -d "2" <<< "$Mode")" && Imagetype="compose"
  case "$Mode" in
    enfuse)                                              Imagetype="enfuse" ;;
  esac

  [ -z "$Imagename" ] && {
    Generalimage="yes"
    case "$Imagetype" in
      enfuse)     Imagename="$Cachedir/enfuse.${Firstimage}..${Lastimage}.$Sourcemd5.tif" ;;
      evaluate)   Imagename="$Cachedir/evaluate.${Firstimage}..${Lastimage}.$Mode.$Sourcemd5.mpc" ;;
      compose)    Imagename="$Cachedir/compose.${Firstimage}..${Lastimage}.$Mode.$Sourcemd5.mpc" ;;
      color)      Imagename="mpr:$Mode" ;;
    esac
  }

  [ "$Showname" ] && {
    echo "$Imagename"
    return 0
  }

  [ "$Generalimage" = "yes" ] && case $Imagetype in
    color) ;;
    *) [ -e "$Imagename" ] && Skip="yes" ;;
  esac

  sendmagickmessage "NOTE:Generating image $Imagename"
  [ "$Skip" = "yes" ] && {
    sendmagickmessage "NOTE:Skipping image generation, already exists: $Imagename"
    return 0
  }

  case "$Imagetype" in
    enfuse) ### FIXME first..last
      enfuse_split "$Imagename" ${Firstimage} ${Lastimage}
    ;;
    evaluate)
      load_sourceimages ### FIXME first..last
      evaluate "$Mode" "$Imagename" $(sourceimagelist $Firstimage $Lastimage)
    ;;
    compose)
      grep -q "2" <<< "$Mode" && Swap="-swap 0,1" || Swap=""
      Mode="$(tr -d "2" <<< "$Mode")"
      generate_image --mode min --first $Firstimage
      generate_image --mode max --last $Lastimage

      Command="
  $(generate_image --showname --mode min --first $Firstimage --last $Lastimage)
  $(generate_image --showname --mode max --first $Firstimage --last $Lastimage)
    -alpha off
    $Swap
    -compose $Mode -composite
    -write $Imagename
    $(showimagecode "$Imagename")
    -delete 0"

      cmd "$Command"
      cmd_waitforready
    ;;
    color)
      Command="
  -size $Size
  canvas:$Mode
    $Tifstorealpha
    -write $Imagename
    -delete 0"
      cmd "$Command"
      cmd_waitforready
    ;;
  esac

  return 0
}
generate_video() {
  note "Generating video $Video"
  Videoframerate=5
  #nice ffmpeg -y -hide_banner -nostdin  -r $Videoframerate -f image2 -start_number 1 -i $Framedir/frame%04d.$Imageformat $Destinationfile || note "ERROR in video generation"
  [ -f "$Video" ] && rm "$Video"
  nice ffmpeg -y -hide_banner -nostdin  -r $Videoframerate -f image2 -start_number 1 -i "$Cachedir/videoframe%04d.$Imageformat" "$Video" || note "ERROR in video generation"
  rm $Cachedir/videoframe*
  ffplay "$Video"
}
level_masks() {
  local Maskbasename Maskmax Maskmin Maskmd5 Clutimage Resultmask
  local Count Mask Masklist Levelmin Levelmax
  local Longoptions Parsedoptions
  local Firstimage Lastimage

  Longoptions="first:,last:,name:,output:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --first)    Firstimage="${2:-}" ; shift ;;
      --last)     Lastimage="${2:-}" ; shift ;;
      --name)     Maskbasename="${2:-}" ; shift ;;
      --output)   Outputbasename="${2:-}" ; shift ;;
    esac
    shift
  done

  Maskbasename="${Maskbasename:-NO_MASK_SPECIFIED}"
  Firstimage="${Firstimage:-1}"
  Lastimage="${Lastimage:-$Sourceimagenumber}"
  Outputbasename="${Outputbasename:-"$Maskbasename"}"

  Masklist="$(masklist "$Maskbasename" "$Firstimage" "$Lastimage")"
  Maskmax="mpr:maskmax"
  Maskmin="mpr:maskmin"
  Clutimage="mpr:clut"

  sendmagickmessage "NOTE:Leveling $Maskbasename"

  evaluate max $Maskmax $Masklist
  Levelmax="$(getmagickinfo "$Maskmax" '%[fx:maxima*100]')"
  Levelmin="$(maskarg_defaultvalue $Argmethod levelmin)"
  echo "max:$Argmethod:$Levelmax" >> ~/imfuse.statistic.level
  [ -z "$Levelmin" ] && {
    evaluate min $Maskmin $Masklist
    Levelmin="$(getmagickinfo "$Maskmin" '%[fx:minima*100]')"
    echo "min:$Argmethod:$Levelmin" >> ~/imfuse.statistic.level
  }

  compare "$Levelmin" lt "1" && compare "$Levelmax" gt "99" && [ "$Maskbasename" = "$Outputbasename" ] && {
    sendmagickmessage "Skipping level, range is greater than 1%..99%"
    return 0
  }

  Command="
  $Maskmax
    -level ${Levelmin}%,${Levelmax}%
    -write $Maskmax
    -delete 0"
  cmd "$Command"
  cmd_waitforready
  mkclut_uniform "$Maskmax" "$Clutimage"

  for Count in $(seq $Lastimage -1 $Firstimage); do
    sendmagickmessage "PROGRESS:Mask leveling $Maskbasename ${Levelmin}%,${Levelmax}% step $Count / $Sourceimagenumber"

    Command="
  $(maskname "$Maskbasename" "$Count")
    -level ${Levelmin}%,${Levelmax}%
  $Clutimage
    -clut
    -write $(maskname "$Outputbasename" "$Count")
    $(showimagecode "$(maskname "$Outputbasename" "$Count")")
    -delete 0"

    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"
  cmd_waitforready

  return "${Error:-0}"
}
maskfromimage() {
  # Generate masks with basename $2 based on comparision with a single image $1
  local Imagename Maskbasename Sourceimage Maskname
  local Command Count

  Imagename="${1:-}"
  Maskbasename="${2:-}"

  sendmagickmessage "NOTE:Generating mask comparing with image $Imagename"
  for Count in $(seq $Sourceimagenumber); do
    Maskname="$(maskname "$Maskbasename" "$Count")"
    Sourceimage="$(sourceimagename $Count)"

    Command="$Command
  $(sendmagickmessage "PROGRESS:image comparision mask step $Count / $Sourceimagenumber")"

    Command="
  '$Imagename' 
    -write mpr:image
    -delete 0
  mpr:image
    -channel alpha
    -separate
    -write mpr:alpha
    -delete 0
  mpr:image
    $Grayscaleconverter
  ( '$Sourceimage' $Grayscaleconverter )
    -compose Difference -composite
    -alpha off 
    -negate
    -write mpr:diffmask
    -delete 0
  mpr:diffmask
### FIXME
#  mpr:alpha
#    -compose multiply -composite
    -write '$Maskname'
    $(showimagecode "$Maskname")
    -delete 0"

    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"
  cmd_waitforready

  return 0
}
mkclut_uniform() {
  # generate a clut image to uniform distribution in level_masks()
  # contains code parts from http://www.fmwconcepts.com/imagemagick/mkclut_uniform/
  local Referenceimage Clutimage Netpbm Netpbmdata
  local Histogramarray Colorcountarray Totalpixel Lutlist Expo Quantumrange Factor
  local Command Key1 Key2 Count

  Referenceimage="${1:-}"
  Clutimage="${2:-}"

  Quantumrange="$(getmagickinfo $Referenceimage "%[fx:quantumrange]")"
  Expo="$(getmagickinfo rose: "%[fx:e]")" 

  # FIXME use 16 bit depth?
  Key1="$(generate_key)"
  Key2="$(generate_key)"
  Command="
  $Referenceimage
    -colorspace gray
    -depth 8
    -format '\n$Key1\n%c$Key2\n'
    -write histogram:info:-
    -delete 0"
  cmd "$Command"
  cmd_waitforready
  Histogramarray="$(sed -n "/$Key1/,/$Key2/p" $Magickfifolog | sed '1d ; $d')"
  Histogramarray=($(echo "$Histogramarray" | sed -n  's/[ ]*\([0-9]*\).*gray[(]\([0-9]*\).*$/\1 \2/p' \
                                           | LC_ALL=C awk     '{ bin[int($2)] += $1; } 
                                                      END { for (i=0;i<256;i++) {hist = bin[i]+0; print hist; } } ' ) )
  Colorcountarray=($(echo ${Histogramarray[*]} | LC_ALL=C awk '{ split($0,count," ") }
                                                       END { for (i=0;i<256;i++) { cum += count[i]; print cum } }' ))
  Totalpixel=${Colorcountarray[255]}
  Factor="$(getmagickinfo rose: "%[fx:$Quantumrange/$Totalpixel]")"
  Lutlist="$(for ((Count=0; Count<256; Count++)); do
    echo "${Colorcountarray[$Count]}"
  done | LC_ALL=C awk -v Factor="$Factor" '{ print int(Factor*$1); }')"

  Netpbm="P2 256 1 $Quantumrange $Lutlist"
  Netpbmdata="$(base64 <<< "$Netpbm")"
  sendmagickmessage "Content of encoded NetPBM clut image: $(echo "$Netpbm" | tr "\n" " ")"
  Command="
  'inline:data:image/netpbm;base64,
$Netpbmdata
'
    -scale 256x1\!
    -write $Clutimage
    -delete 0"
  cmd "$Command"
  cmd_waitforready
  return 0
}
threshold() {
  local Mask Image= Blackthreshold Whitethreshold Thresholdblur Cutmask= Cutimage=
  local Command
  local Longoptions Parsedoptions

  Longoptions="image:,mask:,percent1:,percent2:,blur:,cutmask::,cutimage::"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --blur)     Thresholdblur="${2:-}" ; shift ;;
      --mask)     Mask="${2:-}" ; shift ;;
      --image)    Image="${2:-}" ; shift ;;
      --percent1) Blackthreshold="${2:-}" ; shift ;;
      --percent2) Whitethreshold="${2:-}" ; shift ;;
      --cutmask)  Cutmask="${2:-"soft"}" ; shift ;;
      --cutimage) Cutimage="${2:-"soft"}" ; shift ;;
    esac
    shift
  done

  Blackthreshold="${Blackthreshold:-0}"
  Whitethreshold="${Whitethreshold:-100}"
  Thresholdblur="${Thresholdblur:-0}"

  Command="
  $Mask
    -alpha off
    -write mpr:mask
    -delete 0
  mpr:mask
    -threshold ${Blackthreshold}%
    -write mpr:blackthreshold
    -delete 0
  mpr:mask
    -threshold $((Whitethreshold))%
    -negate
    -write mpr:whitethreshold
    -delete 0
  mpr:blackthreshold
  mpr:whitethreshold
    -compose Darken -composite
    -write mpr:threshold
    -delete 0"
  [ "$Thresholdblur" -gt "0" ] && Command="$Command
  mpr:threshold
    -blur 0x$Thresholdblur
    -write mpr:threshold
    -delete 0"
  case "$Cutmask" in
    soft)
      Command="$Command
  mpr:mask
  mpr:threshold
    -compose Lighten -composite
    -write mpr:mask
    -delete 0
  mpr:mask
    -write $Mask
    -delete 0"
    ;;
    hard)
      Command="$Command
  mpr:threshold
    -write $Mask
    -delete 0"
    ;;
  esac
  case "$Cutimage" in
    soft)
      Command="$Command
  mpr:mask
  mpr:threshold
    -compose Lighten -composite
    -write mpr:mask
    -delete 0
  $Image
  mpr:mask
    -alpha off
    -compose CopyOpacity -composite
    -write $Image
    -delete 0"
    ;;
    hard)
      Command="$Command
  $Image
  mpr:threshold
    -alpha off
    -compose CopyOpacity -composite
    -write $Image
    -delete 0"
    ;;
  esac
  Command="$Command
  +set registry:mask
  +set registry:threshold
  +set registry:whitethreshold
  +set registry:blackthreshold"

  cmd "$Command"
  cmd_waitforready
  return 0
}

# core focus stack routines

focus_maskmethod() {
  # Mask generating ImageMagick options
  # Most of them are based on edge detection: http://www.imagemagick.org/Usage/convolve/#edgedet
  local Method Sourceimage Enfuseimage
  local Maskgenerator=
  local Firstimage Lastimage

  Method="${1:-none}"
  Firstimage="${2:-1}"
  Lastimage="${3:-$Sourceimagenumber}"

  case $Method in
    blur)
      Maskgenerator="
  # --blur
  mpr:sourcegray
    -blur ${Argradius1:-0}x${Argsigma1:-0.75}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    channel|saturation|chroma|lightness|darkness)
      Maskgenerator="$Maskgenerator
  # --$Method
  mpr:sourceimage
    -colorspace ${Argword1:-HSB} 
    -channel ${Argword2:-1} -separate
    +channel"
      [ "$Method" = "darkness" ] && Maskgenerator="$Maskgenerator
    -negate"
    ;;
    comet) ### FIXME saturate drops some angles
      Maskgenerator="
  # --comet
  mpr:sourcegray 
    -define morphology:compose=${Argword1:-Lighten}
    -morphology Convolve Comet:${Argradius1:-0}x${Argsigma1:-5}:>
  mpr:sourcegray
    -compose difference -composite"
    ;;
    compass)
      Maskgenerator="
  # --compass
  mpr:sourcegray
    -define convolve:scale=50%!
    -define morphology:compose=Lighten
    -define convolve:bias=50%
    -morphology Convolve Compass:>"
#-compose Difference -composite" # sort of interesting.
    ;;
    compose)
      Maskgenerator="
  # --compose=$Argword1
  ( mpr:sourcegray -alpha off )
  ( '$(generate_image --showname --mode "$Argword1" --first $Firstimage --last $Lastimage)' $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    diffstat)
      Maskgenerator="
  # --diffstat"
      [ "$Argword1" = "source" ] && {
        Maskgenerator="$Maskgenerator
  mpr:sourcegray"
      } || {
        Maskgenerator="$Maskgenerator
  ( mpr:sourcegray -statistic ${Argword1:-median} ${Argradius1:-5} )"
      }
      [ "$Argword2" = "source" ] && {
        Maskgenerator="$Maskgenerator
  mpr:sourcegray"
      } || {
        Maskgenerator="$Maskgenerator
  ( mpr:sourcegray -statistic ${Argword2:-mean} ${Argradius1:-5} )"
Maskgenerator="$Maskgenerator
    -compose Difference -composite"
      }
    ;;
    dog) # DoG: Difference of Gaussian
      Maskgenerator="
  # --dog
  mpr:sourcegray
    -define convolve:scale=100,100%
    -morphology Convolve DoG:${Argradius1:-0},${Argsigma1:-0.75},${Argsigma2:-1.2}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    enfuse)
      Maskgenerator="
  # --enfuse
  ( mpr:sourcegray -alpha off )
  ( '$(generate_image --showname --mode enfuse --first $Firstimage --last $Lastimage)' $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    evaluate|min|max|mean|median)
      Maskgenerator="
  # --${Argword1:-$Method}
  ( mpr:sourcegray -alpha off )
  ( '$(generate_image --showname --mode "${Argword1:-$Method}" --first $Firstimage --last $Lastimage)' $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    GAUSSexperimental) 
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=-100,200%
    -morphology Convolve Gaussian:${Argradius1:-0}x${Argsigma1:-0.75}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    CROSSMORPHexperimental)
      Maskgenerator="
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1:-3}x1+1+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1:-3}x1+${Argradius1:-3}+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:1x${Argradius1:-3}+0+1 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:1x${Argradius1:-3}+0+${Argradius1:-3} )
    -evaluate-sequence min"
    ;;
    CROSSMORPH2experimental)
      Maskgenerator="
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1}x$((Argradius1/2))+0+$((Argradius1/4)) )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1}x$((Argradius1/2))+$((Argradius1-1))+$((Argradius1/4)) )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:$((Argradius1/2))x$((Argradius1))+$((Argradius1/4))+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:$((Argradius1/2))x$((Argradius1))+$((Argradius1/4))+$((Argradius1-1)) )
    -evaluate-sequence min"
    ;;
    experimental)
      Maskgenerator="
  # --experimental
  ( mpr:sourcegray -colorspace HSB -channel 1 -separate +channel )
    -statistic standarddeviation ${Argradius1:-2}x${Argradius1:-2}"
    ;;
    free)
      Maskgenerator="
  # --free='$Argword1'
  mpr:sourcegray 
    $Argword1"
    ;;
    freediff)
      Maskgenerator="
  # --freediff='$Argword1'
  mpr:sourcegray 
    $Argword1
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    freichen)
      case $Argword1 in
        "")
          Maskgenerator="
  # --freichen
  (
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:1>
  )
  (
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:2>
  )
    -compose Screen
    -composite"
        ;;
        *)
          Maskgenerator="
  # --freichen=$Argword1
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=10%
    -morphology Convolve FreiChen:${Argword1:-0}>"
        ;;
      esac
    ;;
    gaussian)
      Maskgenerator="
  # --gaussian ${Argradius1:-0}x${Argsigma1:-0.75}
  ( mpr:sourcegray -gaussian-blur ${Argradius1:-0}x${Argsigma1:-0.75} )
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    XXXhalo)
      Maskgenerator="
  mpr:sourcegray
    -threshold $(calc "100-${Argpercent1:-50}")%
    -write mpr:halomask
    -delete 0
  mpr:sourcegray
    -brightness-contrast -23,-100
  mpr:halomask
    -compose CopyOpacity -composite
  mpr:sourcegray
    -compose DstOver -composite    
    "
    ;;
    halo)
      Maskgenerator="
  # --halo
  mpr:sourcegray
    -threshold $(calc "100-${Argpercent1:-50}")%
    -morphology Dilate Octagon:${Argradius1:-2}
    -blur 0x${Argsigma1:-5}
    -auto-level
    -negate"
    ;;
    image)
      Maskgenerator="
  # --image
  ( mpr:sourcegray -alpha off )
  ( '$Argword1' $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    kirsch)
      Maskgenerator="
  # --kirsch
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=screen
    -define convolve:bias=15%
    -morphology Convolve Kirsch:>"
    ;;
    laplacian)
      Maskgenerator="
  # --laplacian
  mpr:sourcegray
    -define convolve:bias=5%
    -define convolve:scale=100%!
    -morphology Convolve Laplacian:${Argword1:-0}>"
    ;;
    log)  # LoG: Laplacian of Gaussian
      Maskgenerator="
  # --log
  mpr:sourcegray
    -define convolve:scale=100,100%
    -morphology Convolve LoG:${Argradius1:-0}x${Argsigma1:-0.75}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    morphology)
      Maskgenerator="
  # --morphology
  mpr:sourcegray
    -morphology ${Argword1:-edge}:${Argradius2:-1} Octagon:${Argradius1:-1}"
    ;;
    none)
      Maskgenerator="
  # --none
  mpr:sourcegray"
    ;;
    prewitt)
      Maskgenerator="
  # --prewitt
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=screen
    -define convolve:bias=10%
    -morphology Convolve Prewitt:>"
    ;;
    roberts)
      Maskgenerator="
  # --roberts
  mpr:sourcegray
    -define convolve:scale=100%
    -define morphology:compose=screen
    -define convolve:bias=10%
    -morphology Convolve Roberts:@"
    ;;
    sobel)
      Maskgenerator="
  # --sobel
  mpr:sourcegray
    -define convolve:scale=100%!
    -define convolve:bias=10%
    -define morphology:compose=screen
    -morphology Convolve Sobel:>"
    ;;
    statistic)
      Maskgenerator="
  # --statistic
  mpr:sourcegray
    -statistic ${Argword1:-standarddeviation} ${Argradius1:-2}x${Argradius1:-2}"
    ;;
    unsharp)
      Maskgenerator="
  # --unsharp
  mpr:sourcegray -unsharp ${Argradius1:-0}x${Argsigma1:-5}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    wavelet)
      Maskgenerator="
  # --wavelet
  mpr:sourcegray 
    -wavelet-denoise ${Argpercent1:-10}%
  mpr:sourcegray
    -compose Difference -composite"
    ;;
  esac

  grep . <<< "$Maskgenerator"
}
focus_generate_masks() {
  local Maskgenerator Maskgenerator_all= Basenamelist= Maskready= Maskmax Mode Line Imagename Command= Maskmd5 Count
  local Longoptions Parsedoptions
  local Firstimage Lastimage

  Longoptions="first:,last:,type:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --first)    Firstimage="${2:-}" ; shift ;;
      --last)     Lastimage="${2:-}" ; shift ;;
      --type)     Masktype="${2:-}" ; shift ;;
    esac
    shift
  done

  Firstimage="${Firstimage:-1}"
  Lastimage="${Lastimage:-$Sourceimagenumber}"
  Masktype="${Masktype:-"contrast,image,channel"}"

  # Generate Code for mask generation
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    Maskgenerator=""

    [ -n "$Argchannel" ] && {
      Maskgenerator="$Maskgenerator
  # =C=$Argchannel
  mpr:sourcegray
    -write mpr:sourcegray.bak
    -delete 0
  mpr:sourceimage
    -write mpr:sourceimage.bak
    -delete 0
  (
    mpr:sourceimage
      -colorspace $Argcolorspace
      -channel $Argchannelnumber
      -separate
      +channel
  )
    -write mpr:sourceimage
    -write mpr:sourcegray
    -delete 0"
    }
    Maskgenerator="$Maskgenerator
$(focus_maskmethod "$Argmethod" $Firstimage $Lastimage)"

    [ "$Argdiff" ] && Maskgenerator="$Maskgenerator
  # =diff
  mpr:sourcegray
    -compose Difference -composite"

    [ "$Argnegate" ] && Maskgenerator="$Maskgenerator
    # =negate
    -negate"

    [ "$Argblur" ] && {
      Maskgenerator="$Maskgenerator
    # =blur
    -blur 0x$Argblur"
    }

    [ "$Argwave" ] && Maskgenerator="$Maskgenerator
    # =wave
    -wavelet-denoise ${Argwave:-30}%"

    grep -q "$Argtype" <<< "$Masktype" && {
      Maskmd5="$(md5cut "$Sourcemd5 $Colorspace $Grayscaleconverter $Maskgenerator")"
      Argbasename="$Argmethod.$Maskmd5"
      #Argbasename="${Argmethod}${Argoptions}.$Sourcemd5"
      maskarg_store "$Count"

      ## avoid [double] creating of existing masks
      Maskready="no"
      maskexist "$Argbasename" $Firstimage $Lastimage && {
        Maskready="yes"
        sendmagickmessage "NOTE:Skipping mask generation, already exists: $Argbasename"
      }
      grep -q -x "$Argbasename" <<< "$Basenamelist" && Maskready="yes"
      Basenamelist="$Basenamelist
$Argbasename"

      [ "$Maskready" = "no" ] && {
        case "$Argmethod" in
          channel|saturation|chroma|lightness|darkness) ;;
          compose)                      generate_image --mode "$Argword1"               --first $Firstimage --last $Lastimage;;
          enfuse)                       generate_image --mode "enfuse"                  --first $Firstimage --last $Lastimage ;;
          evaluate|min|max|mean|median) generate_image --mode "${Argword1:-$Argmethod}" --first $Firstimage --last $Lastimage ;;
          image) ;;
        esac
        Maskgenerator_all="$Maskgenerator_all
$Maskgenerator
    -write $(maskname "$Argbasename" NUMBER)
    $(showimagecode "$(maskname "$Argbasename" NUMBER)")
    -delete 0"
    [ -n "$Argchannel" ] && {
      Maskgenerator="$Maskgenerator
  # /=C
  mpr:sourceimage.bak
    -write mpr:sourceimage
    +set registry:sourceimage.bak
    -delete 0
  mpr:sourcegray.bak
    -write mpr:sourcegray
    +set registry:sourcegray.bak
    -delete 0"
    }
      }
    }
  done

  # Generate masks
  [ -n "$Maskgenerator_all" ] && {
    sendmagickmessage "NOTE:Generating masks"
    grep -q "NUMBER" <<< "$Maskgenerator_all" && load_sourceimages $Firstimage $Lastimage

    for Count in $(seq $Lastimage -1 $Firstimage); do
      Number="$(printnum $Count)"
      Command=""

      # Generate command to generate masks
      sendmagickmessage "PROGRESS:Mask generation step $Count / $Sourceimagenumber"
      maskarg_single "colorspace"
      Command="$Command
  ( $(sourceimagename $Count)
      -colorspace ${Colorspace:-$Argword1}"
      [ -n "$Argword2" ] && Command="$Command
      -channel $Argword2
      -separate
      +channel"
      Command="$Command
  )
    -alpha off
    -write mpr:sourceimage
    -delete 0
  mpr:sourceimage"

      # --grayscale
      [ "$Grayscaleconverter" ] && Command="$Command
      # --grayscale
      $Grayscaleconverter"
      Command="$Command
    -write mpr:sourcegray
    -delete 0"

      Command="$Command
${Maskgenerator_all//NUMBER/$Number}"

      cmd "$Command"
    done

    sendmagickmessage "/PROGRESS"
    cmd_waitforready
    Command="
    +set registry:sourceimage
    +set registry:sourcegray"
    cmd "$Command"
    cmd_waitforready
  }

  # level and uniform masks
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    grep -q "$Argtype" <<< "$Masktype" && [ "$Arglevel" = "yes" ] && {
      [ "$Masktocache" = "yes" ] && [ -e "$Cachedir/level.$Argbasename" ] && { ### FIXME
        sendmagickmessage "NOTE:level_masks(): Skipping, mask is already leveled."
      } || {
        level_masks --name="$Argbasename" --first="$Firstimage" --last="$Lastimage"
        [ "$Masktocache" = "yes" ] && :> "$Cachedir/level.$Argbasename"
      }
    }
  done

  return 0
}
focus_merge_masks() {
  # Merge different masks.

  local Mergemask Mergecode Methodnumber= Mergemethod
  local Weightmax
  local Command Count
  local Firstimage Lastimage

  [ "$Maskmethodnumber" = "0" ] && {
    note "Skipping merge, no mask options are specified."
    return 0
  }

  Firstimage="${1:-1}"
  Lastimage="${2:-$Sourceimagenumber}"

  # --level
  maskarg_single "level" && {
    case "$Argword1" in
      all)
        Firstimage="1"
        Lastimage="$Sourceimagenumber"
      ;;
      slab)
      ;;
      off)
      ;;
    esac
  }

  sendmagickmessage "NOTE:Merging masks"
  Mergemaskbasename="mergemask"

  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      contrast|channel|comparision)
        LC_ALL=C awk 'BEGIN {exit !('${Argweight:-100}' >= '${Weightmax:-0}')}' && Weightmax="${Argweight:-100}"
        Methodnumber="$((Methodnumber+1))"
      ;;
    esac
  done
  Weightmax=100

  maskarg_single "merge" ||:
  Mergemethod="${Argword1:-"Screen"}"
  case "${Mergemethod,,}" in ### FIXME check further modes
    multiply)
      Mergecode="
  mpr:white
    -alpha off"
    ;;
    *|screen)
      Mergecode="
  mpr:black
    -alpha off"
    ;;
  esac

  ### code for contrast masks

  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      contrast|unknown)
        Mergemaskbasename="$Mergemaskbasename-$Argmethod"
        Mergecode="$Mergecode
  (
  $(maskname "$Argbasename" NUMBER)
    # =t (threshold)
    -black-threshold ${Argthreshold1:-0}%
    -white-threshold ${Argthreshold2:-100}%
    # =w (weight)
    +level 0%,$(calc "(100 * ${Argweight:-100}) / ( $Weightmax * $Methodnumber )" )%
  )
    -compose $Mergemethod -composite"
      ;;
    esac
  done
  Mergecode="$Mergecode
    -write mpr:mergemask
    -delete 0"

  ### code for contrast mask postprocessing

  for Count in $(seq $Imoptionsnumber); do
    maskarg_parse "$Count"
    case "$Argtype" in
      merge)
        Mergemaskbasename="$Mergemaskbasename-${Imoptions[$Count]}${Imarguments[$Count]}"
        Mergecode="$Mergecode
  mpr:mergemask"
        case "${Imoptions[$Count]}" in

          maskblur)
            Mergecode="$Mergecode
    # --maskblur
    -blur 0x$Argsigma1"
          ;;

          maskmorph)
    Mergecode="$Mergecode
    # --maskmorph
    -threshold ${Argthreshold1:-0}%
    -write mpr:cutmask
    -delete 0
  mpr:mergemask
  mpr:cutmask
    -compose Darken -composite
    -morphology $Argword1:$Argradius2 $Argword2:$Argradius1
  mpr:mergemask
    -compose Lighten -composite"
          ;;

          maskstat)
            Mergecode="$Mergecode
    # --maskstat
    -statistic $Argword1 $Argradius1"
            case "${Argword1,,}" in
              contrast|mode|standarddeviationX)
                Mergecode="$Mergecode
  mpr:mergemask
    -alpha off
    -compose Difference -composite"
              ;;
            esac
          ;;

          maskwave)
            Mergecode="$Mergecode
    # --maskwave
    -wavelet-denoise ${Argpercent1:-30}%"
          ;;

        esac
        Mergecode="$Mergecode
    -write mpr:mergemask
    -delete 0"
      ;;
    esac
  done

  ### code for channel and comparision masks

  Mergecode="$Mergecode
  mpr:mergemask"

  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      channel|comparision)
        Mergemaskbasename="$Mergemaskbasename-$Argmethod"
        Mergecode="$Mergecode
  (
  $(maskname "$Argbasename" NUMBER)
    # =t (threshold)
    -black-threshold ${Argthreshold1:-0}%
    -white-threshold ${Argthreshold2:-100}%
    # =w (weight)
    +level 0%,$(calc "(100 * ${Argweight:-100}) / ( $Weightmax * $Methodnumber )" )% 
  )
    -compose $Mergemethod -composite"
      ;;
    esac
  done
  Mergecode="$Mergecode
    -write mpr:mergemask
    -delete 0"

  ### run

  Mergemaskbasename="$Mergemaskbasename.$(md5cut "$Sourcemd5 $Mergecode" )"

  maskexist "$Mergemaskbasename" "$Firstimage" "$Lastimage"  && note "Skipping merge, $Mergemaskbasename $Firstimage..$Lastimage already exists" && return 0
  # merge masks
  for Count in $(seq $Lastimage -1 $Firstimage); do
    Command=""
    Mergemask="$(maskname "$Mergemaskbasename" $Count)"

    Command="$Command
  $(sendmagickmessage "PROGRESS:Mask merging step $Count / $Sourceimagenumber")"
    Command="$Command
$(sed "s/NUMBER/$(printnum $Count)/g" <<< "$Mergecode" )
  mpr:mergemask
    $Tifstore 
    -write $Mergemask
    $(showimagecode "$Mergemask")
    -delete 0"

    maskexist "$Mergemaskbasename" "$Count" || cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"
  cmd_waitforready

  # --level
  maskarg_single "level" && {
    case "$Argword1" in
      off) ;;
      slab)
        level_masks --name="$Mergemaskbasename" --output="level${Firstimage}..${Lastimage}_$Mergemaskbasename" --first="$Firstimage" --last="$Lastimage"
        Mergemaskbasename="level${Firstimage}..${Lastimage}_$Mergemaskbasename"
      ;;
      all)
        [ "$Masktocache" = "yes" ] && [ -e "$Cachedir/$Mergemaskbasename" ] && {
          sendmagickmessage "NOTE:--level: Skipping, mask is already leveled."
        } || {
          level_masks --name="$Mergemaskbasename" --output="levelall_$Mergemaskbasename" --first="$Firstimage" --last="$Lastimage"
          Mergemaskbasename="levelall_$Mergemaskbasename"
          [ "$Masktocache" = "yes" ] && :> "$Cachedir/$Mergemaskbasename"
        }
      ;;
    esac
  }

  return ${Error:-0}
}
focus_hard() {
  # Finally: focus stacking

  local Resultimage Maskmaxcopy= Cutblur= Cutsoft= Lessthanmax=
  local Firstimage Lastimage
  local Focusimagebasename Focusimagefile Focusimagemaskfile
  local Sourceimage Sourcemask Maskmax Lessthanmaxmask
  local Command Count
  local Levelmax= Levelmin=
  local Longoptions Parsedoptions

  Longoptions="lessthanmax:,maskmax:,output:,cutblur:,cutsoft:,firstimage:,lastimage:"

  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --output)       Resultimage="${2:-}" ; shift ;;
      --cutblur)      Cutblur="${2:-}" ; shift ;;
      --cutsoft)      Cutsoft="${2:-}" ; shift ;;
      --lessthanmax)  Lessthanmax="${2:-}" ; shift ;;
      --maskmax)      Maskmaxcopy="${2:-}" ; shift ;;
      --firstimage)   Firstimage="${2:-}" ; shift ;;
      --lastimage)    Lastimage="${2:-}" ; shift ;;
      --) ;;
    esac
    shift
  done

  Firstimage="${Firstimage:-1}"
  Lastimage="${Lastimage:-$Sourceimagenumber}"

  sendmagickmessage "NOTE:Focus montage hard"

  Focusimagebasename="focus-hard.$Firstimage..$Lastimage.$(md5cut "$(masklist "$Mergemaskbasename") $Cutblur $Cutsoft $Lessthanmax")"
  Focusimagefile="$Cachedir/$Focusimagebasename.tif"
  Focusimagemaskfile="$Cachedir/$Focusimagebasename.mask.tif"

  [ -e "$Focusimagefile" ] && {
    sendmagickmessage "NOTE:Skipping focus_hard(), image already exists."
    Command="
  $Focusimagefile
    $Tifstore
    -write mpr:resultimage
    -write $Resultimage
    -delete 0"
    [ -n "$Maskmaxcopy" ] && Command="$Command
  $Focusimagemaskfile
    $Tifstore
    -write mpr:resultmask
    -write $Maskmaxcopy
    -delete 0"
    cmd "$Command"
    cmd_waitforready
    return 0
  }

  load_sourceimages $Firstimage $Lastimage

  generate_image --mode transparent --name "$Focusimagefile"
  #Maskmax="${Maskmax:-mpr:resultmask}"

  #Maskmax="mpr:mergemax"
  #evaluate max "$Maskmax" $(masklist "$Mergemaskbasename" $Firstimage $Lastimage)
  #Levelmax="$(getmagickinfo "$Maskmax" '%[fx:maxima*100]')"
  #Levelmin="$(getmagickinfo "$Maskmax" '%[fx:minima*100]')"

  [ "$Lessthanmax" ] && generate_image --mode transparent --name "mpr:lessthanmax"


  Command="
  $Focusimagefile
    -alpha Opaque
    -alpha off
    -write mpr:resultimage
    -delete 0
  mpr:black
    -alpha off
    -write mpr:resultmask
    -delete 0"
  cmd "$Command"

  for Count in $(seq $Lastimage -1 $Firstimage); do
    Command=""
    Sourcemask="$(maskname "$Mergemaskbasename" "$Count")"
    Sourceimage="$(sourceimagename $Count)"

    Command="$Command
  $(sendmagickmessage "PROGRESS:Focus montage step $Count / $Sourceimagenumber")"
    # Load images
    Command="$Command
  $Sourceimage
    -alpha off
    -write mpr:sourceimage
    -delete 0
  $Sourcemask
    -alpha off
    #-level $Levelmin%,$Levelmax%
    -write mpr:sourcemask
    -delete 0"

    Command="$Command
  # stepwise increase maskmax
  mpr:sourcemask 
  mpr:resultmask 
    -compose Lighten -composite
    -write mpr:resultmask
    -delete 0"

    Command="$Command
  # get area of source mask equal or sharper than current max
  mpr:resultmask
  mpr:sourcemask
    -compose MinusSrc -composite -fill white +opaque black
    -alpha off
    -negate
    -write mpr:cutmask
    -delete 0"

    # --lessthanmax, --less
    [ "$Lessthanmax" ] && { 
      Command="$Command
  ## --lessthanmax, --less
  mpr:cutmask
    -write mpr:cutmask_max
    -delete 0"

      Command="$Command
  # get part of actual maskmax
  mpr:resultmask
  mpr:cutmask_max
    -alpha Off -compose CopyOpacity -composite
    -write mpr:maskmax_part
    -delete 0"

      Command="$Command
  # paint actual maskmax part into lessmask
  mpr:lessthanmax
  mpr:maskmax_part
    -compose Over -composite
    -write mpr:lessthanmax
    -delete 0"

      Command="$Command
  # get area of source mask that is stronger (+offset) than lessmask)
  mpr:sourcemask 
  ( mpr:lessthanmax -evaluate Add ${Lessthanmax:-0}% )
    -compose MinusSrc -composite
    -fill white +opaque black 
    -write mpr:cutmask_less
    -delete 0"

      Command="$Command
  # reduce max in maskmax where --lessthanmax takes over
  mpr:sourcemask
  mpr:cutmask_less
    -compose CopyOpacity -composite
    -write mpr:sourcemask_part
    -delete 0
  mpr:resultmask
  mpr:sourcemask_part
    -compose Over -composite
    -write mpr:resultmask
    -delete 0"

      Command="$Command
  # darken lessmask with current source mask to get a mask with decreasing sharpness after a max peak
  mpr:lessthanmax
  mpr:sourcemask
    -compose Darken -composite
    -write mpr:lessthanmax
    -delete 0"

      Command="$Command
  # get area of source mask equal or sharper than current max (same code as above, but now with less-adjusted maskmax.
  mpr:sourcemask
  mpr:resultmask
    -compose MinusDst -composite -fill white +opaque black
    -alpha off
    -negate
    -write mpr:cutmask
    -delete 0"

      Command="$Command
    ##/--lessthanmax"
    } 

    [ "$Cutsoft" ] && Command="$Command
  # --cutsoft: add a blur to cut mask
  mpr:cutmask
    -alpha off
    -blur 0x${Cutsoft:-1}
  mpr:cutmask
    -compose Lighten -composite
    -write mpr:cutmask
    -delete 0"

    [ "$Cutblur" ] && Command="$Command
  # --cutblur: blur entire cut mask
  mpr:cutmask
    -alpha off
    -blur 0x${Cutblur:-1}
    -write mpr:cutmask
    -delete 0"

    Command="$Command
  # get part of source image
  mpr:sourceimage
  mpr:cutmask
    -alpha off -compose CopyOpacity -composite
    -write mpr:sourcepart
    -delete 0"

    Command="$Command
  # add part of source to result
  mpr:resultimage
  mpr:sourcepart
    -compose Over -composite
    -alpha off
    -write mpr:resultimage
    $(showimagecode "mpr:resultimage")
    -delete 0"

#    [ "$Slabnumber" = "1" ] && Command="$Command
#  +set registry:$Sourceimage
#  +set registry:$Sourcemask"

    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"

  Command="
  # store result image and mask
  mpr:resultimage
    $Tifstore 
    -write $Resultimage
    -write $Focusimagefile
    -delete 0
  mpr:resultmask
    $Tifstore
    -write $Focusimagemaskfile
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  [ "$Maskmaxcopy" ] && {
    Command="
  # copy max mask
  mpr:resultmask
    -write $Maskmaxcopy
    -delete 0"
    cmd "$Command"
    cmd_waitforready
  }

  Command="
  +set registry:cutmask
  +set registry:cutmask_less
  +set registry:cutmask_max
  +set registry:lessthanmax
  +set registry:maskmax
  +set registry:maskmax_part
  +set registry:sourceimage
  +set registry:sourcemask
  +set registry:sourcemask_part
  +set registry:sourcepart"
  cmd "$Command"
  cmd_waitforready
  #+set registry:resultimage

  return 0
}
focus_soft() {
  local Resultimage Maskmaxcopy
  local Level Composemode
  local Firstimage Lastimage
  local Count Command
  local Focusimagebasename Focusimagefile Focusimagemaskfile
  local Longoptions Parsedoptions

  Longoptions="composemode:,maskmax:,output:,level:,firstimage:,lastimage:"

  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --output)       Resultimage="${2:-}" ; shift ;;
      --level)        Level="${2:-}" ; shift ;;
      --maskmax)      Maskmaxcopy="${2:-}" ; shift ;;
      --firstimage)   Firstimage="${2:-}" ; shift ;;
      --lastimage)    Lastimage="${2:-}" ; shift ;;
      --composemode)  Composemode="${2:-}" ; shift ;;
      --) ;;
    esac
    shift
  done

  Firstimage="${Firstimage:-1}"
  Lastimage="${Lastimage:-$Sourceimagenumber}"
  Level="${Level:-"0%x100%"}"
  Composemode="${Composemode:-Plus}"

  sendmagickmessage "NOTE:Focus montage soft"

  Addsource="mpr:addsource"

  Focusimagebasename="focus-soft.$(percentrm "$Level").$Firstimage..$Lastimage.$(md5cut "$(masklist $Mergemaskbasename)")"
  Focusimagefile="$Cachedir/$Focusimagebasename.tif"
  Focusimagemaskfile="$Cachedir/$Focusimagebasename.mask.tif"

  [ "$Force" = "focus" ] && forcefocus
  [ -e "$Focusimagefile" ] && {
    sendmagickmessage "NOTE:Skipping focus_soft(), image already exists."
    Command="
  $Focusimagefile
    $Tifstore
    -write mpr:resultimage
    -write $Resultimage
    -delete 0"
    [ -n "$Maskmaxcopy" ] && Command="$Command
  $Focusimagemaskfile
    $Tifstore
    -write mpr:resultmask
    -write $Maskmaxcopy
    -delete 0"
    cmd "$Command"
    cmd_waitforready
    return 0
  }

  load_sourceimages $Firstimage $Lastimage

  Command="
  mpr:black
    -alpha off
    -depth 16
    -write mpr:addmask
    -delete 0
  mpr:black
    -alpha off
    -depth 16
    -write mpr:addsource
    -delete 0"
  cmd "$Command"

  for Count in $(seq $Lastimage -1 $Firstimage); do
    Command=""
    Sourcemask="$(maskname "$Mergemaskbasename" "$Count")"
    Sourceimage="$(sourceimagename $Count)"

    sendmagickmessage "PROGRESS:Focus montage soft step $Count / $Sourceimagenumber"

    Command="$Command
  $Sourceimage
    -depth 16
    -alpha off
    -write mpr:sourceimage
    -delete 0
  $Sourcemask
    -depth 16
    -write mpr:mask
    -delete 0"

    Command="$Command
  mpr:mask
    +level $Level
    -evaluate Divide $Sourceimagenumber
    -write mpr:mask
    -delete 0
  mpr:addmask
  mpr:mask
    -compose $Composemode -composite
    -write mpr:addmask
    -delete 0
  mpr:addsource
  ( mpr:sourceimage mpr:mask -compose Multiply -composite )
    -evaluate-sequence Add
    -write mpr:sourceadd
    -write mpr:addsource
    -delete 0"

    [ "$Showimageprocessing" ] && {
      Command="$Command
  # create result only for --show
  mpr:addsource
  mpr:addmask
    -compose DivideSrc -composite
    -write mpr:resultimage
    $(showimagecode "mpr:resultimage")
    -delete 0"
    }

    Command="$Command
  +set registry:$Sourceimage
  +set registry:$Sourcemask"

    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"
  Command="
  mpr:addsource
  mpr:addmask
    -compose DivideSrc -composite
    $Tifstorealpha
    -write mpr:resultimage
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  mkclut_uniform "mpr:addmask" "mpr:clut" ### FIXME --slabs
  Command="
  mpr:addmask
  mpr:clut
    -clut
    -write $Focusimagemaskfile
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  [ "$Maskmaxcopy" ] && {
    cp "$Focusimagemaskfile" "$Maskmaxcopy"
  }

  Command="
  mpr:resultimage
    $Tifstore 
    -write $Focusimagefile
    -write $Resultimage
    $(showimagecode "$Focusimagefile")
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  Command="
  +set registry:addmask
  +set registry:addsource
  +set registry:clut
  +set registry:mask
  +set registry:sourceadd
  +set registry:sourceimage"
  cmd "$Command"
  cmd_waitforready
  #+set registry:resultimage

  return ${Error:-0}
}
focus_main() {
  local Slabstep
  local Command Count
  local Slabmaskmax Slabmaskmin
  local Backgroundnumber Backgroundtype Backgroundimage
  local Cutblur= Cutsoft= Less=
  local Transparentlayers=

  focus_generate_masks --type="contrast"
  [ "$Maskmethodnumber" -gt "0" ] && { 
    for Slabstep in $(seq $Slabnumber -1 1); do
      Slabresult[$Slabstep]="$Cachedir/slabresult.$Resultbasename.slab$Slabstep.mpc"
      Slabmask[$Slabstep]="$Cachedir/slabresult.$Resultbasename.slab$Slabstep-mask.mpc"
      sendmagickmessage "NEWLINE"
      sendmagickmessage "NOTE:Generating slab $Slabstep / $Slabnumber: ${Slabfirstimage[$Slabstep]}..${Slablastimage[$Slabstep]}"

      focus_generate_masks --type="comparision,channel" --first "${Slabfirstimage[$Slabstep]}" --last "${Slablastimage[$Slabstep]}"
      focus_merge_masks                                         "${Slabfirstimage[$Slabstep]}"        "${Slablastimage[$Slabstep]}"

      # focus
      case $Softmode in
        "no")
          maskarg_single "cutblur" && Cutblur="$Argsigma1"
          maskarg_single "cutsoft" && Cutsoft="$Argsigma1"
          maskarg_single "less"    && Less="$Argpercent1"
          focus_hard --maskmax "${Slabmask[$Slabstep]}" --output "${Slabresult[$Slabstep]}" \
                     --firstimage="${Slabfirstimage[$Slabstep]}" --lastimage="${Slablastimage[$Slabstep]}" \
                     --cutsoft "$Cutsoft" --cutblur "$Cutblur" --lessthanmax "$Less"
        ;;
        "yes")
          maskarg_single "soft" ||:
          focus_soft --maskmax "${Slabmask[$Slabstep]}" --output "${Slabresult[$Slabstep]}" \
                     --firstimage="${Slabfirstimage[$Slabstep]}" --lastimage="${Slablastimage[$Slabstep]}" \
                     --level "${Argpercent1}%x${Argpercent2}%" --compose="$Argword1"
        ;;
      esac
    done

    for Slabstep in $(seq $Slabnumber -1 1); do
      sendmagickmessage "NOTE:Postprocessing slab $Slabstep / $Slabnumber: ${Slabfirstimage[$Slabstep]}..${Slablastimage[$Slabstep]}"
      Slabresultpost[$Slabstep]="$Cachedir/slabresult.$Resultbasename.slab$Slabstep-post.mpc"
      Slabmaskpost[$Slabstep]="$Cachedir/slabresult.$Resultbasename.slab$Slabstep-post-mask.mpc"
      [ -e "${Slabresultpost[$Slabstep]}" ] && {
        sendmagickmessage "NOTE:Skipping --alpha --threshold --finalblur, already done."
      } || {

        false && [ "$Testsetup" ] && {
          Slabmaskmax="$Cachedir/slabmask.max.$Resultbasename.mpc"
          Slabmaskmin="$Cachedir/slabmask.min.$Resultbasename.mpc"
          evaluate max $Slabmaskmax ${Slabmask[@]}
          #evaluate min $Slabmaskmin ${Slabmask[@]}
          Levelmax="$(getmagickinfo "$Slabmaskmax" '%[fx:maxima*100]')"
          Levelmin="$(getmagickinfo "$Slabmaskmax" '%[fx:minima*100]')"
        }

        Command="
${Slabresult[$Slabstep]}
  -write ${Slabresultpost[$Slabstep]}
  -delete 0
${Slabmask[$Slabstep]}
  -level ${Levelmin:-0}%x${Levelmax:-100}%
  -write ${Slabmaskpost[$Slabstep]}
  -delete 0"
        cmd "$Command"

        for Count in $(seq "$Imoptionsnumber"); do
          maskarg_parse "$Count"
          Option="${Imoptions[$Count]}"
          case "$Argtype" in
            postfocus)
              sendmagickmessage "NOTE:Applying --${Imoptions[$Count]}=${Imarguments["$Count"]%,TYPE*}"
              case "$Option" in
                alpha)
                  alphalevel --image "${Slabresultpost[$Slabstep]}" --mask "${Slabmaskpost[$Slabstep]}" \
                             --level "${Argpercent1}%x${Argpercent2}%"
                ;;
                finalblur)
                  finalblur  --image "${Slabresultpost[$Slabstep]}" --mask "${Slabmaskpost[$Slabstep]}" \
                             --percent "$Argthreshold1" --sigma1 "$Argsigma1" --sigma2 "$Argsigma2"
                ;;
                finalblur2)
                  finalblur2 --image "${Slabresultpost[$Slabstep]}" --mask "${Slabmaskpost[$Slabstep]}" \
                             --percent "$Argthreshold1" --blur "$Argradius1"
                ;;
                threshold)
                  threshold  --image "${Slabresultpost[$Slabstep]}" --mask "${Slabmaskpost[$Slabstep]}" \
                             --percent1 "$Argthreshold1" --percent2 "$Argthreshold2" --blur "$Argsigma1" \
                             --cutimage="hard"
                  Command="
  ${Slabresultpost[$Slabstep]}
  ${Slabmaskpost[$Slabstep]}
    -alpha off
    -compose CopyOpacity -composite
    -write ${Slabresultpost[$Slabstep]}
    -delete 0"
#                  cmd "$Command"
#                  cmd_waitforready
                ;;
              esac
            ;;
          esac
        done
      }
    done
  }

  Command="
  # composing slab results
  mpr:transparent
    -alpha set
    -write mpr:resultimage
    -delete 0
  mpr:resultimage"
  for Slabstep in $(seq $Slabnumber -1 1); do
    Command="$Command
  ${Slabresultpost[$Slabstep]}
    -compose Over -composite
    $(showimagecode)"
  done
  Command="$Command
    -write mpr:resultimage
    $Tifstorealpha
    $(showimagecode)
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  # --background
  Backgroundnumber="0"
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      background)
        sendmagickmessage "NOTE:Processing --${Imoptions[$Count]}=${Imarguments["$Count"]%,TYPE*}"
        Backgroundnumber="$((Backgroundnumber+1))"
        checkmagicklist color                     "$Argword1"   && Backgroundtype="color"
        checkmagicklist evaluate                  "$Argword1"   && Backgroundtype="evaluate"
        checkmagicklist compose  "$(tr -d "2" <<< "$Argword1")" && Backgroundtype="compose"
        [ -f "$Argword1" ]                                      && Backgroundtype="image"
        case $Argword1 in
          enfuse)                                                  Backgroundtype="$Argword1" ;;
          none)                           Argword1="transparent" ; Backgroundtype="color" ;;
        esac
        [ -n "${Backgroundtype:-}" ] || error "--background: Unknown background: '$Argword1'"
        case "$Backgroundtype" in
          color|evaluate|compose|enfuse)
            Backgroundimage[$Backgroundnumber]="$(generate_image --showname --mode "$Argword1")"
            generate_image --mode "$Argword1"
          ;;
          image) ### FIXME
            Backgroundimage[$Backgroundnumber]="$Argword1"
          ;;
        esac
      ;;
    esac
  done

  # --layered
  case "$Storelayered" in
    yes)
      sendmagickmessage "NOTE:Generating layered tif"
      { maskarg_single "threshold" || maskarg_single "alpha" ; } && Transparentlayers="yes"
      generate_image --mode cyan
      generate_image --mode magenta
      generate_image --mode yellow
      generate_image --mode green
      Command="
  # --layered
  mpr:resultimage
  mpr:cyan
  mpr:magenta
  mpr:yellow
  mpr:green"
      for Count in $(seq "$Backgroundnumber"); do
        Command="$Command
  ${Backgroundimage[$Count]}"
      done
      for Slabstep in $(seq $Slabnumber -1 1); do
        [ "$Transparentlayers" = "yes" ] && Command="$Command
  ${Slabresult[$Slabstep]}"
        Command="$Command
  ${Slabresultpost[$Slabstep]}"
      done
      Command="$Command
    $Tifstorealpha
    #-define tiff:write-layers=yes
    -write $Outputimage
    $(showimagecode "$Outputimage")
    -delete 0"
    ;;

    no)
      Command="
  mpr:transparent"
      for Count in $(seq "$Backgroundnumber"); do
        Command="$Command
  ${Backgroundimage[$Count]}
    -compose Over -composite"
      done
      Command="$Command
  mpr:resultimage
    -compose Over -composite
    -write mpr:resultimage
    -delete 0
  mpr:resultimage
    $Tifstorealpha
    -write $Outputimage
    -delete 0"
    ;;
  esac

  cmd "$Command"
  cmd_waitforready

  [ "$Maskmethodnumber" = "0" ] && [ "$Backgroundnumber" = "0" ] && note "No mask option and no background has been specified.
  imfuse has generated an empty transparent result image.
  Suggestion: Try at least '--background=enfuse', or short: --bg"

  # --savemask
  [ "$Savemask" ] && {
    cmd "  # --savemask"
    evaluate max "$Savemask" ${Slabmaskpost[$Slabstep]}
  }
}

### mask args

maskarg_parse() {
  local Key Line Value

  eval $Arglist
  Argmethod="${Imoptions[${1:-}]}"
  Argcount="${1:-}"

  while read -d, Line; do
    grep -q "=" <<< "$Line" && {
      Key="$(cut   -d= -f1    <<< "$Line")"
      Value="$(cut -d= -f2 -s <<< "$Line")"
      :
    } || {
      Key="$(digitrm "$Line")"
      Value="$(sed "s/${Key:-NOKEY}//"  <<< "$Line")"
    }
    case $Key in
      "w"|"w%")           Argweight="$(percentrm "$Value")" ;;
      "r"|"r%")           [ -z "$Argradius1" ]  && Argradius1="$Value" || Argradius2="$Value" ;;
      "R")                Argradius2="${Value}" ;;
      "s")                [ -z "$Argsigma1" ]   && Argsigma1="$Value"  || Argsigma2="$Value" ;;
      "S")                Argsigma2="${Value}" ;;
      "p"|"%"|"p%")       [ -z "$Argpercent1" ] && Argpercent1="$(percentrm "$Value")" || Argpercent2="$(percentrm "$Value")" ;;
      "P"|"P%")           Argpercent2="$(percentrm "$Value")" ;;
      "t")                Argthreshold1="$(percentrm "$Value")" ;;
      "T")                Argthreshold2="$(percentrm "$Value")" ;;
      "n")                [ -z "$Argnumber1" ]   && Argnumber1="$Value"  || Argnumber2="$Value" ;;
      "N")                Argnumber2="$(percentrm "$Value")" ;;
      "C")                Argchannel="$Value"
                          Argcolorspace="$(cut -d'-' -f1 <<< "$Argchannel")"
                          Argchannelnumber="$(cut -d'-' -f2 <<< "$Argchannel")" ;;
      "wave")             Argwave="${Value:-$(maskarg_defaultvalue   "$Argmethod" wave)}" ;;
      "diff")             Argdiff="s" ;;
      "blur")             Argblur="${Value:-$(maskarg_defaultvalue   "$Argmethod" blur)}" ;;
      "neg"|"negate")     Argnegate="neg" ;;
      "LEVEL")            Arglevel="yes" ;;
      "TYPE")             Argtype="$Value" ;;
      "BASENAME")         Argbasename="$Value" ;;
      *|WORD1|WORD2) ### FIXME
        [ -z "$Argword1" ] && Argword1="$Line" || Argword2="$Line" 
        Argword1="${Argword1#WORD1=}"
        Argword2="${Argword2#WORD2=}"
      ;;
    esac
  done <<< "${Imarguments[${1:-}]},"

  return 0
}
maskarg_store() {
  local Argoptions=
  Argcount="${1:-}"
  [ "$Argweight" ]             && Argoptions="$Argoptions,w$Argweight"
  [ "$Argradius1" ]            && Argoptions="$Argoptions,r$Argradius1"
  [ "$Argradius2" ]            && Argoptions="$Argoptions,R$Argradius2"
  [ "$Argsigma1" ]             && Argoptions="$Argoptions,s$Argsigma1"
  [ "$Argsigma2" ]             && Argoptions="$Argoptions,S$Argsigma2"
  [ "$Argpercent1" ]           && Argoptions="$Argoptions,p$Argpercent1"
  [ "$Argpercent2" ]           && Argoptions="$Argoptions,P$Argpercent2"
  [ "$Argthreshold1" ]         && Argoptions="$Argoptions,t$Argthreshold1"
  [ "$Argthreshold2" ]         && Argoptions="$Argoptions,T$Argthreshold2"
  [ "$Argnumber1" ]            && Argoptions="$Argoptions,n$Argnumber1"
  [ "$Argnumber2" ]            && Argoptions="$Argoptions,N$Argnumber2"
  [ "$Argchannel" ]            && Argoptions="$Argoptions,C=$Argchannel"
  [ "$Argword1" ]              && Argoptions="$Argoptions,$Argword1"
  [ "$Argword2" ]              && Argoptions="$Argoptions,$Argword2"
  [ "$Argwave" ]               && Argoptions="$Argoptions,wave$Argwave"
  [ "$Argdiff" ]               && Argoptions="$Argoptions,diff"
  [ "$Argblur" ]               && Argoptions="$Argoptions,blur$Argblur"
  [ "$Argnegate" ]             && Argoptions="$Argoptions,neg"
  [ "$Argtype" ]               && Argoptions="$Argoptions,TYPE=$Argtype"
  [ "$Arglevel" ]              && Argoptions="$Argoptions,LEVEL"
  [ "$Argbasename" ]           && Argoptions="$Argoptions,BASENAME=$Argbasename"
  Argoptions="${Argoptions#,}"
  Imarguments[$Argcount]="$Argoptions"
}
maskarg_defaultvalue() {
  case "${2:-}" in
    blur)
      echo "1"
    ;;
    less)
      echo "50"
    ;;
    levelmin)
      case "${1:-}" in
        blur)       echo "0" ;;
        comet)      echo "0" ;;
        compass)    echo "45" ;;
        dog)        echo "0" ;;
        diffstat)
          case "$Argword1,$Argword2" in
            "median,mean") echo "0" ;;
            "min,max")     echo "0" ;;
          esac
        ;;
        freichen)
          case $Argword1 in
            "") echo "33.6584" ;;
            15) echo "19" ;;
          esac
        ;;
        gaussian)   echo "0" ;;
        #kirsch)     echo "" ;;
        laplacian)
          case $Argword1 in
            3)      echo "0" ;;
          esac
        ;;
        log)        echo "0" ;;
        morphology) echo "0" ;;
        prewitt)    echo "34.3893" ;;
        #roberts)    echo "7.64782%,100%" ;;
        sobel)      echo "34.3893" ;;
        statistic)
          case $Argword1 in
            standarddeviation) echo "0" ;;
          esac
        ;;
        #unsharp
        wavelet)    echo "0" ;;
        *)          echo "" ;;
      esac
    ;;
    percent1)
      case "${1:-}" in
        alpha)      echo "0" ;;
        halo)       echo "25" ;;
        wavelet)    echo "10" ;;

        less)       echo "50" ;;
        maskwave)   echo "50" ;;
        soft)       echo "2" ;;
        *)          echo "" ;;
      esac
    ;;
    percent2)
      case "${1:-}" in
        alpha)      echo "100" ;;
        soft)       echo "100" ;;
        *)          echo "" ;;
      esac
    ;;
    radius1)
      case "${1:-}" in
        #blur)       echo "" ;; # 0
        #comet)      echo "" ;; # 0
        compass)    echo "" ;;
        diffstat)   echo "3" ;;
        #dog)        echo "" ;; # 0
        freichen)   echo "" ;;
        #gaussian)   echo "" ;; # 0
        kirsch)     echo "" ;;
        laplacian)  echo "" ;;
        #log)        echo "" ;; # 0
        morphology) echo "1" ;;
        prewitt)    echo "" ;;
        roberts)    echo "" ;;
        sobel)      echo "" ;;
        statistic)  echo "2" ;;
        #unsharp)    echo "" ;; # 0

        finalblur2) echo "4" ;;
        maskmorph)  echo "2" ;;
        maskstat)   echo "6" ;;
        *)          echo "" ;;
      esac
    ;;
    radius2)
      case "${1:-}" in
        maskmorph)  echo "2" ;;
        morphology) echo "1" ;;
        *)          echo "" ;;
      esac
    ;;
    sigma1)
      case "${1:-}" in
        blur)       echo "0.3" ;;
        comet)      echo "5" ;;
        compass)    echo "" ;;
        diffstat)   echo "" ;;
        dog)        echo "0.4" ;;
        freichen)   echo "" ;;
        gaussian)   echo "0.3" ;;
        halo)       echo "5" ;;
        kirsch)     echo "" ;;
        laplacian)  echo "" ;;
        log)        echo "0.2" ;;
        morphology) echo "" ;;
        prewitt)    echo "" ;;
        roberts)    echo "" ;;
        sobel)      echo "" ;;
        statistic)  echo "" ;;
        unsharp)    echo "2" ;;
        wavelet)    echo "" ;;

        cutblur)    echo "2" ;;
        cutsoft)    echo "2" ;;
        finalblur)  echo "3" ;;
        maskblur)   echo "2" ;;
        threshold)  echo "0" ;;
        *)          echo "" ;;
      esac
    ;;
    sigma2)
      case "${1:-}" in
        dog)       echo "$(calc "${Argsigma1:-0.3} * 1.6")" ;;
        finalblur) echo "2" ;;
        *)         echo "" ;;
      esac
    ;;
    alpha)
      echo "100"
    ;;
    threshold1)
      case "${1:-}" in
        finalblur)  echo "50" ;;
        finalblur2) echo "50" ;;
        threshold)  echo "50" ;;
        *)          echo "" ;;
      esac
    ;;
    threshold2)
      case "${1:-}" in
        threshold) echo "" ;;
        *)     echo "" ;;
      esac
    ;;
    type)
      case "${1:-}" in
        blur|comet|compass|diffstat|dog|free|freediff|freichen|gaussian|kirsch|laplacian|log|morphology|prewitt|roberts|sobel|statistic|unsharp|wavelet)
          echo "contrast"
        ;;
        channel|chroma|darkness|lightness|saturation)
          echo "channel"
        ;;
        image|enfuse|compose|evaluate|min|max|mean|median)
          echo "comparision"
        ;;
        maskblur|maskmorph|maskstat|maskwave)
          echo "merge"
        ;;
        alpha|finalblur|finalblur2|threshold)
          echo "postfocus"
        ;;
        bg)
          echo "background"
        ;;
        colorspace|cutblur|cutsoft|grayscale|less|level|merge|soft)
          echo "single"
        ;;
        slabs)
          echo "slab"
        ;;
        experimental)
          echo "contrast"
        ;;
        *)
          echo "UNKNOWN"
          error "maskarg_defaultvalue(): Unknown type for method ${1:-}"
          return 1
        ;;
      esac
    ;;
    wave)
      echo "30"
    ;;
    word1)
      case "${1:-}" in
        channel)    echo "HSL" ;;
        chroma)     echo "HCL" ;;
        comet)      echo "lighten" ;;
        compose)    echo "overlay" ;;
        darkness)   echo "HSL" ;;
        diffstat)   echo "median" ;;
        evaluate)   echo "max" ;;
        freichen)   echo "" ;;
        freediff)   echo "-sharpen 0x3" ;;
        laplacian)  echo "3" ;;
        lightness)  echo "HSL" ;;
        morphology) echo "edgeout" ;;
        saturation) echo "HSL" ;;
        statistic)  echo "standarddeviation" ;;

        bg)         echo "enfuse" ;;
        colorspace) echo "SRGB" ;;
        grayscale)  echo "Rec709Luma" ;;
        level)      echo "all" ;;
        maskmorph)  echo "close" ;;
        maskstat)   echo "mean" ;;
        merge)      echo "screen" ;;
        soft)       echo "plus" ;;
        *)          echo "" ;;
      esac
    ;;
    word2)
      case "${1:-}" in
        channel)    echo "2" ;;
        chroma)     echo "1" ;;
        darkness)   echo "2" ;;
        diffstat)   echo "mean" ;;
        lightness)  echo "2" ;;
        maskmorph)  echo "Octagon" ;;
        saturation) echo "1" ;;
        *)          echo "" ;;
      esac
    ;;
  esac
}
maskarg_checkallowed() {
  local Method Option Arg
  local Errormessage=
  Method="${1:-}"
  Option="${2:-}"
  Arg="${3:-}"

  case "$Option" in
    blur)
      case "$Argtype" in
        contrast|comparision|channel) ;;
        *) Errormessage="$Method does not take argument blur" ;;
      esac
    ;;
    C)
      case "$Argtype" in
        contrast|comparision|channel) ;;
        *) Errormessage="$Method does not take argument blur" ;;
      esac
    ;;
    percent1)
      case "$Method" in
        wavelet|halo) ;;
        alpha|less|maskwave|soft) ;;
        slabs) ;;
        *) Errormessage="$Method does not take argument percent" ;;
      esac
    ;;
    percent2)
      case "$Method" in
        alpha) ;;
        soft) ;;
        slabs) ;;
        *) Errormessage="$Method does not take argument percent2" ;;
      esac
    ;;
    radius1)
      case "$Method" in
        halo|morphology) ;;
        maskmorph) ;;
        diffstat|statistic|maskstat)
          [ "${Arg:-0}" -lt "2" ] && Errormessage="--$Method needs a radius of at least 2"
        ;;
        finalblur2) ;;
        slabs) ;;
        *) Errormessage="$Method does not take argument radius" ;;
      esac
    ;;
    radius2)
      case "$Method" in
        morphology|maskmorph) ;;
        *) Errormessage="$Method does not take argument radius2" ;;
      esac
    ;;
    sigma1)
      case "$Method" in
        blur|comet|dog|gaussian|halo|log|unsharp) ;;
        cutblur|cutsoft|finalblur|maskblur|threshold) ;;
        *) Errormessage="$Method does not take argument sigma" ;;
      esac
    ;;
    sigma2)
      case "$Method" in
        dog|finalblur) ;;
        *) Errormessage="$Method does not take argument sigma2" ;;
      esac
    ;;
    threshold1)
      case "$Argtype" in
        contrast|comparision|channel) ;;
        *)
          case "$Method" in
            maskmorph|finalblur|finalblur2|threshold) ;;
            *) Errormessage="$Method does not take argument threshold1" ;;
          esac
        ;;
      esac
    ;;
    threshold2)
      case "$Argtype" in
        contrast|comparision|channel) ;;
        *)
          case "$Method" in
            threshold) ;;
            *) Errormessage="$Method does not take argument threshold1" ;;
          esac
        ;;
      esac
    ;;
    wave)
      case "$Argtype" in
        contrast|comparision|channel) ;;
        *) Errormessage="$Method does not take argument wave" ;;
      esac
    ;;
    word1)
      case "$Method" in
        enfuse) ;;
        comet|freichen|freediff|laplacian) ;;
        channel|chroma|darkness|lightness|saturation) ;;
        compose|merge|soft)
          Arg="$(lowercase "${Arg}")"
          checkmagicklist "compose" "$(tr -d '2' <<< "$Arg")" || {
            Errormessage="--$Method=$Arg: unknown argument.
  Please choose one out of 'magick -list $Method'"
          }
        ;;
        evaluate)
          Arg="$(lowercase "${Arg}")"
          checkmagicklist "evaluate" "$(tr -d '2' <<< "$Arg")" || {
            Errormessage="--$Method=$Arg: unknown argument.
  Please choose one out of 'magick -list $Method'"
          }
        ;;
        morphology)
          Arg="$(lowercase "${Arg}")"
          checkmagicklist "morphology" "$(tr -d '2' <<< "$Arg")" || {
            Errormessage="--$Method=$Arg: unknown argument.
  Please choose one out of 'magick -list $Method'"
          }
        ;;
        image) 
          [ -f "${Arg}" ] || Errormessage="--image: File not found: $Arg"
        ;;
        statistic|diffstat|maskstat)
          Arg="$(lowercase "${Arg}")"
          Arg="$(maskarg_checkstatistic "$Arg")"
          [ "$Arg" = "source" ] && Errormessage="--$Method does not take argument $Arg
  Please choose one out of 'magick -list statistic'"
        ;;
        level)
          case "$Arg" in
            all|slab|off) ;;
            *) Errormessage="$Method does not take argument word1 $Arg" ;;
          esac
        ;;
        maskmorph) ;;
        colorspace) ;;
        bg) ;;
        grayscale) ;;
        slabs) 
          case "$Arg" in
            kurt) ;;
            *) Errormessage="--$Method does not know mode $Arg" ;;
          esac
        ;;
        *) Errormessage="$Method does not take argument word1 $Arg" ;;
      esac
    ;;
    word2)
      case "$Method" in
        colorspace) ;;
        diffstat)
          Arg="$(lowercase "${Arg}")"
          Arg="$(maskarg_checkstatistic "$Arg")"
        ;;
        channel|chroma|darkness|lightness|saturation) ;;
        slabs) ;;
        maskmorph) ;;
        *) Errormessage="$Method does not take argument word2 $Arg" ;;
      esac
    ;;
  esac

  [ "$Errormessage" ] && {
    error "$Errormessage"
    return 1
  }
  echo "$Arg"
  return 0
}
maskarg_checkstatistic() {
  local Mode

  Mode="${1:-}"
  case ${Mode,,} in
    0|source|none)          Mode="source" ;;
    1|gradient|grad)        Mode="gradient" ;;
    2|maximum|max)          Mode="maximum" ;;
    3|mean)                 Mode="mean" ;;
    4|median)               Mode="median" ;;
    5|minimum|min)          Mode="minimum" ;;
    6|mode)                 Mode="mode" ;;
    7|nonpeak)              Mode="nonpeak" ;;
    8|9|rms|rootmeansquare) Mode="rms" ;;
    10|standarddeviation|standard_deviation|standard-deviation|dev) 
                            Mode="standarddeviation" ;;
    #*) error "Unknown statistic mode '$Mode'" ; return 1;;
    *) return 1 ;;
  esac
  [ "$Error" ] && return 1
  echo "$Mode"
  return 0
}
maskarg_checkpercent() {
  # Allow percent values to be given without a leading 'p'. Few options only.
  [ -z "$Argpercent1" ] && [ -n "$Argword1" ] && {
    Argpercent1="$Argword1"
    Argword1=""
  }
  [ -n "$Argpercent1" ] && [ -n "$Argword1" ] && {
    error "Option does not take percent value along with a word argument"
    return 1
  }
  
  [ "$Argpercent1" = "auto" ] || [ "$Argpercent1" = "$(digitonly "$Argpercent1")" ] || {
    error "Invalid percent value: $Argpercent1"
    return 1
  }
}
maskarg_checksigma() {
  # Allow sigma values to be given without a leading 's'. Few options only.
  [ -z "$Argsigma1" ] && [ -n "$Argword1" ] && {
    Argsigma1="$Argword1"
    Argword1=""
  }
  [ -n "$Argsigma1" ] && [ -n "$Argword1" ] && {
    error "Option does not take sigma value along with a word argument"
    return 1
  }
  [ "$Argsigma1" = "auto" ] || [ "$Argsigma1" = "$(digitonly "$Argsigma1")" ] || {
    error "Invalid sigma value: $Argsigma1"
    return 1
  }
}
maskarg_single() {
  # provide arguments of an option $1 that can be specified only once
  local Count
  eval $Arglist
  for Count in $(seq "$Imoptionsnumber"); do
    [ "${Imoptions[$Count]}" = "${1:-}" ] && maskarg_parse "$Count" && break
  done
  [ "${Imoptions[$Count]}" = "${1:-}" ]
}

### magick -script interaction

cmd() {
  local Command
  Command="${1:-}"
  [ -n "$Magickfifo" ] && {
    echo "$Command" >> "$Magickfifo"
    echo "$Command" >> "$Magickscriptlog"
  }
  return 
}
cmd_waitforkeyvalue() {
  # wait for keyword $1 in output of magick. Prints output after first :
  local Key Line
  Key="${1:-}"
  while read Line; do
    grep -q "$Key" <<< "$Line" && break
  done < <(tail -F "$Magickfifolog" ||:)
  echo "$(cut -d: -f2- <<< "$Line")"
  return 0
}
cmd_waitforready() {
  # wait for magick command toolchain to be ready
  local Command Count File Line Key
  Key="$(generate_key)"
  #Command="
  #rose:
  #  -format '$Key\n'
  #  -write info:
  #  -delete -1"
  #cmd "$Command"
  sendmagickmessage "$Key"
  cmd_waitforkeyvalue "$Key" >/dev/null
  return
}
readmagickmessage() {
  # read and parse messages from magick
  local Line Code Content
  while read Line; do
    Code="$(cut -d: -f1 <<< "$Line")"
    Content="$(cut -d: -f2- <<< "$Line")"
    case "$Code" in
      PROGRESS)
        printsameline "imfuse: $Content"
      ;;
      /PROGRESS|NEWLINE)
        echo "" >&2
      ;;
      NOTE)
        note "$Content"
      ;;
      SHOW)
        showimage "$Content"
    esac
    grep -q error <<< "$Line" && {
      note "magick ERROR:
$Line"
      break
    }
  done < <(tail -F "$Magickfifolog" ||:)
}
sendmagickmessage() {
  # send message $1 to output of magick
  local Command=
  case "$(cut -d: -f1 <<< "${1:-}")" in
    PROGRESS)
      Command="$Command
# $(cut -d: -f2- <<< "${1:-}")"
    ;;
    NOTE)
      Command="$Command
#### $(cut -d: -f2- <<< "${1:-}") ####
#"
    ;;
    *)
      Command="$Command
  # sending message ${1:-}"
    ;;
  esac
  Command="$Command
  rose:
    -format '${1:-}\n'
    -write info:
    -delete -1"
  cmd "$Command"
  return 0
}
showimagecode() {
  local Image Imageformat
  # magick code to store current image and print a showimage message for readmagickmessage()
  [ "$Showimageprocessing" ] && {
    Image="${1:-}"
    Imageformat="$(rev <<< "$Image" | cut -d. -f1 | rev)"
    [ "$(cut -c1-4 <<< "$Image")" = "mpr:" ] && Imageformat="mpr"
    case "$Imageformat" in
      ""|"mpr"|"mpc"|"miff")
        echo "# show image
    -write '$Showimage'
    -format 'SHOW:$Showimage\n'
    -write info:"
      ;;
      *)
        sendmagickmessage "SHOW:$Image"
      ;;
    esac
  }
  return 0
}
getmagickinfo() {
  # get info output for image $1 in format $2
  local Key1 Key2 Command
  Key1="$(generate_key)"
  Key2="$(generate_key)"
  Command="
  # get info ${2:-} about image ${1:-}
  ${1:-}
    -format '$Key1\n${2:-}\n$Key2\n'
    -write info:
    -delete -1"
  cmd "$Command"
  cmd_waitforready
  cmd_waitforkeyvalue "$Key2" >/dev/null
  sed -n "/$Key1/,/$Key2/p" $Magickfifolog | sed '1d ; $d'
  # code for multiple line info. -format would need a leading \n.
  #cmd_waitforkeyvalue "$Key" >/dev/null
  #sed -n "/$Key/,\$p" $Magickfifolog | sed '1d' | sed '$d' # FIXME might not be reliable; current solution to get multiple output lines
}

### main

trap_sigint() {
  local Count=0
  trap - ERR
  set +x
  note "Received SIGINT"
  kill "$Magickscriptpid"
  :> "$Exitnotefile"
  multicore_break
  finish 130
}
finish() {
  local Count=0
  trap - ERR
  set +x

  cmd "-exit"
  [ -d "$Cachedir" ] && :> "$Exitnotefile"
  multicore_wait
  break 2>/dev/null

  while ps -p "$Magickscriptpid" >/dev/null 2>&1; do
    sleep 1
    Count="$((Count+1))"
    [ "$Count" -gt "3" ] && printsameline "Waiting infinitely since $Count seconds for magick pid $Magickscriptpid to terminate"
  done
  echo "" >&2

  [ -n "$Magickmessagepid" ] && kill "$Magickmessagepid"
  #ps -p "$Magickmessagepid" >/dev/null 2>&1 && kill "$Magickmessagepid"
  exec 3>&-

  #[ -f "$Magickfifolog" ]   && cp "$Magickfifolog" .
  [ -f "$Magickscriptlog" ] && cp "$Magickscriptlog" .

  [ -f "${Showimage:-}" ] && rm "$Showimage"
  [ "$Keepcache" = "no" ] && [ -d "$Cachedir" ] && rm -R "$Cachedir"

  #jobs
  trap - SIGINT
  trap - EXIT
  exit "${1:-0}"
}
checkexit() {
  [ -e "$Exitnotefile" ] && finish
}
declare_variables() {
  Arglist='
  Argbasename=""
  Argchannel=""
  Argchannelnumber=""
  Argcolorspace=""
  Argcount=""
  Argwave=""
  Argdiff=""
  Arglevel=""
  Argblur=""
  Argmethod=""
  Argnegate=""
  Argnumber1=""
  Argnumber2=""
  Argoptions=""
  Argpercent1=""
  Argpercent2=""
  Argradius1=""
  Argradius2=""
  Argsigma1=""
  Argsigma2=""
  Argthreshold1=""
  Argthreshold2=""
  Argtype=""
  Argweight=""
  Argword1=""
  Argword2=""
  '
  eval $Arglist

  Align=""
  Cachedir=""
  Colorspace=""
  Error=""
  Exitnotefile=""
  Exifsourceimage=""
  Firstimage=""
  Firstmaskmethod=""
  Force=""
  Freemem=""
  Grayscale=""
  Grayscaleconverter=""
  Grayscalenumber=""
  Image=""
  Imageformat="tif"
  Imageheight=""
  Imagelistmemsize=""
  Imagememsize=""
  Imagewidth=""
  Image_needlist="
black
transparent
white"
  Imarguments=""
  Imoptions=""
  Imoptionsnumber="0"
  Imsourceimagelist=""
  Keepcache="no"
  Limitmemory=""
  Line=""
  Loadsourceimages=""
  Magickbin=""
  Magickfifo=""
  Magickfifolog=""
  Magickmessagepid=""
  Magickpixelmemory=""
  Magickscriptlog=""
  Magickscriptpid=""
  Magickversion=""
  Maskmethodnumber="0"
  Masksuffix="mpc"
  Masktocache="no"
  Mergemaskbasename=""
  Outputbasename=""
  Outputdir=""
  Outputimage=""
  Parsedoptions=""
  Revertimagelist=""
  Resultbasename=""
  Savemask=""
  Showimage=""
  Showimageprocessing=""
  Showname=""
  Slabautoall="no"
  Slabfirstimage=""
  Slablastimage=""
  Slabmask=""
  Slabmaskpost=""
  Slaboptcount="0"
  Slaboptarg=""
  Slaboverlap=""
  Slabresult=""
  Slabresultpost=""
  Slabnumber="0"
  Slabsize=""
  Slabstep=""
  Softmode="no"
  Sourceimage=""
  Sourceimagelist=""
  Sourceimagenumber="0"
  Sourceimagesalreadyloaded=""
  Sourcemd5=""
  Startzeit="$(date +%s)"
  Storelayered="no"
  Testarg=""
  Testimage=""
  Testsetup=""
  Tifstore="+repage -quality 100% -compress lzw"
  Tifstorealpha="$Tifstore -type TrueColorAlpha"
  Untrap=""
  Verbose=""
  Video=""
  Videoframecount=""
  Viewnior=""

  return 0
}
parse_options() {
  local Shortoptions Longoptions Parsedoptions

  Shortoptions="ho:vVW"
  Longoptions="basename:,cache::,exif::,force::,help,limit-memory::,mask2cache,output:,savemask::,showimage,showname,test::,verbose,version,video"
  Longoptions="$Longoptions,align,revert"
  Longoptions="$Longoptions,colorspace::,grayscale::"
  Longoptions="$Longoptions,blur::,comet::,compass::,diffstat::,dog::,gaussian::,freichen::,kirsch::,laplacian::,log::,morphology::,prewitt::,roberts::,sobel::,statistic::,unsharp::,wavelet::"  
  Longoptions="$Longoptions,compose::,enfuse::,evaluate::,halo::,image::,max::,mean::,median::,min::"
  Longoptions="$Longoptions,channel::,chroma::,darkness::,lightness::,saturation::"
  Longoptions="$Longoptions,experimental::,free::,freediff::"
  Longoptions="$Longoptions,level::,maskblur::,maskmorph::,maskstat::,maskwave::,merge::"
  Longoptions="$Longoptions,cutblur::,cutsoft::,less::,slabs::,soft::"
  Longoptions="$Longoptions,alpha::,finalblur::,finalblur2::,threshold::"
  Longoptions="$Longoptions,background::,bg::,layered"

  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@")" || error "Error while parsing options."
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    [ "$Error" ] && break
    case "${1:-}" in
      --align)             Align="yes"                     ;;
      --basename)          Outputbasename="${2:-auto}"     ; shift ;;
      --cache)             Cachedir="${2:-auto}"           ; shift ;;
      --exif)              Exifsourceimage="${2:-auto}"    ; shift ;;
      --force)             Force="${2:-yes}"               ; shift ;;
      -h|--help)           usage                           ; finish 0 ;;
      --layered)           Storelayered="yes"              ;;
      --limit-memory)      Limitmemory="${2:-"80%"}"       ; shift ;;
      --mask2cache)        Masktocache="yes"               ;;
      -o|--output)         Outputimage="${2:-}"            ; shift ;;
      --revert)            Revertimagelist="-r"            ;;
      --savemask)          Savemask="${2:-auto}"           ; shift ;;
      -V|--showimage)      Showimageprocessing="yes"       ;;
      --showname)          Showname="yes"                  ;;
      --test)              Testsetup="test" ; Testarg="${2:-}" ; shift ;;
      -v|--verbose)        Verbose="yes"                   ;;
      --version)           echo "imfuse v$Version"         ; finish 0 ;;
      --video)             Video="auto"                    ;;
      -W)                  Viewnior="yes"                  ;;

--blur|--channel|--chroma|--comet|--compass|--compose|--darkness|--diffstat|--dog|--enfuse|--evaluate|\
--experimental|--free|--freediff|\
--freichen|--gaussian|--halo|--image|--kirsch|--laplacian|--lightness|--log|--morphology|\
--max|--mean|--median|--min|\
--none|--prewitt|--roberts|--saturation|--sobel|--statistic|--unsharp|--wavelet|\
--maskblur|--maskmorph|--maskstat|--maskwave|\
--alpha|--finalblur|--finalblur2|--threshold|\
--bg|--background|\
--colorspace|--cutblur|--cutsoft|--grayscale|--less|--level|--merge|--soft|\
--slabs)
        Imoptionsnumber="$((Imoptionsnumber+1))"
        Argmethod="${1#--}"
        [ "$Argmethod" = "background" ] && Argmethod="bg"
        Imoptions[$Imoptionsnumber]="$Argmethod"
        Imarguments[$Imoptionsnumber]="${2:-}"
        maskarg_parse "$Imoptionsnumber"
        maskarg_store "$Imoptionsnumber"
        shift
      ;;
      --) ;;
      *)
        [ -f "${1:-}" ] || error "File not found: ${1:-}"
        grep -q ' ' <<< "${1:-}" && error "imfuse does not accept whitespace ' ' in pathes or file names: ${1:-}"
        Sourceimagenumber="$((Sourceimagenumber+1))"
        Sourceimagelist[$Sourceimagenumber]="${1:-}"
      ;;
    esac
    shift
  done
  Sourceimagelist="$(IFS=$'\n' sort -V $Revertimagelist <<< "${Sourceimagelist[@]:-}")"
  return ${Error:-0}
}
check_options() {
  # parse arguments, check validity, set defaults

  local Arg Part1 Part2 Weightsum= Weightrest Masknoweightcount= Singleoptionlist=
  local Firstimage Lastimage Slabsize Position
  local Error=

  [ "$Sourceimagenumber" = "0" ] && error "No source images provided."

  # --cache
  [ -n "$Cachedir" ] && {
    Masktocache="yes"
    Keepcache="yes"
    [ "$Cachedir" = "auto" ] && Cachedir=""
  }
  Cachedir="$(sed s%'~'%$HOME% <<< "$Cachedir")"
  case "$Masktocache" in
    yes) [ -z "$Cachedir" ] && Cachedir="./cache.imfuse" ;;
    no)  [ -z "$Cachedir" ] && Cachedir="./cache.imfuse.$$" ;;
  esac
  mkdir -p $Cachedir   || error "Error creating cache folder $Cachedir"
  Testimage="$Cachedir/test.png"
  Resultmask="$Cachedir/result.max.tif"
  Exitnotefile="$Cachedir/exit"
  rm -f "$Exitnotefile"

  # mask options
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    Argtype="$(maskarg_defaultvalue "$Argmethod" type)"
    [ -z "$Argradius1" ]    && Argradius1="$(maskarg_defaultvalue    "$Argmethod" radius1)"
    [ -z "$Argradius2" ]    && Argradius2="$(maskarg_defaultvalue    "$Argmethod" radius2)"
    [ -z "$Argsigma1" ]     && Argsigma1="$(maskarg_defaultvalue     "$Argmethod" sigma1)"
    [ -z "$Argsigma2" ]     && Argsigma2="$(maskarg_defaultvalue     "$Argmethod" sigma2)"
    [ -z "$Argpercent1" ]   && Argpercent1="$(maskarg_defaultvalue   "$Argmethod" percent1)"
    [ -z "$Argpercent2" ]   && Argpercent2="$(maskarg_defaultvalue   "$Argmethod" percent2)"
    [ -z "$Argthreshold1" ] && Argthreshold1="$(maskarg_defaultvalue "$Argmethod" threshold1)"
    [ -z "$Argthreshold2" ] && Argthreshold2="$(maskarg_defaultvalue "$Argmethod" threshold2)"
    [ -z "$Argword1" ]      && Argword1="$(maskarg_defaultvalue      "$Argmethod" word1)"
    [ -z "$Argword2" ]      && Argword2="$(maskarg_defaultvalue      "$Argmethod" word2)"
    [ -n "$Argradius1" ]    && Argradius1="$(maskarg_checkallowed    "$Argmethod" radius1    "$Argradius1")"
    [ -n "$Argradius2" ]    && Argradius2="$(maskarg_checkallowed    "$Argmethod" radius2    "$Argradius2")"
    [ -n "$Argsigma1" ]     && Argsigma1="$(maskarg_checkallowed     "$Argmethod" sigma1     "$Argsigma1")"
    [ -n "$Argsigma2" ]     && Argsigma2="$(maskarg_checkallowed     "$Argmethod" sigma2     "$Argsigma2")"
    [ -n "$Argpercent1" ]   && Argpercent1="$(maskarg_checkallowed   "$Argmethod" percent1   "$Argpercent1")"
    [ -n "$Argpercent2" ]   && Argpercent2="$(maskarg_checkallowed   "$Argmethod" percent2   "$Argpercent2")"
    [ -n "$Argthreshold1" ] && Argthreshold1="$(maskarg_checkallowed "$Argmethod" threshold1 "$Argthreshold1")"
    [ -n "$Argthreshold2" ] && Argthreshold2="$(maskarg_checkallowed "$Argmethod" threshold2 "$Argthreshold2")"
    [ -n "$Argword1" ]      && Argword1="$(maskarg_checkallowed      "$Argmethod" word1      "$Argword1")"
    [ -n "$Argword2" ]      && Argword2="$(maskarg_checkallowed      "$Argmethod" word2      "$Argword2")"

    case "$Argtype" in
      single)
        grep -q -w "$Argmethod" <<< "$Singleoptionlist" && error "Option --$Argmethod can be specified only once."
        Singleoptionlist="$Singleoptionlist $Argmethod"
      ;;
    esac
    case "$Argtype" in
      contrast)
        Arglevel="yes"
      ;;
    esac
    case "$Argtype" in
      contrast|channel|comparision)
        Maskmethodnumber="$((Maskmethodnumber+1))"
        [ -z "$Firstmaskmethod" ] && Firstmaskmethod="$Argmethod"
      ;;
    esac

    case $Argmethod in
      compose)
        Image_needlist="$Image_needlist
max
min
$Argword1"
      ;;
      evaluate)
        Image_needlist="$Image_needlist
$Argword1"
      ;;
      freichen)
        case $Argword1 in
          10|12|19) Argdiff=yes ;;
        esac
      ;;
      image)
        [ -f "$Argword1" ] || error "--image needs an image file name as argument. Not found: '$Argword1'"
      ;;
      max|mean|median|min)
        Image_needlist="$Image_needlist
$Argmethod"
      ;;
      morphology)
        case $Argword1 in
          close) ;;
          edge|edgein|edgeout|tophat|bottomhat) ;;
          *) Argdiff="yes" ;;
        esac
      ;;
      soft)
        Softmode="yes"
      ;;
      statistic)
        case $Argword1 in
          gradient|standarddeviation|"") Argdiff="" ;;
          *)                             Argdiff="yes" ;;
        esac
      ;;
    esac

    maskarg_store "$Count"
  done
  checkexit
    for Count in $(seq "$Imoptionsnumber"); do
note "${Imoptions[$Count]}=${Imarguments[$Count]}"
    done
  # w, weight
  for Count in $(seq $Imoptionsnumber); do
    maskarg_parse "$Count"
    case $Argtype in
      contrast|channel|comparision)
        Weightsum="$((Weightsum + Argweight))"
        [ -z "$Argweight" ]   && Masknoweightcount="$((Masknoweightcount+1))"
      ;;
    esac
  done
  Weightrest="$((100-Weightsum))"
  LC_ALL=C awk 'BEGIN {exit !('${Weightsum:-100}' > 100)}' && error "Sum of weight arguments exceed 100%."
  for Count in $(seq $Imoptionsnumber); do
    maskarg_parse "$Count"
    case $Argtype in
      contrast|channel|comparision)
        [ -z "$Argweight" ] && {
          LC_ALL=C awk 'BEGIN {exit !('${Weightrest:-0}' <= 0)}' && error "Sum of weight arguments exceed 100%, nothing left for --$Argmethod."
          Argweight="$(calc "$Weightrest / $Masknoweightcount ")"
        }
        maskarg_store "$Count"
      ;;
    esac
  done

  # --align
  [ "$Align" = "yes" ] && {
    command -v focus-stack >/dev/null || {
      error "--align: focus-stack not found.
  Please install focus-stack.
  https://github.com/PetteriAimonen/focus-stack"
      checkexit
    }
  }

  # --basename
  case $Outputbasename in
    #"")   Outputbasename="imfuse" ;;
    auto) Outputbasename="$(basename "$(pwd)")" ;;
  esac
  [ -d "$Outputbasename" ] && {
    Outputdir="$Outputbasename"
    Outputbasename=""
  } || {
    Outputdir="$(dirname "$Outputbasename")"
    Outputbasename="$(basename "$Outputbasename")"
  }

  # --colorspace
  maskarg_single "colorspace" && Colorspace="${Argword1^^}"
  Colorspace="${Colorspace:-"SRGB"}"

  # --grayscale
  maskarg_single "grayscale" && {
    Grayscale="$Argword1"
    case ${Grayscale,,} in
      0|none|"")         Grayscalenumber=0 ; Grayscale="none" ;;
      1|rec601luma)      Grayscalenumber=1 ; Grayscale="Rec601Luma" ;;
      2|rec601luminance) Grayscalenumber=2 ; Grayscale="Rec601Luminance" ;;
      3|rec709luma)      Grayscalenumber=3 ; Grayscale="Rec709Luma" ;;
      4|rec709luminance) Grayscalenumber=4 ; Grayscale="Rec709Luminance" ;;
      5|brightness)      Grayscalenumber=5 ; Grayscale="Brightness" ;;
      6|lightness)       Grayscalenumber=6 ; Grayscale="Lightness" ;;
      7|average)         Grayscalenumber=7 ; Grayscale="Average" ;;
      8|ms)              Grayscalenumber=8 ; Grayscale="MS" ;;
      9|rms)             Grayscalenumber=9 ; Grayscale="RMS" ;;
      *)
        error "--grayscale: Unknown argument: $Grayscale"
        checkexit
      ;;
    esac
    case $Grayscale in
      ""|none)
        Grayscaleconverter=""
      ;;
      *)
        Grayscaleconverter="-grayscale $Grayscale"
        Argword1="$Grayscale"
        maskarg_store "$Argcount"
      ;;
    esac
  }

  # --level
  maskarg_single "level" || {
    Argmethod="level"
    Argtype="single"
    Argword1="all"
    Imoptionsnumber="$((Imoptionsnumber+1))"
    Imoptions[$Imoptionsnumber]="$Argmethod"
    maskarg_store "$Imoptionsnumber"
  }

  # --showimage
  [ "$Showimageprocessing" ] && {
    command -v geeqie >/dev/null || {
      note "-V, --showimage: geeqie not found.
  Please install geeqie."
      Showimageprocessing=""
    }
  }

  # --slabs
  for Count in $(seq "$Imoptionsnumber"); do
    [ "${Imoptions[$Count]}" = "slabs" ] && Slaboptcount="$((Slaboptcount+1))"
  done
  [ "$Maskmethodnumber" -gt "0" ] && [ "$Slaboptcount" = "0" ] && {
    eval $Arglist
    Imoptionsnumber="$((Imoptionsnumber+1))"
    Imoptions[$Imoptionsnumber]="slabs"
    Imarguments[$Imoptionsnumber]="n1,N$Sourceimagenumber,TYPE=slab"
    maskarg_parse "$Imoptionsnumber"
    maskarg_store "$Imoptionsnumber"
    Slabautoall="yes"
  }
  for Count in $(seq "$Imoptionsnumber"); do
    [ "${Imoptions[$Count]}" = "slabs" ] && {
      maskarg_parse "$Count"
      [ -z "$Argnumber1" ] && [ -n "$Argpercent1" ] && Argnumber1="$(numberofpercent "$Argpercent1")"
      [ -z "$Argnumber2" ] && [ -n "$Argpercent2" ] && Argnumber2="$(numberofpercent "$Argpercent2")"
      grep -q "%" <<< "$Argradius1" && Argradius1="$(numberofpercent "$Argradius1")"
      [ -z "$Argnumber2" ] && [ -z "$Argradius1" ]  && Argradius1="$(numberofpercent "5")" # default radius 5%
      [ -z "$Argnumber1" ] && Argnumber1="$(numberofpercent "14")"                         # default 7 slabs
      maskarg_store "$Count"
      # single slab
      [ -n "$Argnumber1" ] && [ -n "$Argnumber2" ] && {
        Argradius1="${Argradius1:-0}"
        Firstimage="$((Argnumber1-Argradius1))"
        Lastimage="$((Argnumber2+Argradius1))"
        [ "$Firstimage" -lt "1" ]                 && Firstimage="1"
        [ "$Lastimage" -gt "$Sourceimagenumber" ] && Lastimage="$Sourceimagenumber"
        Slabnumber="$((Slabnumber+1))"
        Slabfirstimage[$Slabnumber]="$Firstimage"
        Slablastimage[$Slabnumber]="$Lastimage"
      }

      # generate set of slabs
      [ -n "$Argnumber1" ] && [ -z "$Argnumber2" ] && {
        Slabsize="$Argnumber1"
        Position="0"
        while [ "${Lastimage:-0}" -lt "$Sourceimagenumber" ]; do
          Firstimage="$((Position-Argradius1))"
          Lastimage="$((Position+Slabsize+Argradius1))"
          [ "$Firstimage" -lt "1" ]                 && Firstimage="1"
          [ "$Argword1" = "kurt" ]                  && Firstimage="1"
          [ "$Lastimage" -gt "$Sourceimagenumber" ] && Lastimage="$Sourceimagenumber"
          Slabnumber="$((Slabnumber+1))"
          Slabfirstimage[$Slabnumber]="$Firstimage"
          Slablastimage[$Slabnumber]="$Lastimage"
          Position="$((Position+Slabsize))"
        done
      }
    }
  done

  # --soft
  [ "$Softmode" = "yes" ] && {
    maskarg_single "cutblur" && Softmode="error"
    maskarg_single "cutsoft" && Softmode="error"
    maskarg_single "less"    && Softmode="error"
    [ "$Softmode" = "error" ] && {
      error "Option --soft does not support options
  --cutblur, --cutsoft, --less."
      checkexit
    }
  }

  return ${Error:-0}
}
main_setup() {

  # check magick version
  Magickbin="$(command -v magick)"
  [ -e "/usr/lib/x86_64-linux-gnu/libtcmalloc_minimal.so.4.5.6" ] && {
    # https://imagemagick.org/script/openmp.php
    # https://goog-perftools.sourceforge.net/doc/tcmalloc.html
    #Magickbin="env LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libtcmalloc_minimal.so.4.5.6 $Magickbin"
    :
  }
  [ -z "$Magickbin" ] && error "Command 'magick' not found. Please install ImageMagick version 7."
  Magickversion="$($Magickbin -version)"
  # Bytesperpixel*(channels)*unknownfactor
  grep -q " Q8 "        <<< "$Magickversion" && Magickpixelmemory="$(( 1*(5) *3 ))"
  grep -q " Q8-HDRI "   <<< "$Magickversion" && Magickpixelmemory="$(( 2*(5) *3 ))"
  grep -q " Q16 "       <<< "$Magickversion" && Magickpixelmemory="$(( 2*(5) *3 ))"
  grep -q " Q16-HDRI "  <<< "$Magickversion" && Magickpixelmemory="$(( 4*(5) *3 ))"
  grep -q " Q32 "       <<< "$Magickversion" && Magickpixelmemory="$(( 4*(5) *3 ))"
  grep -q " Q32-HDRI "  <<< "$Magickversion" && Magickpixelmemory="$(( 8*(5) *3 ))"
  Magickversion="$(head -n1 <<< "$Magickversion" | cut -d' ' -f3)"

  # check RAM
  Freemem="$(printfreememory)"
  [ -z "$Freemem" ] && {
    note "WARNING: failed to estimate free memory.
  Blindly guessing 1GB."
    Freemem="1000000"
  }
  Limitmemory="${Limitmemory:-"80%"}"
  grep -q "%" <<< "$Limitmemory" && {
    Limitmemory="$(tr -d "%" <<< "$Limitmemory")"
    Limitmemory="$((Freemem*Limitmemory/100))"
  } || {
    Limitmemory="$((Limitmemory*1000))"
  }

  # Image properties
  Sourceimagenumberlength="${#Sourceimagenumber}"
  Image="${Sourceimagelist[1]}"
  Imagewidth="$($Magickbin  -format '%w' "$Image" info:)"
  Imageheight="$($Magickbin -format '%h' "$Image" info:)"
  Imagememsize="$((Imagewidth*Imageheight*Magickpixelmemory/1000))"
  Imagememsize="$((Imagememsize*125/100))" # by observation. Alpha channel?
  Imagelistmemsize="$((Sourceimagenumber*Imagememsize))"

  Sourcemd5="$(md5cut "$(ls -l --full-time ${Sourceimagelist[@]})" )"
  echo "$Sourcemd5" > "$Cachedir/md5"
  Showimage="${XDG_RUNTIME_DIR:-$Cachedir}/imfuse.showimage.tif"

  # check if source images should be loaded to RAM
  [ "$((Imagelistmemsize))" -lt "$((Limitmemory/2))" ] && Loadsourceimages="yes" || Loadsourceimages="no"

  # --output, --basename
  check_outputname
  # --showname
  [ "$Showname" = "yes" ] && {
    echo "$Outputimage"
    finish
  }

  note "
  imfuse Version:                     $Version
  Imagemagick version:                $Magickversion
  Image number:                       $Sourceimagenumber
  Image width:                        $Imagewidth px
  Image height:                       $Imageheight px
  Image memory size (estimated):      $Imagememsize KB
  Image list memory size (estimated): $((Imagelistmemsize/1024)) MB
  Memory total (including zram):      $(($(printtotalmemory)/1000)) MB
  Memory currently free:              $((Freemem/1000)) MB
  Memory limit for imagemagick:       $((Limitmemory/1000)) MB
  Loading source images to RAM:       $Loadsourceimages
  Option summary: $Resultbasename"
  #[ "$Maskmethodnumber" = "0" ] && note "No mask option specified, generating background only: $Background"

  # start magick -script in background
  Magickfifo="$Cachedir/magickfifo"
  Magickfifolog="$Cachedir/magickmessage.log"
  Magickscriptlog="$Cachedir/magickscript.log"
  Magickfifolog="./magickmessage.log"
  Magickscriptlog="./magickscript.log"
  :> $Magickscriptlog
  rm -f "$Magickfifo" 2>/dev/null ||:
  mkfifo $Magickfifo
  exec 3<>$Magickfifo
  (
    $Untrap
    nice magick -limit memory ${Limitmemory}KB -define registry:temporary-path=$Cachedir -script - <&3 >$Magickfifolog 2>&1
  ) & Magickscriptpid="$!"
  (
    $Untrap
    readmagickmessage
  ) & Magickmessagepid="$!"

  # --force
  [ -f "$Outputimage" ] && [ -z "$Force" ] && {
    showimage "$Outputimage"
    [ "$Viewnior" ] && viewnior "$Outputimage" &
    note "Output image already exists with matching md5sum.
  You can force imfuse to run nonetheless with option --force."
    echo $Outputimage
    exit
    return 0
  }

  # start geeqie
  maskarg_single "colorspace"
  Command="
# $Resultbasename
# $(date)
  ( wizard:
      -colorspace ${Colorspace:-$Argword1}"
      [ -n "$Argword2" ] && Command="$Command
      -channel $Argword2
      -separate
      +channel"
      Command="$Command
  )
    $Grayscaleconverter
    -statistic standard_deviation 2
    -auto-level
    -write $Showimage
    -delete 0"
  cmd "$Command"
  cmd_waitforready
  [ "$Showimageprocessing" = "yes" ] && geeqie -t -r --File:"$Showimage" 2>/dev/null

  return 0
}
main() {
#  shopt -s inherit_errexit
  set -Eu
  trap trap_sigint SIGINT
  trap finish      EXIT
  trap finish      ERR
  Untrap="
trap - SIGINT
trap - EXIT
trap - ERR"

  declare_variables
  parse_options "$@"
  check_options
  [ "$Error" ] && return 1
  main_setup
  multicore_init

  # --force
  [ "$Force" = "mask" ]  && forcemask
  [ "$Force" = "merge" ] && forcemerge
  [ "$Force" = "level" ] && forcelevel
  [ "$Force" = "focus" ] && forcefocus
  [ "$Force" = "post" ]  && forcepost

  # --align
  [ "$Align" = "yes" ] && {
    align || error "Error in align()."
  }

  # Generate backgrounds etc.
  Image_needlist="$(grep . <<< "$Image_needlist" | sort -V | uniq)"
  for Mode in $Image_needlist; do
    generate_image --mode "$Mode"
  done

  # run
  focus_main

  # --exif: transfer EXIF metadata from first image to result
  [ "$Exifsourceimage" ] && {
    [ "$Exifsourceimage" = "auto" ] && Exifsourceimage="${Sourceimagelist[1]}"
    exiftransfer "$Exifsourceimage" "$Outputimage"
  }

  showimage "$Outputimage"
  note "Ready after $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")"
  echo "$Outputimage"
  command -v xclip >/dev/null && echo "$Outputimage" | xclip -i -selection clipboard

  # -W
  [ "$Viewnior" ] && viewnior "$Outputimage" &
  # --video
  [ "$Video" ]    && generate_video

  return "${Error:-0}"
}
main "$@" || Error=1
finish "${Error:-0}"
