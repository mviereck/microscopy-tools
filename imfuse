#! /bin/bash

# imfuse
Version="0.1"

usage() {
  echo "imfuse v$Version - combine focus stackshot images to an overall sharp image.
Aims to be similar to enfuse, but with the help of ImageMagick.

Dependencies:
  imagemagick      Mandatory (command 'convert' or 'magick').
  geeqie           Optional, used by option -V, --showimage.
  enfuse           Optional, used by option --enfuse.

Usage:
  imfuse [OPTIONS] -- image1 image2 image3 ...

General options:
     --cachedir=DIR          Specify a cache folder.
 -h, --help                  Show this help and exit.
 -o, --output=FILE           Specify result image.
 -v, --verbose               Show verbose output.
     --version               Show imfuse version and exit.
 -V, --showimage             Show intermediate results with geeqie.

Mask generating methods:                                 Default: --compose
     --blur                  Difference of -blur.
                             Takes options: 
                               --radius                  Default: 0
                               --sigma1                  Default: 3
                               --sigma2                  Default: 1.6*sigma1
     --compass               Compass edge detection. 
     --compose [=MODE]       Composes a result with mode MODE based on a max
                             and a min calculation of the source images.
                             Compare IM option -compose. Default: overlay
                             MODE can be one of '$(basename $Magickbin) -list compose'
                             Some MODEs of interest:
                               bumpmap colorburn difference linearburn 
                               linearlight modulate multiply overlay pegtoplight
                             Does not generate masks but directly combines.
                             Takes options:
                               --swap       
                             Hint: Generate max+min images with --evaluate and
                             provide only them to --compose to speed it up.
     --dog                   Difference of Gaussians.
                             Takes options: 
                               --radius                  Default: 0
                               --sigma1                  Default: 0.5
                               --sigma2                  Default: 1.6*sigma1
     --enfuse [=ENFUSEARGS]  Uses external binary enfuse for mask generation.
                             Takes options: 
                               --radius                  Default: 5
                             Optionally add custom enfuse options ENFUSEARGS.
                             One of interest is '--hard-mask'.
                             Option --radius sets --contrast-window-size=RADIUS.
     --evaluate [=MODE]      Evaluates a result of all source images with
                             mode MODE.                  Default: max
                             MODE can be one of '$(basename $Magickbin) -list evaluate'
                             Compare IM option -evaluate-sequence.
                             Most of interest:
                               max      Brightest pixels in sequence. 
                                        Fast and pretty result.
                               mean     Average pixel values in sequence. 
                                        Useful to combine imfuse results.
                               median   Middle pixel values in sequence. 
                                        Useful to combine imfuse results.
                               min      Darkest pixels in sequence.
                             Does not generate masks but directly combines.
     --free='IMOPTION'       Custom ImageMagick option IMOPTION 
                             for mask generation.        Default: '-edge 2'
     --freichen              Frei-Chen edge detection. 
     --kirsch                Kirsch edge detection. 
     --laplacian [=MODE]     Laplacian edge detection.
                             MODE is the kernel number to use.
     --log                   Logarithm of Gaussian.
                             Takes options: 
                               --radius                  Default: 0
                               --sigma1                  Default: 0.5
     --prewitt               Prewitt edge detection. 
     --roberts               Roberts edge detection. 
     --sobel                 Sobel edge detection. 
     --statistic [=MODE]     ImageMagick option -statistic.
                             Takes options:
                               --radius                  Default: 5
                             Argument MODE is one of:
                                      gradient|grad
                                      maximum|max
                                      mean
                                      median
                                      minimum|min
                                      mode
                                      nonpeak
                                      rms
                                      standarddeviation|dev
                             Default: standarddeviation
     --unsharp               Difference of -unsharp.
                             Takes options: 
                               --radius                  Default: 0
                               --sigma1                  Default: 3
                               --sigma2                  Default: 1.6*sigma1
                                      

Method settings: (Effect depends on method, see above.)
 -r, --radius=RADIUS         Automatically chooses a radius if RADIUS=0
 -s, --sigma=SIGMA1
 -S, --sigma2=SIGMA2         Default: SIGMA2=SIGMA1*1.6
     --swap                  Invert order of max/min in --compose.
                             Changes result of some but not all compose modes.
 
Method independent adjustments:
     --addmax                Add a maximum image of source images to image list.
     --addmean               Add a mean image of source images to image list.
     --addmin                Add a minimum image of source images to image list.
 -g, --gamma [=GAMMA]        Adjust gamma of result. GAMMA>1 brightens the image,
                             GAMMA<1 darkens the image.  Default: auto
 -m, --mode FUSEMODE         Method to fuse images based on generated masks.
                             Does not affect --evaluate and --compose.
                             FUSEMODE can be:
                             1 : prefer sharp areas of source images
                             2 : prefer sharp areas of intermediate result
                             3 : provide source masks to enfuse
                             4 : provide diff masks to enfuse
                             5 : combine 1+2, multiply evaluate max+min
                             6 : combine 1+2  with evaluate max
                             7 : combine 1+2  with evaluate min
"
}

### Messages

error() {
  [ -z "$Error" ] && echo "imfuse ERROR: $*
" >&2
  Error=1
  #exit 1
}
note() {
  [ -z "$Error" ] && echo "imfuse note: $*"
  return 0
}
verbose() {
  [ "$Verbose" = "yes" ] && echo "imfuse: $*"
  return 0
}
showimage() {
  [ "$Showimage" = "yes" ] && geeqie -t -r File:"${1:-}" &
  return 0
}

### Misc

freememory() {
  local Freemem Line Zram
  Freemem="$(LC_ALL=C free | grep "Mem:" | awk '{print $7}')"
  while read Line; do
    Zram="$(awk '{print ($3 - $4)}' <<< "$Line")"
    Zram="$((Zram/1000))"
    Freemem="$((Freemem + Zram))"
  done < <(/sbin/swapon --bytes | grep zram)
  echo $Freemem
}
lowercase() {
    # Usage: lowercase "string"
    printf '%s\n' "${1,,}"
}
printnum(){
  # print number $1 with leading zeroes.
  # $1 number
  # $2 digits. Default: 3
  printf %0${2:-3}d "${1:-0}"
}
trap_sigint() {
  error "Received SIGINT"
}

### Image processing

evaluate_step() {
  # evaluate in small stack steps to avoid high memory usage and caching.
  # Gives correct results for max and min, but not for mean or median.
  ### FIXME weak results for unknown reasons
  
  local Imagelist Destinationfile
  local Mode Step Stepsize Stackcount Stacklist
  local Startzeit Dauer Restzeit
  
  Mode="${1:-}" ; shift
  Destinationfile="${1:-}" ; shift
  Stepsize=40
  while [ $# -gt 0 ]; do
    Imagelist="$Imagelist
${1:-}"
    shift
  done
  Imagelist="$(tail -n+2 <<< "$Imagelist")"
  Startzeit="$(date +%s)"
  Stackcount=0
  set -x
  for Step in 0 $(seq $((Imagenumber/$Stepsize)) ); do
    Stackcount="$((Stackcount+1))"
    Stacklist="$(tail -n+$((Stepsize*Step+1)) <<< "$Imagelist" | head)"
    [ "$Step" != "0" ] && Stacklist="$Destinationfile $Stacklist"
    nice $Magickbin $Stacklist -evaluate-sequence $Mode $Destinationfile || return 1
    showimage $Destinationfile
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-((Step+1)*Stepsize)) / ((Step+1)*Stepsize) ))"
    [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
    verbose "Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T") ($Restzeit)"
  done
  set +x
}
evaluate_split() {

  local Imagelist Resultimage Mode
  local Startzeit Dauer Restzeit
  local Image Split Splitpercent Showsplit Part Partimage Partimagelist
  local Startzeit Dauer Restzeit Count
  
  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  while [ $# -gt 0 ]; do
    Imagelist="$Imagelist
${1:-}"
    shift
  done
  Imagelist="$(tail -n+2 <<< "$Imagelist")"
  
  Split="$((Imagelistmemsize/Freemem +1))"
  
  case $Split in
    1) 
      $Magickbin $Imagelist -evaluate-sequence $Mode $Resultimage
    ;;
    *)
      Startzeit="$(date +%s)"
      Splitpercent="$((100/Split))"
      Showsplit="$(printnum $(( (Split+1)/2 )) 3)"
      Count="0"
      for Image in $Imagelist; do
        Count="$((Count+1))"
        verbose "Splitting image $Count / $Imagenumber into $Split pieces due to low memory: $(basename $Image)"
        $Magickbin $Image -crop 100%x${Splitpercent}% $Cachedir/split%03d.$(basename $Image).tif || return 1
        showimage $Cachedir/split${Showsplit}.$(basename $Image).tif
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
      done
      Startzeit="$(date +%s)"
      for Part in $(seq 0 $((Split-1))) ; do
        verbose "Evaluating part $((Part+1)) / $Split"
        Partimage=$Cachedir/$Mode.part$Part.tif
        $Magickbin $Cachedir/split$(printnum $Part 3).*.tif -evaluate-sequence $Mode $Partimage || return 1
        Partimagelist="$Partimagelist $Partimage"
        showimage $Partimage
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Split-Part+1) / (Part+1) ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
      done
      $Magickbin $Partimagelist -append $Resultimage
    ;;
  esac
}

fuse_focus_stackshot()  {
  # fuse focus image stackshot.
  # Based on snibgo's focus stacking script at http://im.snibgo.com/focstack.htm
  
  local Count Number Firstimage 
  local Sourcemask Resultmask Diffmask Resultcount Sourcecount
  local Maskgenerator Maskgenerator2
  local Writesourcemask Writeresultmask Writediffmask Writesourcecount Writeresultcount
  local Startzeit Dauer Restzeit
  
  # Use first image as base of result
  Firstimage="$(head -n1 <<< "$Imagelist")"
  $Magickbin "$Firstimage" "$Resultimage" || error "Error while reading first image"
  
  showimage "$Resultimage"
  
  # Interate on rest of image list
#  Count=1
#  for Sourceimage in $(grep -v -x "$Firstimage" <<< "$Imagelist"); do
  Startzeit="$(date +%s)"
  Count=0
  for Sourceimage in $Imagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    Sourcemask="$Cachedir/${Number}.mask.source.tif"
    Resultmask="$Cachedir/${Number}.mask.result.tif"
    Resultcount="$Cachedir/${Number}.result.tif"
    Diffmask="$Cachedir/${Number}.mask.diff.tif"
    [ "$Savemask" = "yes" ] && {
      Writesourcemask="-write $Sourcemask"
      Writeresultmask="-write $Resultmask"
      Writeresultcount="-write $Resultcount"
      Writediffmask="-write $Diffmask"
    }
    
    verbose "Processing Image $Count / $Imagenumber with method $Method in fuse mode $Mode: $(basename $Sourceimage)" 
    
    # Mask generating ImageMagick options
    # Most of them are based on edge detection: http://www.imagemagick.org/Usage/convolve/#edgedet
    Maskgenerator=""
    Maskgenerator2=""
    case $Method in
      blur)
        # Compare two blurred images with different sigma.
        # Concept and result is similar to Difference of Gaussian (DoG). Using -gaussian-blur gives same as DoG.
        # Code based on https://im.snibgo.com/simpalign.htm#twoBlrDiff.bat
        Maskgenerator="( -clone 0 -blur ${Radius}x${Sigma1} )
                       ( -clone 0 -blur ${Radius}x${Sigma2} )
                       -delete 0
                       -compose Difference -composite"
#                       -grayscale RMS"
      ;;
      blur2)
        Maskgenerator="( -clone 0 -blur ${Radius}x${Sigma1} )
                       ( -clone 0 -blur ${Radius}x${Sigma2} )
                       -delete 0
                       -compose Mathematics -define compose:args=0,-4,4,0.5 -composite
                       -grayscale RMS"
      ;;
      compass)
        Maskgenerator="-define convolve:scale=50%!
                       -define convolve:bias=50%
                       -morphology Convolve Compass" ### FIXME
      ;;
      dog) # DoG: Difference of Gaussian
        # This will generate a 'DoG' or "Difference of Gaussians" kernel in which 
        # the gaussian generated by 'sigma1' will have the gaussian generated by 'sigma2' subtracted from it. 
        # Normally 'sigma2' is the larger so that the 'central peak' of the kernel is positive. 
        # Reversing the two numbers will effectivally negate the resulting kernel. 
        # By generating two 'Gaussian' kernels of slightly different sigma values (in a ratio of approximatally 1.6), 
        # and subtracting them from each other you can actually generate a close approximation of a Laplacian of a Gaussian. 
        Maskgenerator="-define convolve:bias=50%
                       -morphology Convolve DoG:$Radius,$Sigma1,$Sigma2"
      ;;
      enfuse) # masks generated by enfuse instead by ImageMagick
        (
          cd "$Cachedir" 
          enfuse --contrast-weight=1 --saturation-weight=0 --exposure-weight=0 \
               --save-masks \
               --contrast-window-size=$Radius \
               -o enfuse-out.tif \
               $Maskgeneratorargument \
               "$Sourceimage" "$Resultimage" \
               2>&1 | grep -v -E 'no usable resolution|loading next image|will assume 300 dpi|assuming all pixels|does not have an alpha channel'
          grep -q "hard-mask" <<< "$Maskgeneratorargument" && {
            mv hardmask-1.tif $Sourcemask
            mv hardmask-2.tif $Resultmask
          } || {
            mv softmask-1.tif $Sourcemask
            mv softmask-2.tif $Resultmask
          }
          rm softmask-1.tif softmask-2.tif hardmask-1.tif hardmask-2.tif enfuse-out.tif 2>/dev/null
        )
        # workaround to put results into magick command
        Maskgenerator=" -delete 0 $Sourcemask" 
        Maskgenerator2="-delete 0 $Resultmask"
      ;;
      experimental)
        Maskgenerator="-edge $Radius"
      ;;
      free)
        Maskgenerator="$Maskgeneratorargument"
      ;;
      freichen)
        Maskgenerator="-define convolve:scale=50%!
                       -define morphology:compose=Lighten
                       -define convolve:bias=50%
                       -morphology Convolve FreiChen:>" ### FIXME allow more modes
      ;;
      kirsch)
        Maskgenerator="-define convolve:scale=50%!
                       -define convolve:bias=50%
                       -morphology Convolve Kirsch" ### FIXME
      ;;
      laplacian)
        Maskgenerator="-define convolve:bias=50%
                       -define convolve:scale=!
                       -morphology Convolve Laplacian:$Maskgeneratorargument"
      ;;
      log)  # LoG: Laplacian of Gaussian
        Maskgenerator="-define convolve:bias=50% \
                       -morphology Convolve LoG:${Radius}x${Sigma1}"
      ;;
      prewitt)
        Maskgenerator="-define convolve:scale=50%!
                       -define convolve:bias=50%
                       -morphology Convolve Prewitt" ### FIXME
      ;;
      roberts)
        Maskgenerator="-define morphology:compose=Lighten
                       -define convolve:bias=50%
                       -morphology Convolve Roberts:@"
      ;;
      sobel)
        Maskgenerator="-define convolve:scale=!
                       -define convolve:bias=50%
                       -define morphology:compose=Lighten
                       -morphology Convolve Sobel:>"
      ;;
      statistic)
        Maskgenerator="-statistic $Maskgeneratorargument ${Radius}x${Radius}"
      ;;
      unsharp)
        Maskgenerator="( -clone 0 -unsharp ${Radius}x${Sigma1} )
                       ( -clone 0 -unsharp ${Radius}x${Sigma2} )
                       -delete 0
                       -compose Difference -composite
                       -grayscale RMS"
      ;;
    esac
    Maskgenerator2="${Maskgenerator2:-$Maskgenerator}" # workaround for --enfuse. Otherwise Maskgenerator==Maskgenerator2
    Maskgenerator="$(echo $Maskgenerator)"
    Maskgenerator2="$(echo $Maskgenerator2)"
    
    # --negate
    [ "$Negate" = "yes" ] && {
      Maskgenerator="-negate $Maskgenerator"
      Maskgenerator2="-negate $Maskgenerator2"    
    }
    
    # --weight
    [ "$Sourceweight" ] && {
      Maskgenerator="$Maskgenerator -modulate $Sourceweight"    
    }

    Maskgenerator="-grayscale RMS $Maskgenerator"    
    Maskgenerator2="-grayscale RMS $Maskgenerator2"    

    # Apply masks to fuse current source image with intermediate result image
    case $Mode in
      1)
        # prefer source over result
        $Magickbin \
          $Sourceimage \
            -write mpr:sourceimage \
            $Maskgenerator \
            -write mpr:sourcemask $Writesourcemask \
            -delete 0 \
          $Resultimage \
            -write mpr:resultimage \
            $Maskgenerator2 \
            -write mpr:resultmask $Writeresultmask \
            -delete 0 \
          mpr:sourcemask mpr:resultmask \
            -compose MinusDst -composite -fill white +opaque black -write mpr:diffmask $Writediffmask \
            -delete 0 \
          mpr:sourceimage mpr:resultimage mpr:diffmask \
            -alpha off -compose Over -composite $Writeresultcount \
            "$Resultimage" || error "Error in fuse"
        showimage $Resultimage
      ;;
      2)
        # prefer result over source
        $Magickbin \
          $Sourceimage \
            -write mpr:sourceimage \
            $Maskgenerator \
            -write mpr:sourcemask $Writesourcemask \
            -delete 0 \
          $Resultimage \
            -write mpr:resultimage \
            $Maskgenerator2 \
            -write mpr:resultmask $Writeresultmask \
            -delete 0 \
          mpr:resultmask mpr:sourcemask \
            -compose MinusDst -composite -fill white +opaque black \
            -write mpr:diffmask $Writediffmask \
            -delete 0 \
          mpr:resultimage mpr:sourceimage mpr:diffmask \
            -alpha off -compose Over -composite $Writeresultcount \
            "$Resultimage" || error "Error in fuse"
        showimage $Resultimage
      ;;
      3)
        # enfuse source masks
        $Magickbin \
          $Sourceimage \
            $Maskgenerator \
            $Sourcemask || error "Error in mask generation"
        showimage $Sourcemask
      ;;
      4)
        # enfuse diff masks
        $Magickbin \
          $Sourceimage \
            $Maskgenerator \
            -write mpr:sourcemask $Writesourcemask \
            -delete 0 \
          $Resultimage \
            $Maskgenerator2 \
            -write mpr:resultmask $Writeresultmask \
            -delete 0 \
          mpr:sourcemask mpr:resultmask \
            -compose MinusDst -composite -fill white +opaque black \
            $Diffmask
        showimage $Diffmask
      ;;
      5)
        # combine mode 1+2: multiply max+min
        $Magickbin \
          $Sourceimage \
            -write mpr:sourceimage  \
            $Maskgenerator  \
            -write mpr:sourcemask \
            -delete 0 \
          $Resultimage \
            -write mpr:resultimage \
            $Maskgenerator2 \
            -write mpr:resultmask \
            -delete 0 \
          mpr:sourcemask mpr:resultmask \
            -compose MinusDst -composite -fill white +opaque black  \
            -write mpr:diffmask \
            -delete 0 \
          mpr:sourceimage mpr:resultimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result1 \
            -delete 0 \
          mpr:resultmask mpr:sourcemask \
            -compose MinusDst -composite -fill white +opaque black \
            -write mpr:diffmask                   \
            -delete 0 \
          mpr:resultimage mpr:sourceimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result2 \
            -delete 0 \
          mpr:result1 mpr:result2 \
            -evaluate-sequence min \
            -write mpr:resultmin \
            -delete 0 \
          mpr:result1 mpr:result2 \
            -evaluate-sequence max \
            -write mpr:resultmax \
            -delete 0 \
          mpr:resultmin mpr:resultmax \
            -evaluate-sequence multiply \
            -gamma 2 \
          "$Resultimage" || error "Error in fuse"
        showimage $Resultimage
      ;;
      6)
        # combine mode 1+2: max
        $Magickbin \
          $Sourceimage \
            -write mpr:sourceimage  \
            $Maskgenerator  \
            -write mpr:sourcemask \
            -delete 0 \
          $Resultimage \
            -write mpr:resultimage \
            $Maskgenerator2 \
            -write mpr:resultmask \
            -delete 0 \
          mpr:sourcemask mpr:resultmask \
            -compose MinusDst -composite -fill white +opaque black  \
            -write mpr:diffmask \
            -delete 0 \
          mpr:sourceimage mpr:resultimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result1 \
            -delete 0 \
          mpr:resultmask mpr:sourcemask \
            -compose MinusDst -composite -fill white +opaque black \
            -write mpr:diffmask                   \
            -delete 0 \
          mpr:resultimage mpr:sourceimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result2 \
            -delete 0 \
          mpr:result1 mpr:result2 \
            -evaluate-sequence max \
          "$Resultimage" || error "Error in fuse"
        showimage $Resultimage
      ;;
      7)
        # combine mode 1+2: min
        $Magickbin \
          $Sourceimage \
            -write mpr:sourceimage  \
            $Maskgenerator  \
            -write mpr:sourcemask \
            -delete 0 \
          $Resultimage \
            -write mpr:resultimage \
            $Maskgenerator2 \
            -write mpr:resultmask \
            -delete 0 \
          mpr:sourcemask mpr:resultmask \
            -compose MinusDst -composite -fill white +opaque black  \
            -write mpr:diffmask \
            -delete 0 \
          mpr:sourceimage mpr:resultimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result1 \
            -delete 0 \
          mpr:resultmask mpr:sourcemask \
            -compose MinusDst -composite -fill white +opaque black \
            -write mpr:diffmask                   \
            -delete 0 \
          mpr:resultimage mpr:sourceimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result2 \
            -delete 0 \
          mpr:result1 mpr:result2 \
            -evaluate-sequence min \
          "$Resultimage" || error "Error in fuse"
        showimage $Resultimage
      ;;
      8)
        # combine mode 1+2: overlay max+min
        $Magickbin \
          $Sourceimage \
            -write mpr:sourceimage  \
            $Maskgenerator  \
            -write mpr:sourcemask \
            -delete 0 \
          $Resultimage \
            -write mpr:resultimage \
            $Maskgenerator2 \
            -write mpr:resultmask \
            -delete 0 \
          mpr:sourcemask mpr:resultmask \
            -compose MinusDst -composite -fill white +opaque black  \
            -write mpr:diffmask \
            -delete 0 \
          mpr:sourceimage mpr:resultimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result1 \
            -delete 0 \
          mpr:resultmask mpr:sourcemask \
            -compose MinusDst -composite -fill white +opaque black \
            -write mpr:diffmask                   \
            -delete 0 \
          mpr:resultimage mpr:sourceimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result2 \
            -delete 0 \
          mpr:result1 mpr:result2 \
            -evaluate-sequence min \
            -write mpr:resultmin \
            -delete 0 \
          mpr:result1 mpr:result2 \
            -evaluate-sequence max \
            -write mpr:resultmax \
            -delete 0 \
          mpr:resultmin mpr:resultmax \
            -compose overlay -composite \
          "$Resultimage" || error "Error in fuse"
        showimage $Resultimage
      ;;
    esac
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
  done
  [ "$Error" ] && return "${Error:-0}"
  case $Mode in
    3)
      enfuse --load-masks=$Cachedir/%n.mask.source.tif -o $Resultimage $Imagelist || error "Error in enfuse"
    ;;
    4)
      enfuse --load-masks=:$Cachedir/%n.mask.diff.tif --hard-mask  -o $Resultimage $Imagelist || error "Error in enfuse"
    ;;
  esac
  
  return "${Error:-0}"
}

### main

declare_variables() {
  Addmax="no"
  Addmean="no"
  Addmin="no"
  Compress=""
  Error=""
  Freemem=""
  Gamma=""
  Sourceweight=""
  Image=""
  Imageformat="tif"
  Imageheight=""
  Imagelist=""
  Imagelistmemsize=""
  Imagememsize=""
  Imagenumber=""
  Imagewidth=""
  Magickbin=""
  Magickpixelmemory=""
  Magickversion=""
  Method=""
  Maskgeneratorargument=""
  Mode=""
  Negate="no"
  Outputimage=""
  Revertimagelist="no"
  Savemask="no"
  Showimage="no"
  Swapcompose=""
  Startzeit="$(date +%s)"
  Cachedir=""
  Radius=""
  Sigma1=""
  Sigma2=""
  Verbose="no"
  return 0
}
parse_options() {
  local Shortoptions Longoptions Parsedoptions Parsererror Parsererrorfile
  
  Shortoptions="g::hm:o:r:s:S:vV"
  Longoptions="cachedir:,help,verbose,version,output:,showimage"
  Longoptions="$Longoptions,addmax,addmean,addmin,gamma::,mode:,negate,radius:,revert,sigma:,sigma1:,sigma2:,swap,weight:"
  Longoptions="$Longoptions,blur::,compass::,compose::,dog::,enfuse::,evaluate::,experimental::,free::,freichen::,kirsch::,laplacian::,log::,prewitt::,roberts::,sobel::,statistic::,unsharp::"  

  Parsererrorfile="/tmp/imfuse.parserserror.$RANDOM"
  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@" 2>"$Parsererrorfile")"
  [ -e $Parsererrorfile ] && Parsererror="$(cat "$Parsererrorfile")" && rm "$Parsererrorfile"
  [ "$Parsererror" ] && error "$Parsererror"
  eval set -- "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    [ "$Error" ] && break
    case "${1:-}" in
      -h|--help)           usage ; exit 0 ;;
      --addmax)            Addmax="yes" ;;
      --addmean)           Addmean="yes" ;;
      --addmin)            Addmin="yes" ;;
      -g|--gamma)          Gamma="${2:-auto}" ; shift ;;
      -m|--mode)           Mode="${2:-}" ; shift ;;
      --negate)            Negate="yes" ;;
      -o|--output)         Outputimage="${2:-}" ; shift ;;
      -V|--showimage)      Showimage="yes" ;;
      -s|--sigma|--sigma1) Sigma1="${2:-}" ; shift ;;
      -S|--sigma2)         Sigma2="${2:-}" ; shift ;;
       --swap)             Swapcompose="-swap 0,1" ;;
      -r|--radius)         Radius="${2:-}" ; shift ;;
      --revert)            Revertimagelist="yes" ;;
      --cachedir)          Cachedir="${2:-}" ; Savemask="yes" ; shift ;;
      -v|--verbose)        Verbose="yes" ;;
         --version)        echo "imfuse v$Version"; exit 0 ;;
      --weight)            Sourceweight="${2:-}" ; shift ;;
      --blur|--compass|--compose|--dog|--enfuse|--evaluate|--experimental|--free|--freichen|--kirsch|--laplacian|--log|--prewitt|--roberts|--sobel|--statistic|--unsharp)
        Method="${1#--}"
        Maskgeneratorargument="${2:-}"  && shift
      ;;  
      --) ;;
      *)
        Imagelist="$Imagelist
$(realpath "${1:-}")" 
        [ -f "${1:-}" ] || error "File not found: ${1:-}"
      ;;
    esac
    shift
  done
  return ${Error:-0}
}
check_options() {
  [ -z "$Imagelist" ] && error "No images specified"
  
  # --method
  case $Method in
    enfuse)
      command -v enfuse >/dev/null || error "--enfuse: command enfuse not found. Please install enfuse."
    ;;
    "")
      Method="compose"
      note "Setting --$Method"
    ;;
  esac
  
  # --sigma1
  case $Method in
    experimental) ;;
    blur|dog|log|unsharp)
      [ -z "$Sigma1" ] && {
        Sigma1="0.5"
        note "Setting --sigma=$Sigma1"
      }
    ;;
    *)
      [ -n "$Sigma1" ] && {
        note "Not used with --method=$Method: --sigma=$Sigma1"
        Sigma1=""
      }
    ;;
  esac
  
  # --sigma2
  case $Method in
    experimental) ;;
    blur|dog|unsharp)
      [ -z "$Sigma2" ] && {
        Sigma2="$(awk "BEGIN {print $Sigma1 * 1.6}")"
        note "Setting --sigma2=$Sigma2"
      }
    ;;
    *)
      [ -n "$Sigma2" ] && {
        note "Not used with --method=$Method: --sigma2=$Sigma2"
        Sigma2=""
      }
    ;;
  esac
  
  # Method argument
  case $Method in
    compose)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="overlay"
        note "Setting --$Method=$Maskgeneratorargument"
      }
      grep -q -x -i "$Maskgeneratorargument" <<< "$($Magickbin -list compose)" || {
        error "--$Method=$Maskgeneratorargument: unknown argument.
  Please choose one out of '$Magickbin -list compose'
  or compare IM option -compose."
      }
      Maskgeneratorargument="$(lowercase "$Maskgeneratorargument")"
    ;;
    evaluate)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="max"
        note "Setting --$Method=$Maskgeneratorargument"
      }
      grep -q -x -i "$Maskgeneratorargument" <<< "$($Magickbin -list evaluate)" || {
        error "--$Method=$Maskgeneratorargument: unknown argument.
  Please choose one out of '$Magickbin -list evaluate'
  or compare IM option -evaluate-sequence."
      }
      Maskgeneratorargument="$(lowercase "$Maskgeneratorargument")"
    ;;
    experimental) ;;
    laplacian)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="0"
        note "Setting --$Method=$Maskgeneratorargument"
      }
    ;;
    free)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="-edge 2"
        note "Setting --$Method='$Maskgeneratorargument'"
      }
    ;;
    statistic)
      case $Maskgeneratorargument in
        gradient|maximum|minimum|mean|median|mode|nonpeak|rms|standarddeviation) ;;
        dev|standard-deviation)  Maskgeneratorargument="standarddeviation" ;;
        grad) Maskgeneratorargument="gradient" ;;
        max)  Maskgeneratorargument="maximum" ;;
        min)  Maskgeneratorargument="minimum" ;;
        "")
          Maskgeneratorargument="standarddeviation"
          note "Setting --$Method=$Maskgeneratorargument"
        ;;
        *)
          note "--statistic: unknown argument $Maskgeneratorargument.
  Setting --$Method=standarddeviation"
          Maskgeneratorargument="standarddeviation"
        ;;
      esac
    ;;
    *)
      [ -n "$Maskgeneratorargument" ] && {
        note "Arguments not used in --$Method=$Maskgeneratorargument"
        Maskgeneratorargument=""
      }
    ;;
  esac
  
  # --radius
  grep -q "\." <<< "$Radius" && {
    Radius="0"
    note "--radius takes integer values only.
  Setting --radius=0 (auto)"
  }
  [ -z "$Radius" ] && Radius="0"
  case $Method in
    enfuse) 
      [ "$Radius" = "0" ] && {
        Radius="5"
        note "Setting --radius=$Radius"
      }
      [ "$Radius" -lt "3" ] && {
        note "--enfuse needs a radius of at least 3.
  Setting --radius=3"
      }
      [ "$((Radius%2))" -eq 0 ] && {
        Radius="$((Radius+1))"
        note "--enfuse needs an odd value for --radius.
  Setting --radius=$Radius"
      }
    ;;
    statistic)
      [ "$Radius" = "0" ] && {
        Radius="5"
        note "Setting --radius=$Radius"
      }
    ;;
  esac
  
  # --mode
  case $Method in
    compose|evaluate)
      case $Mode in
        "") ;;
        *) 
          note "--mode: Not used by --$Method" 
          Mode=""
        ;;
      esac
    ;;
    *)
      case $Mode in
        1|2|3|4|5|6|7|8) ;;
        "")
          note "Setting --mode=1"
          Mode=1
        ;;
        *) 
          note "Invalid --mode=$Mode
  Setting --mode=1"
          Mode=1
        ;;
      esac
    ;;
  esac
  
  # --cachedir
  [ -z "$Cachedir" ] && Cachedir="/tmp/imfuse.$RANDOM"
  Cachedir="$(sed s%'~'%$HOME% <<< "$Cachedir")"
  Cachedir="$(realpath -m "$Cachedir")"
  
  # --output
  [ -z "$Outputimage" ] && {
    case $Method in
      blur|dog|unsharp)             Outputimage="imfuse.${Method}.${Radius}x${Sigma1}-${Radius}x${Sigma2}" ;;
      compose|evaluate|laplacian)   Outputimage="imfuse.${Method}.${Maskgeneratorargument}" ;;
      enfuse)                       Outputimage="imfuse.${Method}.r${Radius}";;
      log)                          Outputimage="imfuse.${Method}.${Radius}x${Sigma1}";;
      statistic)                    Outputimage="imfuse.${Method}.${Maskgeneratorargument}.r${Radius}" ;;
      *)                            Outputimage="imfuse.${Method}" ;;
    esac
    case $Method in
      compose) [ "$Swapcompose" ] && Outputimage="${Outputimage}.swap";;
      evaluate) ;;
      *) Outputimage="${Outputimage}.m${Mode}" ;;
    esac
    [ "$Sourceweight" ] && Outputimage="${Outputimage}.w${Sourceweight}"
    case $Gamma in
      "") ;;
      auto) Outputimage="${Outputimage}.g" ;;
      *)    Outputimage="${Outputimage}.g$Gamma" ;;
    esac
    Outputimage="${Outputimage}.${Imageformat}"
    note "Setting --output=$Outputimage"
  }
  Resultimage="$Cachedir/imfuse.result-${Method}.tif"
  Outputimage="$(realpath $Outputimage)"
  
  grep -q -i '\.tif$' <<< "$Outputimage" && Compress="-compress zip"
  
  [ "$Revertimagelist" = "yes" ] && Imagelist="$(tac <<< "$Imagelist")"
  
  verbose "--$Method=$Maskgeneratorargument
--mode=$Mode
--radius=$Radius
--sigma=$Sigma1
--sigma2=$Sigma2
--gamma=$Gamma
--addmax: $Addmax
--addmean: $Addmean
--addmin: $Addmin
Cachedir: $Cachedir"
  
  return ${Error:-0}
}
main() {
  #set -eu
  trap trap_sigint SIGINT
  
  declare_variables
  
  command -v convert >/dev/null && Magickbin="convert"
  command -v magick  >/dev/null && Magickbin="magick"
  [ -z "$Magickbin" ] && error "Neither command convert nor magick found. Please install ImageMagick."
  Magickversion="$($Magickbin -version)"
  grep -q " Q8 "   <<< "$Magickversion" && Magickpixelmemory="4"
  grep -q " Q16 "  <<< "$Magickversion" && Magickpixelmemory="8"
  grep -q " HDRI " <<< "$Magickversion" && Magickpixelmemory="16"
  [ "$Error" ] && return 1
  
  Freemem="$(freememory)"
  
  parse_options "$@"
  check_options
  [ "$Error" ] && return 1
  
  Imagelist="$(grep -v -x "" <<< "$Imagelist")"
  Imagenumber="$(grep -c "." <<< "$Imagelist")"
  Imagenumberlength="${#Imagenumber}"
  
  Image="$(head -n1 <<< "$Imagelist")"
  Imagewidth=$($Magickbin  -format '%w' "$Image" info:)
  Imageheight=$($Magickbin -format '%h' "$Image" info:)
  Imagememsize="$((Imagewidth*Imageheight*Magickpixelmemory/1000))"
  Imagelistmemsize="$((Imagenumber*Imagememsize))"
  Image=""
  
  verbose "Image number: $Imagenumber
  Image width:  $Imagewidth
  Image height: $Imageheight
  Image memory size:      $Imagememsize kb
  Image list memory size: $Imagelistmemsize kb
  Free Memory:            $Freemem kb"
  
  mkdir -p $Cachedir || error "Error creating cache folder $Cachedir"
  [ "$Error" ] && return 1
  
  # --addmean
  [ "$Addmean" = "yes" ] && {
    evaluate_split mean $Cachedir/mean.tif $(echo $Imagelist) || error "Error in --addmean"
    Imagelist="$Cachedir/mean.tif
$Imagelist"
  }
  [ "$Error" ] && return 1
  # --addmin
  [ "$Addmin" = "yes" ] && {
    evaluate_split min $Cachedir/min.tif $(echo $Imagelist) || error "Error in --addmin"
    Imagelist="$Cachedir/min.tif
$Imagelist"
  }
  [ "$Error" ] && return 1
  # --addmax
  [ "$Addmax" = "yes" ] && {
    evaluate_split max $Cachedir/max.tif $(echo $Imagelist) || error "Error in --addmax"
    Imagelist="$Cachedir/max.tif
$Imagelist"
  }
  [ "$Error" ] && return 1
 
  case $Method in
    evaluate)
      evaluate_split $Maskgeneratorargument $Resultimage $Imagelist || error "Error in --$Method=$Maskgeneratorargument"
    ;;
    compose)
      [ "$Freemem" -lt "$Imagelistmemsize" ] && {
        verbose "--compose: Generating max image"
        evaluate_split max $Cachedir/max.tif $Imagelist
        verbose "--compose: Generating min image"
        evaluate_split min $Cachedir/min.tif $Imagelist
        verbose "--compose: compositing $Maskgeneratorargument"
       $Magickbin \
         $Cachedir/max.tif $Cachedir/min.tif $Swapcompose \
           -compose $Maskgeneratorargument -composite \
         $Resultimage || error "Error in --$Method=$Maskgeneratorargument"
      } || {
        $Magickbin \
          $(echo $Imagelist) \
            \( -clone 0--1 -evaluate-sequence max -write mpr:max -delete 0--1 \) \
            \( -clone 0--1 -evaluate-sequence min -write mpr:min -delete 0--1 \) \
            -delete 0--1 \
          mpr:max mpr:min $Swapcompose \
            -compose $Maskgeneratorargument -composite \
          $Resultimage || error "Error in --$Method=$Maskgeneratorargument"
      }
    ;;
    *)
      fuse_focus_stackshot  || error "Error while fusing stackshot"
    ;;
  esac
  [ "$Error" ] && return 1
  
  # --gamma
  case $Gamma in
    "") ;;
    auto) $Magickbin "$Resultimage" -auto-gamma     "$Resultimage" || error "Error in --gamma=$Gamma" ;;
    *)    $Magickbin "$Resultimage" -gamma "$Gamma" "$Resultimage" || error "Error in --gamma=$Gamma" ;;
  esac
  [ "$Error" ] && return 1
  
  $Magickbin "$Resultimage" $Compress "$Outputimage"  || error "Error storing result in $Outputimage"
  showimage "$Outputimage"
  note "Ready after $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")"
    
  return "${Error:-0}"
}

main "$@"
[ "$Savemask" = "no" ] && [ -d "$Cachedir" ] && rm -R "$Cachedir"
exit "${Error:-0}"
