#! /bin/bash

# imfuse
Version="0.7.6-beta"

# ToDo:
# New BUG s:
# --soft --alpha

# =alpha,less: wrong result
# --soft: preview of montage is grey
# enfuse_split() not ready
# --slabs
#
# imfuse:
# split enfuse with crops having ~10px overlap
# --slab
# BUG: levelU kills data near 0% (--test pyramid)
# add w to each mask if n>1
# --level for --soft?
# mkclut_uniform() fails with b&w masks -> clut and result black
# --revert: broken
# ARG close: how to match --close ARG?
# whitespace in file names -> file names into array
# --maskblur altogether?
# --gamma?
# check --kirsch
# drop --unsharp?
# drop --denoise?
# --denoise after merge?
# drop --halo?
# find halo solution
# check exiftransfer / damaged one Beerenwanze or Spinne image

usage() {
  echo "imfuse v$Version
Combines focus stackshot images to one overall sharp image.

It assumes that the alphanumerical order of the input images goes from
top to bottom; for the other way around use option --revert.

Dependencies:
  imagemagick         Mandatory (command 'convert' or 'magick').
  enfuse              Optional, needed for some options.
  focus-stack         Optional, needed for option --align.
                      https://github.com/PetteriAimonen/focus-stack
  geeqie              Optional, used by option -V, --showimage.
  exiftool            Optional, to transfer metadata from first image to result.

Usage:
  imfuse [OPTIONS] -- image1 image2 image3 ...

General options:
     --align              Align images.
     --basename [=NAME]   Base name [+path] for output image. 
     --cache [=DIR]       Store generated masks and images in directory DIR.
                          They can be reused by later runs of imfuse.
                          Default DIR: ./cache.imfuse
     --exif [=IMAGE]      Transfer exif meta data from IMAGE or first image.
 -h, --help               Show this help and exit.
     --layered            Store background and single slabs in layered TIF.
     --limit-memory=ARG   Limit amount of used memory. Default: 80%
                          ARG can be a % value or an absolute value for MB.
 -o, --output=FILE        Result image file name.
     --savemask [=FILE]   Store contrast mask in file FILE.
     --threads            Number of parallel threads to run at once.
                          Default: number of CPU's (nproc).
     --version            Show imfuse version and exit.
 -V, --showimage          Show intermediate results with image viewer geeqie.
     --video              Generate a video of shown intermediate images.
 -W                       Show result with image viewer viewnior.

The mask generating options below can take additionally arguments [=ARG].
Multiple arguments are comma-separated. 
  Example: --morphology=r3,less20,close,maskblur --saturation=w50
Arguments taken by all mask options:
  w         Mask weight. Percent value from 0 to 100.
            Of interest if specifying more than one mask generation method.
            Example: --morphology --saturation=w25
            This will generate two masks. The saturation mask will only have
            noteable effect where the morphology mask strength is below 25%.
  less      Compare option --less, here applied for single mask only.
  alpha     Compare option --alpha, here applied for single mask only.
  maskblur  Compare option --maskblur, here applied for single mask only.
  denoise   Compare option --denoise, here applied for single mask only.
  negate    Negate/invert the mask. Rarely needed.
Arguments taken by few options only:
  r         Radius. Must be an integer value.
            Increased radius mostly causes less noise, less details and
            more contrast. Smaller radius causes more details and more noise.
  s         Sigma. Takes non-integer values like 0.75.
            Increased sigma mostly causes less noise, less details and
            more contrast. Smaller sigma causes more details and more noise.
  S         Second Sigma. Taken only optionally by --dog.
  p         Percent value.
  (words)   Some options take one or two word arguments.


Contrast mask options:
Most of interest: --morphology, --statistic, --wavelet
 --blur [=ARG]        Blur edge detection. 
                      Similar to --gaussian, but faster and less accurate.
                      ARG additionally takes argument: 
                        s       sigma                Default: 0.75
 --comet [=ARG]       Comet edge detection. Compares rotated mean areas.
                      ARG additionally takes arguments: 
                        s       sigma                Default: 5
                        (word)  MODE                 Default: Lighten
                      MODE can be one of 'magick -list compose'
                      Recommended: Lighten, Darken.
 --compass [=ARG]     Compass edge detection. 
 --dog [=ARG]         Difference of Gaussian. 
                      ARG additionally takes arguments: 
                        s       sigma                Default: 0.4
                        S       sigma2               Default: 1.6*sigma1
 --diffstat [=ARG]    Compares two local statistics of source images. 
                      Uses ImageMagick option -statistic. Compare --statistic.
                      ARG additionally takes arguments: 
                        r       radius               Default: 3
                        (word)  STAT1                Default: median
                        (word)  STAT2                Default: mean
                      Possible STAT1 and STAT2:
                        0|none|source
                        1|gradient|grad
                        2|maximum|max
                        3|mean
                        4|median
                        5|minimum|min
                        6|mode
                        7|nonpeak
                        8|9|rms|rootmeansquare
                        10|standarddeviation|dev
                      Most interesting alternative is a max,min difference.
 --free [=ARG]        Custom ImageMagick option for mask generation.
                      ARG is an arbitrary ImageMagick command, but must not
                      contain a comma.               Default: '-sharpen 0x3'
 --freediff [=ARG]    Custom ImageMagick option for mask generation.
                      The resulting mask  will be a '-compose Difference' 
                      comparision with the source image.
                      ARG is an arbitrary ImageMagick command, but must not
                      contain a comma.
 --freichen [=ARG]    Frei-Chen edge detection. 
                      ARG additionally takes arguments: 
                        (word)  MODENUMBER
                      Possible MODENUMBERs at:
                      http://www.imagemagick.org/Usage/convolve/#freichen
                      Default: A combination of modes 1 and 2.
 --gaussian [=ARG]    Gaussian blur edge detection. 
                      Similar to --blur, but slower and more accurate.
                      ARG additionally takes argument: 
                        s       sigma                Default: 0.3
 --kirsch [=ARG]      Kirsch edge detection. 
 --laplacian [=ARG]   Laplacian edge detection.
                      ARG additionally takes arguments: 
                        (word)  MODENUMBER           Default: 3
                      Possible MODENUMBERs at:
                      http://www.imagemagick.org/Usage/convolve/#laplacian
 --log [=ARG]         Laplacian of Gaussian.
                      ARG additionally takes argument: 
                        s       sigma                Default: 0.2
 --morphology [=ARG]  Morphology edge detection.
                      ARG additionally takes arguments: 
                        r       radius               Default: 2
                        (word)  MODE                 Default: edge
                      MODE can be one of 'magick -list morphology'
                      Some MODEs of interest:
                        edge, dilateintensity, smooth
 --prewitt [=ARG]     Prewitt edge detection. 
 --roberts [=ARG]     Roberts edge detection. 
 --sobel [=ARG]       Sobel edge detection. 
 --statistic [=ARG]   ImageMagick option -statistic.
                      ARG additionally takes arguments: 
                        r       radius               Default: 2
                        (word)  STAT                 Default: standarddeviation
                      Argument STAT is one of (number or name):
                        1|gradient|grad
                        2|maximum|max
                        3|mean
                        4|median
                        5|minimum|min
                        6|mode
                        7|nonpeak
                        8|9|rms|rootmeansquare
                        10|standarddeviation|dev
                      Get an impressive strong contrast with a high radius.
 --unsharp [=ARG]     Difference of -unsharp.
                      ARG additionally takes argument: 
                        s       sigma                Default: 2
 --wavelet [=ARG]     Based on ImageMagick option -wavelet-denoise.
                      ARG additionally takes arguments:
                        p       percent               Default: 10

Image comparision mask options:
Most of interest: none
 --compose [=ARG]     Composes evaluated min,max of source images with MODE.
                      ARG additionally takes arguments:
                        (word)   MODE                Default: overlay
                      Adding a '2', e.g. '--compose=overlay2' swaps min,max
                      to max,min and can give a different result.
                      MODE can be one of 'magick -list compose'
                      Some MODEs of interest:
                        overlay interpolate colordodge hardlight reflect 
                        softburn softlight linearlight pegtoplight
 --enfuse [=ARG]      Image comparision with a basic enfuse result.
 --evaluate [=ARG]    Evaluates from all source images with mode MODE and
                      compares the result with each source image.
                      ARG additionally takes arguments:
                        (word)   MODE                Default: max
                      MODE can be one of 'magick -list evaluate'
                      Compare --max, --min, --mean, --median.
 --halo [=ARG]        Remove light halo of white background (overexposure).
                      ARG additionally takes arguments:
                        p        percent             Default: 25
                        r        radius              Default: 2
                        s        sigma               Default: 5
                      Greater percent removes more light.
                      sigma is a -blur sigma for a soft cut.
                      radius is a kernel radius.
                      Needs high 'weight' values even greater than 100.
                      Well to combine with --darkness.
 --image [=ARG]       Loads an image and generates masks based on 
                      similarity with source images.
                      ARG additionally takes arguments:
                        (word)   An image file name
 --max [=ARG]         Same as --evaluate=max. Brightest pixels of stack.
                      Result is similar to --lightness.
 --mean [=ARG]        Same as --evaluate=mean. Average of pixels in stack.
 --median [=ARG]      Same as --evaluate=median. Median pixel of stack.
 --min [=ARG]         Same as --evaluate=min. Darkest pixels of stack.
                      Result is similar to --darkness.

Colorspace channel mask options:
Most of interest: --saturation
(All are variations of --channel, most of interest is --saturation)
 --channel [=ARG]     Use a colorspace channel as mask.
                      ARG additionally takes arguments:
                        (word)   Colorspace           Default: HSL
                        (word)   Color channel        Default: 1
                      Colorspace can be one of 'magick -list colorspace'
                      The color channel is a number from 0..31.
 --chroma [=ARG]      Chroma channel from HCL colorspace.
 --darkness [=ARG]    Negated lightness channel from HSL colorspace.
                      Dark result, similar to --min.
 --lightness [=ARG]   Lightness channel from HSL colorspace. 
                      Bright result, similar to --max.
 --saturation [=ARG]  Saturation channel from HSL colorspace.
                      Adding this with low weight, e.g. --saturation=w5,
                      can soften the image so it looks more natural.

Mask merging options:
Most of interest: --maskstat, --maskblur, --close
 --close [=ARG]       Closes gaps between nearby contrast lines to mark the 
                      area in between as strong contrast, too.
                      Can reduce artefacts in partial transparent objects.
                      Helps e.g. to strengthen thin shiny objects like hairs.
                      Takes arguments similar to contrast mask ARG:
                        r        kernel iteration    Default: 2
                        R        radius              Default: 2
                        p        threshold           Default: 25
                      Multiplying r and R results in the real radius applied.
                      A multiplied value like 3x4 (r3,R4) is faster than 
                      setting one of r oder R to 12.
                      Percent p is a threshold value; --close is only applied
                      to contrast areas stronger than percent p.
 --darkenmask=MASK    Use mask image MASK to darken the merged contrast masks.
                      (Special use cases, needed for script slab.)
 --denoise [=%]       Experimental option to remove noise in low contrast areas.
                      The percent value is a threshold. 
                      Rather use --alpha or --finalblur.
 --grayscale=MODE     Grayscale converting method before mask generation.
                      Compare ImageMagick option -grayscale. Default: RMS
                      MODE is one of: (number or name)
                0 none             No grayscale conversion. Barely tested.
                1 Rec601Luma       0.298839R' + 0.586811G' + 0.114350B'
                2 Rec601Luminance  0.298839R  + 0.586811G  + 0.114350B
                3 Rec709Luma       0.212656R' + 0.715158G' + 0.072186B'
                4 Rec709Luminance  0.212656R  + 0.715158G  + 0.072186B
                5 Brightness       max(R', G', B')
                6 Lightness        (min(R', G', B') + max(R', G', B')) / 2.0
                7 Average          (R' + G' + B') / 3.0
                8 MS               (R'^2 + G'^2 + B'^2) / 3.0
                9 RMS              sqrt( (R'^2 + G'^2 + B'^2) / 3.0 )
 --maskblur [=SIGMA]  Blur masks with SIGMA (default 1). Enhances contrast.
                      Applied to contrast masks only.
 --maskstat [rRADIUS,METHOD]  Apply a statistic method for each mask pixel
                      to adjust it according to its neighborhood.
 --merge [=COMPOSE]   Compose mode to merge multiple masks. Default: Plus
                      Of interest: Screen Interpolate Multiply Exclusion Blend

Fusion options:
Most of interest: --less, --slab, --soft
 --cutblur [=SIGMA]   Blur cut masks in final montage. Default SIGMA: 2
 --cutsoft [=SIGMA]   Similar to --cutblur, but composes default sharp cut mask
                      over blurred cut mask. Default SIGMA: 2
 --less [=%]          Strenghtens less contrasted objects in front of strong
                      contrasted background objects. 
                      Well to combine with --close and / or --cutblur.
                      Percent value % is the minimum intermediate contrast
                      difference between background and foreground object.
                      Default % depends on first mask, mostly 45% or 60%.
                      If unsharp areas appear, use a smaller less value.
                      If the foreground object still has holes, try --cutblur,
                      --maskblur or --close.
                      (If also using color channel or image comparision masks,
                      rather use 'less' as a mask argument than globally.)
 --sigmoidalclut [=CONTRASTxMIDPOINT]   Change grayscale distribution of 
                      contrast masks along a sigmoidal curve. 
                      Helps to strenghten high contrast areas and to weaken
                      low contrast areas. Main use case is option --soft.
                      CONTRAST bends the curve; the higher, the stronger.
                      MIDPOINT is the inflection point of the curve in percent.
                      Compare IM option -sigmoidal-contrast.
                      Default CONTRAST: 10, default MIDPOINT: 50%
 --slab [=LAYERS,rOVERLAP] Split stack into LAYERS different
                      stacks and fuse them separately. 
                      Use --threshold or --alpha to make layers transparent.
                      The layers will be composed over each other onto
                      a background (to specify with --background).
                      OVERLAP specifies how many images neighbored slabs share.
                        Default LAYERS:    5
                        Default OVERLAP:   5
                      See also --layered to store the single layers.
                      That allows manual rework of the results in gimp.
 --prefertop [=%]     Prefer top layer images up to %. Default %: 20
                      Similar to --less, but a rather brute-force attempt.
 --soft [=CONTRASTxMIDPOINT]   Enable soft fusion mode. Different concept than 
                      default maximum contrast montage. Images are multiplied 
                      with their contrast masks and added altogether as a whole.
                      For arguments compare --sigmoidalclut.
                      Does not support --less and --cutblur.

Post processing options:
 --alpha [=LEVEL]     Generate transparent image using the contrast mask as 
                      alpha channel (=transparency channel).
                      Good method to reduce noise in low contrast areas.
                      The semitransparent result is composed over a background.
                      Default background is 'enfuse'. Check also 'transparent'.
                      Can take an argument as one or two percent values.
                      Simplified usage: If only one value is given, 
                      positive values make the image more transparent and 
                      negative values make it less transparent.
                      Advanced usage: Two percent values A%xB% are applied
                      as '+level A%xB%' on the transparency alpha channel.
                      This allows to adjust transparency of low contrast areas 
                      with A% and of high contrast areas with B%. 
                      Negative values and higher than 100% are possible.
                      Try script 'demo-alphalevel' to understand the effects.
 --bg, --background [=BG]  Specify a background to paint on. Default: enfuse
                      BG can be an image name or one out of:
                        enfuse
                        transparent
                        magick -list color
                        magick -list evaluate (compare --evaluate)
                        magick -list compose  (compare --compose)
                      Useful for options --alpha, --threshold and --layered.
                      Recommendations: enfuse mean max min
                                       colorize colorize2 pinlight pinlight2
                      Interesting: interpolate overlay pegtoplight reflect
 --finalblur [=pPERCENT,rRADIUS,sSIGMA]  Soft blur of bokeh. 
                      Blurs along a sigmoidal curve from low contrast (much blur)
                      to high contrast (less blur). 
                        r        radius of blur      Default: 2
                        s        sigma of curve      Default: 5
                        p        mid-point of curve  Default: 40%
                      The curve looks like:
                                xxxx
                              xx
                             x
                           xx
                       xxxx
                      The stronger sigma is, the steepening the curve will be.
                      A higher percent moves mid-point to the right and 
                      will blur more low contrast areas.
                      A bigger radius causes a stronger blur.
 --threshold [=pPERCENT,sSIGMA] Make low contrast area transparent. 
                      Set SIGMA to blur the cut mask border. 
                                                     Default PERCENT: 50
                                                     Default SIGMA: 2

Basics:
Fusing a focus stack aims to generate an overall sharp image of several single
captures that only show partial sharp areas.
Sharp areas show more contrast and detail than blurry unsharp areas.

So one important part is to find areas with a lot of contrast and detail.
This is done with the contrast mask options. From each source image the area
with more contrast than all other source images will be part of the result.

Artefacts / stack failures:
The attempt to get the strongest contrast areas out of the source images
has some weaknesses and can lead to artefacts.

 - Low contrast noise artefacts:
  All contrast mask methods give unsatisfying results in areas that have low 
  contrast on all source images of the stack.
  Possibilities:
   - Option --alpha gives a quite satisfying result for low contrast noise areas.
     Example: '--diffstat --alpha' or '--diffstat=alpha'
   - Another possibility to soften the noise is option --finalblur.
     Example: '--diffstat --finalblur'

 - Objects in foreground with background artefacts:
  Sometimes objects in background result in a stronger contrast mask than
  objects in foreground. The foreground object will be incomplete.
  This can be fixed with option --less, additionally --cutblur or --close.

Examples:
Have a folder 'stackshot' containing all stack source images.
Go to the folder above 'stackshot'.
  Run imfuse with:
    imfuse -VW --align --diffstat                            stackshot/*
  You might be unsatisfied with low contrast areas. Try:
    imfuse -VW --align --diffstat --maskblur                 stackshot/*
    imfuse -VW --align --diffstat --maskblur --soft          stackshot/*
    imfuse -VW --align --diffstat --maskblur --alpha         stackshot/*
  You might have incomplete foreground objects. Try:
    imfuse -VW --align --diffstat --maskblur --alpha --less  stackshot/*

  Try also other mask options instead of (or additionally to) --diffstat,
  e.g. --wavelet or --morphology. Play with radius/sigma of mask options,
  e.g. --diffstat=r5. Try different percent values for --less,
  e.g. --less=p30 or --less=p80.
  Think of radius or sigma like brush sizes.
  Small values create small brushes painting more details and more noise.
  Great values create big brushes painting less details and less noise.
"
}

### Messages

error() {
  [ -z "${Error:-}" ] && echo "
imfuse ERROR: $*
" >&2
  Error=1
  finish 1
}
note() {
  [ -z "${Error:-}" ] && echo "imfuse: $*" >&2
  return 0
}
verbose() {
  [ "$Verbose" = "yes" ] && echo "imfuse: $*" >&2
  return 0
}
showimage() {
  local Frame
  [ "$Showimageprocessing" = "yes" ] && geeqie -t -r --File:"${1:-}" 2>/dev/null &
  #[ "$Showimageprocessing" ] && bash imgview "${1:-}"
  [ "$Video" ] && {
#    Videoframecount="$((Videoframecount+1))"
    Videoframecount="$(ls $Cachedir/videoframe????.* | sort -V | tail -n1)"
    Videoframecount="$(basename "$Videoframecount")"
    Videoframecount="${Videoframecount//[^0-9]/}"
    Videoframecount="$(sed "s/^0*//" <<< "$Videoframecount")"
    Videoframecount="$(calc "$Videoframecount+1")"
    Frame="$Cachedir/videoframe$(printnum "$Videoframecount").tif"
    #ln -s "${1:-}" "$Frame"
    cp "${1:-}" "$Frame" ### FIXME ln -s where possible
  }
  return 0
}

### Misc

calc() {
  LC_ALL=C awk "BEGIN {print $* }"
}
comma2whitespace() {
  #sed "s/,/ /g" <<< "${1:-}"
  echo "${1//,/ /}"
}
digitonly() {
  #sed "s/[^0-9.]//g" <<< "${1:-}"
  echo "${1//[^0-9.]/}"
}
digitrm() {
  #sed "s/[0-9.]//g" <<< "${1:-}"
  echo "${1//[0-9.]/}"
}
generate_key() {
  # generate a unique key value from current time and nanoseconds
  date +%s.%N
}
levelparse() {
  local String Part1 Part2
  String="${1:-}"
  String="$(tr -d '%' <<< "$String")"
  grep -q "x" <<< "$String" && {
    Part1="$(cut -dx    -f1 <<< "$String")"
    Part2="$(cut -dx -s -f2 <<< "$String")"
    :
  } || {
    Part1="$((0-String))"
    Part2="$((100-String))"
  }
  echo "${Part1}x${Part2}"
}
levelpercent() {
  local String Part1 Part2
  String="${1:-}"
  String="$(tr -d '%' <<< "$String")"
  Part1="$(cut -dx    -f1 <<< "$String")"
  Part2="$(cut -dx -s -f2 <<< "$String")"
  echo "${Part1}%x${Part2}%"
}
lowercase() {
    # Usage: lowercase "string"
    printf '%s\n' "${1,,}"
}
md5cut() {
  # print last 6 digits
  tr "\n" " " <<< "${1:-}" | md5sum | cut -c27-32
}
parse_percent() {
  local Percent
  Percent="${1:-}"
  Percent="$(tr -d 'p%' <<< "$Percent")"
  [ "$Percent" = "$(digitonly "$Percent")" ] || {
    error "Invalid percent value: ${1:}"
    return 1
  }
  echo "$Percent"
}
percentrm() {
  # remove % from string
  #sed s/%//g <<< "${1:-}"
  echo "${1//%/}"
}
printnum(){
  # print number $1 with leading zeroes.
  # $1 number
  # $2 digits. Default: 4
  [ "${1:-}" = "NUMBER" ] && echo "NUMBER" && return 0 
  printf %0${2:-4}d "${1:-0}"
}
printsameline() {
  # print $1 without newline at begin of current line
  echo -ne "${1:-}\033[0K\r" >&2
}
printfreememory() {
  # print current free memory including zram
  local Memory Line Zram
  Memory="$(LC_ALL=C free | grep "Mem:" | LC_ALL=C awk '{print $7}')"
  while read Line; do
    Zram="$(LC_ALL=C awk 'BEGIN {OFMT = "%.0f"} {print ($3 - $4)}' <<< "$Line")"
    Zram="$(LC_ALL=C awk 'BEGIN {OFMT = "%.0f"} {print $1 / 1000}' <<< "$Zram")"
    Memory="$((Memory + Zram))"
  done < <(/sbin/swapon --bytes | grep zram)
  echo $Memory
}
printtotalmemory() {
  # print total memory including zram
  local Memory Line Zram
  Memory="$(LC_ALL=C free | grep "Mem:" | LC_ALL=C awk '{print $2}')"
  while read Line; do
    Zram="$(LC_ALL=C awk 'BEGIN {OFMT = "%.0f"} {print $3}' <<< "$Line")"
    Zram="$(LC_ALL=C awk 'BEGIN {OFMT = "%.0f"} {print $1 / 1000}' <<< "$Zram")"
    Memory="$((Memory + Zram))"
  done < <(/sbin/swapon --bytes | grep zram)
  echo $Memory
}
unspecialstring() {
  # Replace all characters except those described in "a-zA-Z0-9_" with a '-'. 
  # Replace newlines, too.
  # Remove leading and trailing '-'
  # Avoid double '--'
  # Return empty string if only special chars are given.
  printf %s "${1:-}" | LC_ALL=C tr -cs "a-zA-Z0-9._" "-" | sed -e 's/^-// ; s/-$//'
}

### Files

checkmagicklist() {
  ### FIXME
  magick -list "${1:-}" | grep -q -w -i "^${2:-XXX}"
}
masklist() {
  local Basename List= Firstimage Lastimage
  Firstimage="${2:-1}"
  Lastimage="${3:-$Imagenumber}"
  Basename="${1:-}"
  for Count in $(seq $Imagenumber); do
    List="$List
$(maskname "$Basename" $Count)"
  done
  grep . <<< "$List" | sed -n "${Firstimage},${Lastimage}p"
}
sourceimagename() {
  # print source image name number $1.
  # might be an mpr: or a file depending on $Loadsourceimages.
  sed "${1:-}q;d" <<< "$Imsourceimagelist"
}
maskexist() {
  case "$Masktocache" in
    yes)
      Masklist="$(find $Cachedir/mask.${1:-}.*.${Masksuffix})"
      Maskcount="$(grep -c . <<< "$Masklist")"
      [ "$Maskcount" = "$Imagenumber" ] && return 0 || return 1
    ;;
    no)
      return 1
    ;;
  esac
}
maskname() {
  [ -z "${1:-}" ] && error "maskname(): maskbasename is empty: ${1:-} ${2:-}"
  [ -z "${2:-}" ] && error "maskname(): number not given: ${1:-} ${2:-}"
  case "$Masktocache" in
    yes)
      echo "$Cachedir/mask.${1:-}.$(printnum "${2:-}").${Masksuffix}"
    ;;
    no)
      echo "mpr:${1:-}.$(printnum "${2:-}")"
    ;;
  esac
}

### image processing helpers

align() {
  # align with focus-stack
  # https://github.com/PetteriAimonen/focus-stack

  local Log Line Image Count Command
  local X Y W H Lmax=0 Tmax=0 Rmin=10000000 Bmin=10000000
  local Aligndir Newsourceimagelist=

  Log="$Cachedir/align.log"
  Aligndir="$Cachedir/aligned.$Sourcemd5"
  mkdir -p "$Cachedir/aligned"

  note "Aligning source images with external tool focus-stack."
  focus-stack --verbose --output="$Aligndir/" --align-only --no-contrast --no-whitebalance $Sourceimagelist >"$Log" || return 1

  # calculate smallest valid area common to all aligned images
  while read Line; do
    Line="$(cut -d' ' -f4- <<< "$Line")"
    X="$(digitonly "$(cut -d, -f1 <<< "$Line")" )"
    Y="$(digitonly "$(cut -d, -f2 <<< "$Line")" )"
    W="$(digitonly "$(cut -d, -f3 <<< "$Line")" )"
    H="$(digitonly "$(cut -d, -f4 <<< "$Line")" )"
    [ "$X" -gt "$Lmax" ] && Lmax="$X"
    [ "$Y" -gt "$Tmax" ] && Tmax="$Y"
    [ "$((X+W))" -lt "$Rmin" ] && Rmin="$((X+W))"
    [ "$((Y+H))" -lt "$Bmin" ] && Bmin="$((X+W))"
  done < <(grep "valid area" "$Log" ||:)
  X="$Lmax"
  Y="$Tmax"
  W="$((Rmin-Lmax-1))"
  H="$((Bmin-Tmax-1))"

  # crop aligned images to valid area, store as mpr source images
  ### FIXME could use Cachedir as new source image list in case of $Loadsourceimages=no
  Count=0
  while read Image; do
    Count="$((Count+1))"
    Command=""
    Number="$(printnum "$Count")"
    Image="$Aligndir/$(basename "$Image")"
    Newsourceimagelist="$Newsourceimagelist
$Image"
    case "$Loadsourceimages" in
      yes)
        Imsourceimagelist="$Imsourceimagelist
mpr:sourceimage.$(printnum $Count)"
      ;;
      no)
        Imsourceimagelist="$Imsourceimagelist
$Image"
      ;;
    esac
    Imsourceimagelist="$(grep . <<< "$Imsourceimagelist")"
    Command="$Command
  $(sendmagickmessage "PROGRESS:Cropping aligned images ${W}x${H}+${X}+${Y} $Count / $Imagenumber")"
    Command="$Command
  $Image
    -crop ${W}x${H}+${X}+${Y}
    -write $(sourceimagename $Count)
    $(showimagecode "$(sourceimagename $Count)")
    -delete 0"
    cmd "$Command"
  done <<< "$Sourceimagelist"
  sendmagickmessage "/PROGRESS"
  cmd_waitforready

  Sourceimagelist="$(grep . <<< "$Newsourceimagelist")"
  Sourcemd5="$(md5cut "$(ls -l --full-time $Sourceimagelist)" )"

  case "$Loadsourceimages" in
    yes)
      Sourceimagesalreadyloaded="yes"
      rm -r "$Aligndir"
    ;;
  esac

  return 0
}
alphalevel() {
  local Command Image Mask Level Clut= Clutimage
  local Longoptions Parsedoptions

  Longoptions="image:,mask:,level:,clut:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --image)        Image="${2:-}" ; shift ;;
      --mask)         Mask="${2:-}"  ; shift ;;
      --level)        Level="${2:-}" ; shift ;;
      --clut)         Clut="${2:-}"  ; shift ;;
    esac
    shift
  done

  [ -z "$Image" ] && return 1
  Level="${Level:-0x100}"
  Level="$(levelparse "$Level")"
  Level="$(levelpercent "$Level")"

  sendmagickmessage "NOTE:Applying --alpha=$Level"
  Command="
  ## alphalevel()
  '$Image'
    -write mpr:al_image
    -delete 0"
  case "$Mask" in
    "")
      Command="$Command
  mpr:al_image
    -channel alpha
    -separate
    -write mpr:al_mask
    -delete 0"
    ;;
    *)
      Command="$Command
  $Mask
    -write mpr:al_mask
    -delete 0"
    ;;
  esac

  [ "$Clut" ] && {
    Command="$Command
  -size 256x256
  gradient:
    -rotate 90
    -depth 16
    -sigmoidal-contrast ${Clut}%
    -write mpr:al_clut
    -delete 0
  mpr:al_mask
  mpr:al_clut
    -clut
    -write mpr:al_mask
    -delete 0"
  }

  Command="$Command
  mpr:al_mask
    +level $Level
    -write mpr:al_mask
    -delete 0"

  case "$Mask" in
    "") ;;
    *)
      Command="$Command
  mpr:al_mask
    -write $Mask
    -delete 0"
    ;;
  esac

  Command="$Command
  mpr:al_image
  mpr:al_mask
    -alpha off
    -compose CopyOpacity -composite
    $Tifstorealpha
    -write $Image
    -delete 0"

  Command="$Command
  +set registry:al_clut
  +set registry:al_image
  +set registry:al_mask"

  Command="$Command
  ## /alphalevel()"

  cmd "$Command"
  cmd_waitforready
  return 0
}
clut_gaussian() {
  # create gaussian clut image $1 with sigma $2
  local Command Clutimage Sigma
  Clutimage="${1:-}"
  Sigma="${2:-1}"
  Command="
  -size 1x1
  xc:white
    -bordercolor Black
    -border 2x0
    -filter gaussian
    -define filter:sigma=$Sigma
    -resize 512x256!
    -crop 50%x100%+0+0
    -auto-level
    -write $Clutimage
    -delete -1"
  cmd "$Command"
  cmd_waitforready
}
denoisecode() {
  echo "
    -write mpr:denoisemask
    -delete 0
  mpr:denoisemask
    -threshold ${1:-10}%
    -negate
    -transparent white
    -write mpr:cutmask
    -delete 0
  mpr:denoisemask
    -wavelet-denoise 50%
  mpr:cutmask
    -alpha off -compose CopyOpacity -composite
    -write mpr:blurlowcontrast
    -delete 0
  mpr:denoisemask
  mpr:blurlowcontrast
    -compose over -composite
"
}
enfuse_split() {
  local Mem_free Mem_needed Outputimage Enfuseoptions Sourceimage Sourceimagelist

  Outputimage="${1:-}" ; shift
  Sourceimagelist=""
  while [ $# -gt 0 ]; do
    Sourceimagelist="$Sourceimagelist
${1:-}"
    shift
  done
  Sourceimagelist="$(grep . <<< "$Sourceimagelist")"

  Mem_free="$(printfreememory)"
  Mem_needed="$((Imagewidth * Imageheight * 2 * 32 / 8))"
  Enfuseoptions="--contrast-weight=1 --saturation-weight=0 --exposure-weight=0 --hard-mask"

  false && [ "$Mem_needed" -ge "$Mem_free" ] && error "Not enough free memory to run enfuse.
  Free memory:             $Mem_free
  Estimated needed memory: $Mem_needed"

 # [ "$Mem_needed" -lt "$Mem_free" ] && {
    sendmagickmessage "[ generating image with external tool enfuse ]"
    nice enfuse $Enfuseoptions -o "$Outputimage" $Sourceimagelist 2>&1 | grep -v -E "loading next image|assuming all pixels should contribute|does not have an alpha channel|TIFFDecoder" || error "Failed to generate enfuse image"
    return "${Error:-0}"
 # }

  ##################
  [ "$Mem_needed" -ge "$Mem_free" ] && {
    note "enfuse needs more memory than available for this stack. Splitting source images."
    Splits=3
    Splitcache="$Cachedir/enfuse.split"
    Splitwidth=$((Imagewidth/Splits))
    mkdir -p $Splitcache
    for Split in $(seq $Splits); do
      Splitgeometry[$Split]="$((Splitwidth + 20))x${Imageheight}+$(( (Split -1) * Splitwidth ))+0"
    done
    for Sourceimage in $Sourceimagelist; do
      $Magickbin $Sourceimage -crop 
    done
    return
  }
}
evaluate() {
  local Sourceimagelist Resultimage Mode
  local Startzeit Dauer Restzeit

  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  Sourceimagelist=""
  while [ $# -gt 0 ]; do
    Sourceimagelist="$Sourceimagelist
${1:-}"
    shift
  done
  Sourceimagelist="$(grep . <<< "$Sourceimagelist")"

  sendmagickmessage "NOTE:Evaluating $Mode: $Resultimage"

  Command="
  # evaluate() $Mode: $Resultimage
  $Sourceimagelist
    -alpha off
    -evaluate-sequence $Mode
    $Tifstore
    -write $Resultimage
    $(showimagecode "$Resultimage")
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  return 0
}
exiftransfer() {
  # Transfer exif data from image $1 to image $2
  # Does not transfer image size information.
  # Sets orientation tag to horizontal / no rotation.
  # Several warnings are supressed.
  local Sourceimage Destinationimage Exifargs
  
  Sourceimage="${1:-}"
  Destinationimage="${2:-}"
  Exifargs="$(exiftool -a -u -g1 -args "$Sourceimage")"
  Exifargs="$(LC_ALL=C grep -v -E -- \
    '-ExifTool|-System:|-File:|ImageWidth|ImageHeight|ImageSize|Compression|Orientation|Resolution' <<< "$Exifargs" \
    | sed "s/'/'\"'\"'/g ; s/=/='/ ; s/\$/'/" )"
  eval exiftool -ignoreMinorErrors -overwrite_original_in_place $Exifargs -Orientation=Horizontal "$Destinationimage" 2>&1 | grep -v -E 'Warning|files updated'
}
finalblur() {
  # --finalblur

  local Longoptions Parsedoptions
  local Image Midpoint Blur Mask Sigma
  local Command

  Longoptions="image:,mask:,percent:,sigma:,blur:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --blur)    Blur="${2:-}" ;;
      --image)   Image="${2:-}" ;;
      --mask)    Mask="${2:-}" ;;
      --percent) Midpoint="${2:-}" ;;
      --sigma)   Sigma="${2:-}" ;;
    esac
    shift
    shift
  done

  sendmagickmessage "NOTE:Applying --finalblur=p${Midpoint},r${Blur},s${Sigma}"
  Command="
  # --finalblur
  $Image
    -write mpr:image
    -delete 0
  $Mask
    -write mpr:mask
    -delete 0
  -size 1x256
  gradient:
    -rotate 90
    -depth 8
    -sigmoidal-contrast ${Sigma}x$((100-Midpoint))%
    -write mpr:clut
    -delete 0
  mpr:mask
    -negate
    -write mpr:mask
    -delete 0
  mpr:mask
  mpr:clut
    -clut
    -write mpr:mask
    -delete 0
  mpr:image
  mpr:mask
    -compose Blur
    -set option:compose:args ${Blur}x${Blur}
    -composite
    -write $Image
    $(showimagecode "$Image")
    -delete 0
"
  cmd "$Command"
  cmd_waitforready
}
generate_image() {
  local Mode Imagename Swap Imagetype Showname= Command Size 
  local Generalimage= Skip=

  [ "${1:-}" = "--showname" ] && Showname="yes" && shift

  Mode="${1:-}"
  Imagename="${2:-}"
  Size="${Imagewidth:-100}x${Imageheight:-100}"

  checkmagicklist color                     "$Mode"   && Imagetype="color"
  checkmagicklist evaluate                  "$Mode"   && Imagetype="evaluate"
  checkmagicklist compose  "$(tr -d "2" <<< "$Mode")" && Imagetype="compose"
  case "$Mode" in
    enfuse)                                              Imagetype="enfuse" ;;
  esac

  [ -z "$Imagename" ] && {
    Generalimage="yes"
    case "$Imagetype" in
      enfuse)     Imagename="$Cachedir/enfuse.$Sourcemd5.tif" ;;
      evaluate)   Imagename="$Cachedir/evaluate.$Mode.$Sourcemd5.mpc" ;;
      compose)    Imagename="$Cachedir/compose.$Mode.$Sourcemd5.mpc" ;;
      color)      Imagename="mpr:$Mode" ;;
    esac
  }

  [ "$Showname" ] && {
    echo "$Imagename"
    return 0
  }

  [ "$Generalimage" = "yes" ] && case $Imagetype in
    color) ;;
    *) [ -e "$Imagename" ] && Skip="yes" ;;
  esac

  sendmagickmessage "NOTE:Generating image $Imagename"
  [ "$Skip" = "yes" ] && {
    sendmagickmessage "NOTE:Skipping image generation, already exists: $Imagename"
    return 0
  }

  case "$Imagetype" in
    enfuse)
      enfuse_split "$Imagename" $Sourceimagelist
    ;;
    evaluate)
      load_sourceimages
      evaluate "$Mode" "$Imagename" $Imsourceimagelist
    ;;
    compose)
      grep -q "2" <<< "$Mode" && Swap="-swap 0,1" || Swap=""
      Mode="$(tr -d "2" <<< "$Mode")"
      generate_image min
      generate_image max

      Command="
  $(generate_image --showname min)
  $(generate_image --showname max)
    -alpha off
    $Swap
    -compose $Mode -composite
    -write $Imagename
    $(showimagecode "$Imagename")
    -delete 0
  +set registry:$(generate_image --showname min | cut -d: -f2)
  +set registry:$(generate_image --showname max | cut -d: -f2)"

      cmd "$Command"
      cmd_waitforready
    ;;
    color)
      Command="
  -size $Size
  canvas:$Mode
    -colorspace sRGB
    -type TrueColorAlpha
    $(showimagecode "$Imagename")
    -write $Imagename
    -delete 0"
      cmd "$Command"
      cmd_waitforready
    ;;
  esac

  return 0
}
generate_video() {
  note "Generating video $Video"
  Videoframerate=5
  #nice ffmpeg -y -hide_banner -nostdin  -r $Videoframerate -f image2 -start_number 1 -i $Framedir/frame%04d.$Imageformat $Destinationfile || note "ERROR in video generation"
  [ -f "$Video" ] && rm "$Video"
  nice ffmpeg -y -hide_banner -nostdin  -r $Videoframerate -f image2 -start_number 1 -i "$Cachedir/videoframe%04d.$Imageformat" "$Video" || note "ERROR in video generation"
  rm $Cachedir/videoframe*
  ffplay "$Video"
}
level_masks() {
  local Maskbasename Maskmax Maskmin Maskmd5 Clutimage Resultmask
  local Count Mask Masklist Levelmin Levelmax

  Maskbasename="${1:-NO_MASK_SPECIFIED}"
  Masklist="$(masklist "$Maskbasename")"
  Maskmax="mpr:maskmax"
  Maskmin="mpr:maskmin"
  Clutimage="mpr:clut"

  sendmagickmessage "NOTE:Leveling $Maskbasename"
  [ "$Masktocache" = "yes" ] && [ -e "$Cachedir/level.$Maskbasename" ] && {
    sendmagickmessage "NOTE:level_masks(): Skipping, mask is already leveled."
    return 0
  }
  evaluate max $Maskmax $Masklist
  Levelmax="$(getmagickinfo "$Maskmax" '%[fx:maxima*100]')"
  Levelmin="$(maskarg_defaultvalue $Argmethod levelmin)"
  [ -z "$Levelmin" ] && {
    evaluate min $Maskmin $Masklist
    Levelmin="$(getmagickinfo "$Maskmin" '%[fx:minima*100]')"
  }

  Command="
  $Maskmax
    -level ${Levelmin}%,${Levelmax}%
    -write $Maskmax
    -delete 0"
  cmd "$Command"
  cmd_waitforready
  mkclut_uniform "$Maskmax" "$Clutimage"

  Count=0
  for Mask in $Masklist ; do
    Command=""
    Count="$((Count+1))"

    Command="$Command
  $(sendmagickmessage "PROGRESS:Mask leveling $Maskbasename ${Levelmin}%,${Levelmax}% step $Count / $Imagenumber")"

    Command="$Command
  $Mask
    -level ${Levelmin}%,${Levelmax}%
  $Clutimage
    -clut
    -write $Mask
    $(showimagecode "$Mask")
    -delete 0"

    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"
  cmd_waitforready
  [ "$Masktocache" = "yes" ] && echo "${Levelmin}%,${Levelmax}%" > "$Cachedir/level.$Maskbasename"

  return "${Error:-0}"
}
load_sourceimages() {
  # Load source images into imagemagick registry
  local Sourceimage Count Number Command

  [ "$Sourceimagesalreadyloaded" = "yes" ] && return 0

  Count="0"
  while read Sourceimage; do
    Count="$((Count+1))"
    Number="$(printnum "$Count")"
    Command=""
    case "$Loadsourceimages" in
      yes)
        Imsourceimagelist="$Imsourceimagelist
mpr:sourceimage.$(printnum $Count)"
        Imsourceimagelist="$(grep . <<< "$Imsourceimagelist")"

        sendmagickmessage "PROGRESS:Loading source image $Count / $Imagenumber"
        Command="$Command
  '$Sourceimage'
    -alpha off
    -depth 16
    -write $(sourceimagename $Count)
    $(showimagecode "$(sourceimagename $Count)")
    -delete 0"
        cmd "$Command"
      ;;
      no)
        Imsourceimagelist="$Imsourceimagelist
$Sourceimage"
      ;;
    esac
  done <<< "$Sourceimagelist"
  sendmagickmessage "/PROGRESS"
  cmd_waitforready

  Imsourceimagelist="$(grep . <<< "$Imsourceimagelist")"
  Sourceimagesalreadyloaded="yes"

  return 0
}
maskfromimage() {
  # Generate masks with basename $2 based on comparision with a single image $1
  local Imagename Maskbasename Sourceimage Maskname
  local Command Count

  Imagename="${1:-}"
  Maskbasename="${2:-}"

  sendmagickmessage "NOTE:Generating mask comparing with image $Imagename"
  for Count in $(seq $Imagenumber); do
    Maskname="$(maskname "$Maskbasename" "$Count")"
    Sourceimage="$(sourceimagename $Count)"

    Command="$Command
  $(sendmagickmessage "PROGRESS:image comparision mask step $Count / $Imagenumber")"

    Command="
  '$Imagename' 
    -write mpr:image
    -delete 0
  mpr:image
    -channel alpha
    -separate
    -write mpr:alpha
    -delete 0
  mpr:image
    $Grayscaleconverter
  ( '$Sourceimage' $Grayscaleconverter )
    -compose Difference -composite
    -alpha off 
    -negate
    -write mpr:diffmask
    -delete 0
  mpr:diffmask
### FIXME
#  mpr:alpha
#    -compose multiply -composite
    -write '$Maskname'
    $(showimagecode "$Maskname")
    -delete 0"

    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"
  cmd_waitforready

  return 0
}
mkclut_uniform() {
  # generate a clut image to uniform distribution in level_masks()
  # contains code parts from http://www.fmwconcepts.com/imagemagick/mkclut_uniform/
  local Referenceimage Clutimage Netpbm Netpbmdata
  local Histogramarray Colorcountarray Totalpixel Lutlist Expo Quantumrange Factor
  local Command Key1 Key2 Count

  Referenceimage="${1:-}"
  Clutimage="${2:-}"

  Quantumrange="$(getmagickinfo $Referenceimage "%[fx:quantumrange]")"
  Expo="$(getmagickinfo rose: "%[fx:e]")" 

  # FIXME use 16 bit depth?
  Key1="$(generate_key)"
  Key2="$(generate_key)"
  Command="
  $Referenceimage
    -colorspace gray
    -depth 8
    -format '\n$Key1\n%c$Key2\n'
    -write histogram:info:-
    -delete 0"
  cmd "$Command"
  cmd_waitforready
  Histogramarray="$(sed -n "/$Key1/,/$Key2/p" $Magickfifolog | sed '1d ; $d')"
  Histogramarray=($(echo "$Histogramarray" | sed -n  's/[ ]*\([0-9]*\).*gray[(]\([0-9]*\).*$/\1 \2/p' \
                                           | LC_ALL=C awk     '{ bin[int($2)] += $1; } 
                                                      END { for (i=0;i<256;i++) {hist = bin[i]+0; print hist; } } ' ) )
  Colorcountarray=($(echo ${Histogramarray[*]} | LC_ALL=C awk '{ split($0,count," ") }
                                                       END { for (i=0;i<256;i++) { cum += count[i]; print cum } }' ))
  Totalpixel=${Colorcountarray[255]}
  Factor="$(getmagickinfo rose: "%[fx:$Quantumrange/$Totalpixel]")"
  Lutlist="$(for ((Count=0; Count<256; Count++)); do
    echo "${Colorcountarray[$Count]}"
  done | LC_ALL=C awk -v Factor="$Factor" '{ print int(Factor*$1); }')"

  Netpbm="P2 256 1 $Quantumrange $Lutlist"
  Netpbmdata="$(base64 <<< "$Netpbm")"
  sendmagickmessage "Content of encoded NetPBM clut image: $(echo "$Netpbm" | tr "\n" " ")"
  Command="
  'inline:data:image/netpbm;base64,
$Netpbmdata
'
    -scale 256x1\!
    -write $Clutimage
    -delete 0"
  cmd "$Command"
  cmd_waitforready
  return 0
}
threshold() {
  local Image Mask Threshold Thresholdblur Command Error
  local Longoptions Parsedoptions

  Longoptions="image:,mask:,percent:,blur:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --blur)    Thresholdblur="${2:-}" ;;
      --image)   Image="${2:-}" ;;
      --mask)    Mask="${2:-}" ;;
      --percent) Threshold="${2:-}" ;;
    esac
    shift
    shift
  done

  sendmagickmessage "NOTE:Applying --threshold=p$Threshold,r$Thresholdblur"
  Command="
  $Image
    -write mpr:image
    -delete 0
  $Mask
    -write mpr:mask
    -delete 0"
  case $Globalalpha in
    "")
      Command="$Command
  mpr:image
  ( mpr:mask -threshold ${Threshold}% -alpha off -blur 0x${Thresholdblur:-0} )
    -alpha off
    -compose CopyOpacity -composite
    -write $Image
    -delete 0"
    ;;
    *)
      Command="$Command
  mpr:image
  ( mpr:mask -black-threshold ${Threshold}% -alpha off -blur 0x${Thresholdblur:-0} )
    -alpha off
    -compose CopyOpacity -composite
    -write $Image
    -delete 0"
    ;;
  esac
  Command="$Command
  +set registry:image
  +set registry:mask"

  cmd "$Command"
  cmd_waitforready
  return 0
}

# core focus stack routines

focus_maskmethod() {
  # Mask generating ImageMagick options
  # Most of them are based on edge detection: http://www.imagemagick.org/Usage/convolve/#edgedet
  local Method Sourceimage
  local Maskgenerator=

  Method="${1:-none}"
  case $Method in
    blur)
      Maskgenerator="
  # --blur
  mpr:sourcegray
    -blur ${Argradius1:-0}x${Argsigma1:-0.75}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    channel|saturation|chroma|lightness|darkness)
      Maskgenerator="$Maskgenerator
  # --$Method
  mpr:sourceimage
    -colorspace ${Argword1:-HSB} 
    -channel ${Argword2:-1} -separate
    +channel"
      [ "$Method" = "darkness" ] && Maskgenerator="$Maskgenerator
    -negate"
    ;;
    comet) ### FIXME saturate drops some angles
      Maskgenerator="
  # --comet
  mpr:sourcegray 
    -define morphology:compose=${Argword1:-Lighten}
    -morphology Convolve Comet:${Argradius1:-0}x${Argsigma1:-5}:>
  mpr:sourcegray
    -compose difference -composite"
    ;;
    compass)
      Maskgenerator="
  # --compass
  mpr:sourcegray
    -define convolve:scale=50%!
    -define morphology:compose=Lighten
    -define convolve:bias=50%
    -morphology Convolve Compass:>"
#-compose Difference -composite" # sort of interesting.
    ;;
    compose)
      Maskgenerator="
  # --compose=$Argword1
  ( mpr:sourcegray -alpha off )
  ( '$(generate_image --showname "$Argword1")' $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    diffstat)
      Maskgenerator="
  # --diffstat"
      [ "$Argword1" = "source" ] && {
        Maskgenerator="$Maskgenerator
  mpr:sourcegray"
      } || {
        Maskgenerator="$Maskgenerator
  ( mpr:sourcegray -statistic ${Argword1:-median} ${Argradius1:-5} )"
      }
      [ "$Argword2" = "source" ] && {
        Maskgenerator="$Maskgenerator
  mpr:sourcegray"
      } || {
        Maskgenerator="$Maskgenerator
  ( mpr:sourcegray -statistic ${Argword2:-mean} ${Argradius1:-5} )"
Maskgenerator="$Maskgenerator
    -compose Difference -composite"
      }
    ;;
    dog) # DoG: Difference of Gaussian
      Maskgenerator="
  # --dog
  mpr:sourcegray
    -define convolve:scale=100,100%
    -morphology Convolve DoG:${Argradius1:-0},${Argsigma1:-0.75},${Argsigma2:-1.2}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    enfuse)
      Maskgenerator="
  # --enfuse
  ( mpr:sourcegray -alpha off )
  ( '$(generate_image --showname enfuse)' $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    evaluate|min|max|mean|median)
      Maskgenerator="
  # --${Argword1:-$Method}
  ( mpr:sourcegray -alpha off )
  ( '$(generate_image --showname "${Argword1:-$Method}")' $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    GAUSSexperimental) 
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=-100,200%
    -morphology Convolve Gaussian:${Argradius1:-0}x${Argsigma1:-0.75}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    CROSSMORPHexperimental)
      Maskgenerator="
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1:-3}x1+1+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1:-3}x1+${Argradius1:-3}+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:1x${Argradius1:-3}+0+1 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:1x${Argradius1:-3}+0+${Argradius1:-3} )
    -evaluate-sequence min"
    ;;
    CROSSMORPH2experimental)
      Maskgenerator="
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1}x$((Argradius1/2))+0+$((Argradius1/4)) )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1}x$((Argradius1/2))+$((Argradius1-1))+$((Argradius1/4)) )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:$((Argradius1/2))x$((Argradius1))+$((Argradius1/4))+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:$((Argradius1/2))x$((Argradius1))+$((Argradius1/4))+$((Argradius1-1)) )
    -evaluate-sequence min"
    ;;
    experimental)
      Maskgenerator="
  mpr:sourcegray
    -threshold 80%
    -blur 0x5
    -auto-level
    -negate"
    ;;
    free)
      Maskgenerator="
  # --free='$Argword1'
  mpr:sourcegray 
    $Argword1"
    ;;
    freediff)
      Maskgenerator="
  # --freediff='$Argword1'
  mpr:sourcegray 
    $Argword1
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    freichen)
      case $Argword1 in
        "")
          Maskgenerator="
  # --freichen
  (
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:1>
  )
  (
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:2>
  )
    -compose Screen
    -composite"
        ;;
        *)
          Maskgenerator="
  # --freichen=$Argword1
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=10%
    -morphology Convolve FreiChen:${Argword1:-0}>"
        ;;
      esac
    ;;
    gaussian)
      Maskgenerator="
  # --gaussian ${Argradius1:-0}x${Argsigma1:-0.75}
  ( mpr:sourcegray -gaussian-blur ${Argradius1:-0}x${Argsigma1:-0.75} )
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    XXXhalo)
      Maskgenerator="
  mpr:sourcegray
    -threshold $(calc "100-${Argpercent1:-50}")%
    -write mpr:halomask
    -delete 0
  mpr:sourcegray
    -brightness-contrast -23,-100
  mpr:halomask
    -compose CopyOpacity -composite
  mpr:sourcegray
    -compose DstOver -composite    
    "
    ;;
    halo)
      Maskgenerator="
  # --halo
  mpr:sourcegray
    -threshold $(calc "100-${Argpercent1:-50}")%
    -morphology Dilate Octagon:${Argradius1:-2}
    -blur 0x${Argsigma1:-5}
    -auto-level
    -negate"
    ;;
    image)
      Maskgenerator="
  # --image
  ( mpr:sourcegray -alpha off )
  ( '$Argword1' $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    kirsch)
      Maskgenerator="
  # --kirsch
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=screen
    -define convolve:bias=15%
    -morphology Convolve Kirsch:>"
    ;;
    laplacian)
      Maskgenerator="
  # --laplacian
  mpr:sourcegray
    -define convolve:bias=5%
    -define convolve:scale=100%!
    -morphology Convolve Laplacian:${Argword1:-0}>"
    ;;
    log)  # LoG: Laplacian of Gaussian
      Maskgenerator="
  # --log
  mpr:sourcegray
    -define convolve:scale=100,100%
    -morphology Convolve LoG:${Argradius1:-0}x${Argsigma1:-0.75}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    morphology)
      Maskgenerator="
  # --morphology
  mpr:sourcegray
    -morphology ${Argword1:-edge}:${Argradius2:-1} Octagon:${Argradius1:-2}"
    ;;
    none)
      Maskgenerator="
  # --none
  mpr:sourcegray"
    ;;
    prewitt)
      Maskgenerator="
  # --prewitt
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=screen
    -define convolve:bias=10%
    -morphology Convolve Prewitt:>"
    ;;
    roberts)
      Maskgenerator="
  # --roberts
  mpr:sourcegray
    -define convolve:scale=100%
    -define morphology:compose=screen
    -define convolve:bias=10%
    -morphology Convolve Roberts:@"
    ;;
    sobel)
      Maskgenerator="
  # --sobel
  mpr:sourcegray
    -define convolve:scale=100%!
    -define convolve:bias=10%
    -define morphology:compose=screen
    -morphology Convolve Sobel:>"
    ;;
    statistic)
      Maskgenerator="
  # --statistic
  mpr:sourcegray
    -statistic ${Argword1:-standarddeviation} ${Argradius1:-2}x${Argradius1:-2}"
    ;;
    unsharp)
      Maskgenerator="
  # --unsharp
  mpr:sourcegray -unsharp ${Argradius1:-0}x${Argsigma1:-5}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    wavelet)
      Maskgenerator="
  # --wavelet
  mpr:sourcegray 
    -wavelet-denoise ${Argpercent1:-10}%
  mpr:sourcegray
    -compose Difference -composite"
    ;;
  esac

  grep . <<< "$Maskgenerator"
}
focus_generate_masks() {
  local Maskgenerator Maskgenerator_all= Basenamelist= Maskready= Maskmax Mode Line Imagename Command= Maskmd5 Count

  Maskmethodlist="$(grep "\S" <<< "$Maskmethodlist")"
  [ -n "$Maskmethodlist" ] && while read Line; do
    [ "$Error" ] && break

    maskarg_parse "$Line"

    Maskgenerator="$(focus_maskmethod "$Argmethod")"

    [ "$Argdiff" ] && Maskgenerator="$Maskgenerator
  mpr:sourcegray
    -compose Difference -composite"

    [ "$Argnegate" ] && Maskgenerator="$Maskgenerator
    # =negate
    -negate"

    [ "${Argclose1}" ] && Maskgenerator="$Maskgenerator
    -morphology Close:${Argclose2:-1} Octagon:${Argclose1:-3}"

    [ "$Argmaskblur" ] && {
      Maskgenerator="$Maskgenerator
    -blur 0x$Argmaskblur"
    }

    Maskmd5="$(md5cut "$Sourcemd5 $Maskgenerator")"
    Argbasename="$Argmethod$Argoptions.$Maskmd5"
    maskarg_store

    ## avoid [double] creating of existing masks
    Maskready="no"
    maskexist "$Argbasename" && {
      Maskready="yes"
      sendmagickmessage "NOTE:Skipping mask generation, already exists: $Argbasename"
    }
    grep -q -x "$Argbasename" <<< "$Basenamelist" && Maskready="yes"
    Basenamelist="$Basenamelist
$Argbasename"

    [ "$Maskready" = "no" ] && {
      [ "$Argmethod" = "enfuse" ] && {
        generate_image enfuse
      }
      Maskgenerator_all="$Maskgenerator_all
$Maskgenerator"
      Maskgenerator_all="$Maskgenerator_all
    -write $(maskname "$Argbasename" NUMBER)
    $(showimagecode "$(maskname "$Argbasename" NUMBER)")
    -delete 0"
    }
  done <<< "$Maskmethodlist"

  verbose "mask generator kernels:
$(magick xc:white -define morphology:showkernel=1 $(grep -E -- '-define|-morphology' <<< "$Maskgenerator_all" | grep -v "Close") null: 2>&1)"

  [ -z "$Maskmethodlist" ] && return 0

  sendmagickmessage "NOTE:Generating masks"
  # Generate masks
  grep -q "NUMBER" <<< "$Maskgenerator_all" || sendmagickmessage "NOTE:Skipping mask generation, nothing to do."
  grep -q "NUMBER" <<< "$Maskgenerator_all" && load_sourceimages
  grep -q "NUMBER" <<< "$Maskgenerator_all" && for Count in $(seq $Imagenumber); do
    Number="$(printnum $Count)"
    Command=""

    # Generate command to generate masks
    Command="$Command
  $(sendmagickmessage "PROGRESS:Mask generation step $Count / $Imagenumber")"
    Command="$Command
  $(sourceimagename $Count)
    -write mpr:sourceimage
    -delete 0
  mpr:sourceimage"

    # --grayscale
    [ "$Grayscaleconverter" ] && Command="$Command
    $Grayscaleconverter"
    Command="$Command
    -write mpr:sourcegray
    -delete 0"

    Command="$Command
${Maskgenerator_all//NUMBER/$Number}"

    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"
  cmd_waitforready
  Command="
  +set registry:sourceimage
  +set registry:sourcegray"
  cmd "$Command"
  cmd_waitforready

  # level
  # less,alpha
  while read Line; do
    maskarg_parse "$Line"

    # level and uniform masks
    [ "$Arglevel" = "yes" ] && level_masks "$Argbasename"

    ### FIXME magickscript
    # =alpha,less
    [ "${Argless}" ] && [ "${Argalpha}" ] && {
      error "--option=less,alpha is not supported yet."
      note "Generating alpha&less image for mask $Argmethod"
      Imagename="$Cachedir/$Argbasename-prepare-less${Argless}-alpha${Argalpha}-cb${Cutblur}.tif"
      Maskmax="$Cachedir/$Argbasename-prepare-less${Argless}-alpha${Argalpha}-cb${Cutblur}.mask.tif"
      focus_hard --alpha "$Argalpha" --lessthanmax "$Argless" --cutsoft "$Cutsoft" --cutblur "$Cutblur" --maskmax="$Maskmax" --output "$Imagename" --masklist="$(masklist "$Argbasename")" || error "Error in focus_generate_masks->focus_hard for less+alpha"
      alphalevel --image "$Imagename" --mask "$Maskmax" --level "$Argalpha"
      #$Magickbin "$Enfusebaseimage" "$Imagename" -compose Over -composite "$Imagename" || error "Failed to compose alpha result on enfuse background"
      Argbasename="$Argmethod-alpha$Argalpha-less$Argless-cb$Cutblur.$(md5cut "$Argbasename $Argalpha $Argless $Cutblur" )"
      note "Generating comparision masks from alpha&less result of $Argmethod"
      maskfromimage $Imagename $Argbasename
      Arglevel=""
      Argtype="image"
      maskarg_store
    }

    ### FIXME
    # =less
    [ "${Argless}" ] && [ -z "${Argalpha}" ] && {
      error "--option=less is not supported yet."
      Imagename="mpr:$Argbasename-prepare-less$Argless-cb${Cutblur}.tif"
      Maskmax="mpr:$Argbasename-less${Argless}-cb$Cutblur.mask.tif"
      focus_hard --lessthanmax "$Argless" --maskmax "$Maskmax" --output "$Imagename" -- $(masklist "$Argbasename")
      Argdarkenmask="$Maskmax"
      maskarg_store
    }
  done <<< "$Maskmethodlist"

  return ${Error:-0}
}
focus_merge_masks() {
  # Merge different masks.

  local Mergemask
  local Count Number Weightmax Prefertopcode= Methodnumber=
  local Command
  local Methodmask Mergecode=
  local Clutmaskimage

  [ -z "$Maskmethodlist" ] && {
    note "Skipping merge, no mask options are specified."
    return 0
  }
  sendmagickmessage "NOTE:Merging masks"
  Mergemaskbasename="mergemask"

  while read Line; do
    maskarg_parse "$Line"
    #[ "${Argweight:-100}" -gt "${Weightmax:-0}" ] && Weightmax="${Argweight:-100}"
    LC_ALL=C awk 'BEGIN {exit !('${Argweight:-100}' >= '${Weightmax:-0}')}' && Weightmax="${Argweight:-100}"
    Methodnumber="$((Methodnumber+1))"
  done <<< "$Maskmethodlist"
  Methodnumber=1 # overwritten for mean instead of Screen
  Weightmax=100

  [ "$Globalsigmoidal" ] && Mergecode="$Mergecode
  # clut for --sigmoidalclut
  -size 256x256
  gradient:
    -rotate 90
    -depth 16
    -sigmoidal-contrast ${Globalsigmoidal}%
    -write mpr:sigmoidalclut
    -delete 0"

  # generate merge code
  Mergemethod="${Mergemethod:-plus}"
  while read Line; do
    maskarg_parse "$Line"
    Mergemaskbasename="$Mergemaskbasename-$Argmethod"
    Methodmask="$(maskname "$Argbasename" NUMBER)"

    Mergecode="$Mergecode
  (
  $Methodmask"

    [ "$Argdarkenmask" ] && Mergecode="$Mergecode
  # =less
  $Argdarkenmask
    -compose Darken -composite"

    [ "$Argdenoise" ] && Mergecode="$Mergecode
  # =denoise
  $(denoisecode "$Argdenoise")"

    Mergecode="$Mergecode
  # =w (weight)
    +level 0%,$(calc "(100 * ${Argweight:-100}) / ( $Weightmax * $Methodnumber )" )% 
  )
    -compose $Mergemethod -composite"

    Mergecode="$Mergecode
  +set registry:$(cut -d: -f2- <<< "$Methodmask")"
  done <<< "$Maskmethodlist"
  Mergecode="$(sed "0,/-compose $Mergemethod -composite/{/-compose $Mergemethod -composite/d;}" <<< "$Mergecode")" # delete first -compose

  [ "$Globaldenoise" ] && {
    Mergecode="$Mergecode
  # --denoise
  $(denoisecode "$Globaldenoise")"
    Mergemaskbasename="$Mergemaskbasename-denoise$Globaldenoise"
  }

  Mergecode="$Mergecode
    -write mpr:mergemask
    -delete 0"

  [ "$Globalmaskstat" ] && {
    Mergecode="$Mergecode
  # --maskstat
  mpr:mergemask
    -statistic $Globalmaskstatmethod $Globalmaskstatradius
    -write mpr:mergemask
    -delete 0"
    Mergemaskbasename="$Mergemaskbasename-maskstat$Globalmaskstat"
  }

  [ "$Globalmaskblur" ] && {
    Mergecode="$Mergecode
  # --maskblur
  mpr:mergemask
    -blur 0x$Globalmaskblur
    -write mpr:mergemask
    -delete 0"
    Mergemaskbasename="$Mergemaskbasename-maskblur$Globalmaskblur"
  }

  [ "$Globalclose" ] && {
    Mergecode="$Mergecode
  # --close
  mpr:mergemask
    -threshold ${Globalclosethreshold:-50}%
    -write mpr:cutmask
    -delete 0
  mpr:mergemask
  mpr:cutmask
    -compose Darken -composite
    -morphology Close:${Globalclose1:-2} Octagon:${Globalclose2:-2}
  mpr:mergemask
    -compose Lighten -composite
    -write mpr:mergemask
    -delete 0"
    Mergemaskbasename="$Mergemaskbasename-close=r${Globalclose1}R${Globalclose2}p${Globalclosethreshold}"
  }

  [ "$Globalsigmoidal" ] && {
    Mergecode="$Mergecode
  # --sigmoidalclut
  mpr:mergemask
  mpr:sigmoidalclut
    -clut
    -write mpr:mergemask
    -delete 0"
    Mergemaskbasename="$Mergemaskbasename-sigmoidal$Globalsigmoidal"
  }

  # --prefertop
  [ "$Prefertop" ] && Mergemaskbasename="$Mergemaskbasename-prefertop$Prefertop"

  [ "$Darkenmask" ] && {
    Mergecode="$Mergecode
  # --darkenmask
  mpr:mergemask
  $Darkenmask
    -compose Darken -composite
    -write mpr:mergemask
    -delete 0"
    Mergemaskbasename="$Mergemaskbasename-darken$(md5cut "$Darkenmask")"
  }

  Mergemaskbasename="$Mergemaskbasename.$(md5cut "$Sourcemd5 $Mergecode $Prefertop" )"

  maskexist "$Mergemaskbasename" && note "Skipping merge, $Mergemaskbasename already exists" && return 0
  # merge masks
  for Count in $(seq $Imagenumber); do
    Command=""
    Number="$(printnum $Count)"
    Mergemask="$(maskname "$Mergemaskbasename" $Count)"

    [ "${Prefertop:-0}" -lt "0" ] && Prefertopcode="
    # --prefertop
    +level 0,$(calc "100 - -1*$Prefertop * $Count / $Imagenumber")%"
    [ "${Prefertop:-0}" -gt "0" ] && Prefertopcode="
    # --prefertop
    +level 0,$(calc "100 -    $Prefertop *($Imagenumber - $Count) / $Imagenumber")%"

    Command="$Command
  $(sendmagickmessage "PROGRESS:Mask merging step $Count / $Imagenumber")"
    Command="$Command
  #$(sourceimagename $Count)
  #  -alpha set 
  #  -alpha extract
  #  -write mpr:sourcealpha
  #  -delete 0
$(sed "s/NUMBER/$Number/g" <<< "$Mergecode" )
  #mpr:mergemask
  #mpr:sourcealpha
  #  -compose Darken -composite
  #  -write mpr:mergemask
  #  -delete 0
  mpr:mergemask
    $Prefertopcode
    $Tifstore 
    -write $Mergemask
    $(showimagecode "$Mergemask")
    -delete 0"

    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"
  cmd_waitforready

  return ${Error:-0}
}
focus_hard() {
  # Finally: focus stacking

  local Outputimage Sourceimage Cutblur= Cutsoft=
  local Firstimage Lastimage
  local Lessthanmaxmask
  local Maskmax Maskmaxcopy= Maskmaxready=
  local Count
  local Contrastmaxlevel Alphalevel= Lessthanmax=
  local Command
  local Focusimagebasename Focusimagefile Focusimagemaskfile
  local Sourcemask
  local Longoptions Parsedoptions

  Longoptions="lessthanmax:,maskmax:,output:,cutblur:,cutsoft:,firstimage:,lastimage:"

  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --output)       Outputimage="${2:-}" ; shift ;;
      --cutblur)      Cutblur="${2:-}" ; shift ;;
      --cutsoft)      Cutsoft="${2:-}" ; shift ;;
      --lessthanmax)  Lessthanmax="${2:-}" ; shift ;;
      --maskmax)      Maskmaxcopy="${2:-}" ; shift ;;
      --firstimage)   Firstimage="${2:-}" ; shift ;;
      --lastimage)    Lastimage="${2:-}" ; shift ;;
      --) ;;
    esac
    shift
  done

  Firstimage="${Firstimage:-1}"
  Lastimage="${Lastimage:-$Imagenumber}"

  sendmagickmessage "NOTE:Focus montage hard"

  Focusimagebasename="focus-hard.$Firstimage..$Lastimage.$(md5cut "$(masklist "$Mergemaskbasename") $Cutblur $Cutsoft $Lessthanmax")"
  Focusimagefile="$Cachedir/$Focusimagebasename.tif"
  Focusimagemaskfile="$Cachedir/$Focusimagebasename.mask.tif"

  [ -e "$Focusimagefile" ] && {
    sendmagickmessage "NOTE:Skipping focus_hard(), image already exists."
    Command="
  $Focusimagefile
    $Tifstore
    -write mpr:resultimage
    -write $Outputimage
    -delete 0"
    [ -n "$Maskmaxcopy" ] && Command="$Command
  $Focusimagemaskfile
    $Tifstore
    -write mpr:resultmask
    -write $Maskmaxcopy
    -delete 0"
    cmd "$Command"
    cmd_waitforready
    return 0
  }

  load_sourceimages

  generate_image transparent "$Focusimagefile"
  Maskmax="${Maskmax:-mpr:resultmask}"

  evaluate max "$Maskmax" $(masklist "$Mergemaskbasename" $Firstimage $Lastimage)

  [ "$Lessthanmax" ] && generate_image transparent "mpr:lessthanmax"

  #generate_image black "$Maskmax" # works, too. montage begins with full unsharp source getting increasingly sharp

  Command="
  $Focusimagefile
    -alpha Opaque
    -alpha off
    -write mpr:resultimage
    -delete 0
  $Maskmax
    -alpha off
    -write mpr:resultmask
    -delete 0"
  cmd "$Command"

  for Count in $(seq $Firstimage $Lastimage); do
    Command=""
    Sourcemask="$(maskname "$Mergemaskbasename" "$Count")"
    Sourceimage="$(sourceimagename $Count)"

    Command="$Command
  $(sendmagickmessage "PROGRESS:Focus montage step $Count / $Imagenumber")"
    # Load images
    Command="$Command
  $Sourceimage
    -alpha off
    -write mpr:sourceimage
    -delete 0
  $Sourcemask
    -alpha off
    -write mpr:sourcemask
    -delete 0"

    Command="$Command
  # stepwise increase maskmax
  mpr:sourcemask 
  mpr:resultmask 
    -compose Lighten -composite
    -write mpr:resultmask
    -delete 0"

    Command="$Command
  # get area of source mask equal or sharper than current max
  mpr:resultmask
  mpr:sourcemask
    -compose MinusSrc -composite -fill white +opaque black
    -alpha off
    -negate
    -write mpr:cutmask
    -delete 0"

    false && [ "$Background" ] && Command="$Command   
  # drop areas with contrast=0
  mpr:cutmask
  ( mpr:sourcemask -threshold 0% )
    -compose Darken -composite
    -write mpr:cutmask
    -delete 0"

    # --lessthanmax, --less
    [ "$Lessthanmax" ] && { 
      Command="$Command
  ## --lessthanmax, --less
  mpr:cutmask
    -write mpr:cutmask_max
    -delete 0"

      Command="$Command
  # get part of actual maskmax
  mpr:resultmask
  mpr:cutmask_max
    -alpha Off -compose CopyOpacity -composite
    -write mpr:maskmax_part
    -delete 0"

      Command="$Command
  # paint actual maskmax part into lessmask
  mpr:lessthanmax
  mpr:maskmax_part
    -compose Over -composite
    -write mpr:lessthanmax
    -delete 0"

      Command="$Command
  # get area of source mask that is stronger (+offset) than lessmask)
  mpr:sourcemask 
  ( mpr:lessthanmax -evaluate Add ${Lessthanmax:-0}% )
    -compose MinusSrc -composite
    -fill white +opaque black 
    -write mpr:cutmask_less
    -delete 0"

      Command="$Command
  # reduce max in maskmax where --lessthanmax takes over
  mpr:sourcemask
  mpr:cutmask_less
    -compose CopyOpacity -composite
    -write mpr:sourcemask_part
    -delete 0
  mpr:resultmask
  mpr:sourcemask_part
    -compose Over -composite
    -write mpr:resultmask
    -delete 0"

      Command="$Command
  # darken lessmask with current source mask to get a mask with decreasing sharpness after a max peak
  mpr:lessthanmax
  mpr:sourcemask
    -compose Darken -composite
    -write mpr:lessthanmax
    -delete 0"

      Command="$Command
  # get area of source mask equal or sharper than current max (same code as above, but now with less-adjusted maskmax.
  mpr:sourcemask
  mpr:resultmask
    -compose MinusDst -composite -fill white +opaque black
    -alpha off
    -negate
    -write mpr:cutmask
    -delete 0"

      Command="$Command
    ##/--lessthanmax"
    } 

    [ "$Cutsoft" ] && Command="$Command
  # --cutsoft: add a blur to cut mask
  mpr:cutmask
    -alpha off
    -blur 0x${Cutsoft:-1}
  mpr:cutmask
    -compose Lighten -composite
    -write mpr:cutmask
    -delete 0"

    [ "$Cutblur" ] && Command="$Command
  # --cutblur: blur entire cut mask
  mpr:cutmask
    -alpha off
    -blur 0x${Cutblur:-1}
    -write mpr:cutmask
    -delete 0"

    Command="$Command
  # get part of source image
  mpr:sourceimage
  mpr:cutmask
    -alpha off -compose CopyOpacity -composite
    -write mpr:sourcepart
    -delete 0"

    Command="$Command
  # add part of source to result
  mpr:resultimage
  mpr:sourcepart
    -compose Over -composite
    -alpha off
    -write mpr:resultimage
    $(showimagecode "mpr:resultimage")
    -delete 0"

    Command="$Command
  +set registry:$Sourceimage
  +set registry:$Sourcemask"

    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"

  Command="
  # store result image and mask
  mpr:resultimage
    $Tifstore 
    -write $Outputimage
    -write $Focusimagefile
    -delete 0
  mpr:resultmask
    $Tifstore
    -write $Focusimagemaskfile
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  [ "$Maskmaxcopy" ] && {
    Command="
  # copy max mask
  mpr:resultmask
    -write $Maskmaxcopy
    -delete 0"
    cmd "$Command"
    cmd_waitforready
  }

  Command="
  +set registry:cutmask
  +set registry:cutmask_less
  +set registry:cutmask_max
  +set registry:lessthanmax
  +set registry:maskmax
  +set registry:maskmax_part
  +set registry:sourceimage
  +set registry:sourcemask
  +set registry:sourcemask_part
  +set registry:sourcepart"
  cmd "$Command"
  cmd_waitforready
  #+set registry:resultimage

  return 0
}
focus_soft() {
  local Outputimage Alphalevel Maskmaxcopy
  local Count Command
  local Longoptions Parsedoptions
  local Sigmoidal=
  local Focusimagebasename Focusimagefile Focusimagemaskfile
  local Firstimage Lastimage

  Longoptions="alpha:,maskmax:,output:,sigmoidal:,firstimage:,lastimage:"

  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --output)       Outputimage="${2:-}" ; shift ;;
      --alpha)        Alphalevel="${2:-}" ; shift ;;
      --sigmoidal)    Sigmoidal="${2:-}" ; shift ;;
      --maskmax)      Maskmaxcopy="${2:-}" ; shift ;;
      --firstimage)   Firstimage="${2:-}" ; shift ;;
      --lastimage)    Lastimage="${2:-}" ; shift ;;
      --) ;;
    esac
    shift
  done

  Firstimage="${Firstimage:-1}"
  Lastimage="${Lastimage:-$Imagenumber}"

  sendmagickmessage "NOTE:Focus montage soft"

  Addsource="mpr:addsource"

  Focusimagebasename="focus-soft.$Firstimage..$Lastimage-$Alphalevel$-$Sigmoidal.$(md5cut "$(masklist $Mergemaskbasename)")"
  Focusimagefile="$Cachedir/$Focusimagebasename.tif"
  Focusimagemaskfile="$Cachedir/$Focusimagebasename.mask.tif"

  [ -e "$Focusimagefile" ] && {
    sendmagickmessage "NOTE:Skipping focus_soft(), image already exists."
    Command="
  $Focusimagefile
    $Tifstore
    -write mpr:resultimage
    -write $Outputimage
    -delete 0"
    [ -n "$Maskmaxcopy" ] && Command="$Command
  $Focusimagemaskfile
    $Tifstore
    -write mpr:resultmask
    -write $Maskmaxcopy
    -delete 0"
    cmd "$Command"
    cmd_waitforready
    return 0
  }

  load_sourceimages

  [ "$Sigmoidal" = "auto" ] && Sigmoidal=""

  Command="
  mpr:black
    -write mpr:addmask
    -delete 0
  mpr:black
    -write mpr:addsource
    -delete 0"
  [ "$Sigmoidal" ] && {
    Command="$Command
  # --sigmoidalclut
  -size 256x256
  gradient:
    -rotate 90
    -depth 16
    -sigmoidal-contrast ${Sigmoidal}%
    -write mpr:clut
    -delete 0"
  }
  cmd "$Command"

  for Count in $(seq $Firstimage $Lastimage); do
    Command=""
    Sourcemask="$(maskname "$Mergemaskbasename" "$Count")"
    Sourceimage="$(sourceimagename $Count)"

    sendmagickmessage "PROGRESS:Focus montage step $Count / $Imagenumber"

    Command="$Command
  $Sourceimage
    -depth 16
    -write mpr:sourceimage
    -delete 0
  $Sourcemask
    -depth 16
    -write mpr:mask
    -delete 0"

    [ "$Sigmoidal" ] && Command="$Command
  # --sigmoidalclut
  mpr:mask
  mpr:clut
    -clut
    -write mpr:mask
    -delete 0"

    Command="$Command
  mpr:mask
    +level 2%,100%
    -evaluate Divide $Imagenumber
    -write mpr:mask
    -delete 0
  mpr:addmask
  mpr:mask
    -compose Plus -composite
    -write mpr:addmask
    -delete 0
  mpr:addsource
  ( mpr:sourceimage mpr:mask -compose Multiply -composite )
    -evaluate-sequence Add
    -write mpr:sourceadd
    -write mpr:addsource
    -delete 0"

    [ "$Showimageprocessing" ] && {
      Command="$Command
  # create result only for --show
  mpr:addsource
  mpr:addmask
    -compose DivideSrc -composite
    -write mpr:resultimage
    $(showimagecode "mpr:resultimage")
    -delete 0"
    }

    Command="$Command
  +set registry:$Sourceimage
  +set registry:$Sourcemask"

    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"
  Command="
  mpr:addsource
  mpr:addmask
    -compose DivideSrc -composite
    $Tifstorealpha
    -write mpr:resultimage
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  mkclut_uniform "mpr:addmask" "mpr:clut" ### FIXME --slabs
  Command="
  mpr:addmask
  mpr:clut
    -clut
    -write $Focusimagemaskfile
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  [ "$Maskmaxcopy" ] && {
    cp "$Focusimagemaskfile" "$Maskmaxcopy"
  }

  Command="
  mpr:resultimage
    $Tifstore 
    -write $Focusimagefile
    -write $Outputimage
    $(showimagecode "$Focusimagefile")
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  Command="
  +set registry:addmask
  +set registry:addsource
  +set registry:clut
  +set registry:mask
  +set registry:sourceadd
  +set registry:sourceimage"
  cmd "$Command"
  cmd_waitforready
  #+set registry:resultimage

  return ${Error:-0}
}
focus_main() {

  # Generate masks
  [ -n "$Maskmethodlist" ] && {
    focus_generate_masks
    focus_merge_masks
  }

  # Focus stacking
  for Slabstep in $(seq $Slabs); do
    Slabresult[$Slabstep]="$Cachedir/$Resultbasename.slab$Slabstep.mpc"
    Slabmask[$Slabstep]="$Cachedir/$Resultbasename.slab$Slabstep-mask.mpc"
    [ "$Slabs" -gt "1" ] && sendmagickmessage "NOTE:Generating slab $Slabstep / $Slabs"
    [ -n "$Maskmethodlist" ] && {
      case $Softmode in
        "") 
          focus_hard --maskmax "${Slabmask[$Slabstep]}" --output "${Slabresult[$Slabstep]}" \
                     --firstimage="${Slabfirstimage[$Slabstep]}" --lastimage="${Slablastimage[$Slabstep]}" \
                     --lessthanmax "$Globalless" --cutsoft "$Cutsoft" --cutblur "$Cutblur"
        ;;
        *)  ### FIXME
          focus_soft --maskmax "${Slabmask[$Slabstep]}" --output "${Slabresult[$Slabstep]}" \
                     --firstimage="${Slabfirstimage[$Slabstep]}" --lastimage="${Slablastimage[$Slabstep]}" \
                     --alpha "$Globalalpha" --sigmoidal "$Softmode"
        ;;
      esac

      Slabresultpost[$Slabstep]="$Cachedir/$Resultbasename.slab$Slabstep-post.mpc"
      Slabmaskpost[$Slabstep]="$Cachedir/$Resultbasename.slab$Slabstep-post-mask.mpc"
      [ -e "${Slabresultpost[$Slabstep]}" ] && {
        sendmagickmessage "NOTE:Skipping --alpha --threshold --finalblur, already done."
      } || {
        Command="
${Slabresult[$Slabstep]}
  -write ${Slabresultpost[$Slabstep]}
  -delete 0
${Slabmask[$Slabstep]}
  -write ${Slabmaskpost[$Slabstep]}
  -delete 0"
        cmd "$Command"

        # --finalblur
        [ "$Finalblur" ] && {
          finalblur --image "${Slabresultpost[$Slabstep]}" --mask "${Slabmaskpost[$Slabstep]}" --percent "$Finalblurpercent" --sigma "$Finalblursigma" --blur "$Finalblurradius"
        }

        # --alpha
        [ "$Globalalpha" ] && {
          alphalevel --image "${Slabresultpost[$Slabstep]}" --mask "${Slabmaskpost[$Slabstep]}" --level "$Globalalpha"
        }

        # --threshold
        [ "$Globalthreshold" ] && {
          threshold --image "${Slabresultpost[$Slabstep]}" --mask "${Slabmaskpost[$Slabstep]}" --percent "$Globalthreshold" --blur "$Globalthresholdblur"
        }
      }
    }
  done

  Command="
  # composing slab results
  mpr:transparent
    -alpha set
    -write mpr:resultimage
    -delete 0
  mpr:resultimage"
  for Slabstep in $(seq $Slabs); do
    Command="$Command
  ${Slabresultpost[$Slabstep]}
    -compose Over -composite
    $(showimagecode)"
  done
  Command="$Command
    -write mpr:resultimage
    $Tifstorealpha
    $(showimagecode)
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  # --background
  [ "$Background" ] && [ "$Storelayered" = "no" ] && {
    sendmagickmessage "NOTE:Applying --background=$Background"
    Command="
  # --background=$Backgroundimage
  $Backgroundimage
  mpr:resultimage
    -compose Over -composite
    -write mpr:resultimage
    -delete 0"
    cmd "$Command"
    cmd_waitforready
  }

  # --layered
  case "$Storelayered" in
    yes)
      sendmagickmessage "NOTE:Generating layered tif"
      generate_image cyan
      generate_image magenta
      generate_image yellow
      generate_image green
      Command="
  # --layered
  mpr:resultimage
  mpr:cyan
  mpr:magenta
  mpr:yellow
  mpr:green"
      [ "$Background" ] && Command="$Command
  $Backgroundimage"
      for Slabstep in $(seq $Slabs); do
        Command="$Command
  ${Slabresult[$Slabstep]}
  ${Slabresultpost[$Slabstep]}"
      done
      Command="$Command
    $Tifstorealpha
    #-define tiff:write-layers=yes
    -write $Outputimage
    $(showimagecode "$Outputimage")
    -delete 0"
    ;;
    no)
      Command="
  mpr:resultimage
    $Tifstorealpha
    -write $Outputimage
    -delete 0"
    ;;
  esac

  cmd "$Command"
  cmd_waitforready

  # --savemask
  [ "$Savemask" ] && {
    cmd "  # --savemask"
    evaluate max "$Savemask" ${Slabmaskpost[$Slabstep]}
  }
}

### mask args

maskarg_parse() {
  local Key Line Value

  Argbasename=""
  Argclose1=""
  Argclose2=""
  Argdarkenmask=""
  Argdenoise=""
  Argdiff=""
  Argless=""
  Arglevel=""
  #Argmethod=""
  Argnegate=""
  Argoptions=""
  Argpercent1=""
  Argpercent2=""
  Argradius1=""
  Argradius2=""
  Argsigma1=""
  Argsigma2=""
  Argalpha=""
  Argtype=""
  Argweight=""
  Argword1=""
  Argword2=""

  while read -d, Line; do
    grep -q "=" <<< "$Line" && {
      Key="$(cut   -d= -f1    <<< "$Line")"
      Value="$(cut -d= -f2 -s <<< "$Line")"
      :
    } || {
      Key="$(digitrm "$Line")"
      Value="$(sed "s/${Key:-NOKEY}//"  <<< "$Line")"
    }
    case $Key in
      #"w"|"w%")       Argweight="${Value:-$(maskarg_defaultvalue    "$Firstmaskmethod" noise)}" ;;
      "w"|"w%")           Argweight="${Value:-}" ;;
      "r")                Argradius1="$Value" ;;
      "R")                Argradius2="${Value}" ;;
      "s")                Argsigma1="$Value" ;;
      "S")                Argsigma2="${Value}" ;;
      "p"|"%")            Argpercent1="$(percentrm "$Value")" ;;
      "P")                Argpercent2="$(percentrm "$Value")" ;;
      "alpha"|"alphax")     
        Argalpha="$(tr -d "alpha=" <<< "$Line")"
        Argalpha="${Argalpha:-$(maskarg_defaultvalue      "$Argmethod" alpha)}"
        Argalpha="$(levelparse "$Argalpha")"
      ;;
      "denoise")          Argdenoise="${Value:-$(maskarg_defaultvalue   "$Argmethod" noise)}" ;;
      "d"|"diff")         Argdiff="s" ;;
      "less")             Argless="${Value:-$(maskarg_defaultvalue      "$Argmethod" less)}" ;;
      "blur"|"maskblur")  Argmaskblur="${Value:-$(maskarg_defaultvalue  "$Argmethod" maskblur)}" ;;
      "n"|"neg"|"negate") Argnegate="neg" ;;
      "c"|"close"|"cx"|"closex")
        Value="$(tr -d "close" <<< "$Line")"
        Value="${Value:-$(maskarg_defaultvalue                          "$Argmethod" close)}"
        Argclose1=$(cut -dx    -f1 <<< "$Value")
        Argclose2=$(cut -dx -s -f2 <<< "$Value")
        Argclose1="$(digitonly "$Argclose1")"
        Argclose2="$(digitonly "$Argclose2")"
        Argclose2="${Argclose2:-1}"
      ;;
      "CLOSE1")           Argclose1="$Value" ;;
      "CLOSE2")           Argclose2="$Value" ;;
      "LEVEL")            Arglevel="yes" ;;
      "DARKENMASK")       Argdarkenmask="$Value" ;;
      "NUM")              Maskmethodcount="$Value" ;;
      "METHOD")           Argmethod="$Value" ;;
      "TYPE")             Argtype="$Value" ;;
      "OPTIONS")          Argoptions="$Value" ;;
      "BASENAME")         Argbasename="$Value" ;;
      *|WORD1|WORD2) ### FIXME
        [ -z "$Argword1" ] && Argword1="$Line" || Argword2="$Line" 
        Argword1="${Argword1#WORD1=}"
        Argword2="${Argword2#WORD2=}"
      ;;
    esac
  done <<< "${1:-},"
}
maskarg_store() {
  Maskmethodcount="${1:-$Maskmethodcount}"
  Newoption="METHOD=$Argmethod"
  Argoptions=
  [ "$Argweight" ]             && Newoption="$Newoption,w=$Argweight"
  [ "$Argradius1" ]            && Newoption="$Newoption,r=$Argradius1"
  maskarg_checkallowed "$Argmethod" radius1  "$Argradius1" --silent  && Argoptions="$Argoptions-r$Argradius1"
  [ "$Argradius2" ]            && Newoption="$Newoption,R=$Argradius2"
  maskarg_checkallowed "$Argmethod" radius2  "$Argradius2" --silent  && Argoptions="$Argoptions-R$Argradius2"
  [ "$Argsigma1" ]             && Newoption="$Newoption,s=$Argsigma1"
  maskarg_checkallowed "$Argmethod" sigma1   "$Argsigma1" --silent   && Argoptions="$Argoptions-s$Argsigma1"
  [ "$Argsigma2" ]             && Newoption="$Newoption,S=$Argsigma2"
  maskarg_checkallowed "$Argmethod" sigma2   "$Argsigma2" --silent   && Argoptions="$Argoptions-S$Argsigma2"
  [ "$Argpercent1" ]           && Newoption="$Newoption,p=$Argpercent1"
  maskarg_checkallowed "$Argmethod" percent1 "$Argpercent1" --silent && Argoptions="$Argoptions-p$Argpercent1"
  [ "$Argpercent2" ]           && Newoption="$Newoption,P=$Argpercent2"
  maskarg_checkallowed "$Argmethod" percent2 "$Argpercent2" --silent && Argoptions="$Argoptions-P$Argpercent2"
  [ "$Argless" ]               && Newoption="$Newoption,less=$Argless"
  [ "$Argclose1" ]             && Newoption="$Newoption,CLOSE1=$Argclose1"
  [ "$Argclose2" ]             && Newoption="$Newoption,CLOSE2=$Argclose2"
  [ "$Argword1" ]              && Newoption="$Newoption,WORD1=$Argword1"
  maskarg_checkallowed "$Argmethod" word1    "$Argword1" --silent    && Argoptions="$Argoptions-$Argword1"
  [ "$Argword2" ]              && Newoption="$Newoption,WORD2=$Argword2"
  maskarg_checkallowed "$Argmethod" word2    "$Argword2" --silent    && Argoptions="$Argoptions-$Argword2"
  [ "$Argdenoise" ]            && Newoption="$Newoption,denoise=$Argdenoise"
  [ "$Argdiff" ]               && Newoption="$Newoption,diff"
  [ "$Argalpha" ]              && Newoption="$Newoption,alpha=$Argalpha"
  [ "$Argmaskblur" ]           && Newoption="$Newoption,maskblur=$Argmaskblur"
  [ "$Argnegate" ]             && Newoption="$Newoption,negate"
  [ "$Argdarkenmask" ]         && Newoption="$Newoption,DARKENMASK=$Argdarkenmask"
  [ "$Arglevel" ]              && Newoption="$Newoption,LEVEL"
  [ "$Argtype" ]               && Newoption="$Newoption,TYPE=$Argtype"
  [ "$Argbasename" ]           && Newoption="$Newoption,BASENAME=$Argbasename"
  Newoption="$Newoption,OPTIONS=$Argoptions"
  Newoption="$Newoption,NUM=$Maskmethodcount"

  grep -q "NUM=$Maskmethodcount" <<< "$Maskmethodlist" \
    && Maskmethodlist="$(sed "s&.*NUM=$Maskmethodcount.*&$Newoption&" <<< "$Maskmethodlist")" \
    || Maskmethodlist="$Maskmethodlist
$Newoption"
  Maskmethodlist="$(grep "\S" <<< "$Maskmethodlist")"
}
maskarg_defaultvalue() {
  case "${2:-}" in
    close)
      echo "2x2,p25"
    ;;
    maskblur)
      case "${1:-}" in
        blur|comet|compass|diffstat|dog|freichen|gaussian|kirsch|laplacian|log|morphology|prewitt|roberts|sobel|statistic|unsharp|wavelet)
          echo "1"
        ;;
        *)
          echo "0"
        ;;
      esac
    ;;
    less)
      case "${1:-}" in
        blur)       echo "60" ;;
        comet)      echo "45" ;;
        compass)    echo "45" ;;
        dog)        echo "35" ;;
        diffstat)
          case "$Argword1,$Argword2" in
            "median,mean") echo "45" ;;
            "min,max")     echo "45" ;;
            *)             echo "45" ;;
          esac
        ;;
        freichen)   
          case $Argword1 in
            "")     echo "45" ;;
            15)     echo "10" ;;
          esac
        ;;
        gaussian)   echo "60" ;;
        kirsch)     echo "60" ;;
        laplacian)
          case $Argword1 in
            3)      echo "60" ;;
          esac
        ;;
        log)        echo "60" ;;
        morphology) echo "60" ;;
        prewitt)    echo "60" ;;
        roberts)    echo "60" ;;
        sobel)      echo "45" ;;
        statistic)  echo "45" ;;
        #unsharp
        wavelet)    echo "60" ;;
        *)          echo "60" ;;
      esac
    ;;
    levelmin)
      case "${1:-}" in
        blur)       echo "0" ;;
        comet)      echo "0" ;;
        compass)    echo "45" ;;
        dog)        echo "0" ;;
        diffstat)
          case "$Argword1,$Argword2" in
            "median,mean") echo "0" ;;
            "min,max")     echo "0" ;;
          esac
        ;;
        freichen)
          case $Argword1 in
            "") echo "33.6584" ;;
            15) echo "19" ;;
          esac
        ;;
        gaussian)   echo "0" ;;
        #kirsch)     echo "" ;;
        laplacian)
          case $Argword1 in
            3)      echo "0" ;;
          esac
        ;;
        log)        echo "0" ;;
        morphology) echo "0" ;;
        prewitt)    echo "34.3893" ;;
        #roberts)    echo "7.64782%,100%" ;;
        sobel)      echo "34.3893" ;;
        statistic)
          case $Argword1 in
            standarddeviation) echo "0" ;;
          esac
        ;;
        #unsharp
        wavelet)    echo "0" ;;
        *)          echo "" ;;
      esac
    ;;
    noise)
      echo "50"
      false && case "${1:-}" in
        #blur)       echo "15" ;;
        #comet
        compass)    echo "25" ;;
        diffstat)   echo "15" ;;
        #dog
        freichen)   echo "15" ;;
        #gaussian)   echo "15" ;;
        image|evaluate|compose|enfuse)
                    echo "100" ;;
        #kirsch)     echo "2" ;;
        #laplacian
        log)        echo "10" ;;
        morphology) echo "10" ;;
        prewitt)    echo "15" ;;
        #roberts
        sobel)      echo "1" ;;
        statistic)  echo "10" ;;
        #unsharp
        wavelet)    echo "10" ;;
        *)          echo "15" ;;
      esac
    ;;
    percent1)
      case "${1:-}" in
        halo)       echo "25" ;;
        wavelet)    echo "10" ;;
        *)          echo "" ;;
      esac
    ;;
    percent2)
      case "${1:-}" in
        *)          echo "" ;;
      esac
    ;;
    radius1)
      case "${1:-}" in
        #blur)       echo "" ;; # 0
        #comet)      echo "" ;; # 0
        compass)    echo "" ;;
        diffstat)   echo "3" ;;
        #dog)        echo "" ;; # 0
        freichen)   echo "" ;;
        #gaussian)   echo "" ;; # 0
        kirsch)     echo "" ;;
        laplacian)  echo "" ;;
        #log)        echo "" ;; # 0
        morphology) echo "1" ;;
        prewitt)    echo "" ;;
        roberts)    echo "" ;;
        sobel)      echo "" ;;
        statistic)  echo "2" ;;
        #unsharp)    echo "" ;; # 0
        *)          echo "" ;;
      esac
    ;;
    radius2)
      case "${1:-}" in
        *)          echo "" ;;
      esac
    ;;
    sigma1)
      case "${1:-}" in
        blur)       echo "0.3" ;;
        comet)      echo "5" ;;
        compass)    echo "" ;;
        diffstat)   echo "" ;;
        dog)        echo "0.4" ;;
        freichen)   echo "" ;;
        gaussian)   echo "0.3" ;;
        halo)       echo "5" ;;
        kirsch)     echo "" ;;
        laplacian)  echo "" ;;
        log)        echo "0.2" ;;
        morphology) echo "" ;;
        prewitt)    echo "" ;;
        roberts)    echo "" ;;
        sobel)      echo "" ;;
        statistic)  echo "" ;;
        unsharp)    echo "2" ;;
        wavelet)    echo "" ;;
        *)          echo "" ;;
      esac
    ;;
    sigma2)
      case "${1:-}" in
        dog)       echo "$(calc "${Argsigma1:-0.3} * 1.6")" ;;
        *)         echo "" ;;
      esac
    ;;
    alpha)
      echo "100"
    ;;
    type)
      case "${1:-}" in
        blur|comet|compass|diffstat|dog|freichen|gaussian|kirsch|laplacian|log|morphology|prewitt|roberts|sobel|statistic|unsharp|wavelet)
          echo "mask"
        ;;
        *)
          echo "image"
        ;;
      esac
    ;;
    word1)
      case "${1:-}" in
        channel)    echo "HSL" ;;
        chroma)     echo "HCL" ;;
        comet)      echo "lighten" ;;
        compose)    echo "overlay" ;;
        darkness)   echo "HSL" ;;
        diffstat)   echo "median" ;;
        evaluate)   echo "max" ;;
        freichen)   echo "" ;;
        freediff)   echo "-sharpen 0x3" ;;
        laplacian)  echo "3" ;;
        lightness)  echo "HSL" ;;
        morphology) echo "edge" ;;
        saturation) echo "HSL" ;;
        statistic)  echo "standarddeviation" ;;
        *)          echo "" ;;
      esac
    ;;
    word2)
      case "${1:-}" in
        channel)    echo "2" ;;
        chroma)     echo "1" ;;
        darkness)   echo "2" ;;
        diffstat)   echo "mean" ;;
        lightness)  echo "2" ;;
        saturation) echo "1" ;;
        *)          echo "" ;;
      esac
    ;;
  esac
}
maskarg_checkallowed() {
  local Method Option Arg Silent
  local Errormessage=
  Method="${1:-}"
  Option="${2:-}"
  Arg="${3:-}"
  Silent="${4:-}"

  case "$Option" in
    radius1)
      case "$Method" in
        #blur|comet|dog|gaussian|halo|log|morphology|unsharp|wavelet) ;;
        halo|morphology) ;;
        diffstat|statistic)
          [ "${Arg:-0}" -lt "2" ] && Errormessage="--$Method needs a radius of at least 2"
        ;;
        *) Errormessage="$Method does not take argument radius" ;;
      esac
    ;;
    radius2)
      Errormessage="$Method does not take argument radius2"
    ;;
    sigma1)
      case "$Method" in
        blur|comet|dog|gaussian|halo|log|unsharp) ;;
        *) Errormessage="$Method does not take argument sigma" ;;
      esac
    ;;
    sigma2)
      case "$Method" in
        dog) ;;
        *) Errormessage="$Method does not take argument sigma2" ;;
      esac
    ;;
    percent1)
      case "$Method" in
        wavelet|halo) ;;
        *) Errormessage="$Method does not take argument percent1" ;;
      esac
    ;;
    percent2)
      case "$Method" in
        *) Errormessage="$Method does not take argument percent2" ;;
      esac
    ;;
    word1)
      case "$Method" in
        enfuse) ;;
        comet|freichen|freediff|laplacian) ;;
        channel|chroma|darkness|lightness|saturation) ;;
        compose|evaluate|morphology)
          Arg="$(lowercase "${Arg}")"
          checkmagicklist "$Method" "$(tr -d '2' <<< "$Arg")" || {
            Errormessage="--$Method=$Arg: unknown argument.
  Please choose one out of 'magick -list $Method'"
          }
        ;;
        diffstat)
          Arg="$(lowercase "${Arg}")"
          Arg="$(maskarg_checkstatistic "$Arg")"
        ;;
        image) 
          [ -f "${Arg}" ] || Errormessage="--image: File not found: $Arg"
        ;;
        statistic)
          Arg="$(lowercase "${Arg}")"
          Arg="$(maskarg_checkstatistic "$Arg")"
          [ "$Arg" = "source" ] && Errormessage="--$Method does not take argument $Arg
  Please choose one out of 'magick -list $Method'"
        ;;
        *) Errormessage="$Method does not take argument word1 $Arg" ;;
      esac
    ;;
    word2)
      case "$Method" in
        diffstat)
          Arg="$(lowercase "${Arg}")"
          Arg="$(maskarg_checkstatistic "$Arg")"
        ;;
        channel|chroma|darkness|lightness|saturation) ;;
        *) Errormessage="$Method does not take argument word2 $Arg" ;;
      esac
    ;;
  esac

  case "$Silent" in
    "")
      [ "$Errormessage" ] && {
        error "$Errormessage"
        return 1
      }
      echo "$Arg"
    ;;
    *)
      [ "$Errormessage" ] && return 1
    ;;
  esac
  return 0
}
maskarg_checkstatistic() {
  local Mode

  Mode="${1:-}"
  case ${Mode,,} in
    0|source|none)          Mode="source" ;;
    1|gradient|grad)        Mode="gradient" ;;
    2|maximum|max)          Mode="maximum" ;;
    3|mean)                 Mode="mean" ;;
    4|median)               Mode="median" ;;
    5|minimum|min)          Mode="minimum" ;;
    6|mode)                 Mode="mode" ;;
    7|nonpeak)              Mode="nonpeak" ;;
    8|9|rms|rootmeansquare) Mode="rms" ;;
    10|standarddeviation|standard_deviation|standard-deviation|dev) 
                            Mode="standarddeviation" ;;
    #*) error "Unknown statistic mode '$Mode'" ; return 1;;
    *) return 1 ;;
  esac
  [ "$Error" ] && return 1
  echo "$Mode"
  return 0
}
maskarg_checkpercent() {
  # Allow percent values to be given without a leading 'p'. Few options only.
  [ -z "$Argpercent1" ] && [ -n "$Argword1" ] && {
    Argpercent1="$Argword1"
    Argword1=""
  }
  [ -n "$Argpercent1" ] && [ -n "$Argword1" ] && {
    error "Option does not take percent value along with a word argument"
    return 1
  }
  
  [ "$Argpercent1" = "auto" ] || [ "$Argpercent1" = "$(digitonly "$Argpercent1")" ] || {
    error "Invalid percent value: $Argpercent1"
    return 1
  }
}
maskarg_checksigma() {
  # Allow sigma values to be given without a leading 's'. Few options only.
  [ -z "$Argsigma1" ] && [ -n "$Argword1" ] && {
    Argsigma1="$Argword1"
    Argword1=""
  }
  [ -n "$Argsigma1" ] && [ -n "$Argword1" ] && {
    error "Option does not take sigma value along with a word argument"
    return 1
  }
  [ "$Argsigma1" = "auto" ] || [ "$Argsigma1" = "$(digitonly "$Argsigma1")" ] || {
    error "Invalid sigma value: $Argsigma1"
    return 1
  }
}

### magick -script interaction

cmd() {
  local Command
  Command="${1:-}"
  [ -n "$Magickfifo" ] && {
    echo "$Command" >> "$Magickfifo"
    echo "$Command" >> "$Magickscriptlog"
  }
  return 
}
cmd_waitforkeyvalue() {
  # wait for keyword $1 in output of magick. Prints output after first :
  local Key Line
  Key="${1:-}"
  while read Line; do
    grep -q "$Key" <<< "$Line" && break
  done < <(tail -F "$Magickfifolog" ||:)
  echo "$(cut -d: -f2- <<< "$Line")"
  return 0
}
cmd_waitforready() {
  # wait for magick command toolchain to be ready
  local Command Count File Line Key
  Key="$(generate_key)"
  #Command="
  #rose:
  #  -format '$Key\n'
  #  -write info:
  #  -delete -1"
  #cmd "$Command"
  sendmagickmessage "$Key"
  cmd_waitforkeyvalue "$Key" >/dev/null
  return
}
readmagickmessage() {
  # read and parse messages from magick
  local Line Code Content
  while read Line; do
    Code="$(cut -d: -f1 <<< "$Line")"
    Content="$(cut -d: -f2- <<< "$Line")"
    case "$Code" in
      PROGRESS)
        printsameline "imfuse: $Content"
      ;;
      /PROGRESS)
        echo "" >&2
      ;;
      NOTE)
        note "$Content"
      ;;
      SHOW)
        showimage "$Content"
    esac
    grep -q error <<< "$Line" && error "magick error:
$Line"
  done < <(tail -F "$Magickfifolog" ||:)
}
sendmagickmessage() {
  # send message $1 to output of magick
  local Command=
  case "$(cut -d: -f1 <<< "${1:-}")" in
    PROGRESS)
      Command="$Command
# $(cut -d: -f2- <<< "${1:-}")"
    ;;
    NOTE)
      Command="$Command
#### $(cut -d: -f2- <<< "${1:-}") ####
#"
    ;;
    *)
      Command="$Command
  # sending message ${1:-}"
    ;;
  esac
  Command="$Command
  rose:
    -format '${1:-}\n'
    -write info:
    -delete -1"
  cmd "$Command"
  return 0
}
showimagecode() {
  local Image Imageformat
  # magick code to store current image and print a showimage message for readmagickmessage()
  [ "$Showimageprocessing" ] && {
    Image="${1:-}"
    Imageformat="$(rev <<< "$Image" | cut -d. -f1 | rev)"
    [ "$(cut -c1-4 <<< "$Image")" = "mpr:" ] && Imageformat="mpr"
    case "$Imageformat" in
      ""|"mpr"|"mpc"|"miff")
        echo "# show image
    -write $Showimage
    -format 'SHOW:$Showimage\n'
    -write info:"
      ;;
      *)
        sendmagickmessage "SHOW:$Image"
      ;;
    esac
  }
  return 0
}
getmagickinfo() {
  # get info output for image $1 in format $2
  local Key1 Key2 Command
  Key1="$(generate_key)"
  Key2="$(generate_key)"
  Command="
  # get info ${2:-} about image ${1:-}
  ${1:-}
    -format '$Key1\n${2:-}\n$Key2\n'
    -write info:
    -delete -1"
  cmd "$Command"
  cmd_waitforready
  cmd_waitforkeyvalue "$Key2" >/dev/null
  sed -n "/$Key1/,/$Key2/p" $Magickfifolog | sed '1d ; $d'
  # code for multiple line info. -format would need a leading \n.
  #cmd_waitforkeyvalue "$Key" >/dev/null
  #sed -n "/$Key/,\$p" $Magickfifolog | sed '1d' | sed '$d' # FIXME might not be reliable; current solution to get multiple output lines
}

### main

trap_sigint() {
  local Count=0
  trap - ERR
  note "Received SIGINT"
  kill "$Magickscriptpid"
  finish 130
}
finish() {
  local Count=0
  trap - ERR

  cmd "-exit"
  while ps -p "$Magickscriptpid" >/dev/null 2>&1; do
    sleep 1
    Count="$((Count+1))"
    [ "$Count" -gt "5" ] && printsameline "Waiting infinitely since $Count seconds for magick $Magickscriptpid to terminate"
  done
  echo "" >&2

  ps -p "$Magickmessagepid" >/dev/null 2>&1 && kill "$Magickmessagepid"
  exec 3>&-

  #[ -f "$Magickfifolog" ]   && cp "$Magickfifolog" .
  [ -f "$Magickscriptlog" ] && cp "$Magickscriptlog" .

  [ -f "${Showimage:-}" ] && rm "$Showimage"
  [ "$Keepcache" = "no" ] && [ -d "$Cachedir" ] && rm -R "$Cachedir"

  #jobs
  trap - SIGINT
  trap - EXIT
  exit "${1:-0}"
}
declare_variables() {
  Arglist='
  Argbasename=""
  Argclose1=""
  Argclose2=""
  Argdarkenmask=""
  Argdenoise=""
  Argdiff=""
  Argless=""
  Arglevel=""
  Argmaskblur=""
  Argmethod=""
  Argnegate=""
  Argoptions=""
  Argpercent1=""
  Argpercent2=""
  Argradius1=""
  Argradius2=""
  Argsigma1=""
  Argsigma2=""
  Argalpha=""
  Argtype=""
  Argweight=""
  Argword1=""
  Argword2=""
  '
  eval $Arglist

  Align=""
  Background=""
  Backgroundimage=""
  Backgroundtype=""
  Basename=""
  Cachedir=""
  Caseeval=""
  Casecompose=""
  Composefactor="" ### FIXME
  Cutblur=""
  Cutsoft=""
  Darkenmask=""
  Difference_needlist=""
  Error=""
  Exifsourceimage=""
  Finalblur=""
  Finalblurpercent=""
  Finalblurradius=""
  Finalblursigma=""
  Firstimage=""
  Firstmaskmethod=""
  Forceoverwrite=""
  Freemem=""
  Globalalpha=""
  Globalclose=""
  Globalclose1=""
  Globalclose2=""
  Globalclosethreshold=""
  Globaldenoise=""
  Globalmaskblur=""
  Globalmaskstat=""
  Globalmaskstatmethod=""
  Globalmaskstatradius=""
  Globalless=""
  Globalsigmoidal=""
  Globalthreshold=""
  Globalthresholdblur=""
  Grayscale=""
  Grayscaleconverter=""
  Grayscalenumber=""
  Image=""
  Imageformat="tif"
  Imageheight=""
  Imagelistmemsize=""
  Imagememsize=""
  Imagenumber=""
  Imagewidth=""
  Image_needlist="
black
transparent
white"
  Imsourceimagelist=""
  Keepcache="no"
  Limitmemory=""
  Line=""
  Loadsourceimages=""
  Magickbin=""
  Magickfifo=""
  Magickfifolog=""
  Magickmessagepid=""
  Magickpixelmemory=""
  Magickscriptlog=""
  Magickscriptpid=""
  Magickversion=""
  Maskmethodcount=""
  Maskmethodlist=""
  Maskmethodnumber=""
  Masksuffix="mpc"
  Masktocache="no"
  Mergemaskbasename=""
  Mergemethod=""
  Outputimage=""
  Parsedoptions=""
  Prefertop=""
  Revertimagelist=""
  Resultbasename=""
  Savemask=""
  Showimage=""
  Showimageprocessing=""
  Showname=""
  Slabfirstimage=""
  Slablastimage=""
  Slabmask=""
  Slabmaskpost=""
  Slaboverlap=""
  Slabresult=""
  Slabresultpost=""
  Slabs=""
  Slabsize=""
  Slabstep=""
  Softmode=""
  Sourceimage=""
  Sourceimagelist=""
  Sourceimagesalreadyloaded=""
  Sourcemd5=""
  Startzeit="$(date +%s)"
  Storelayered="no"
  Testarg=""
  Testimage=""
  Testsetup=""
  Tifstore="+repage -quality 100% -compress lzw"
  Tifstorealpha="$Tifstore -type TrueColorAlpha"
  Untrap=""
  Verbose=""
  Video=""
  Videoframecount=""
  Viewnior=""

  return 0
}
parse_options() {
  local Shortoptions Longoptions Parsedoptions

  Shortoptions="ho:vVW"
  Longoptions="align,basename:,cache::,exif::,force::,help,limit-memory::,mask2cache,output:,savemask::,showimage,showname,test::,threads:,verbose,version,video"
  Longoptions="$Longoptions,alpha::,background::,bg::,close::,cutblur::,cutsoft::,darkenmask:,denoise::,finalblur::,grayscale:,layered,less::,maskblur::,maskstat::,merge::,prefertop::,revert,sigmoidalclut::,slabs::,soft::,threshold::"
  Longoptions="$Longoptions,channel::,chroma::,compose::,darkness::,enfuse::,evaluate::,halo::,image::,lightness::,max::,mean::,median::,min::,saturation::"
  Longoptions="$Longoptions,blur::,comet::,compass::,diffstat::,dog::,enfuse::,gaussian::,freichen::,kirsch::,laplacian::,log::,morphology::,none::,prewitt::,roberts::,sobel::,statistic::,unsharp::,wavelet::"  
  Longoptions="$Longoptions,experimental::,free::,freediff::"

  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@")" || error "Error while parsing options."
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    [ "$Error" ] && break
    case "${1:-}" in
         --align)             Align="yes"                     ;;
         --alpha)             Globalalpha="${2:-auto}"        ; shift ;;
         --bg|--background)   Background="${2:-auto}"         ; shift ;;
         --basename)          Basename="${2:-auto}"           ; shift ;;
         --darkenmask)        Darkenmask="${2:-}"             ; shift ;;
         --cache)             Cachedir="${2:-auto}"           ; shift ;;
         --close)             Globalclose="${2:-auto}"        ; shift ;;
         --cutblur)           Cutblur="${2:-auto}"            ; shift ;;
         --cutsoft)           Cutsoft="${2:-auto}"            ; shift ;;
         --denoise)           Globaldenoise="${2:-auto}"      ; shift ;;
         --exif)              Exifsourceimage="${2:-auto}"    ; shift ;;
         --finalblur)         Finalblur="${2:-auto}"          ; shift ;;
         --force)             Forceoverwrite="${2:-yes}"      ; shift ;;
         --grayscale)         Grayscale="${2:-auto}"          ; shift ;;
      -h|--help)              usage                           ; exit 0 ;;
         --layered)           Storelayered="yes"              ;;
         --limit-memory)      Limitmemory="${2:-"80%"}"       ; shift ;;
         --less)              Globalless="${2:-auto}"         ; shift ;;
         --mask2cache)        Masktocache="yes"               ;;
         --maskblur)          Globalmaskblur="${2:-auto}"     ; shift ;;
         --maskstat)          Globalmaskstat="${2:-auto}"     ; shift ;;
         --merge)             Mergemethod="${2:-auto}"        ; shift ;;
         --prefertop)         Prefertop="${2:-auto}"          ; shift ;;
      -o|--output)            Outputimage="${2:-}"            ; shift ;;
         --revert)            Revertimagelist="yes"           ;;
         --savemask)          Savemask="${2:-auto}"           ; shift ;;
      -V|--showimage)         Showimageprocessing="yes"       ;;
         --showname)          Showname="yes"                  ;;
         --sigmoidalclut)     Globalsigmoidal="${2:-auto}"    ; shift ;;
         --slabs)             Slabs="${2:-auto}"              ; shift ;;
         --soft)              Softmode="${2:-auto}"           ; shift ;;
         --test)              Testsetup="test"                ; Testarg="${2:-}" ; shift ;;
         --threads)           Multicore_maxprocesses="${2:-}" ; shift ;;
         --threshold)         Globalthreshold="${2:-auto}"    ; shift ;;
      -v|--verbose)           Verbose="yes"                   ;;
         --version)           echo "imfuse v$Version"         ; exit 0 ;;
         --video)             Video="auto"                    ;;
      -W)                     Viewnior="yes"                  ;;

--blur|--channel|--chroma|--comet|--compass|--compose|--darkness|--diffstat|--dog|--enfuse|--evaluate|\
--experimental|--free|--freediff|\
--freichen|--gaussian|--halo|--image|--kirsch|--laplacian|--lightness|--log|--morphology|\
--max|--mean|--median|--min|\
--none|--prewitt|--roberts|--saturation|--sobel|--statistic|--unsharp|--wavelet)
        Argmethod="${1#--}"
        Maskgeneratorargument="${2:-}" && shift
        Maskmethodnumber="$((Maskmethodnumber+1))"
        Maskmethodcount="$Maskmethodnumber"
        maskarg_parse "$Maskgeneratorargument"
        maskarg_store "$Maskmethodcount"
      ;;
      --) ;;
      *)
        Sourceimagelist="$Sourceimagelist
${1:-}"
        [ -f "${1:-}" ] || error "File not found: ${1:-}"
      ;;
    esac
    shift
  done
  Sourceimagelist="$(grep .     <<< "$Sourceimagelist")"
  Sourceimagelist="$(sort -V -r <<< "$Sourceimagelist")"
  return ${Error:-0}
}
check_options() {
  local Arg Part1 Part2 Weightsum= Weightrest Masknoweightcount=

  # source images
  [ -z "$Sourceimagelist" ] && error "No images specified"
  grep -q ' ' <<< "$Sourceimagelist" && error "imfuse does not accept whitespace ' ' in pathes or file names:
$(grep -m1 ' ' <<< "$Sourceimagelist")"
  Imagenumber="$(grep -c "." <<< "$Sourceimagelist")"

  #Maskmethodlist="$(sort -V   <<< "$Maskmethodlist")"
  Maskmethodlist="$(grep "\S" <<< "$Maskmethodlist")"
  [ -n "$Maskmethodlist" ] && while read Line; do
    maskarg_parse "$Line"
    [ -z "$Argradius1" ]  && Argradius1="$(maskarg_defaultvalue            "$Argmethod" radius1)"
    [ -z "$Argradius2" ]  && Argradius2="$(maskarg_defaultvalue            "$Argmethod" radius2)"
    [ -z "$Argsigma1" ]   && Argsigma1="$(maskarg_defaultvalue             "$Argmethod" sigma1)"
    [ -z "$Argsigma2" ]   && Argsigma2="$(maskarg_defaultvalue             "$Argmethod" sigma2)"
    [ -z "$Argpercent1" ] && Argpercent1="$(maskarg_defaultvalue           "$Argmethod" percent1)"
    [ -z "$Argpercent2" ] && Argpercent2="$(maskarg_defaultvalue           "$Argmethod" percent2)"
    [ -z "$Argword1" ]    && Argword1="$(maskarg_defaultvalue              "$Argmethod" word1)"
    [ -z "$Argword2" ]    && Argword2="$(maskarg_defaultvalue              "$Argmethod" word2)"
    [ -n "$Argradius1" ]  && { Argradius1="$(maskarg_checkallowed  "$Argmethod" radius1  "$Argradius1")"  || Error=1 ; }
    [ -n "$Argradius2" ]  && { Argradius2="$(maskarg_checkallowed  "$Argmethod" radius2  "$Argradius2")"  || Error=1 ; }
    [ -n "$Argpercent1" ] && { Argpercent1="$(maskarg_checkallowed "$Argmethod" percent1 "$Argpercent1")" || Error=1 ; }
    [ -n "$Argpercent2" ] && { Argpercent2="$(maskarg_checkallowed "$Argmethod" percent2 "$Argpercent2")" || Error=1 ; }
    [ -n "$Argsigma1" ]   && { Argsigma1="$(maskarg_checkallowed   "$Argmethod" sigma1   "$Argsigma1")"   || Error=1 ; }
    [ -n "$Argsigma2" ]   && { Argsigma2="$(maskarg_checkallowed   "$Argmethod" sigma2   "$Argsigma2")"   || Error=1 ; }
    [ -n "$Argword1" ]    && { Argword1="$(maskarg_checkallowed    "$Argmethod" word1    "$Argword1")"    || Error=1 ; }
    [ -n "$Argword2" ]    && { Argword2="$(maskarg_checkallowed    "$Argmethod" word2    "$Argword2")"    || Error=1 ; }
    #[ -z "$Argweight" ]   && Argweight="100"
    Weightsum="$((Weightsum + Argweight))"
    [ -z "$Argweight" ]   && Masknoweightcount="$((Masknoweightcount+1))"
    case $Argmethod in
      blur|comet|compass|diffstat|dog|enfuse|free|freediff|freichen|gaussian|kirsch|laplacian|log|morphology|prewitt|roberts|sobel|statistic|unsharp|wavelet)
        Arglevel="yes"
      ;;
    esac

    Argtype="$(maskarg_defaultvalue "$Argmethod" type)"
    [ "${Argalpha}" ] && Background="${Background:-enfuse}"
    [ "$Maskmethodcount" = "1" ] && Firstmaskmethod="$Argmethod"

    case $Argmethod in
      compose)
        Image_needlist="$Image_needlist
max
min
$Argword1"
      ;;
      evaluate)
        Image_needlist="$Image_needlist
$Argword1"
      ;;
      freichen)
        case $Argword1 in
          10|12|19) Argdiff=yes ;;
        esac
      ;;
      image)
        [ -e "$Argword1" ] || error "--image needs an image file name as argument. Not found: '$Argword1'"
      ;;
      max|mean|median|min)
        Image_needlist="$Image_needlist
$Argmethod"
      ;;
      morphology)
        case $Argword1 in
          edge|edgein|edgeout|tophat|bottomhat) ;;
          *) Argdiff="yes" ;;
        esac
      ;;
      statistic)
        case $Argword1 in
          gradient|standarddeviation|"") Argdiff="" ;;
          *)                             Argdiff="yes" ;;
        esac
      ;;
    esac

    maskarg_store "$Maskmethodcount"
  done <<< "$Maskmethodlist"
  [ "$Error" ] && return 1

  # w, weight
  Weightrest="$((100-Weightsum))"
  LC_ALL=C awk 'BEGIN {exit !('${Weightsum:-100}' > 100)}' && error "Sum of weight arguments exceed 100%."
  [ -n "$Maskmethodlist" ] && while read Line; do
    maskarg_parse "$Line"
    #Argweight="$(calc "$Argweight * 100 / $Weightsum")"
    [ -z "$Argweight" ] && {
      LC_ALL=C awk 'BEGIN {exit !('${Weightrest:-0}' <= 0)}' && error "Sum of weight arguments exceed 100%, nothing left for --$Argmethod."
      Argweight="$(calc "$Weightrest / $Masknoweightcount")"
    }
    maskarg_store
  done <<< "$Maskmethodlist"

  # --alpha
  case $Globalalpha in
    "") ;;
    *)
      [ "$Globalalpha" = "auto" ] && Globalalpha="0x100"
      Globalalpha="$(levelparse "$Globalalpha")"
      Background="${Background:-enfuse}"
    ;;
  esac

  # --basename
  case $Basename in
    #"")   Basename="imfuse" ;;
    auto) Basename="$(basename "$(pwd)")" ;;
  esac
  [ -d "$Basename" ] && {
    Outputdir="$Basename"
    Basename=""
  } || {
    Outputdir="$(dirname "$Basename")"
    Basename="$(basename "$Basename")"
  }

  # --cachedir
  [ -n "$Cachedir" ] && {
    Masktocache="yes"
    Keepcache="yes"
    [ "$Cachedir" = "auto" ] && Cachedir=""
  }
  Cachedir="$(sed s%'~'%$HOME% <<< "$Cachedir")"
  case "$Masktocache" in
    yes) [ -z "$Cachedir" ] && Cachedir="./cache.imfuse" ;;
    no)  [ -z "$Cachedir" ] && Cachedir="./cache.imfuse.$$" ;;
  esac

  # --close
  false && case $Globalclose in
    ""|"0") Globalclose="" ;;
    *)
      [ "$Globalclose" = "auto" ] && Globalclose="$(maskarg_defaultvalue "$Firstmaskmethod" close)"
      Globalclose1=$(cut -dx    -f1 <<< "$Globalclose")
      Globalclose2=$(cut -dx -s -f2 <<< "$Globalclose")
      Globalclose1="$(digitonly "$Globalclose1")"
      Globalclose2="$(digitonly "$Globalclose2")"
      Globalclose1="${Globalclose1:-1}"
      Globalclose2="${Globalclose2:-1}"
      Globalclose="${Globalclose1}x${Globalclose2}"
      false && [ "$Maskmethodnumber" = "1" ] && {
        maskarg_parse "$Maskmethodlist"
        Argclose1="$Globalclose1"
        Argclose2="$Globalclose2"
        maskarg_store
        Globalclose=""
        Globalclose1=""
        Globalclose2=""
      }
    ;;
  esac
  case $Globalclose in
    ""|"0") Globalclose="" ;;
    *)
      [ "$Globalclose" = "auto" ] && Globalclose="r,R,p"
      maskarg_parse "$Globalclose"
      Globalclose1="${Argradius1:-2}"
      Globalclose2="${Argradius2:-2}"
      Globalclosethreshold="${Argpercent1:-0}"
      Globalclose="r${Globalclose1},R${Globalclose2},p${Globalclosethreshold}"
    ;;
  esac

  # --cutblur
  case "$Cutblur" in
    "") ;;
    auto) Cutblur="2" ;;
    *)
      maskarg_parse "$Cutblur"
      maskarg_checksigma "$Cutblur"
      Cutblur="$Argsigma1"
    ;;
  esac

  # --cutsoft
  case "$Cutsoft" in
    "") ;;
    auto) Cutsoft="2" ;;
    *)
      maskarg_parse "$Cutsoft"
      maskarg_checksigma "$Cutsoft"
      Cutsoft="$Argsigma1"
    ;;
  esac

  # --denoise
  case $Globaldenoise in
    auto) Globaldenoise="10" ;;
  esac

  # --finalblur
  [ "$Finalblur" ] && {
    Argmethod="finalblur"
    maskarg_parse "$Finalblur"
    maskarg_checkpercent "$Finalblur"
    [ "$Argpercent1" = "auto" ] && Argpercent1=""
    Finalblurpercent="${Argpercent1:-40}"
    Finalblurradius="${Argradius1:-2}"
    Finalblursigma="${Argsigma1:-5}"
  }

  # --grayscale
  case ${Grayscale,,} in
    ""|auto)           Grayscale="RMS" ;;
  esac
  case ${Grayscale,,} in
    0|none)            Grayscalenumber=0 ; Grayscale="none" ;;
    1|rec601luma)      Grayscalenumber=1 ; Grayscale="Rec601Luma" ;;
    2|rec601luminance) Grayscalenumber=2 ; Grayscale="Rec601Luminance" ;;
    3|rec709luma)      Grayscalenumber=3 ; Grayscale="Rec709Luma" ;;
    4|rec709luminance) Grayscalenumber=4 ; Grayscale="Rec709Luminance" ;;
    5|brightness)      Grayscalenumber=5 ; Grayscale="Brightness" ;;
    6|lightness)       Grayscalenumber=6 ; Grayscale="Lightness" ;;
    7|average)         Grayscalenumber=7 ; Grayscale="Average" ;;
    8|ms)              Grayscalenumber=8 ; Grayscale="MS" ;;
    9|rms)             Grayscalenumber=9 ; Grayscale="RMS" ;;
    *)
      error "--grayscale: Unknown argument: $Grayscale"
    ;;
  esac
  case $Grayscale in
    ""|none) Grayscaleconverter="" ;;
    *)       Grayscaleconverter="-grayscale $Grayscale" ;;
  esac

  # --align
  [ "$Align" = "yes" ] && {
    command -v focus-stack >/dev/null || {
      error "--align: focus-stack not found.
  Please install focus-stack.
  https://github.com/PetteriAimonen/focus-stack"
    }
  }

  # --less
  case $Globalless in
    0)    Globalless="" ;;
    auto) Globalless="$(maskarg_defaultvalue "$Firstmaskmethod" less )" ;;
    *)
      maskarg_parse "$Globalless"
      maskarg_checkpercent "$Globalless"
      Globalless="$Argpercent1"
  esac

  # --maskblur
  case $Globalmaskblur in
    0)    Globalmaskblur="" ;;
    auto) Globalmaskblur="2" ;;
    *)
      maskarg_parse "$Globalmaskblur"
      maskarg_checksigma "$Globalmaskblur"
      Globalmaskblur="$Argsigma1"
    ;;
  esac

  # --maskstat
  [ "$Globalmaskstat" ] && {
    [ "$Globalmaskstat" = "auto" ] && Globalmaskstat=""
    maskarg_parse "$Globalmaskstat"
    Globalmaskstatradius="${Argradius1:-6}"
    Globalmaskstatmethod="${Argword1:-median}"
    Globalmaskstat="r$Globalmaskstatradius,$Globalmaskstatmethod"
  }

  # --merge
  Mergemethod="${Mergemethod:-Plus}"
  Mergemethod="${Mergemethod,,}"

  # --prefertop
  case $Prefertop in
    "") ;;
    auto) Prefertop="20" ;;
    *)
      maskarg_parse "$Prefertop"
      maskarg_checkpercent "$Prefertop"
      Prefertop="$Argpercent1"
  esac

  # --revert
  [ "$Revertimagelist" = "yes" ] && Sourceimagelist="$(tac <<< "$Sourceimagelist")"

  # --showimage
  [ "$Showimageprocessing" ] && {
    command -v geeqie >/dev/null || {
      note "-V, --showimage: geeqie not found.
  Please install geeqie."
      Showimageprocessing=""
    }
  }

  # --sigmoidalclut
  [ "$Globalsigmoidal" ] && {
    [ "$Globalsigmoidal" = "auto" ] && Globalsigmoidal="10x50%"
    Globalsigmoidal="$(percentrm "$Globalsigmoidal")"
    Part1="$(cut -dx -f1 <<< "$Globalsigmoidal")"
    Part2="$(cut -dx -f2 -s <<< "$Globalsigmoidal")"
    Part1="${Part1:-10}"
    Part2="${Part2:-50}"
    Globalsigmoidal="${Part1}x${Part2}"
  }

  # --slabs
  [ "$Slabs" = "auto" ] && Slabs="5,r5"
  [ -n "$Maskmethodlist" ] && {
    Slabs="${Slabs:-1}"
  } || {
    Slabs=0
  }
  [ "$Slabs" != "0" ] && {
    maskarg_parse "$Slabs"
    Slabs="${Argword1:-10}"
    Slaboverlap="${Argradius1:-5}"
    Slabsize="$((Imagenumber / Slabs))"
    for Slabstep in $(seq $Slabs); do
      Slabfirstimage[$Slabstep]="$((Slabsize*(Slabstep-1) +1))"
      Slablastimage[$Slabstep]="$((Slabsize*Slabstep+Slaboverlap))"
      [ "${Slablastimage[$Slabstep]}" -gt "$Imagenumber" ] && Slablastimage[$Slabstep]="$Imagenumber"
    done
  }

  # --soft
  [ "$Softmode" ] && {
    [ "$Cutblur" ]    && error "Option --soft does not support option --cutblur."
    [ "$Cutsoft" ]    && error "Option --soft does not support option --cutsoft."
    [ "$Globalless" ] && error "Option --soft does not support option --less. You can specify 'less' as a mask argument instead."
  }
  [ "$Softmode" ] && [ "$Softmode" != "auto" ] && {
    Softmode="$(percentrm "$Softmode")"
    Part1="$(cut -dx -f1 <<< "$Softmode")"
    Part2="$(cut -dx -f2 -s <<< "$Softmode")"
    Part1="${Part1:-10}"
    Part2="${Part2:-50}"
    Softmode="${Part1}x${Part2}"
  }

  # --threshold
  case $Globalthreshold in
    "") ;;
    auto) 
      Globalthreshold="50"
      Globalthresholdblur="2"
    ;;
    *)
      maskarg_parse "$Globalthreshold"
      maskarg_checkpercent "$Globalthreshold"
      Globalthreshold="${Argpercent1:-50}"
      Globalthresholdblur="${Argsigma1:-2}"
    ;;
  esac
  [ "$Globalthreshold" ] && Background="${Background:-transparent}"

  # --background
  [ "$Background" = "auto" ] && Background="enfuse"
  [ -z "$Maskmethodlist" ] && {
    Background="${Background:-enfuse}"
    note "No mask option specified, generating background only: $Background"
  }
  [ "$Background" ] && {
    checkmagicklist color                     "$Background"   && Backgroundtype="color"
    checkmagicklist evaluate                  "$Background"   && Backgroundtype="evaluate"
    checkmagicklist compose  "$(tr -d "2" <<< "$Background")" && Backgroundtype="compose"
    [ -f "$Background" ]                                      && Backgroundtype="image"
    case $Background in
      enfuse)                                                    Backgroundtype="$Background" ;;
      none)                   Background="" ;                    Backgroundtype="none" ;;
    esac
    [ "$Backgroundtype" ] || error "--background: Unknown background: '$Background'"
  }

  return ${Error:-0}
}
check_background() {
  # --background

  case $Backgroundtype in
    none)
      Background=""
      Backgroundimage=""
    ;;
    compose)
      Background="$(lowercase $Background)"
      Image_needlist="$Image_needlist
min
max
$Background"
      Backgroundimage="$(generate_image --showname "$Background")"
    ;;
    evaluate)
      Background="$(lowercase $Background)"
      Image_needlist="$Image_needlist
$Background"
      Backgroundimage="$(generate_image --showname "$Background")"
    ;;
    color)
      Image_needlist="$Image_needlist
$Background"
      Backgroundimage="$(generate_image --showname "$Background")"
    ;;
    image)
      Backgroundimage="$Background"
    ;;
    enfuse)
      Image_needlist="$Image_needlist
enfuse"
      Backgroundimage="$(generate_image --showname "$Background")"
    ;;
  esac
}
check_outputname() {
  # Generate a unique output name showing options

  Resultbasename="imfuse."
  [ "$Align" = "yes" ] && Resultbasename="${Resultbasename}align_"

  # step mask generation
  case $Grayscalenumber in
    9) ;;
    *) Resultbasename="${Resultbasename}_gray=$Grayscalenumber" ;;
  esac
  while read Line; do
    [ -z "$Line" ] && break
    maskarg_parse "$Line"
    Resultbasename="${Resultbasename}_${Argmethod}="
    [ "$Argweight" != "100" ]    && Resultbasename="$Resultbasename-w$(LC_ALL=C awk 'BEGIN {printf "%0.0f",'$Argweight'}')"
    [ "$Argradius1" ]            && Resultbasename="$Resultbasename-r$Argradius1"
    [ "$Argsigma1" ]             && Resultbasename="$Resultbasename-s$Argsigma1"
    [ "$Argradius2" ]            && Resultbasename="$Resultbasename-R$Argradius2"
    [ "$Argsigma2" ]             && Resultbasename="$Resultbasename-S$Argsigma2"
    [ "$Argpercent1" ]           && Resultbasename="$Resultbasename-p$Argpercent1"
    [ "$Argpercent2" ]           && Resultbasename="$Resultbasename-P$Argpercent2"
    [ "$Argalpha" ]              && Resultbasename="$Resultbasename-alpha$Argalpha"
    [ "$Argless" ]               && Resultbasename="$Resultbasename-less$Argless"
    [ "$Argclose1" ]             && Resultbasename="$Resultbasename-close$Argclose1"
    [ "$Argclose2" ]             && Resultbasename="${Resultbasename}x$Argclose2"
    [ "$Argmaskblur" ]           && Resultbasename="$Resultbasename-maskblur$Argmaskblur"
    [ "$Argdenoise" ]            && Resultbasename="$Resultbasename-denoise$Argdenoise"
    [ "$Argnegate" ]             && Resultbasename="$Resultbasename-neg"
    case $Argmethod in
      image) ;;
      saturation|chroma|darkness|lightness) ;;
      *) [ "$Argword1" ]         && Resultbasename="$Resultbasename-$(unspecialstring "$Argword1")" ;;
    esac
    case $Argmethod in
      saturation|chroma|darkness|lightness) ;;
      *) [ "$Argword2" ]         && Resultbasename="$Resultbasename-$(unspecialstring "$Argword2")" ;;
    esac
  done <<< "$Maskmethodlist"

  # step merge
  case $Globaldenoise in
    "") ;;
    *) Resultbasename="${Resultbasename}_denoise=$Globaldenoise" ;;
  esac
  [ "$Globalmaskstat" ] && {
    Resultbasename="${Resultbasename}_maskstat=$Globalmaskstat"
  }
  [ "$Globalmaskblur" ] && {
    Resultbasename="${Resultbasename}_maskblur=s$Globalmaskblur"
  }
  case $Globalclose in
    "") ;;
    *) Resultbasename="${Resultbasename}_close=$Globalclose" ;;
  esac
  [ "$Globalsigmoidal" ] && {
    Resultbasename="${Resultbasename}_sigmoidal=$Globalsigmoidal"
  }
  [ "$Prefertop" ] && {
    Resultbasename="${Resultbasename}_prefertop=p$Prefertop"
  }
  case $Mergemethod in
    plus) ;;
    *) Resultbasename="${Resultbasename}_merge=$Mergemethod" ;;
  esac

  # step focus
  [ "$Softmode" ] && {
    Resultbasename="${Resultbasename}_soft"
    [ "$Softmode" != "auto" ] && Resultbasename="${Resultbasename}=${Softmode}"
  }
  case $Globalless in
    ""|0) ;;
    *) Resultbasename="${Resultbasename}_less=p$Globalless" ;;
  esac
  [ "$Cutsoft" ] && {
    Resultbasename="${Resultbasename}_cutsoft=s$Cutsoft"
  }
  [ "$Cutblur" ] && {
    Resultbasename="${Resultbasename}_cutblur=s$Cutblur"
  }
  [ "$Slabs" ] && {
    Resultbasename="${Resultbasename}_slabs${Slabs},r${Slaboverlap}"
  }

  # step postprocessing
  [ "$Finalblur" ] && {
    Resultbasename="${Resultbasename}_finalblur=p${Finalblurpercent}-r${Finalblurradius}-s${Finalblursigma}"
  }
  case $Globalalpha in
    "") ;;
    *) Resultbasename="${Resultbasename}_alpha=$Globalalpha" ;;
  esac
  [ "$Globalthreshold" ] && {
    Resultbasename="${Resultbasename}_threshold=p$Globalthreshold"
    [ "$Globalthresholdblur" ] && Resultbasename="${Resultbasename},s$Globalthresholdblur"
  }
  [ "$Background" ] && case $Backgroundtype in
    "") ;;
    image) Resultbasename="${Resultbasename}_bg=image$(md5cut "$(ls -l --full-time "$Background")")" ;;
    *)     Resultbasename="${Resultbasename}_bg=$Background" ;;
  esac

  # misc
  case $Revertimagelist in
    "yes") Resultbasename="${Resultbasename}_rev" ;;
  esac
  [ "$Darkenmask" ] && {
    Resultbasename="${Resultbasename}_darkenmask"
  }
  [ "$Storelayered" = "yes" ] && {
    Resultbasename="${Resultbasename}_layered"
  }
  case $Testsetup in
    "") ;;
    *) Resultbasename="${Resultbasename}_test$Testarg" ;;
  esac
  Resultbasename="$(sed "s/__/_/g ; s/=-/=/g ; s/=_/_/g  ; s/\.\./\./g ; s/\._/\./g ; s/\._/\./g ; s/=$//g ; s/=\./=/g" <<< "$Resultbasename")"

  Fusemd5sum="$(md5cut "$Sourcemd5 $Maskmethodlist \
$Background $([ "$Darkenmask" ] && md5sum "$Darkenmask") $Cutblur $Cutsoft $Finalblur \
$Globalalpha $Globalclose $Globaldenoise $Globalless $Globalmaskstat $Globalmaskblur $Globalthreshold $Globalthresholdblur \
$Grayscale $Mergemethod $Prefertop $Revertimagelist $Softmode $Testsetup" )"

  Resultbasename="${Resultbasename}_md${Fusemd5sum}"
  [ -z "$Outputdir" ] && Outputdir="$(pwd)"
  case $Outputimage in
    "") Outputimage="$Outputdir/$Basename$Resultbasename.${Imageformat}" ;;
    *) [ "$(basename "$Outputimage")" = "$Outputimage" ] && Outputimage="$Outputdir/$Outputimage" ;;
  esac
  Outputimage="$(realpath -m "$Outputimage")"
  [ "$Video" ] && Video="$Outputimage.webm"

  # --savemask
  [ "$Savemask" = "auto" ] && Savemask="$Outputimage.mask.tif"

  return ${Error:-0}
}
main_setup() {

  # check magick version
  Magickbin="$(command -v magick)"
  [ -z "$Magickbin" ] && error "Command 'magick' not found. Please install ImageMagick version 7."
  Magickversion="$($Magickbin -version)"
  grep -q " Q8 "   <<< "$Magickversion" && Magickpixelmemory="4"
  grep -q " Q16 "  <<< "$Magickversion" && Magickpixelmemory="8"
  grep -q " HDRI " <<< "$Magickversion" && Magickpixelmemory="16"
  Magickversion="$(head -n1 <<< "$Magickversion" | cut -d' ' -f3)"

  # check RAM
  Freemem="$(printfreememory)"
  [ -z "$Freemem" ] && {
    note "WARNING: failed to estimate free memory.
  Blindly guessing 1GB."
    Freemem="1000000"
  }
  Limitmemory="${Limitmemory:-"95%"}"
  grep -q "%" <<< "$Limitmemory" && {
    Limitmemory="$(tr -d "%" <<< "$Limitmemory")"
    Limitmemory="$((Freemem*Limitmemory/100))"
  } || {
    Limitmemory="$((Limitmemory*1000))"
  }

  # Image properties
  Imagenumberlength="${#Imagenumber}"
  Image="$(head -n1 <<< "$Sourceimagelist")"
  Imagewidth="$($Magickbin  -format '%w' "$Image" info:)"
  Imageheight="$($Magickbin -format '%h' "$Image" info:)"
  Imagememsize="$((Imagewidth*Imageheight*Magickpixelmemory/1000))"
  Imagememsize="$((Imagememsize*125/100))" # by observation. Alpha channel?
  Imagelistmemsize="$((Imagenumber*Imagememsize))"
  #Imsourceimagelist="$Sourceimagelist"

  # check if source images should be loaded to RAM
  [ "$((Imagelistmemsize))" -lt "$((Limitmemory*2/3))" ] && Loadsourceimages="yes" || Loadsourceimages="no"

  # --cache
  mkdir -p $Cachedir   || error "Error creating cache folder $Cachedir"
  #rm -rf $Cachedir/*
  Testimage="$Cachedir/test.png"
  Resultmask="$Cachedir/result.max.tif"
  Showimage="${XDG_RUNTIME_DIR:-$Cachedir}/imfuse.showimage.tif"
  Sourcemd5="$(md5cut "$(ls -l --full-time $Sourceimagelist)" )"
  echo "$Sourcemd5" > "$Cachedir/md5"

  # --output, --basename
  check_outputname
  # --showname
  [ "$Showname" = "yes" ] && {
    echo "$Outputimage"
    finish
  }

  note "
  Imagemagick version:                $Magickversion
  Image number:                       $Imagenumber
  Image width:                        $Imagewidth px
  Image height:                       $Imageheight px
  Image memory size (estimated):      $Imagememsize KB
  Image list memory size (estimated): $((Imagelistmemsize/1024)) MB
  Memory total (including zram):      $(($(printtotalmemory)/1000)) MB
  Memory currently free:              $((Freemem/1000)) MB
  Memory limit for imagemagick:       $((Limitmemory/1000)) MB
  Loading source images to RAM:       $Loadsourceimages"

  # start magick -script in background
  Magickfifo="$Cachedir/magickfifo"
  Magickfifolog="$Cachedir/magickmessage.log"
  Magickscriptlog="$Cachedir/magickscript.log"
  Magickfifolog="./magickmessage.log"
  Magickscriptlog="./magickscript.log"
  :> $Magickscriptlog
  rm -f "$Magickfifo" 2>/dev/null ||:
  mkfifo $Magickfifo
  exec 3<>$Magickfifo
  (
    $Untrap
    nice magick -limit memory ${Limitmemory}KB -define registry:temporary-path=$Cachedir -script - <&3 >$Magickfifolog 2>&1
  ) & Magickscriptpid="$!"
  (
    $Untrap
    readmagickmessage
  ) & Magickmessagepid="$!"

  # --force
  [ -f "$Outputimage" ] && [ -z "$Forceoverwrite" ] && {
    showimage "$Outputimage"
    [ "$Viewnior" ] && viewnior "$Outputimage" &
    note "Output image already exists with matching md5sum.
  You can force imfuse to run nonetheless with option --force."
    echo $Outputimage
    exit
    return 0
  }

  # start geeqie
  generate_image transparent "$Cachedir/transparent.tif"
  [ "$Showimageprocessing" = "yes" ] && geeqie -t -r --File:"$Cachedir/transparent.tif" 2>/dev/null

  return 0
}
main() {
  set -Eu
  trap trap_sigint SIGINT
  trap finish      EXIT
  trap finish      ERR
  Untrap="
trap - SIGINT
trap - EXIT
trap - ERR"

  declare_variables
  parse_options "$@"
  check_options
  [ "$Error" ] && return 1
  main_setup

  # --align
  [ "$Align" = "yes" ] && {
    align || error "Error in align()."
  }

  # Generate backgrounds etc.
  check_background
  Image_needlist="$(grep . <<< "$Image_needlist" | sort -V | uniq)"
  for Mode in $Image_needlist; do
    generate_image "$Mode"
  done

  # run
  focus_main

  # Transfer EXIF metadata from first image to result
  [ "$Exifsourceimage" ] && {
    [ "$Exifsourceimage" = "auto" ] && Exifsourceimage="$(head -n1 <<< "$Sourceimagelist")"
    exiftransfer "$Exifsourceimage" "$Outputimage"
  }

  showimage "$Outputimage"
  note "Ready after $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")"
  echo "$Outputimage"

  [ "$Viewnior" ] && viewnior "$Outputimage" &
  [ "$Video" ] && generate_video

  return "${Error:-0}"
}
main "$@" || Error=1
finish "${Error:-0}"
