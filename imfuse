#! /bin/bash

# imfuse
Version="0.3"

usage() {
  echo "imfuse v$Version - combine focus stackshot images to an overall sharp image.
Aims to be similar to enfuse, but based on ImageMagick.

Dependencies:
  imagemagick      Mandatory (command 'convert' or 'magick').
  geeqie           Optional, used by option -V, --showimage.

Usage:
  imfuse [OPTIONS] -- image1 image2 image3 ...

General options:
     --cachedir=DIR          Specify a cache folder.
 -h, --help                  Show this help and exit.
     --layers [=NUMBER]      Additonally store two layered TIFF images
                             with segregated source part and sharpness layers.
                             NUMBER is number of sharpness layers. Default: 24
                             Does not work with --compose or --evaluate.
 -o, --output=FILE           Specify result image.
 -v, --verbose               Show verbose output.
     --version               Show imfuse version and exit.
 -V, --showimage             Show intermediate results with geeqie.
 
imfuse provides two basic ways to get overall sharp results.
 - The traditional way is contrast comparision with the mask methods below.
Reduce artefacts with --soft-weight, --saturation-weight, --denoise, --cutsoft.
 - Another, faster attempt compares max and min images and combines them
with the compositing methods.                            
Default method: Mask comparision with --diffstat

Compositing methods:
     --compose [=MODE]       Composes a result with mode MODE based on a max
                             and a min calculation of the source images.
                             Compare IM option -compose. 
                             MODE can be one of '$(basename $Magickbin) -list compose'
                             Some MODEs of interest:
                               bumpmap colorburn difference linearburn 
                               linearlight modulate multiply overlay pegtoplight
                             Takes options:
                               --swap       
                             Hint: Generate max+min images with --evaluate and
                             provide only them to --compose to speed it up.
                                                         Default MODE: overlay
     --evaluate [=MODE]      Evaluates a result of all source images with
                             mode MODE.                  
                             MODE can be one of '$(basename $Magickbin) -list evaluate'
                             Compare IM option -evaluate-sequence.
                             Most of interest:
                               max      Brightest pixels in sequence. 
                                        Fast and pretty result.
                                        Similar is --statistic=rms
                               mean     Average pixel values in sequence. 
                                        Useful to combine imfuse results.
                               median   Middle pixel values in sequence. 
                                        Useful to combine imfuse results.
                               min      Darkest pixels in sequence.
                                        Similar is --statistic=rms --negate
                                                         Default MODE: max
                             
Mask generating methods:
     --blur                  Blur edge detection. Takes options: 
                               --radius                  Default: 0
                               --sigma                   Default: 0.75
                             Two-mask difference calculation with options:
                               --radius2                 Default: 0
                               --sigma2                  Default: 1.6*sigma1
     --comet [=MODE]         Comet edge detection. Compares rotated mean areas.
                             MODE can be one of '$(basename $Magickbin) -list compose'
                             Recommended: Lighten (default), Darken.
                             Takes options: (low influence)
                               --radius                  Default: 0
                               --sigma                   Default: 5                            
     --compass               Compass edge detection. 
     --diffstat [=STAT1[,STAT2]]  Compares two local statistics of source. 
                             Uses IM option -statistic. Compare --statistic.
                             Possible STAT1 and STAT2:
                               0|none|source
                               1|gradient|grad
                               2|maximum|max
                               3|mean
                               4|median
                               5|minimum|min
                               6|mode
                               7|nonpeak
                               8|9|rms|rootmeansquare
                               10|standarddeviation|dev
                             Default for STAT1: median. Default for STAT2: mean
                             Takes options: 
                               --radius                  Default: 5
                             Two-mask difference calculation with option:
                               --radius2                 Default: radius1*3/2
     --free='IMOPTION'       Custom ImageMagick option IMOPTION 
                             for mask generation.        Default: '-sharpen 0x3'
                             Takes options:
                               --diff                    Default: yes
     --freichen [=MODE]      Frei-Chen edge detection. Possible MODEs at
                             http://www.imagemagick.org/Usage/convolve/#freichen
                             Default: A combination of modes 1 and 2.
     --gaussian              Gaussian blur edge detection.
                             Takes options: 
                               --radius                  Default: 0
                               --sigma                   Default: 0.75
                             Two-mask difference calculation (DoG) with option:
                               --sigma2                  Default: sigma1*1.6
     --kirsch                Kirsch edge detection. 
     --laplacian [=MODE]     Laplacian edge detection.
                             MODE is the kernel number to use.
     --log                   Laplacian of Gaussian.
                             Takes options: 
                               --radius                  Default: 0
                               --sigma1                  Default: 0.75
     --morphology [=MODE]    Achieves strong contrasts.
                             MODE can be one of '$(basename $Magickbin) -list morphology'
                             Takes options:
                               --radius1 (kernel radius)     Default: 2
                               --radius2 (kernel iterations) Default: 1
                               --diff                  Default depends on MODE
                             Increasing radius 1 or 2 increases contrast.
                             Some MODEs of interest:
                               edge, dilateintensity, smooth
     --prewitt               Prewitt edge detection. 
     --roberts               Roberts edge detection. 
     --sobel                 Sobel edge detection. 
     --statistic [=STAT]     IM option -statistic.
                             Takes options:
                               --radius                  Default: 2
                               --diff    Default depends on STAT and --radius2
                             Two-mask difference calculation with options:
                               --radius2                 Default: radius1*3/2
                             Argument STAT is one of (number or name):
                               1|gradient|grad
                               2|maximum|max
                               3|mean
                               4|median
                               5|minimum|min
                               6|mode
                               7|nonpeak
                               8|9|rms|rootmeansquare
                               10|standarddeviation|dev (Default)
                             Get a strong contrast with a high --radius for 
                             standarddeviation.
     --unsharp               Difference of -unsharp.
                             Takes options: 
                               --radius                  Default: 0
                               --sigma1                  Default: 2
                             Higher values for --sigma1 results in strong edges.
                             Two-mask difference calculation with options:
                               --sigma2                  Default: 1.6*sigma1
                                      
Compositing adjustments:
     --swap                  Invert order of max/min in --compose.
                             Changes result of some but not all compose modes.
                             
Method depending mask generation adjustments:
 -r, --radius=RADIUS1        Automatically chooses a radius if RADIUS=0
 -R, --radius2=RADIUS2       Second radius for difference masks.  
 -s, --sigma=SIGMA1          Sigma for some mask generating methods.
 -S, --sigma2=SIGMA2         Second sigma for difference masks.
You can specify a comma separated list for radius and sigma.
For example, --radius=2,3,4 will generate three contrast masks 
with different radii and combine them to one mask.

General mask generation adjustments:
 -d, --denoise [=ARG]        Flatten stacking artefacts based on a min/max
                             comparision of the full stack.
                             ARG is a mask to paint over and is one of:
                               darkness
                               lightness
                               saturation (default)
                               chroma
     --diff [=yes|no]        Difference comparision of mask with source image.
                             Configurable for few options yet.
 -f, --fusemode MODE         Choose fuse mode to combine source images.
                             MODE can be 1,2 or 3.         Default MODE: 1
                             - Fuse mode 1 compares sharpness of source images
                             and generates the result of the sharpest 
                             topmost areas. Sharp contrast, but many artefacts.
                             Every pixel matches exactly one pixel from one 
                             source image.
                             - Fuse mode 2 compares sharpness of source and result
                             in each iteration and overwrites parts of result.
                             Interesting results, but not exactly real.
                             - Fuse mode 3 uses semi-transparent layers with
                             sharpest layers topmost. Soft result with decreased
                             contrast and free of noise artefacts.
     --grayscale=ARG         Grayscale converting method before mask generation.
                             Compare IM options -grayscale and -intensity.
                             ARG is one of: (number or name)
                0 none
                1 Rec601Luma       0.298839R' + 0.586811G' + 0.114350B'
                2 Rec601Luminance  0.298839R  + 0.586811G  + 0.114350B
                3 Rec709Luma       0.212656R' + 0.715158G' + 0.072186B'
                4 Rec709Luminance  0.212656R  + 0.715158G  + 0.072186B
                5 Brightness       max(R', G', B')
                6 Lightness        (min(R', G', B') + max(R', G', B')) / 2.0
                7 Average          (R' + G' + B') / 3.0
                8 MS               (R'^2 + G'^2 + B'^2) / 3.0
                9 RMS              sqrt( (R'^2 + G'^2 + B'^2) / 3.0 ) (default)
     --negate                Invert contrast mask.
     --cutsoft [=SIGMA]      Add a semi-transparent blur around cut masks. 
                             Reduces some artefacts. Disable with SIGMA=0
                             Default: 1                  Option w/o SIGMA: 3
 -t, --threshold [=PERCENT]  Do not use pixels less significant than PERCENT%.
                             You might prefer --layers.  Option w/o PERCENT: 5

Mask weighting options:
Imfuse can add other masks to the contrast mask to reduce stacking artefacts.
They are extracted from image colorspace calculations. (HSB, HCL and CieLAB).
The different masks are combined with a customizable weight given in percent.
Negative percent values or greater than 100 are possible.
     --contrast-weight [=PERCENT]   Contrast mask weight.          
                                    Default: 100         Option w/o PERCENT: 100
     --soft-weight [=PERCENT]       Weight of soft mask taken from --fusemode=3.
                                    Default: 0           Option w/o PERCENT: 50
     --saturation-weight [=PERCENT] Saturation weight. (HSB)
                                    Default: 5           Option w/o PERCENT: 15
     --chroma-weight [=PERCENT]     Color intensity weight. (HCL)
                                    Default: 0           Option w/o PERCENT: 15
     --lightness-weight [=PERCENT]  Lightness weight.  (CieLAB)
                                    (Similar to --evaluate=max)
                                    Default: 0           Option w/o PERCENT: 15
     --darkness-weight [=PERCENT]   Negated Lightness. (CieLAB L)
                                    (Similar to --evaluate=min)
                                    Default: 0           Option w/o PERCENT: 15
     --downweight [=PERCENT] Reduce weight of sharpness masks of lower layers.
                             Helps to strengthen weak objects in foreground.
                             A negative PERCENT reduces weight of upper layers.
                                                         Option w/o PERCENT: 50

Method independent adjustments:
 -g, --gamma [=GAMMA]        Adjust gamma of result. GAMMA>1 brightens,
                             GAMMA<1 darkens the image.  Default GAMMA: auto
"
}

### Messages

error() {
  [ -z "$Error" ] && echo "imfuse ERROR: $*
" >&2
  Error=1
  #exit 1
}
note() {
  [ -z "$Error" ] && echo "imfuse note: $*"
  return 0
}
verbose() {
  [ "$Verbose" = "yes" ] && echo "imfuse: $*"
  return 0
}
showimage() {
  [ "$Showimageprocessing" = "yes" ] && geeqie -t -r File:"${1:-}"
  #[ "$Showimageprocessing" = "yes" ] && display -remote "${1:-}" &
  return 0
}

### Misc

comma2whitespace() {
  sed "s/,/ /g" <<< "${1:-}"
}
freememory() {
  local Freemem Line Zram
  Freemem="$(LC_ALL=C free | grep "Mem:" | awk '{print $7}')"
  while read Line; do
    Zram="$(awk '{print ($3 - $4)}' <<< "$Line")"
    Zram="$((Zram/1000))"
    Freemem="$((Freemem + Zram))"
  done < <(/sbin/swapon --bytes | grep zram)
  Freemem="$((Freemem*100/95))"
  echo $Freemem
}
lowercase() {
    # Usage: lowercase "string"
    printf '%s\n' "${1,,}"
}
multiply() {
  Factor1="${1:-}"
  Factor2="${2:-}"
  [ -z "$Factor1" ] && return 1
  [ -z "$Factor2" ] && return 1
  awk "BEGIN {print $Factor1*$Factor2}"
}
printnum(){
  # print number $1 with leading zeroes.
  # $1 number
  # $2 digits. Default: 3
  printf %0${2:-3}d "${1:-0}"
}
trap_sigint() {
  error "Received SIGINT"
}
unspecialstring() {             # replace special chars of $1 with -
  # Replace all characters except those described in "a-zA-Z0-9_" with a '-'. 
  # Replace newlines, too.
  # Remove leading and trailing '-'
  # Avoid double '--'
  # Return empty string if only special chars are given.
  printf %s "${1:-}" | LC_ALL=C tr -cs "a-zA-Z0-9_" "-" | sed -e 's/^-// ; s/-$//'
}

### Image processing

compose_stack() {
  local Command
  local Sourceimagelist Resultimage Mode
  local Startzeit Dauer Restzeit
  local Startzeit Dauer Restzeit Count
  
  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  while [ $# -gt 0 ]; do
    Sourceimagelist="$Sourceimagelist
${1:-}"
    shift
  done
  Sourceimagelist="$(grep "\S" <<< "$Sourceimagelist")"
  
  [ "$Freemem" -lt "$Imagelistmemsize" ] && {
  
    verbose "--compose: Generating max image"
    evaluate_split max $Cachedir/max.tif $Sourceimagelist
    verbose "--compose: Generating min image"
    evaluate_split min $Cachedir/min.tif $Sourceimagelist
    verbose "--compose: compositing $Mode"
    Command="$Magickbin
  ( $Cachedir/max.tif -evaluate multiply ${Composefactor:-1} )
  ( $Cachedir/min.tif -evaluate multiply ${Composefactor:-1} )
    $Swapcompose
    -compose $Mode -composite
    $Tifstore
  $Resultimage"
            
  } || {
          
    Command="$Magickbin
  $(echo $Sourceimagelist)
  ( -clone 0--1 -evaluate-sequence max -evaluate multiply ${Composefactor:-1} -write mpr:max -delete 0--1 )
  ( -clone 0--1 -evaluate-sequence min -evaluate multiply ${Composefactor:-1} -write mpr:min -delete 0--1 )
    -delete 0--1 \
  mpr:max mpr:min 
    $Swapcompose
    -compose $Mode -composite
    $Tifstore
  $Resultimage"
            
  }
            
  verbose "compose command:
$(grep "\S" <<< "$Command")"
              
  $Command || error "Error in --$Method=$Maskgeneratorargument"
  
  return ${Error:-0}
}

compose_stepx() {
  local Stacklist Imagenumber Stackcount Stackdir Step Image1 Image2 Image3
  Stacklist="$Sourceimagelist"
  Imagenumber="$(grep -c . <<< "$Stacklist")"
  while :; do
    [ "$Error" ] && break
    Stackcount="$((Stackcount+1))"
    echo $Stackcount
    Stackdir=$Cachedir/stack$Stackcount
    mkdir -p $Stackdir
    Imagenumber="$(grep -c . <<< "$Stacklist")"
    [ "$Imagenumber" -lt "2" ] && break
    for Step in $(seq $((Imagenumber/2)) ); do
      [ "$Error" ] && break
      Image1="$(head -n+$Step       <<< "$Stacklist" | tail -n1)"
      Image2="$(head -n+$((Step+1)) <<< "$Stacklist" | tail -n1)"
      [ -z "$Image2" ] && break
      Image3="$(head -n+$((Step+2)) <<< "$Stacklist" | tail -n1)"
      [ "$((Step*2+1))" = "$Imagenumber" ] || Image3=""
      $Magickbin \
        $Image1 $Image2 $Image3 \
          \( -clone 0--1 -evaluate-sequence max -write mpr:max \) \
          \( -clone 0--1 -evaluate-sequence max -write mpr:min \) \
          -delete 0--1 \
        mpr:max mpr:min $Swapcompose \
          -compose multiply -composite -gamma 2 \
        $Tifstore \
        $Stackdir/composite.$Step.tif
      showimage $Stackdir/composite.$Step.tif
    done
    Stacklist="$(ls $Stackdir/* | sort -V)"
  done
}
compose_step2() {

  Stackcount=0
  Startzeit="$(date +%s)"
  for Step in 0 $(seq $((Imagenumber/$Stepsize)) ); do
    [ "$Error" ] && break
    Stackcount="$((Stackcount+1))"
    Stacklist="$(tail -n+$((Stepsize*Step+1)) <<< "$Sourceimagelist" | head)"
    [ -z "$Stacklist" ] && break
    $Magickbin $Stacklist -evaluate-sequence max $Cachedir/max.$Stackcount.tif
    $Magickbin $Stacklist -evaluate-sequence min $Cachedir/min.$Stackcount.tif
    $Magickbin $Cachedir/max.$Stackcount.tif $Cachedir/min.$Stackcount.tif -compose overlay -composite $Cachedir/overlay.$Stackcount.tif
    showimage $Cachedir/overlay.$Stackcount.tif
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-((Step+1)*Stepsize)) / ((Step+1)*Stepsize) ))"
    [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
    note "compose: Duration: $(date -u -d @$Dauer +"%T"); Estimated time left: $(date -u -d @$Restzeit +"%T") ($Restzeit)"
  done
  $Magickbin $Cachedir/overlay* -evaluate-sequence max $Cachedir/max.overlay.tif
  $Magickbin $Cachedir/overlay* -evaluate-sequence max $Cachedir/min.overlay.tif
  $Magickbin $Cachedir/max.overlay.tif $Cachedir/min.overlay.tif -compose overlay -composite $Cachedir/overlay.overlay.tif
  showimage $Cachedir/overlay.overlay.tif
}

evaluate_split() {

  local Sourceimagelist Resultimage Mode
  local Startzeit Dauer Restzeit
  local Image Split Splitpercent Showsplit Part Partimage Partimagelist
  local Startzeit Dauer Restzeit Count
  
  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  while [ $# -gt 0 ]; do
    Sourceimagelist="$Sourceimagelist
${1:-}"
    shift
  done
  Sourceimagelist="$(tail -n+2 <<< "$Sourceimagelist")"
  
  Split="$((Imagelistmemsize/Freemem +1))"
  
  verbose "Generating $Mode image $(basename "$Resultimage") in $Split parts."
  case $Split in
    1) 
      Startzeit="$(date +%s)"
      $Magickbin $Sourceimagelist -evaluate-sequence $Mode $Tifstore $Resultimage || error "Error in evaluate_split / $Mode"
      Dauer="$(( $(date +%s)-Startzeit))"
      verbose "Duration: $(date -u -d @$Dauer +"%T")"
    ;;
    *)
      Startzeit="$(date +%s)"
      Splitpercent="$((100/Split))"
      Showsplit="$(printnum $(( (Split+1)/2 )) 3)"
      Count="0"
      for Sourceimage in $Sourceimagelist; do
        [ "$Error" ] && break
        Count="$((Count+1))"
        verbose "Splitting image $Count / $Imagenumber into $Split pieces due to low memory: $(basename $Sourceimage)"
        $Magickbin $Sourceimage -crop 100%x${Splitpercent}% $Tifstore $Cachedir/split%03d.$(basename $Sourceimage).tif || error "Error in evaluate_split / crop"
        showimage $Cachedir/split${Showsplit}.$(basename $Sourceimage).tif
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); eta: $(date -u -d @$Restzeit +"%T")"
      done
      Startzeit="$(date +%s)"
      for Part in $(seq 0 $((Split-1))) ; do
        [ "$Error" ] && break
        verbose "Evaluating part $((Part+1)) / $Split"
        Partimage=$Cachedir/$Mode.part$Part.tif
        $Magickbin $Cachedir/split$(printnum $Part 3).*.tif -evaluate-sequence $Mode $Tifstore $Partimage || error "Error in evaluate_split / evaluating parts"
        Partimagelist="$Partimagelist $Partimage"
        showimage $Partimage
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Split-Part+1) / (Part+1) ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); eta: $(date -u -d @$Restzeit +"%T")"
      done
      [ "$Error" ] && return 1
      $Magickbin $Partimagelist -append $Tifstore $Resultimage  || error "Error in evaluate_split / appending parts"
    ;;
  esac
  showimage $Resultimage
  return "${Error:-0}"
}

level_masks() {
  local Masklist Maskmax Maskmin
  local Startzeit Dauer Restzeit
  local Count Mask
  
  Masklist="$@"
  Maskmax=$Cachedir/level.mask.max.tif
  Maskmin=$Cachedir/level.mask.min.tif

  evaluate_split max $Maskmax $Masklist || return 1
  Contrastmaxlevel="$($Magickbin "$Maskmax" -format '%[fx:maxima*100]' info:)"
  evaluate_split min $Maskmin $Masklist || return 1
  Contrastminlevel="$($Magickbin "$Maskmin" -format '%[fx:minima*100]' info:)"
  
  Startzeit="$(date +%s)"
  Count=0
  for Mask in $Masklist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
            
    Command="
$Magickbin
  $Mask
    -level ${Contrastminlevel}%,${Contrastmaxlevel}%
  $Mask"
  
  [ "$Count" = "1" ] && verbose "Leveling masks with:
$(grep "\S" <<< "$Command")"
  
    $Command || error "Failure in leveling masks"
  
    showimage "$Mask"
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Leveling $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); eta: $(date -u -d @$Restzeit +"%T")"
  done
  [ "$Error" ] && return "${Error:-0}"
}

focus_maskmethod() {
  # Mask generating ImageMagick options
  # Most of them are based on edge detection: http://www.imagemagick.org/Usage/convolve/#edgedet
  local Method Sourceimage Radius1 Radius2 Sigma1 Sigma2 Maskgeneratorargument Diffstat1 Diffstat2
  local Maskgenerator
    
  Method="${1:-none}"
  Sourceimage="${2:-}"
  Radius1="${3:-}"
  Radius2="${4:-}"
  Sigma1="${5:-}"
  Sigma2="${6:-}"
  Maskgeneratorargument="${7:-}"
  Diffstat1="${8:-}"
  Diffstat2="${9:-}"
    
  case $Method in
    blur)
      # Compare two blurred images with different sigma.
      # Concept and result is similar to Difference of Gaussian (DoG). Using -gaussian-blur gives same as DoG.
      # Code based on https://im.snibgo.com/simpalign.htm#twoBlrDiff.bat
      Maskgenerator="
  ( $Sourceimage -blur ${Radius1:-0}x${Sigma1:-0.75} -write mpr:mask1 -delete 0 )"
      case "$Radius2$Sigma2" in
        "") 
          Maskgenerator="$Maskgenerator
  $Sourceimage mpr:mask1"
        ;;
        *) 
          Maskgenerator="$Maskgenerator
  ( $Sourceimage -blur ${Radius2:-0}x${Sigma2:-1.2} -write mpr:mask2 -delete 0 )
  mpr:mask1 mpr:mask2"
        ;;
      esac
      Maskgenerator="$Maskgenerator
    -compose Difference -composite"
# -compose Mathematics -define compose:args=0,-4,4,0.5 -composite
# -grayscale RMS"
    ;;
    comet) ### FIXME saturate drops some angles
      Maskgenerator="
    -define morphology:compose=${Maskgeneratorargument:-Lighten}
  $Sourceimage -morphology Convolve Comet:${Radius1:-0}x${Sigma1:-5}:>
  $Sourceimage
    -compose difference -composite"
    ;;
    compass)
      Maskgenerator="
  $Sourceimage
    -define convolve:scale=50%!
    -define morphology:compose=Lighten
    -define convolve:bias=50%
    -morphology Convolve Compass:>"
#-compose Difference -composite" # sort of interesting.
    ;;
    diffstat)
      Maskgenerator=""
      [ "$Diffstat1" = "source" ] && Maskgenerator="$Maskgenerator $Sourceimage" || Maskgenerator="$Maskgenerator
  ( $Sourceimage -statistic ${Diffstat1:-median} ${Radius1:-5} )"
      [ "$Diffstat2" = "source" ] && Maskgenerator="$Maskgenerator $Sourceimage" || Maskgenerator="$Maskgenerator
  ( $Sourceimage -statistic ${Diffstat2:-mean} ${Radius1:-5} )"
Maskgenerator="$Maskgenerator
    -compose Difference -composite"
      [ "$Radius2" ] && {
        Maskgenerator="$Maskgenerator
    -write mpr:mask1
    -delete 0"
        [ "$Diffstat1" = "source" ] && Maskgenerator="$Maskgenerator $Sourceimage" || Maskgenerator="$Maskgenerator
  ( $Sourceimage -statistic ${Diffstat1:-median} ${Radius2:-10} )"
        [ "$Diffstat2" = "source" ] && Maskgenerator="$Maskgenerator $Sourceimage" || Maskgenerator="$Maskgenerator
  ( $Sourceimage -statistic ${Diffstat2:-mean} ${Radius2:-10} )"
        Maskgenerator="$Maskgenerator
    -compose Difference -composite
    -write mpr:mask2
    -delete 0
  mpr:mask1 mpr:mask2
    -compose Difference -composite"
      }
    ;;
    GAUSSexperimental) 
      Maskgenerator="
  $Sourceimage
    -define convolve:scale=-100,200%
    -morphology Convolve Gaussian:${Radius1:-0}x${Sigma1:-0.75}
  $Sourceimage
    -compose Difference -composite"
    ;;
    CROSSMORPHexperimental)
      Maskgenerator="
  ( $Sourceimage -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:${Radius1:-3}x1+1+0 )
  ( $Sourceimage -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:${Radius1:-3}x1+${Radius1:-3}+0 )
  ( $Sourceimage -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:1x${Radius1:-3}+0+1 )
  ( $Sourceimage -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:1x${Radius1:-3}+0+${Radius1:-3} )
    -evaluate-sequence min"
    ;;
    CROSSMORPH2experimental)
      Maskgenerator="
  ( $Sourceimage -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:${Radius1}x$((Radius1/2))+0+$((Radius1/4)) )
  ( $Sourceimage -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:${Radius1}x$((Radius1/2))+$((Radius1-1))+$((Radius1/4)) )
  ( $Sourceimage -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:$((Radius1/2))x$((Radius1))+$((Radius1/4))+0 )
  ( $Sourceimage -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:$((Radius1/2))x$((Radius1))+$((Radius1/4))+$((Radius1-1)) )
    -evaluate-sequence min"
    ;;
    experimental)
      Maskgenerator="
  (
  $Sourceimage
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:1
  )
  (
  $Sourceimage
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:2
  )
    -compose Screen
    -composite"
    ;;
    free)
      Maskgenerator="$Sourceimage 
    $Maskgeneratorargument"
    ;;
    freichen)
      case $Maskgeneratorargument in
        "")
          Maskgenerator="
  (
  $Sourceimage
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:1>
  )
  (
  $Sourceimage
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:2>
  )
    -compose Screen
    -composite"
        ;;
        *)
          Maskgenerator="
  $Sourceimage
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=10%
    -morphology Convolve FreiChen:${Maskgeneratorargument:-0}>"
        ;;
      esac
    ;;
    gaussian) 
      case $Sigma2 in
        "")
          Maskgenerator="
  ( $Sourceimage -gaussian-blur ${Radius1:-0}x${Sigma1:-0.75} )
  $Sourceimage
    -compose Difference -composite"
        ;;
        *) # DoG: Difference of Gaussian
          Maskgenerator="
  $Sourceimage
    -define convolve:scale=100,100%
    -morphology Convolve DoG:${Radius1:-0},${Sigma1:-0.75},${Sigma2:-1.2}
  $Sourceimage
    -compose Difference -composite"
        ;;
      esac
    ;;
    kirsch)
      Maskgenerator="
  $Sourceimage
    -define convolve:scale=100%!
    -define morphology:compose=screen
    -define convolve:bias=15%
    -morphology Convolve Kirsch:>"
    ;;
    laplacian)
      Maskgenerator="
  $Sourceimage
    -define convolve:bias=5%
    -define convolve:scale=100%!
    -morphology Convolve Laplacian:${Maskgeneratorargument:-0}>"
    ;;
    log)  # LoG: Laplacian of Gaussian
      Maskgenerator="
  $Sourceimage
    -define convolve:scale=100,100%
    -morphology Convolve LoG:${Radius1:-0}x${Sigma1:-0.75}
  $Sourceimage
    -compose Difference -composite"
    ;;
    morphology)
      Maskgenerator="
  $Sourceimage
    -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Octagon:${Radius1:-2}"
    ;;
    none)
      Maskgenerator="$Sourceimage"
    ;;
    prewitt)
      Maskgenerator="
  $Sourceimage
    -define convolve:scale=100%!
    -define morphology:compose=screen
    -define convolve:bias=10%
    -morphology Convolve Prewitt:>"
    ;;
    roberts)
      Maskgenerator="
  $Sourceimage
    -define convolve:scale=100%
    -define morphology:compose=screen
    -define convolve:bias=10%
    -morphology Convolve Roberts:@"
    ;;
    sobel)
      Maskgenerator="
  $Sourceimage
    -define convolve:scale=100%!
    -define convolve:bias=10%
    -define morphology:compose=screen
    -morphology Convolve Sobel:>"
    ;;
    statistic)
      Maskgenerator="
  ( $Sourceimage -statistic $Maskgeneratorargument ${Radius1:-2}x${Radius1:-2} )"
        [ "$Radius2" ] && Maskgenerator="$Maskgenerator
  ( $Sourceimage -statistic $Maskgeneratorargument ${Radius2:-5}x${Radius2:-5} )
    -compose Difference -composite"
    ;;
    unsharp)
      Maskgenerator="
  ( $Sourceimage -unsharp ${Radius1:-0}x${Sigma1:-5} )
  $Sourceimage
    -compose Difference -composite"
    ;;
  esac
    
  grep . <<< "$Maskgenerator"
}
focus_generate_masks() {
  # Generate masks for focus image stackshot.
  
  local Command Imageproperties
  local Sourcemask Contrastmask Chromamask Saturationmask Darknessmask Lightnessmask Denoisemask Softmask
  local Count Number R1 R2 S1 S2 Masknumber
  local Denoise1image Denoise2image #Denoisediffimage
  local Startzeit Dauer Restzeit
    
  # --grayscale
  Maskgenerator="
  mpr:sourceimage"
  [ "$Grayscaleconverter" ] && Maskgenerator="$Maskgenerator
    $Grayscaleconverter"
  Maskgenerator="$Maskgenerator
    -write mpr:sourcegray
    -delete 0"
    
  # Generate mask generator command part. Regard multiple radii and sigma.
  Radius1="$(comma2whitespace "$Radius1")"
  Radius2="$(comma2whitespace "$Radius2")"
  Sigma1="$(comma2whitespace "$Sigma1")"
  Sigma2="$(comma2whitespace "$Sigma2")"
  Masknumber="0"
  for R1 in ${Radius1:-none}; do
    [ "$R1" = "none" ] && R1=""
    for R2 in ${Radius2:-none}; do
      [ "$R2" = "none" ] && R2=""
      [ "$R2" = "auto" ] && case $Method in
        statistic|diffstat)        R2="$((R1*3/2))" ;;
        morphology)                R2="2" ;;
        blur|gaussian|log|unsharp) R2="$R1" ;;
      esac
      for S1 in ${Sigma1:-none}; do
        [ "$S1" = "none" ] && S1=""
        for S2 in ${Sigma2:-none}; do
          [ "$S2" = "none" ] && S2=""
          [ "$S2" = "auto" ] && S2="$(awk "BEGIN {print $S1 * 1.6}")"
          Masknumber="$((Masknumber+1))"
          Maskgenerator="$Maskgenerator 
$(focus_maskmethod "$Method" "mpr:sourcegray" "$R1" "$R2" "$S1" "$S2" "$Maskgeneratorargument" "$Diffstat1" "$Diffstat2")
    -write mpr:contrastmask$Masknumber
    -delete 0"
        done
      done
    done
  done
  Maskgenerator="$Maskgenerator
  mpr:contrastmask1"
  [ "$Masknumber" -gt "1" ] && {
    Maskgenerator="$Maskgenerator 
    -evaluate Divide $Masknumber"
    for Count in $(seq 2 $Masknumber); do
      Maskgenerator="$Maskgenerator 
  ( mpr:contrastmask$Count -evaluate Divide $Masknumber ) -compose Screen -composite"
    done
  }
  
  # --diff
  [ "$Differencemask" = "yes" ] && Maskgenerator="$Maskgenerator
  mpr:sourceimage
    -compose Difference -composite"

  # --negate
  [ "$Negate" = "yes" ] && {
    Maskgenerator="$Maskgenerator
    -negate"
  }
      
  # --denoise
  [ "$Denoise" ] && {
    Denoise1image="$Cachedir/denoise_compare1.tif"
    Denoise2image="$Cachedir/denoise_compare2.tif"
    Denoisediffimage="$Cachedir/denoise_diff.mpc"
    evaluate_split max $Denoise1image $Sourceimagelist || error "--denoise: Failed to generate max image"
    evaluate_split min $Denoise2image $Sourceimagelist || error "--denoise: Failed to generate min image"
    $Magickbin \
      $Denoise1image $Denoise2image \
        -compose Difference -composite \
        -grayscale $Grayscale \
        -blur 0x5 \
        -auto-level \
      $Denoisediffimage || error "--denoise: Failed to generate mean/median difference image"
  }
     
  grep -q morphology <<< "$Maskgenerator" && verbose "Mask generator kernels:
$($Magickbin xc: -write mpr:sourceimage -define morphology:showkernel=1 $Maskgenerator null: 2>&1)
"      

  # Generate masks
  Startzeit="$(date +%s)"
  Count=0
  for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
        
    Sourcemask="$Cachedir/mask.${Number}.tif"
    Contrastmask="$Cachedir/contrast.${Number}.tif"
    Saturationmask="$Cachedir/saturation.${Number}.tif"
    Chromamask="$Cachedir/chroma.${Number}.tif"
    Darknessmask="$Cachedir/darkness.${Number}.tif"      
    Lightnessmask="$Cachedir/lightness.${Number}.tif"
    Denoisemask="$Cachedir/denoise.${Number}.tif"
    Softmask="$Cachedir/soft.${Number}.tif"
            
    Command="$Magickbin
  $Sourceimage
    -alpha off
    -depth 16
    -write mpr:sourceimage
    -delete 0"
    grep -q contrast <<< "$Needmask"  && Command="$Command
$Maskgenerator
    -alpha off
    -write mpr:sourcemask
    $Tifstore 
    -write $Contrastmask
    -delete 0"
    # --saturation-weight
    grep -q saturation <<< "$Needmask" && Command="$Command
  mpr:sourceimage
    -colorspace HSB -channel G -separate
    $Tifstore 
    -write mpr:saturation
    -write $Saturationmask
    -delete 0"
    # --chroma-weight
    grep -q chroma <<< "$Needmask"     && Command="$Command
  mpr:sourceimage
    -colorspace HCL -channel G -separate
    $Tifstore 
    -write mpr:chroma
    -write $Chromamask
    -delete 0"
    # --darkness-weight
    grep -q darkness <<< "$Needmask"   && Command="$Command
  mpr:sourceimage
    -colorspace LAB -channel R -separate
    -negate
    $Tifstore 
    -write mpr:darkness
    -write $Darknessmask
    -delete 0"
    # --lightness-weight
    grep -q lightness <<< "$Needmask"  && Command="$Command
  mpr:sourceimage
    -colorspace LAB -channel R -separate
    $Tifstore 
    -write mpr:lightness
    -write $Lightnessmask
    -delete 0"
    # --denoise
    [ "$Denoise" ]                     && Command="$Command
  $Cachedir/${Denoise}.${Number}.tif $Denoisediffimage 
    -compose multiply -composite
    -write $Denoisemask
    -delete 0"
    Command="$Command
  null:"
          
    [ "$Count" = "1" ] && verbose "Generating masks with:
$(grep "\S" <<< "$Command")"

    $Command || error "Failure in mask generation"
    
    #showimage $Testimage
    showimage "$Contrastmask"
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Contrast mask $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); eta: $(date -u -d @$Restzeit +"%T")"
  done
  
  
  # Level masks to full black-white spectrum
  grep -q contrast <<< "$Needmask"  && level_masks $Cachedir/contrast*
 # for Line in contrast saturation darkness lightness chroma ; do
 #   grep -q $Line <<< "$Needmask" && level_masks $Cachedir/$Line*
 # done
    
  # --soft-weight masks
  grep -q soft <<< "$Needmask"  && {
    focus_fuse_mode3
    cp $Resultimage $Softresult
      
    # Generate masks
    Startzeit="$(date +%s)"
    Count=0
    Masklist=""
    for Sourceimage in $Sourceimagelist; do
      [ "$Error" ] && break
      Count="$((Count+1))"
      Number="$(printnum $Count $Imagenumberlength)"
      Softmask="$Cachedir/soft.${Number}.tif"
      Masklist="$Masklist $Softmask"
        
      Command="$Magickbin
  ( $Sourceimage -grayscale $Grayscale -alpha off )
  ( $Softresult  -grayscale $Grayscale -alpha off )
    -compose Difference -composite
    -negate
  $Softmask"
         
       $Command || error "Failure in soft mask generation"
  
      [ "$Count" = "1" ] && verbose "Generating soft masks with:
$(grep "\S" <<< "$Command")"

      showimage $Softmask
      Dauer="$(( $(date +%s)-Startzeit))"
      Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
      verbose "Soft mask $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); eta: $(date -u -d @$Restzeit +"%T")"
    done
    #level_masks $Masklist
  }
  
  return "${Error:-0}"
}
focus_merge_masks() {
  # Merge different masks.
  
  local Sourcemask Contrastmask Chromamask Saturationmask Darknessmask Lightnessmask Denoisemask Softmask
  local Downweightoption 
  local Count Masknumber Number
  local Command
  local Startzeit Dauer Restzeit

  Masknumber="0"
  [ "$Contrastweight" != "0" ]   && Masknumber="$((Masknumber+1))"
  [ "$Saturationweight" != "0" ] && Masknumber="$((Masknumber+1))"
  [ "$Chromaweight" != "0" ]     && Masknumber="$((Masknumber+1))"
  [ "$Darknessweight" != "0" ]   && Masknumber="$((Masknumber+1))"
  [ "$Lightnessweight" != "0" ]  && Masknumber="$((Masknumber+1))"
  [ "$Softweight" != "0" ]       && Masknumber="$((Masknumber+1))"
  [ "$Denoiseweight" != "0" ]    && Masknumber="$((Masknumber+1))"
  
  #Meandiff=$Cachedir/mean.tif
  #evaluate_split mean $Meandiff $Sourceimagelist
  #Overlaydiff=$Cachedir/overlay.tif
  #Swapcompose="-swap 0,1"
  #compose_stack overlay $Overlaydiff $Sourceimagelist
  #Masknumber="$((Masknumber+1))"
  
  Startzeit="$(date +%s)"
  Count=0
  for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    
    Sourcemask="$Cachedir/sourcemask.${Number}.tif"
    Contrastmask="$Cachedir/contrast.${Number}.tif"
    Saturationmask="$Cachedir/saturation.${Number}.tif"
    Chromamask="$Cachedir/chroma.${Number}.tif"
    Darknessmask="$Cachedir/darkness.${Number}.tif"     
    Lightnessmask="$Cachedir/lightness.${Number}.tif"
    Denoisemask="$Cachedir/denoise.${Number}.tif"
    Softmask="$Cachedir/soft.${Number}.tif"
        
    # -downweight
    [ "${Downweight:-0}" -lt "0" ] && Downweightoption="+level 0,$(awk "BEGIN { print 100 - $Downweight*$Count/$Imagenumber }")%"
    [ "${Downweight:-0}" -gt "0" ] && Downweightoption="+level 0,$(awk "BEGIN { print 100 + $Downweight*$((Imagenumber-Count))/$Imagenumber }")%"
            
    Command="
$Magickbin"
    Command="$Command
  ( -size ${Imagewidth}x${Imageheight} xc:black )"
    [ "$Contrastweight" -gt "0" ] && Command="$Command
  ( $Contrastmask
    +level 0%,$((Contrastweight/Masknumber))% )
    -compose screen -composite"
    [ "$Contrastweight" -lt "0" ] && Command="$Command
  ( $Contrastmask
    -negate
    +level 0%,$((-1*Contrastweight/Masknumber))% )
    -compose screen -composite"
    # --saturation-weight
    [ "$Saturationweight" -gt "0" ] && Command="$Command
  ( $Saturationmask
    +level 0%,$((Saturationweight/Masknumber))% )
    -compose screen -composite"
    [ "$Saturationweight" -lt "0" ] && Command="$Command
  ( $Saturationmask
    -negate
    +level 0%,$((-1*Saturationweight/Masknumber))% ) 
    -compose screen -composite"
    # --chroma-weight
    [ "$Chromaweight" -gt "0" ]     && Command="$Command
  ( $Chromamask      
    +level 0%,$((Chromaweight/Masknumber))% )     
    -compose screen -composite"
    [ "$Chromaweight" -lt "0" ]     && Command="$Command
  ( $Chromamask
    -negate
    +level 0%,$((-1*Chromaweight/Masknumber))% )     
    -compose screen -composite"
    # --darkness-weight
    [ "$Darknessweight" -gt "0" ]   && Command="$Command
  ( $Darknessmask    
    +level 0%,$((Darknessweight/Masknumber))% )
    -compose screen -composite"
    [ "$Darknessweight" -lt "0" ]   && Command="$Command
  ( $Darknessmask
    -negate
    +level 0%,$((-1*Darknessweight/Masknumber))% )
    -compose screen -composite"
    # --lightness-weight
    [ "$Lightnessweight" -gt "0" ]  && Command="$Command
  ( $Lightnessmask
    +level 0%,$((Lightnessweight/Masknumber))% )
    -compose screen -composite"
    [ "$Lightnessweight" -lt "0" ]  && Command="$Command
  ( $Lightnessmask
    -negate
    +level 0%,$((-1*Lightnessweight/Masknumber))% )
    -compose screen -composite"
    # --denoise
    [ "$Denoiseweight" -gt "0" ]    && Command="$Command
  ( $Denoisemask
    +level 0%,$((Denoiseweight/Masknumber))% )
    -compose screen -composite"
    [ "$Denoiseweight" -lt "0" ]    && Command="$Command
  ( $Denoisemask
    -negate
    +level 0%,$((-1*Denoiseweight/Masknumber))% )
    -compose screen -composite"
    # --soft-weight
    [ "$Softweight" -gt "0" ]       && Command="$Command
  ( $Softmask
    +level 0%,$((Softweight/Masknumber))% )
    -compose screen -composite"
    [ "$Softweight" -lt "0" ]       && Command="$Command
  ( $Softmask
    -negate
    +level 0%,$((-1*Softweight/Masknumber))% )
    -compose screen -composite"
        
false && Command="$Command
  ( $Meandiff $Sourceimage -compose Difference -composite -grayscale RMS -negate +level 0%,$((50/Masknumber))% -write $Testimage ) -compose screen -composite"
false && Command="$Command
  ( $Overlaydiff $Sourceimage -compose Difference -composite -grayscale RMS -negate +level 0%,$((25/Masknumber))% -write $Testimage ) -compose screen -composite"
  
    Command="$Command
    -write mpr:sourcemask
    -delete 0"
    
    false && Command="$Command
      mpr:sourcemask
        +level 1%,99% 
        -write mpr:sourcemask
        -delete 0"
    
    # --threshold
    [ "$Threshold" ] && Command="$Command
  mpr:sourcemask
    -black-threshold ${Threshold:-0}%
    -write mpr:sourcemask
    -delete 0"
    # --downweight
    [ "${Downweight:-0}" != "0" ] && Command="$Command
  mpr:sourcemask
    $Downweightoption
    -write mpr:sourcemask
    -delete 0"
    Command="$Command
  mpr:sourcemask
    $Tifstore 
  $Sourcemask"
  
    [ "$Count" = "1" ] && verbose "Merging masks with:
$(grep "\S" <<< "$Command")"
   
    $Command || error "Error in merging masks: $Method"
      
    showimage "$Sourcemask"
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Merging $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); eta: $(date -u -d @$Restzeit +"%T")"
  done
  [ "$Error" ] && return "${Error:-0}"
  
  return ${Error:-0}
}
focus_fuse_mode1() {
  # --fusemode=1
  # Fuse images, hard contrast
  # Default fuse mode: Find sharpest area in source (brightest in maskmax). First source image wins if it shares same sharpness with later source images.

  local Sourcemask Maskmax
  local Count Number
  local Command
  local Startzeit Dauer Restzeit  
  
  # transparent base image to paint on
  mk_transparent ${Imagewidth}x${Imageheight} $Resultimage
 
  # max of masks to compare single masks
  Maskmax="$Cachedir/mask.max.tif"
  evaluate_split max $Maskmax $Cachedir/sourcemask* || return 1
  
  Startzeit="$(date +%s)"
  Count=0
  for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    Sourcemask="$Cachedir/sourcemask.${Number}.tif"
    
    # Load maskmax, sourcemask and sourceimage into memory. 
    Command="
$Magickbin
  $Maskmax
    -write mpr:maskmax
    -delete 0
  $Sourcemask
    -write mpr:sourcemask
    -delete 0
  $Sourceimage
    -write mpr:sourceimage
    -delete 0"
          
    # keep only parts of source mask that fit maskmax (greatest sharpness in stack)
    Command="$Command
  mpr:sourcemask 
  mpr:maskmax
    -compose MinusDst -composite
    -fill white +opaque black 
    -negate
    -write mpr:sourcepartmask
    -delete 0"
    
    # Soft mask edges
    [ "$Softcut" ] && Command="$Command
  ( mpr:sourcepartmask -blur 0x${Softcut} -auto-level )
  ( mpr:sourcepartmask -transparent black )
    -compose over -composite
    -write mpr:sourcepartmask
    -delete 0"
            
    # get part of source image
    Command="$Command
  mpr:sourceimage 
  mpr:sourcepartmask
    -alpha Off -compose CopyOpacity -composite
    -write mpr:sourcepart
    -delete 0"
    
    # add source image part to result
    Command="$Command
  $Resultimage 
  mpr:sourcepart
    -compose Over -composite
    -type TrueColorAlpha
    $Tifstore 
  $Resultimage"
          
    [ "$Count" = "1" ] && verbose "Fusing with:
$(grep "\S" <<< "$Command")"

    $Command || error "Error in fuse mode 1"
            
    #showimage $Testimage
    showimage $Resultimage
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Fusing $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); eta: $(date -u -d @$Restzeit +"%T")"
  done
       
  return "${Error:-0}"
}
focus_fuse_mode2() {
  # --fusemode=2: Compare on each step if source or result seem to be more sharp
  # Based on snibgo's focus stacking script at http://im.snibgo.com/focstack.htm

  local Sourcemask
  local Count Number
  local Command
  local Startzeit Dauer Restzeit
  
  cp "$(head -n1 <<< "$Sourceimagelist")" "$Resultimage" || error "Failed to copy first source image"
  
  Startzeit="$(date +%s)"
  Count=0
  for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    Sourcemask="$Cachedir/sourcemask.${Number}.tif"
    
    Command="
$Magickbin
  $Resultimage
    -write mpr:sourceimage
    -write mpr:resultimage
    -delete 0
$Maskgenerator
    -level ${Contrastminlevel}%,${Contrastmaxlevel}%
    -write mpr:resultmask
    -delete 0
  mpr:resultmask
  $Sourcemask
    -compose MinusDst -composite -fill white +opaque black
    -write mpr:diffmask
    -delete 0
  mpr:resultimage
  $Sourceimage
  mpr:diffmask
    -alpha off -compose Over -composite
    $Tifstore
  $Resultimage"
          
    [ "$Count" = "1" ] && verbose "Fusing with:
$(grep "\S" <<< "$Command")"
            
    $Command || error "Error in fuse mode 2"

    #showimage $Testimage
    showimage $Resultimage
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Fusing $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); eta: $(date -u -d @$Restzeit +"%T")"
  done
  
  return ${Error:-0}
}
focus_fuse_mode3() {
  # Soft focus stacking with semi-transparent layers
  # --fusemode=3

  local Resulttop Resultbottom Maskmax
  local Count Number
  local Command
  local Startzeit Dauer Restzeit
  
  Resulttop="$Cachedir/resulttop.tif"
  Resultbottom="$Cachedir/resultbottom.tif"
  Maskmax="$Cachedir/mask.max.tif"
  $Magickbin -size ${Imagewidth}x${Imageheight} xc:black -type Grayscale $Tifstore $Maskmax
  mk_transparent ${Imagewidth}x${Imageheight} $Resulttop
  mk_transparent ${Imagewidth}x${Imageheight} $Resultbottom
  mk_transparent ${Imagewidth}x${Imageheight} $Resultimage
  
  Startzeit="$(date +%s)"
  Count=0    
  for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    Sourcemask="$Cachedir/sourcemask.${Number}.tif"
    [ -e "$Sourcemask" ] || Sourcemask="$Cachedir/contrast.${Number}.tif"
    
    Command="
$Magickbin
  $Sourceimage
    -alpha off
    -write mpr:sourceimage
    -delete 0
  $Sourcemask
    -alpha off
    -write mpr:sourcemask
    -delete 0
  $Maskmax
    -alpha off
    -write mpr:maskmax
    -delete 0
  $Resulttop
    -alpha set
    -write mpr:resultimagetop
    -delete 0
  $Resultbottom
    -alpha set
    -write mpr:resultimagebottom
    -delete 0
  mpr:sourcemask 
  mpr:maskmax 
    -compose Lighten -composite
    -write mpr:maskmax
    -write $Maskmax
    -delete 0
  mpr:sourcemask 
  mpr:maskmax
    -compose MinusDst -composite -fill white +opaque black -negate
    -transparent white
    -write mpr:cutmask
    -delete 0
  mpr:sourcemask 
  mpr:cutmask
    -compose Over -composite
    -write mpr:sourcemaskpart
    -delete 0
  mpr:sourceimage 
  mpr:sourcemaskpart
    -alpha off -compose CopyOpacity -composite
    -write mpr:semitransparent
    -alpha off
    -delete 0
  mpr:resultimagetop
  mpr:semitransparent
    -compose Over -composite
    -type TrueColorAlpha
    -write mpr:resultimagetop
    -write $Resulttop
    -delete 0
  mpr:sourcemask 
  ( mpr:cutmask -negate )
    -compose Over -composite
    -write mpr:sourcemaskpart
    -delete 0
  mpr:sourceimage 
  mpr:sourcemaskpart
    -alpha off -compose CopyOpacity -composite
    -write mpr:semitransparent
    -delete 0
  mpr:resultimagebottom 
  mpr:semitransparent
    -compose Over -composite
    -type TrueColorAlpha
    -write mpr:resultimagebottom
    -write $Resultbottom
    -delete 0
  null:"
#  mpr:resultimagebottom
#  mpr:resultimagetop
#    -compose Over -composite
#    -type TrueColorAlpha
#  $Resultimage"


#  mpr:sourcemask 
#  mpr:maskmax 
#    -evaluate-sequence max
#    -write mpr:maskmax
#    -write $Maskmax
#    -delete 0
          
    [ "$Count" = "1" ] && verbose "Fusing with:
$(grep "\S" <<< "$Command")"

    $Command || error "Error in fuse mode 3"
    
    #showimage $Testimage
    showimage $Resulttop
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "soft stack $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); eta: $(date -u -d @$Restzeit +"%T")"
  done
  
  [ "$Error" ] && return $Error

  $Magickbin \
    $Resultbottom \
    $Resulttop \
      -compose Over -composite \
      -alpha off \
      -type TrueColor \
    $Resultimage || error "Failed to compose top and bottom of soft image"
  
  return "${Error:-0}"
}
focus_sharpness_layer() {
  # --layers: Layered TIF with sharpness layers
  local Graylevel Graylevel1 Graylevel2 Pixelnumber Pixelcount Image Layerimage Layerimagelist Layerminpixel Graylevels Histogramm
  local Layercount Count
  local Startzeit Dauer Restzeit
  local Maskmax
  
  Maskmax="$Cachedir/mask.max.tif"
  evaluate_split max $Maskmax $Cachedir/sourcemask*
  Histogramm="$($Magickbin $Maskmax -depth 16 -define histogram:unique-colors=true -format %c histogram:info:-)"
  Graylevels="$(awk '{print $3}' <<< "$Histogramm" | wc -l)"
  Layerminpixel="$(( Imagewidth*Imageheight/(Layernumber-1) ))"
  
  verbose "Creating $Layernumber layers of sharpness areas"
  
  Count=0
  Layercount=0
  Startzeit="$(date +%s)"
  Pixelcount=0
  Pixelnumber=0
  while read Line; do
    [ "$Error" ] && break
    Count=$((Count+1))
    
    Graylevel="$(awk '{print $3}' <<< "$Line")"
    Pixelnumber="$(awk '{print $1}' <<< "$Line")"
    Pixelnumber="${Pixelnumber%:}"
    Pixelcount="$((Pixelcount+Pixelnumber))"
    
    [ "$Pixelcount" -lt "$Layerminpixel" ] && {
      Graylevel1="${Graylevel1:-$Graylevel}"
    }
    
    { [ "$Pixelcount" -gt "$Layerminpixel" ] || [ "$Count" = "$Graylevels" ] ; } && {
      Layercount="$((Layercount+1))"
      Layerimage="$Cachedir/layer_sharpness.$(printnum $Layercount).tif"
      Graylevel2="${Graylevel2:-$Graylevel}"
      Command="
$Magickbin
  $Maskmax
    -depth 16
    -color-threshold "${Graylevel1:-$Graylevel2}"-"$Graylevel"
    -write mpr:layermask
    -delete 0
  $Resultimage
  mpr:layermask
    -colorspace sRGB
    -alpha Off -compose CopyOpacity -composite
    -background blue -alpha background
    $Tifstore
  $Layerimage"
  
      $Command || {
        note "Error in generating sharpness layers"
        break
      }
      
      Layerimagelist="$Layerimagelist $Layerimage"
      
      [ "$Graylevel2" = "$Graylevel" ] && {
        Graylevel1=""
        Pixelcount="0"
      } || {
        Graylevel1="$Graylevel"
        Pixelcount="$Pixelnumber"
      }
      
      showimage $Layerimage
      Dauer="$(( $(date +%s)-Startzeit))"
      Restzeit="$(( Dauer*(Graylevels-Count) / Count ))"
      verbose "Layer $Layercount/$Layernumber. Duration: $(date -u -d @$Dauer +"%T"); eta: $(date -u -d @$Restzeit +"%T")"
    }
    Graylevel2="$Graylevel"
  done <<< "$Histogramm"
    
  [ "$Error" ] && return $Error
  
  verbose "Creating layered result of sharpness areas"
  Image="$(rev <<< "$Outputimage" | cut -d. -f2- | rev).layered_sharpness.tif"
  $Magickbin -type TrueColorAlpha $Maskmax $Layerimagelist $Tifstore "$Image" || note "Failed to create layered sharpness result image."
  
  return "${Error:-0}"
}
mk_transparent() {
  $Magickbin -size ${1:-100x100} xc:blue -transparent blue -type TrueColorAlpha $Tifstore ${2:-transparent.tif} || error "Failed to create transparent image."
}
### main

declare_variables() {
  Basename=""
  Lightnessweight=""
  Cachedir=""
  Composefactor=""
  Compress=""
  Contrastmaxlevel=""
  Contrastminlevel=""
  Contrastweight=""
  Darknessweight=""
  Denoise=""
  Denoiseindex=""
  Denoiseweight=""
  Differencemask=""
  Diffstat1=""
  Diffstat2=""
  Downweight=""
  Error=""
  Freemem=""
  Fusemode=""
  Gamma=""
  Grayscale=""
  Grayscaleconverter=""
  Grayscalenumber=""
  Image=""
  Imageformat="tif"
  Imageheight=""
  Imagelistmemsize=""
  Imagememsize=""
  Imagenumber=""
  Imagewidth=""
  Chromaweight=""
  Layernumber=""
  Layerminpixel=""
  Layers=""
  Loadmaskfile=""
  Magickbin=""
  Magickpixelmemory=""
  Magickversion=""
  Maskgenerator=""
  Maskgeneratorargument=""
  Method=""
  Mode=""
  Needmask=""
  Negate="no"
  Outputimage=""
  Preservecache="no"
  Revertimagelist="no"
  Saturationweight=""
  Showimageprocessing="no"
  Softcut=""
  Softresult=""
  Softweight=""
  Sourceimage=""
  Sourceimagelist=""
  Startzeit="$(date +%s)"
  Storelayers=""
  Stripmask="no"
  Swapcompose=""
  Testimage=""
  Threshold=
  Tifstore="+repage -quality 100% -compress lzw"
  Radius1=""
  Radius2=""
  Sigma1=""
  Sigma2=""
  Verbose="no"
  return 0
}
parse_options() {
  local Shortoptions Longoptions Parsedoptions Parsererror Parsererrorfile
  
  Shortoptions="d::,f:g::hn::o:r:R::s:S::t::vV"
  Longoptions="basename::,cachedir:,help,verbose,version,output:,showimage"
  Longoptions="$Longoptions,chroma-weight::,darkness-weight::,denoise-weight::,lightness-weight::,contrast-weight::,saturation-weight::,soft-weight::"
  Longoptions="$Longoptions,denoise::,diff::,downweight::,factor::,fusemode:,grayscale:,gamma::,layers::,negate,radius:,radius1::,radius2::,revert,sigma:,sigma1:,sigma2::,cutsoft::,swap,threshold::"
  Longoptions="$Longoptions,blur::,comet::,compass::,compose::,diffstat::,gaussian::,evaluate::,experimental::,free::,freichen::,kirsch::,laplacian::,log::,morphology::,none::,prewitt::,roberts::,sobel::,statistic::,unsharp::"  

  Parsererrorfile="/tmp/imfuse.parserserror.$RANDOM"
  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@" 2>"$Parsererrorfile")"
  [ -e $Parsererrorfile ] && Parsererror="$(cat "$Parsererrorfile")" && rm "$Parsererrorfile"
  [ "$Parsererror" ] && error "$Parsererror"
  eval set -- "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    [ "$Error" ] && break
    case "${1:-}" in
      -h|--help)              usage ; exit 0 ;;
         --basename)          Basename="${2:-auto}" ; shift ;;
         --lightness-weight)  Lightnessweight="${2:-auto}" ; shift ;;
         --cachedir)          Cachedir="${2:-}" ; Preservecache="yes" ; shift ;;
         --contrast-weight)   Contrastweight="${2:-auto}" ; shift ;;
         --darkness-weight)   Darknessweight="${2:-auto}" ; shift ;;
      -d|--denoise)           Denoise="${2:-auto}" ; shift ;;
         --denoise-weight)    Denoiseweight="${2:-auto}" ; shift ;;
         --diff)              Differencemask="${2:-yes}" ; shift ;;
         --downweight)        Downweight="${2:-auto}" ; shift ;;
         --factor)            Composefactor="${2:-auto}" ; shift ;;
      -f|--fusemode)          Fusemode="${2:-auto}" ; shift ;;
      -g|--gamma)             Gamma="${2:-auto}" ; shift ;;
         --grayscale)         Grayscale="${2:-auto}" ; shift ;;
         --chroma-weight)     Chromaweight="${2:-auto}" ; shift ;;
         --layers)            Storelayers="yes" ; Layernumber="${2:-auto}" ; shift ;;
         --negate)            Negate="yes" ;;
      -o|--output)            Outputimage="${2:-}" ; shift ;;
      -r|--radius|--radius1)  Radius1="${2:-}" ; shift ;;
      -R|--radius2)           Radius2="${2:-auto}" ; shift ;;
         --revert)            Revertimagelist="yes" ;;
         --saturation-weight) Saturationweight="${2:-auto}" ; shift ;;
      -s|--sigma|--sigma1)    Sigma1="${2:-}" ; shift ;;
      -S|--sigma2)            Sigma2="${2:-auto}" ; shift ;;
         --cutsoft)           Softcut="${2:-auto}" ; shift ;;
         --soft-weight)       Softweight="${2:-auto}" ; shift ;;
         --swap)              Swapcompose="-swap 0,1" ;;
      -t|--threshold)         Threshold="${2:-auto}" ; shift ;;
      -v|--verbose)           Verbose="yes" ;;
         --version)           echo "imfuse v$Version"; exit 0 ;;
      -V|--showimage)         Showimageprocessing="yes" ;;
         --blur|--comet|--compass|--compose|--diffstat|--gaussian|--evaluate|--experimental|--free|--freichen|--kirsch|--laplacian|--log|--morphology|--none|--prewitt|--roberts|--sobel|--statistic|--unsharp)
        Method="${1#--}"
        Maskgeneratorargument="${2:-}"  && shift
      ;;  
      --) ;;
      *)
        Sourceimagelist="$Sourceimagelist
$(realpath "${1:-}")" 
        [ -f "${1:-}" ] || error "File not found: ${1:-}"
      ;;
    esac
    shift
  done
  return ${Error:-0}
}
check_options() {
  
  # --fusemode
  case $Method in
    evaluate|compose) 
      [ "$Fusemode" ] && error "--fusemode has no effect with --$Method" ;;
    *)
      case $Fusemode in
        ""|"auto") 
          Fusemode="1" 
        ;;
        1|2|3) ;;
        4) 
          [ -z "${Method}${Radius1}" ] && {
            Method="statistic"
            Maskgeneratorargument="standarddeviation"
            Radius1="10"
            note "--fusemode=$Fusemode: Setting --$Method=$Maskgeneratorargument --radius1=$Radius1"
          } || {
            note "--fusemode=$Fusemode needs manual setting of parameters
  like --radius and --sigma.
  Default values are often less useable and optimized for --fusemode=1, 2 and 3."
          }
        ;;
        *) error "--fusemode: Unknown mode $Fusemode" ;;
      esac
    ;;
  esac
  
  # Method
  case $Method in
    "")
      Method="diffstat"
      note "Setting --$Method"
    ;;
  esac  
  
  # Method argument
  case $Method in
    comet)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="Lighten"
        note "Setting --$Method=$Maskgeneratorargument"
      }
      grep -q -x -i "$Maskgeneratorargument" <<< "$($Magickbin -list compose)" || {
        error "--$Method=$Maskgeneratorargument: unknown argument.
  Please choose one out of '$Magickbin -list compose'
  Recommended: Darken, Lighten"
      }
      Maskgeneratorargument="$(lowercase "$Maskgeneratorargument")"
    ;;
    compose)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="overlay"
        note "Setting --$Method=$Maskgeneratorargument"
      }
      grep -q -x -i "$Maskgeneratorargument" <<< "$($Magickbin -list compose)" || {
        error "--$Method=$Maskgeneratorargument: unknown argument.
  Please choose one out of '$Magickbin -list compose'
  or compare IM option -compose."
      }
      Maskgeneratorargument="$(lowercase "$Maskgeneratorargument")"
    ;;
    diffstat)
      Diffstat1="$(cut -d, -f1    <<< "$Maskgeneratorargument")"
      Diffstat2="$(cut -d, -f2 -s <<< "$Maskgeneratorargument")"
      case ${Diffstat1,,} in
        ""|auto)                Diffstat1="median" ;;
        0|source|none)          Diffstat1="source" ;;
        1|gradient|grad)        Diffstat1="gradient" ;;
        2|maximum|max)          Diffstat1="maximum" ;;
        3|mean)                 Diffstat1="mean" ;;
        4|median)               Diffstat1="median" ;;
        5|minimum|min)          Diffstat1="minimum" ;;
        6|mode)                 Diffstat1="mode" ;;
        7|nonpeak)              Diffstat1="nonpeak" ;;
        8|9|rms|rootmeansquare) Diffstat1="rms" ;;
        10|standarddeviation|standard_deviation|standard-deviation|dev) 
                                Diffstat1="standarddeviation" ;;
        *) error "--diffstat: Unknown STAT $Diffstat1" ;;
      esac
      case ${Diffstat2,,} in
        ""|auto)                Diffstat2="mean" ;;
        1|gradient|grad)        Diffstat2="gradient" ;;
        2|maximum|max)          Diffstat2="maximum" ;;
        3|mean)                 Diffstat2="mean" ;;
        4|median)               Diffstat2="median" ;;
        5|minimum|min)          Diffstat2="minimum" ;;
        6|mode)                 Diffstat2="mode" ;;
        7|nonpeak)              Diffstat2="nonpeak" ;;
        8|9|rms|rootmeansquare) Diffstat2="rms" ;;
        10|standarddeviation|standard_deviation|standard-deviation|dev)
                                Diffstat2="standarddeviation" ;;
        *) error "--diffstat: Unknown STAT $Diffstat2" ;;
      esac
      [ "$Diffstat1" = "$Diffstat2" ] && note "--diffstat: Method 1 und 2 are the same: $Diffstat1
  This is likely not what you want."
      Maskgeneratorargument="${Diffstat1},${Diffstat2}"
    ;;
    evaluate)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="max"
        note "Setting --$Method=$Maskgeneratorargument"
      }
      grep -q -x -i "$Maskgeneratorargument" <<< "$($Magickbin -list evaluate)" || {
        error "--$Method=$Maskgeneratorargument: unknown argument.
  Please choose one out of '$Magickbin -list evaluate'
  or compare IM option -evaluate-sequence."
      }
      Maskgeneratorargument="$(lowercase "$Maskgeneratorargument")"
    ;;
    experimental) ;;
    freichen) ;;
    laplacian|freichen)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="0"
        note "Setting --$Method=$Maskgeneratorargument"
      }
    ;;
    free)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="-sharpen 0x3"
        note "Setting --$Method='$Maskgeneratorargument'"
      }
    ;;
    morphology)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="edge"
        note "Setting --$Method=$Maskgeneratorargument"
      }
      grep -q -x -i "$Maskgeneratorargument" <<< "$($Magickbin -list morphology)" || {
        error "--$Method=$Maskgeneratorargument: unknown argument.
  Please choose one out of '$Magickbin -list morphology'
  or compare IM option -morphology."
      }
      Maskgeneratorargument="$(lowercase "$Maskgeneratorargument")"
    
    ;;
    statistic)
      case $Maskgeneratorargument in
        ""|auto)                Maskgeneratorargument="standarddeviation" 
          note "Setting --$Method=$Maskgeneratorargument" ;;
        1|gradient|grad)        Maskgeneratorargument="gradient" ;;
        2|maximum|max)          Maskgeneratorargument="maximum" ;;
        3|mean)                 Maskgeneratorargument="mean" ;;
        4|median)               Maskgeneratorargument="median" ;;
        5|minimum|min)          Maskgeneratorargument="minimum" ;;
        6|mode)                 Maskgeneratorargument="mode" ;;
        7|nonpeak)              Maskgeneratorargument="nonpeak" ;;
        8|9|rms|rootmeansquare) Maskgeneratorargument="rms" ;;
        10|standarddeviation|standard_deviation|standard-deviation|dev) 
                                Maskgeneratorargument="standarddeviation" ;;
        *) error "--statistic: Unknown STAT $Maskgeneratorargument" ;;
      esac
    ;;
    *) [ -n "$Maskgeneratorargument" ] && error "Arguments not used in --$Method=$Maskgeneratorargument" ;;
  esac
  
  
  # --denoise
  [ "${Denoise}${Denoiseweight}" ] && {
    [ -z "${Denoise}" ]     && Denoise="auto"
    [ -z "$Denoiseweight" ] && Denoiseweight="auto"
    case $Method in
      evaluate|compose) [ "$Denoise" ] && error "--denoise has no effect with --$Method" ;;
      *)
        case $Denoise in
          "") ;;
          auto) Denoise="saturation" ;;
          1|2|3|4|5|chroma|darkness|lightness|saturation|soft) ;;
          *) error "--denoise: Unknown argument $Denoise"
        esac
        case $Denoise in
          1|chroma)     Denoiseindex=1 ; Denoise="chroma" ;;
          2|darkness)   Denoiseindex=2 ; Denoise="darkness" ;;
          3|lightness)  Denoiseindex=3 ; Denoise="lightness" ;;
          4|saturation) Denoiseindex=4 ; Denoise="saturation" ;;
          5|soft)       Denoiseindex=5 ; Denoise="soft" ;;
        esac
      ;;
    esac
    Needmask="$Needmask $Denoise"
  }
  
  # --diff
  case $Differencemask in
    "") ;;
    1|yes) Differencemask="yes" 
    ;;
    0|no)  Differencemask="no" ;;
    *) error "--diff: Unknown argument: $Differencemask" ;;
  esac
  case $Differencemask in
    "") 
      case $Method in
        free) Differencemask="yes" ;;
        morphology)
          case $Maskgeneratorargument in
            edge|edgein|edgeout|tophat|bottomhat) ;;
            *) 
              Differencemask="yes" 
              note "Setting --diff=$Differencemask"
            ;;
          esac
        ;;
        statistic)
          case $Maskgeneratorargument in
            gradient|standarddeviation) ;;
            *) 
              [ -z "$Radius2" ] && {
                Differencemask="yes" 
                note "Setting --diff=$Differencemask"
              }
            ;;
          esac
      esac
    ;;
    *)
      case $Method in
        experimental|free|morphology|statistic) ;;
        *) error "--diff: Not supported by --$Method yet." ;;
      esac
    ;;
  esac
  
  # --downweight
  case $Method in
    evaluate|compose) [ "$Downweight" ] && error "--downweight has no effect with --$Method" ;;
    *)
      case $Downweight in
        "")   ;;
        auto) Downweight="50" ;;
        *)    Downweight="$(sed s/%// <<< "$Downweight")" ;;
      esac
    ;;
  esac
  
  # --factor
  [ "$Composefactor" = "auto" ] && {
    case $Method in
      compose)
        case $Maskgeneratorargument in
          blend|colordodge|lighten*|lineardodge|plus|screen) 
            Composefactor="0.5" ;;
          bumpmap|colorburn|colordodge|darken*|linearburn|multiply) 
            Composefactor="2" ;;
          overlay|pegtoplight|pinlight|softburn|softlight)
            Composefactor="1" ;;
          difference|hardlight|linearlight|freeze|reflect|stamp|vividlight)
            Composefactor="1" ;;
          colorize|displace|distort|divide*|exclusion|hardmix|interpolate|minus*|modul*|negate|saturate|softdodge) 
            Composefactor="1" ;;
          atop|blur|changemask|clear|copy*|darken|darkenintensity|dissolve|dst*|hue|in|intensity|mathematics|none|out|over|replace|src*|stereo|xor)
            Composefactor="1" ;;
          *) 
            Composefactor="1" ;;
        esac
      ;;
      *) Composefactor=1 ;;
    esac
    note "Setting --factor=$Composefactor"
  }
    
  # --grayscale
  case $Method in
    evaluate|compose) [ "$Grayscale" ] && error "--grayscale has no effect with --$Method" ;;
    *)
      case ${Grayscale,,} in
        ""|auto)           Grayscale="RMS" ;;
      esac
      case ${Grayscale,,} in
        0|none)            Grayscalenumber=0 ; Grayscale="none" ;;
        1|rec601luma)      Grayscalenumber=1 ; Grayscale="Rec601Luma" ;;
        2|rec601luminance) Grayscalenumber=2 ; Grayscale="Rec601Luminance" ;;
        3|rec709luma)      Grayscalenumber=3 ; Grayscale="Rec709Luma" ;;
        4|rec709luminance) Grayscalenumber=4 ; Grayscale="Rec709Luminance" ;;
        5|brightness)      Grayscalenumber=5 ; Grayscale="Brightness" ;;
        6|lightness)       Grayscalenumber=6 ; Grayscale="Lightness" ;;
        7|average)         Grayscalenumber=7 ; Grayscale="Average" ;;
        8|ms)              Grayscalenumber=8 ; Grayscale="MS" ;;
        9|rms)             Grayscalenumber=9 ; Grayscale="RMS" ;;
        *)
          error "--grayscale: Unknown argument: $Grayscale"
        ;;
      esac
      case $Grayscale in
        ""|none) Grayscaleconverter="" ;;
        *)       Grayscaleconverter="-grayscale $Grayscale" ;;
      esac
    ;;
  esac
  
  # --layers
  case $Method in
    evaluate|compose) [ "$Layernumber" ] && error "--layers has no effect with --$Method" ;;
    *)
      case $Layernumber in
        auto) Layernumber="24" ;;
      esac
    ;;
  esac
  
  [ "${Radius1}${Radius2}${Sigma1}${Sigma2}" ] && case $Method in
    evaluate|compose) error "Options --radius, --radius2, --sigma, --sigma2
  have no effect for method --${Method}." ;;
  esac
  
  # --radius1
  [ -z "$Radius1" ] && case $Method in
    blur|comet|gaussian|log|unsharp)
      Radius1="0"
    ;;
    morphology|statistic)
      Radius1="2"
      note "Setting --radius=$Radius1"
    ;;
    diffstat)
      Radius1="5"
      note "Setting --radius=$Radius1"
    ;;
  esac
  
  # --radius2
  [ "$Radius2" ] && case $Method in
    morphology) ;;
    compose|evaluate|freichen|kirsch|laplacian|prewitt|roberts|sobel)
      error "--radius2 is not supported by --$Method"
    ;;
  esac
  
  # --sigma1
  case $Method in
    comet)
      [ -z "$Sigma1" ] && {
        Sigma1="5"
        note "Setting --sigma=$Sigma1"
      }
    ;;
    experimental) ;;
    blur|gaussian|log)
      [ -z "$Sigma1" ] && {
        Sigma1="0.75"
        note "Setting --sigma=$Sigma1"
      }
    ;;
    unsharp)
      [ -z "$Sigma1" ] && {
        Sigma1="2"
        note "Setting --sigma=$Sigma1"
      }
    ;;
    *)
      [ -n "$Sigma1" ] && error "Not used with --method=$Method: --sigma=$Sigma1"
    ;;
  esac
  
  # --sigma2
  case $Method in
    experimental|blur|gaussian|log|unsharp) ;;
    *)
      [ -n "$Sigma2" ] && {
        error "Not used with --method=$Method: --sigma2=$Sigma2"
      }
    ;;
  esac
  
  # --cutsoft
  case $Method in
    evaluate|compose) 
      [ "$Softcut" ] && error "--cutsoft has no effect with --$Method"
    ;;
    *)
      case $Softcut in
        "") ;;
        auto)
          Softcut="2"
          note "Setting --cutsoft=$Softcut"
        ;;
        *) Softcut="$(sed s/%// <<< "$Softcut")" ;;
      esac
    ;;
  esac
  
  # --threshold
  [ "$Threshold" ] && case $Method in
    evaluate|compose) 
      error "--threshold has no effect with --$Method"
    ;;
    *)
      case $Threshold in
        "") ;;
        auto)
          Threshold="5"
          note "Setting --threshold=$Threshold"
        ;;
        *) Threshold="$(sed s/%// <<< "$Threshold")" ;;
      esac
    ;;
  esac

  # --contrast-weight --saturation-weight --chroma-weight --lightness-weight --darkness-weight --soft-weight --denoise-weight
  case $Method in
    compose|evaluate) [ "${Softweight}${Darknessweight}${Lightnessweight}${Contrastweight}${Saturationweight}${Chromaweight}${Denoiseweight}" ] && error "--$Method does not support options
  --contrast-weight --saturation-weight --chroma-weight 
  --darkness-weight --lightness-weight  --denoise-weight
  --soft-weight" ;;
    *)
      Contrastweight="$(sed   s/%// <<< "$Contrastweight")"
      Softweight="$(sed       s/%// <<< "$Softweight")"
      Saturationweight="$(sed s/%// <<< "$Saturationweight")"
      Chromaweight="$(sed     s/%// <<< "$Chromaweight")"
      Darknessweight="$(sed   s/%// <<< "$Darknessweight")"
      Lightnessweight="$(sed  s/%// <<< "$Lightnessweight")"
      Denoiseweight="$(sed    s/%// <<< "$Denoiseweight")"
      case $Contrastweight in
        ""|auto) Contrastweight="100" ;;
      esac
      case $Softweight in
        "")   Softweight="0" ;;
        auto) Softweight="50" ;;
      esac
      case $Saturationweight in
        "")   Saturationweight="0" ;;
        auto) Saturationweight="15" ;;
      esac
      case $Chromaweight in
        "")   Chromaweight="0" ;;
        auto) Chromaweight="15" ;;
      esac
      case $Darknessweight in
        "")   Darknessweight="0" ;;
        auto) Darknessweight="15" ;;
      esac
      case $Lightnessweight in
        "")   Lightnessweight="0" ;;
        auto) Lightnessweight="15" ;;
      esac
      case $Denoiseweight in
        "")   Denoiseweight="0" ;;
        auto) Denoiseweight="25" ;;
      esac
      #[ "$Contrastweight" = "0" ] && [ "$Softweight" = "0" ] && Method="none"
    ;;
  esac
  [ "$Contrastweight" != "0" ]   && Needmask="$Needmask contrast"
  [ "$Softweight" != "0" ]       && Needmask="$Needmask contrast soft"
  [ "$Saturationweight" != "0" ] && Needmask="$Needmask saturation"
  [ "$Chromaweight" != "0" ]     && Needmask="$Needmask chroma"
  [ "$Darknessweight" != "0" ]   && Needmask="$Needmask darkness"
  [ "$Lightnessweight" != "0" ]  && Needmask="$Needmask lightness"

  # --cachedir
  [ -z "$Cachedir" ] && Cachedir="$(pwd)/cache.imfuse.$RANDOM"
  Cachedir="$(sed s%'~'%$HOME% <<< "$Cachedir")"
  Cachedir="$(realpath -m "$Cachedir")"
  
  #### Files ####
  
  [ -z "$Sourceimagelist" ] && error "No images specified"
  Sourceimagelist="$(grep .     <<< "$Sourceimagelist")"
  Sourceimagelist="$(sort -V -r <<< "$Sourceimagelist")"
  
  # --revert
  [ "$Revertimagelist" = "yes" ] && Sourceimagelist="$(tac <<< "$Sourceimagelist")"
  
  # --basename
  case $Basename in
    "")   Basename="imfuse" ;;
    auto) Basename="$(basename "$(pwd)")" ;;
  esac
  [ "$Basename" != "$(unspecialstring "$Basename")" ] && error "--basename: Name must not contain special chars or whitespace: '$Basename'"
  
  # --output
    Resultimage="$Basename"
    case $Method in
      blur|gaussian|log|unsharp)              Resultimage="$Resultimage.${Method}.${Radius1}x${Sigma1}"
        [ "$Radius2$Sigma2" ] &&              Resultimage="${Resultimage}-${Radius2:-$Radius1}x${Sigma2:-$Sigma2}" ;;
      comet)                                  Resultimage="$Resultimage.${Method}.${Maskgeneratorargument}.${Radius1}x${Sigma1}" ;;
      compose|evaluate|laplacian)             Resultimage="$Resultimage.${Method}.${Maskgeneratorargument}" ;;
      diffstat)                               Resultimage="$Resultimage.${Method}.${Diffstat1}-${Diffstat2}.r${Radius1}"
        [ "$Radius2" ] &&                     Resultimage="${Resultimage}-r${Radius2}" ;;
      freichen)                               Resultimage="$Resultimage.${Method}"
        [ "$Maskgeneratorargument" ] &&       Resultimage="$Resultimage.${Maskgeneratorargument}" ;;
      morphology)                             Resultimage="$Resultimage.${Method}.${Maskgeneratorargument}"
        [ "$Radius1" ] &&                     Resultimage="${Resultimage}.r${Radius1}"
        [ "$Radius2" ] &&                     Resultimage="${Resultimage}.R${Radius2}" ;;
      statistic)                              Resultimage="$Resultimage.${Method}.${Maskgeneratorargument}.r${Radius1}" 
        [ "$Radius2" ] &&                     Resultimage="${Resultimage}-r${Radius2}" ;;
      *)                                      Resultimage="$Resultimage.${Method}" ;;
    esac
    [ "$Differencemask" = "yes" ] &&          Resultimage="$Resultimage.diff"
    [ "$Negate" = "yes" ] &&                  Resultimage="$Resultimage.neg"
    case $Method in
      compose) [ "$Swapcompose" ] &&          Resultimage="${Resultimage}.swap";;
      evaluate) ;;
      #*) Resultimage="${Resultimage}.m${Mode}" ;;
    esac
    case $Method in
      compose|evaluate) ;;
      *)
        case $Fusemode in
          1) ;;
          *) Resultimage="${Resultimage}.f$Fusemode" ;;
        esac
        [ "${Contrastweight}${Softweight}${Saturationweight}${Chromaweight}${Darknessweight}${Lightnessweight}${Denoiseweight}" != "100000000" ] && {
          Resultimage="${Resultimage}."
          [ "$Contrastweight"   != "100" ] && Resultimage="${Resultimage}cont${Contrastweight}"
          [ "$Softweight" != "0" ]         && Resultimage="${Resultimage}soft${Softweight}"
          [ "$Saturationweight" != "0" ]   && Resultimage="${Resultimage}sat${Saturationweight}"
          [ "$Chromaweight"  != "0" ]      && Resultimage="${Resultimage}cr${Chromaweight}"
          [ "$Darknessweight" != "0" ]     && Resultimage="${Resultimage}dark${Darknessweight}"
          [ "$Lightnessweight" != "0" ]    && Resultimage="${Resultimage}light${Lightnessweight}"
          [ "$Denoiseweight" != "0" ]      && Resultimage="${Resultimage}noise${Denoiseweight}"
          [ "$Fusemode" = "2" ] && note "--fusemode=2 does not integrate well the *-weight options."
        }
        case $Denoiseindex in
          "") ;;
          *) Resultimage="${Resultimage}.n$Denoiseindex" ;;
        esac
        case $Softcut in
          0|"") ;;
          *) Resultimage="${Resultimage}.sc$Softcut" ;;
        esac
        case $Threshold in
          0|"") ;;
          *) Resultimage="${Resultimage}.t$Threshold" ;;
        esac
        case $Grayscalenumber in
          9) ;;
          *) Resultimage="${Resultimage}.g$Grayscalenumber" ;;
        esac
        case $Downweight in
          ""|0) ;;
          *) Resultimage="${Resultimage}.D$Downweight" ;;
        esac
        [ "$Revertimagelist" = "yes" ] && Resultimage="${Resultimage}.rev"
      ;;
    esac
    case $Gamma in
      "") ;;
      auto) Resultimage="${Resultimage}.G" ;;
      *)    Resultimage="${Resultimage}.G$Gamma" ;;
    esac
    Resultimage="${Resultimage}.${Imageformat}"
    
  [ -z "$Outputimage" ] && {
    Outputimage="$(realpath -m "./$Resultimage")" 
    note "Setting --output=$Outputimage"
  }
  Outputimage="$(realpath "$Outputimage")"
  Resultimage="$Cachedir/$Resultimage"
    
  verbose "--$Method=$Maskgeneratorargument
--cachedir=$Cachedir
--denoise=$Denoise
--fusemode=$Fusemode
--downweight=$Downweight
--gamma=$Gamma
--grayscale=$Grayscale
--layers=$Layernumber
--mode=$Mode
--output=$Outputimage
--radius=$Radius1
--radius2=$Radius2
--sigma=$Sigma1
--sigma2=$Sigma2
--cutsoft=$Softcut
--threshold=$Threshold
--contrast-weight=$Contrastweight
--denoise-weight=$Denoiseweight
--saturation-weight=$Saturationweight
--soft-weight=$Softweight
--chroma-weight=$Chromaweight
--lightness-weight=$Lightnessweight
"
  return ${Error:-0}
}
main() {
  #set -eu
  trap trap_sigint SIGINT
  
  declare_variables
  
  command -v convert >/dev/null && Magickbin="convert"
  command -v magick  >/dev/null && Magickbin="magick"
  [ -z "$Magickbin" ] && error "Neither command convert nor magick found. Please install ImageMagick."
  Magickversion="$($Magickbin -version)"
  grep -q " Q8 "   <<< "$Magickversion" && Magickpixelmemory="4"
  grep -q " Q16 "  <<< "$Magickversion" && Magickpixelmemory="8"
  grep -q " HDRI " <<< "$Magickversion" && Magickpixelmemory="16"
  [ "$Error" ] && return 1
  
  Freemem="$(freememory)"
  [ -z "$Freemem" ] && {
    note "WARNING: failed to estimate free memory.
  Blindly guessing 1000 MB."
    Freemem="1000000"
  }
  
  parse_options "$@"
  check_options
  [ "$Error" ] && return 1
  
  Sourceimagelist="$(grep -v -x "" <<< "$Sourceimagelist")"
  Imagenumber="$(grep -c "." <<< "$Sourceimagelist")"
  Imagenumberlength="${#Imagenumber}"
  
  Image="$(head -n1 <<< "$Sourceimagelist")"
  Imagewidth="$($Magickbin  -format '%w' "$Image" info:)"
  Imageheight="$($Magickbin -format '%h' "$Image" info:)"
  Imagememsize="$((Imagewidth*Imageheight*Magickpixelmemory/1000))"
  Imagememsize="$((Imagememsize*125/100))" # by observation. Alpha channel? Meta data?
  Imagelistmemsize="$((Imagenumber*Imagememsize))"
  Image=""
  
  verbose "Image number: $Imagenumber
  Image width:  $Imagewidth
  Image height: $Imageheight
  Image memory size:      $Imagememsize kb
  Image list memory size: $Imagelistmemsize kb
  Free Memory:            $Freemem kb"
    
  mkdir -p $Cachedir || error "Error creating cache folder $Cachedir"
  rm $Cachedir/*
  [ "$Error" ] && return 1

  Softresult="$Cachedir/softresult.tif"
  Testimage="$Cachedir/test.tif"
  
  case $Method in
    evaluate)
      evaluate_split "$Maskgeneratorargument" "$Resultimage" $Sourceimagelist || error "Error in --$Method=$Maskgeneratorargument"
    ;;
    compose)
      compose_stack  "$Maskgeneratorargument" "$Resultimage" $Sourceimagelist || error "Error in --$Method=$Maskgeneratorargument"
    ;;
    *)
      focus_generate_masks     || return 1
      focus_merge_masks        || return 1
      focus_fuse_mode$Fusemode || return 1
      [ "$Storelayers" ] && focus_sharpness_layer
    ;;
  esac
  [ "$Error" ] && return 1

  # --gamma
  case $Gamma in
    "") ;;
    auto) $Magickbin "$Resultimage" -auto-gamma     $Tifstore "$Resultimage" || error "Error in --gamma=$Gamma" ;;
    *)    $Magickbin "$Resultimage" -gamma "$Gamma" $Tifstore "$Resultimage" || error "Error in --gamma=$Gamma" ;;
  esac
  [ "$Error" ] && return 1

  $Magickbin "$Resultimage" $Tifstore "$Outputimage"  || error "Error storing result in $Outputimage"
  showimage "$Outputimage"
  note "Ready after $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")
$Outputimage"
    
  return "${Error:-0}"
}

main "$@"
[ "$Preservecache" = "no" ] && [ -d "$Cachedir" ] && rm -R "$Cachedir"
exit "${Error:-0}"
