#! /bin/bash

# imfuse
Version="0.5.1"

usage() {
  echo "imfuse v$Version - combine focus stackshot images to an overall sharp image.
Aims to be similar to enfuse, but based on ImageMagick.

Dependencies:
  imagemagick         Mandatory (command 'convert' or 'magick').
  geeqie              Optional, used by option -V, --showimage.

Usage:
  imfuse [OPTIONS] -- image1 image2 image3 ...

General options:
 --cache [=DIR]       Preserve cache files, can be partially reused by imfuse.
                      Optionally specify a cache folder DIR.
 -h, --help           Show this help and exit.
 --layers [=NUMBER]   Additonally store a layered TIFF image where
                      the layers contain different sharpness areas.
                      NUMBER is number of sharpness layers.  Default: 24
 -o, --output=FILE    Specify result image file name.
 -v, --verbose        Show verbose output.
     --version        Show imfuse version and exit.
 -V, --showimage      Show intermediate results with image viewer geeqie.

The mask generating options below can take additionally arguments [=ARG].
Multiple arguments are comma-separated. 
  Example: --morphology=r3,less20,close --saturation=w50,M
Arguments taken by all mask options:
  w         Mask weight. Percent value from 0 to 100.
            Of interest if specifying more than one mask generation method.
            Example: --morphology --saturation=w25
            This will generate two masks. The saturation mask will only have
            noteable effect where the morphology mask strength is below 25%.
  c, close  Closes gaps between nearby contrast lines to mark the area between
            as strong contrast, too. Default for c only: c4.
            Can reduce artefacts in partial transparent objects.
            Helps e.g. to strengthen thin shiny objects like hairs.
            For big values rather use e.g. c4x4 instead of c16, the result 
            will be similar but faster.
  less      Strenghtens less contrasted objects in front of strong background.
            Well to combine with 'close'. Accepts a percent value as a
            minimum intermediate contrast difference.
            Default value depends on mask method and differs from 2..60.
  soft      Generates a soft fused image like general option --soft
            and compares the result with all source images. 
            Useful to reduce noise in low contrast areas.
  m         Multiply with a median/mean difference mask to eventually
            hit artefact areas only. For use with colorspace and image 
            comparision mask options. (Experimental)
  M         Multiply with a min/max difference mask to eventually
            hit artefact areas only. For use with colorspace and image 
            comparision mask options. (Experimental)
  negate    Negate/invert the mask. Rarely needed.
Arguments taken by only few options:
  r         Radius. Must be an integer value.
            Increased radius mostly causes less noise, less details and
            more contrast. Smaller radius causes more details and more noise.
            (Options taking a sigma argument have a radius of 0 by default,
            which means that a radius fitting the sigma value will be 
            calculated automatically.)
  s         Sigma. Takes non-integer values like 0.75.
            Increased sigma mostly causes less noise, less details and
            more contrast. Smaller sigma causes more details and more noise.
  R         Second radius. Rarely needed.
  S         Second Sigma. Taken only optionally by --blur and --gaussian.
  swap      Taken only by --composite.
  (words)   Some options also take one or two words.


Contrast mask options:                               Default: --diffstat
 --blur [=ARG]        Blur edge detection. 
                      Similar to --gaussian, but faster and less accurate.
                      ARG additionally takes arguments: 
                        r       radius               Default: 0
                        s       sigma                Default: 0.75
                      Two-mask difference calculation with arguments:
                        R       radius2              Default: 0
                        S       sigma2               Default: 1.6*sigma1
                      (Just typing --blur=S will cause the two-mask
                      difference calulation with default values.)
 --comet [=ARG]       Comet edge detection. Compares rotated mean areas.
                      ARG additionally takes arguments: 
                        r       radius               Default: 0
                        s       sigma                Default: 5
                        (word)  MODE                 Default: Lighten
                      MODE can be one of '$(basename $Magickbin) -list compose'
                      Recommended: Lighten, Darken.
 --compass [=ARG]     Compass edge detection. 
 --diffstat [=ARG]    Compares two local statistics of source images. 
                      Uses ImageMagick option -statistic. Compare --statistic.
                      ARG additionally takes arguments: 
                        r       radius               Default: 5
                        (word)  STAT1                Default: median
                        (word)  STAT2                Default: mean
                      Possible STAT1 and STAT2:
                        0|none|source
                        1|gradient|grad
                        2|maximum|max
                        3|mean
                        4|median
                        5|minimum|min
                        6|mode
                        7|nonpeak
                        8|9|rms|rootmeansquare
                        10|standarddeviation|dev
                      Most interesting alternative is a max,min difference.
 --free [=ARG]        Custom ImageMagick option for mask generation.
                      ARG is an arbitrary ImageMagick command, but must not
                      contain a comma.               Default: '-sharpen 0x3'
 --freediff [=ARG]    Custom ImageMagick option for mask generation.
                      The resulting mask  will be a '-compose Difference' 
                      comparision with the source image.
                      ARG is an arbitrary ImageMagick command, but must not
                      contain a comma.               Default: '-sharpen 0x3'
 --freichen [=ARG]    Frei-Chen edge detection. 
                      ARG additionally takes arguments: 
                        (word)  MODENUMBER
                      Possible MODENUMBERs at:
                      http://www.imagemagick.org/Usage/convolve/#freichen
                      Default: A combination of modes 1 and 2.
 --gaussian [=ARG]    Gaussian blur edge detection. 
                      Similar to --blur, but slower and more accurate.
                      ARG additionally takes arguments: 
                        r       radius               Default: 0
                        s       sigma                Default: 0.75
                      Two-mask difference calculation (DoG) with arguments:
                        R       radius2              Default: 0
                        S       sigma2               Default: 1.6*sigma1
                      (Just typing --gaussian=S will cause a DoG /
                      Difference of Gaussian calculation.)
 --kirsch [=ARG]      Kirsch edge detection. 
 --laplacian [=ARG]   Laplacian edge detection.
                      ARG additionally takes arguments: 
                        (word)  MODENUMBER           Default: 0
                      Possible MODENUMBERs at:
                      http://www.imagemagick.org/Usage/convolve/#laplacian
 --log [=ARG]         Laplacian of Gaussian.
                      ARG additionally takes arguments: 
                        r       radius               Default: 0
                        s       sigma                Default: 0.75
 --morphology [=ARG]  Morphology edge detection.
                      ARG additionally takes arguments: 
                        r       radius               Default: 2
                        R       kernel iterations    Default: 1
                        (word)  MODE                 Default: edge
                      MODE can be one of '$(basename $Magickbin) -list morphology'
                      Some MODEs of interest:
                        edge, dilateintensity, smooth
                      A high radius is slow. Rather use kernel iterations
                      like e.g. r4,R4 instead of r16.
 --prewitt [=ARG]     Prewitt edge detection. 
 --roberts [=ARG]     Roberts edge detection. 
 --sobel [=ARG]       Sobel edge detection. 
 --statistic [=ARG]   ImageMagick option -statistic.
                      ARG additionally takes arguments: 
                        r       radius               Default: 2
                        (word)  STAT                 Default: standarddeviation
                      Argument STAT is one of (number or name):
                        1|gradient|grad
                        2|maximum|max
                        3|mean
                        4|median
                        5|minimum|min
                        6|mode
                        7|nonpeak
                        8|9|rms|rootmeansquare
                        10|standarddeviation|dev
                      Get an impressive strong contrast with a high radius.
 --unsharp [=ARG]     Difference of -unsharp.
                      ARG additionally takes arguments: 
                        r       radius               Default: 0
                        s       sigma                Default: 2
 --wavelet [=ARG]     Based on ImageMagick option -wavelet-denoise.
                      ARG additionally takes arguments:
                        r       radius               Default: 5
                      (In fact, the radius is a percent threshold value
                      in the range of 0..100.)

Image comparision mask options: (Intended for artefact removal)
 --compose [=ARG]     Composes min and max of source images with MODE.
                      Compare ImageMagick option -compose. 
                      For 'min' and 'max' compare option --evaluate.
                      ARG additionally takes arguments:
                        (word)   MODE                Default: overlay
                        swap     Compose max,min instead of min,max
                                 Makes a difference for some, but not
                                 all compose MODEs.
                      MODE can be one of '$(basename $Magickbin) -list compose'
                      Some MODEs of interest:
                        bumpmap colorburn difference linearburn 
                        linearlight modulate multiply overlay pegtoplight
 --evaluate [=ARG]    Evaluates all source images with mode MODE.
                      Compare ImageMagick option -evaluate-sequence.
                      ARG additionally takes arguments:
                        (word)   MODE                Default: max
                      MODE can be one of '$(basename $Magickbin) -list evaluate'
                      Most of interest:
                        max      Brightest pixels in sequence. 
                        mean     Average pixel values in sequence. 
                        median   Middle pixel values in sequence. 
                        min      Darkest pixels in sequence.
 --halo [=ARG]        Remove light halo of white background.
                      ARG additionally takes arguments:
                        r        radius              Default: 20
                        s        sigma               Default: 5
                      radius is in fact a threshold percent value 0..100.
                      Greater radius removes more light.
                      sigma is a -blur sigma for a soft cut.
                      Needs high 'weight' values even greater than 100.
 --image [=ARG]       Loads an image and generates masks based on 
                      similarity with source images.
                      ARG additionally takes arguments:
                        (word)   An image file name
                           
Colorspace channel mask options: (Intended for artefact removal)
(All are variations of --channel)
 --channel            Use a colorspace channel as mask.
                      ARG additionally takes arguments:
                        (word)   Colorspace           Default: HSL
                        (word)   Color channel        Default: 1
                      Colorspace can be one of '$(basename $Magickbin) -list colorspace'
                      The color channel is a number from 0..31.
 --chroma             Chroma channel from HCL colorspace.
 --darkness           Negated lightness channel from HSL colorspace.
                      (Similar to --evaluate=min)
 --lightness          Lightness channel from HSL colorspace.
                      (Similar to --evaluate=max)
 --saturation         Saturation channel from HSL colorspace.

Mask generation and fusion adjustments:
 --cutsoft [=SIGMA]        Add a semi-transparent blur around cut masks. 
                           Reduces some artefacts.         Default: 3
 --grayscale=ARG           Grayscale converting method before mask generation.
                           Compare ImageMagick option -grayscale.
                           ARG is one of: (number or name)
                0 none             No grayscale conversion. Barely tested.
                1 Rec601Luma       0.298839R' + 0.586811G' + 0.114350B'
                2 Rec601Luminance  0.298839R  + 0.586811G  + 0.114350B
                3 Rec709Luma       0.212656R' + 0.715158G' + 0.072186B'
                4 Rec709Luminance  0.212656R  + 0.715158G  + 0.072186B
                5 Brightness       max(R', G', B')
                6 Lightness        (min(R', G', B') + max(R', G', B')) / 2.0
                7 Average          (R' + G' + B') / 3.0
                8 MS               (R'^2 + G'^2 + B'^2) / 3.0
                9 RMS              sqrt( (R'^2 + G'^2 + B'^2) / 3.0 ) (default)
 --soft                    Enable soft fuse mode. Gives a blurry soft result 
                           free of noise artefacts. Compare 'soft' in mask ARG.
 --weightscale [=PERCENT]  Reduce weight of sharpness masks of lower layers.
                           Helps to strengthen weak objects in foreground.
                           A negative PERCENT reduces weight of upper layers.
                           Rather use --lessthanmax.       Default: 50
                           
Basics:                   
Fusing a focus stack aims to generate an overall sharp image of several single
captures that only show partial sharp areas.
Sharp areas show more contrast and detail than blurry unsharp areas.

So one important part is to find areas with a lot of contrast and detail.
This is done with the contrast mask options. From each source image the area
with more contrast than all other source images will be part of the result.

Artefacts:
The attempt to get the strongest contrast areas out of the source images
has some weaknesses and can lead to artefacts.

 - Low contrast noise artefacts:
  All contrast mask methods give unsatisfying results in areas that have low 
  contrast on all source images of the stack.
  It helps to add other masks to that preference in low contrast areas.
  
  Example: Noise reduction with saturation color channel
  --diffstat --saturation=w15 will generate two masksand combine them.
  --diffstat is a contrast option that gives pretty results for many quite 
  different sources. --saturation=w15 adds masks based on source image color
  saturation. It contains close to no noise, but lacks details.
  The weight w15 causes the saturation masks to take only noteable effect
  where the --diffstat contrast has a low significance not higher than 15%.
  Other noteable masks to use with low weight are --darkness and 
  --compose=overlay. 
  
  Another attempt is to use a soft blurry stack in low contrast areas.
  Example: --diffstat --diffstat=soft,w30 generates two diffstat masks.
  The second one will be blurry and soft. Thanks to the weight of 30% (w30)
  it will give the noise in low contrast areas a friendly soft touch.
  
 - Objects in foreground with background artefacts:
  Sometimes objects background result in a stronger contrast mask than
  objects in foreground. The foreground object will be incomplete.
  This can be fixed with mask arguments 'less' and 'close'.
  
Examples:
Have a folder 'stacksource' containing all stack source images.
  Run imfuse with:
    imfuse -V --cache --diffstat stacksource/*
  You might be unsatisfied with low contrast areas. Try:
    imfuse -V --cache --diffstat --diffstat=soft,w50 stacksource/*
    imfuse -V --cache --diffstat --saturation=w25 stacksource/*
  You might have incomplete foreground objects. Try:
    imfuse -V --cache --diffstat=close,less stacksource/*
"
}

### Messages

error() {
  [ -z "$Error" ] && echo "imfuse ERROR: $*
" >&2
  Error=1
  #exit 1
}
note() {
  [ -z "$Error" ] && echo "imfuse note: $*"
  return 0
}
verbose() {
  [ "$Verbose" = "yes" ] && echo "imfuse: $*"
  return 0
}
showimage() {
  [ "$Showimageprocessing" = "yes" ] && geeqie -t -r File:"${1:-}"
  #[ "$Showimageprocessing" = "yes" ] && display -remote "${1:-}" &
  return 0
}

### Misc

comma2whitespace() {
  sed "s/,/ /g" <<< "${1:-}"
}
calc() {
  awk "BEGIN {print $* }"
}
digitonly() {
  sed "s/[^0-9.]//g" <<< "${1:-}"
}
digitrm() {
  sed "s/[0-9.]//g" <<< "${1:-}"
}
freememory() {
  local Freemem Line Zram
  Freemem="$(LC_ALL=C free | grep "Mem:" | awk '{print $7}')"
  while read Line; do
    Zram="$(awk '{print ($3 - $4)}' <<< "$Line")"
    Zram="$((Zram/1000))"
    Freemem="$((Freemem + Zram))"
  done < <(/sbin/swapon --bytes | grep zram)
  Freemem="$((Freemem*100/95))"
  echo $Freemem
}
lowercase() {
    # Usage: lowercase "string"
    printf '%s\n' "${1,,}"
}
maskexist() {
  local Basename Masklist
  Basename="${1:-$Maskbasename}"
  Masklist="$(masklist "$Basename")"
  Masknumber="$(grep -c . <<< "$Masklist")"
  [ "$Masknumber" = "$Imagenumber" ] && return 0 || return 1
}
masklist() {
  local Basename
  Basename="${1:-$Maskbasename}"
  find $Cachedir -regextype sed -regex "$Cachedir/${Basename}.[0-9]\{$Imagenumberlength\}.tif" | sort
}
percentrm() {
  # remove % from string
  sed s/%//g <<< "${1:-}"
}
printnum(){
  # print number $1 with leading zeroes.
  # $1 number
  # $2 digits. Default: 3
  printf %0${2:-3}d "${1:-0}"
}
unspecialstring() {             # replace special chars of $1 with -
  # Replace all characters except those described in "a-zA-Z0-9_" with a '-'. 
  # Replace newlines, too.
  # Remove leading and trailing '-'
  # Avoid double '--'
  # Return empty string if only special chars are given.
  printf %s "${1:-}" | LC_ALL=C tr -cs "a-zA-Z0-9_" "-" | sed -e 's/^-// ; s/-$//'
}

### Image processing

evaluate_split() {

  local Sourceimagelist Resultimage Mode
  local Startzeit Dauer Restzeit
  local Image Split Splitpercent Showsplit Part Partimage Partimagelist
  local Startzeit Dauer Restzeit Count
  
  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  Sourceimagelist=""
  while [ $# -gt 0 ]; do
    Sourceimagelist="$Sourceimagelist
${1:-}"
    shift
  done
  Sourceimagelist="$(tail -n+2 <<< "$Sourceimagelist")"
  
  Split="$((Imagelistmemsize/Freemem +1))"
  
  verbose "Generating $Mode image $(basename "$Resultimage") in $Split parts."
  case $Split in
    1) 
      Startzeit="$(date +%s)"
      $Magickbin $Sourceimagelist -evaluate-sequence $Mode $Tifstore $Resultimage || error "Error in evaluate_split / $Mode"
      Dauer="$(( $(date +%s)-Startzeit))"
      verbose "Duration: $(date -u -d @$Dauer +"%T")"
    ;;
    *)
      Startzeit="$(date +%s)"
      Splitpercent="$((100/Split))"
      Showsplit="$(printnum $(( (Split+1)/2 )) 3)"
      Count="0"
      for Sourceimage in $Sourceimagelist; do
        [ "$Error" ] && break
        Count="$((Count+1))"
        verbose "Splitting image $Count / $Imagenumber into $Split pieces due to low memory: $(basename $Sourceimage)"
        $Magickbin $Sourceimage -crop 100%x${Splitpercent}% $Tifstore $Cachedir/split%03d.$(basename $Sourceimage).tif || error "Error in evaluate_split / crop"
        showimage $Cachedir/split${Showsplit}.$(basename $Sourceimage).tif
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
      done
      Startzeit="$(date +%s)"
      for Part in $(seq 0 $((Split-1))) ; do
        [ "$Error" ] && break
        verbose "Evaluating part $((Part+1)) / $Split"
        Partimage=$Cachedir/$Mode.part$Part.tif
        $Magickbin $Cachedir/split$(printnum $Part 3).*.tif -evaluate-sequence $Mode $Tifstore $Partimage || error "Error in evaluate_split / evaluating parts"
        Partimagelist="$Partimagelist $Partimage"
        showimage $Partimage
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Split-Part+1) / (Part+1) ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
      done
      [ "$Error" ] && return 1
      $Magickbin $Partimagelist -append $Tifstore $Resultimage  || error "Error in evaluate_split / appending parts"
    ;;
  esac
  showimage $Resultimage
  return "${Error:-0}"
}
focus_fuse() {
  # Finally: focus stacking

  local Resultimage Sourceimage Maskimagelist
  local Resulttop Resultbottom Lessthanmaxmask
  local Maskmax
  local Count Number
  local Contrastmaxlevel Softfusion= Lessthanmax=
  local Command
  local Startzeit Dauer Restzeit
  
  [ "${1:-}" = "--soft" ] && Softfusion="yes" && shift
  [ "${1:-}" = "--lessthanmax" ] && shift && Lessthanmax="${1:-}" && shift
  [ "${1:-}" = "--maskmax" ] && shift && Maskmax="${1:-}" && shift
  Resultimage="${1:-}" && shift
  
  Maskimagelist="$@"
  [ -z "$Maskimagelist" ] && Maskimagelist="$(find $Cachedir/sourcemask* | tr '\n' ' ')"
  
  mkimg_transparent $Resultimage
  Maskmax="${Maskmax:-$Cachedir/mask.max.tif}"
  mkimg_black       $Maskmax
  
  [ "$Softfusion" ] && {
    Resulttop="$Cachedir/resulttop.tif"
    Resultbottom="$Cachedir/resultbottom.tif"
    mkimg_transparent $Resulttop
    mkimg_transparent $Resultbottom
  }
  
  [ "$Lessthanmax" ] && {
    evaluate_split max $Maskmax.all.tif $Maskimagelist || return 1
    Contrastmaxlevel="$($Magickbin $Maskmax.all.tif -format '%[fx:maxima*100]' info:)"
    Lessthanmax="$(calc "$Lessthanmax*$Contrastmaxlevel/100")" 
    Lessthanmaxmask="$Cachedir/lessthanmax.tif"
    mkimg_black "$Lessthanmaxmask"
  }
  
  Startzeit="$(date +%s)"
  Count=0    
  for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    Sourcemask="$(cut -d' ' -f$Number <<< "$Maskimagelist")" 
    
    # Load images
    Command="
$Magickbin
  $Resultimage
    -alpha off
    -write mpr:resultimage
    -delete 0
  $Sourceimage
    -alpha off
    -write mpr:sourceimage
    -delete 0
  $Sourcemask
    -alpha off
    -write mpr:sourcemask
    -delete 0
  $Maskmax
    -alpha off
    -write mpr:maskmax
    -delete 0"
    
    # stepwise increase maskmax
    Command="$Command
  mpr:sourcemask 
  mpr:maskmax 
    -compose Lighten -composite
    -write mpr:maskmax
    -write $Maskmax
    -delete 0"
    
    # get area of source mask equal or sharper than current max
    Command="$Command
  mpr:sourcemask
  mpr:maskmax
    -compose MinusDst -composite -fill white +opaque black
    -negate
    -transparent white
    -write mpr:cutmask
    -delete 0"
    
    ## --lessthanmax,less
    [ "$Lessthanmax" ] && { 
      Command="$Command
  $Lessthanmaxmask
    -write mpr:lessthanmax
    -delete 0
  mpr:cutmask
    -write mpr:cutmask_max
    -delete 0"
      
      # get part of actual maskmax
      Command="$Command
  mpr:maskmax
  mpr:cutmask_max
    -alpha Off -compose CopyOpacity -composite
    -write mpr:maskmax_part
    -delete 0"
    
      # paint actual maskmax part into lessmask
      Command="$Command
  mpr:lessthanmax
  mpr:maskmax_part
    -compose Over -composite
    -write mpr:lessthanmax
    -write $Lessthanmaxmask
    -delete 0"
    
      # get area of source mask that is stronger (+offset) than lessmask)
      Command="$Command
  mpr:sourcemask 
  ( mpr:lessthanmax -evaluate Add ${Lessthanmax:-0}% )
    -compose MinusSrc -composite
    -fill white +opaque black 
    -write mpr:cutmask_less
    -delete 0"
      
      # reduce max in maskmax where --lessthanmax takes over
      Command="$Command
  mpr:sourcemask
  mpr:cutmask_less
    -compose CopyOpacity -composite
    -write mpr:sourcemask_part
    -delete 0
  mpr:maskmax
  mpr:sourcemask_part
    -compose Over -composite
    -write mpr:maskmax
    -write $Maskmax
    -delete 0"
    
      # darken lessmask with current source mask to get a mask with decreasing sharpness after a max peak
      Command="$Command
  mpr:lessthanmax
  mpr:sourcemask
    -compose Darken -composite
    -write mpr:lessthanmax
    -delete 0"
      
      # store lessmask
      Command="$Command
  mpr:lessthanmax
    -write $Lessthanmaxmask
    -delete 0" 
    
      # get area of source mask equal or sharper than current max (same code asabove, but now with less adjusted maskmax.
      Command="$Command
  mpr:sourcemask
  mpr:maskmax
    -compose MinusDst -composite -fill white +opaque black
    -negate
    -transparent white
    -write mpr:cutmask
    -delete 0"
    } #/--lessthanmax

    ## --cutsoft: Soft mask edges
    [ "$Cutsoft" ] && Command="$Command
  ( mpr:cutmask -blur 0x${Cutsoft:-2} -auto-level )
  ( mpr:cutmask -transparent black )
    -compose Over -composite
    -write mpr:cutmask
    -delete 0"
    
    case $Softfusion in
      yes)
        Command="$Command
  $Resulttop
    -alpha set
    -write mpr:resultimagetop
    -delete 0
  $Resultbottom
    -alpha set
    -write mpr:resultimagebottom
    -delete 0"
    
        # get part of source mask
        Command="$Command
  mpr:sourcemask 
  mpr:cutmask
    -compose Over -composite
    -write mpr:sourcemask_part
    -delete 0"
    
        # get part of source image (with semi transparency)
        Command="$Command
  mpr:sourceimage 
  mpr:sourcemask_part
    -alpha off -compose CopyOpacity -composite
    -write mpr:semitransparent
    -alpha off
    -delete 0"
    
        # draw into top half of result
        Command="$Command
  mpr:resultimagetop
  mpr:semitransparent
    -compose Over -composite
    -type TrueColorAlpha
    -write mpr:resultimagetop
    -write $Resulttop
    -delete 0"
    
        # get area of source less sharp than current max
        Command="$Command
  mpr:sourcemask 
  ( mpr:cutmask -negate )
    -compose Over -composite
    -write mpr:sourcemask_part
    -delete 0"
    
        # get part of source mask less sharp than current max (with semi transparency)
        Command="$Command
  mpr:sourceimage 
  mpr:sourcemask_part
    -alpha off -compose CopyOpacity -composite
    -write mpr:semitransparent
    -delete 0"
    
        # draw part of source image less sharp than current max in lower result 
        Command="$Command
  mpr:resultimagebottom 
  mpr:semitransparent
    -compose Over -composite
    -type TrueColorAlpha
    -write mpr:resultimagebottom
    -write $Resultbottom
    -delete 0"
    
        # compose to and bottom result to final result
        Command="$Command
  mpr:resultimagebottom
  mpr:resultimagetop
    -compose Over -composite
    -type TrueColorAlpha
    -write mpr:resultimage
    -delete 0"
    
      ;;
      *)
        Command="$Command
  mpr:sourceimage
  mpr:cutmask
    -alpha off -compose CopyOpacity -composite
    -write mpr:sourcepart
    -delete 0
  mpr:resultimage
  mpr:sourcepart
    -compose Over -composite
    -write mpr:resultimage
    -delete 0"  
      ;;
    esac
    
    Command="$Command
  mpr:resultimage
    $Tifstore
    -write $Resultimage
    -delete 0
  null:"
          
    [ "$Count" = "1" ] && verbose "Fusing with:
$(grep "\S" <<< "$Command")"

    $Command || error "Error while fusing images"
    
    #showimage $Testimage
    showimage $Resultimage
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Fusing $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done
  
  [ "$Error" ] && return $Error

  $Magickbin \
    $Resultimage \
    -alpha off \
    $Resultimage || error "Failed to store result"
  
  return "${Error:-0}"
}
focus_generate_masks() {
  local Maskgenerator Maskbasenamelist= Maskready=
  
  Showimage="$Cachedir/mask.progress.tif"

  # Generate command to generate masks
  Maskgenerator="
  mpr:sourceimage"
  # --grayscale
  [ "$Grayscaleconverter" ] && Maskgenerator="$Maskgenerator
    $Grayscaleconverter"
  Maskgenerator="$Maskgenerator
    -write mpr:sourcegray
    -delete 0"
    
  Maskmethodlist="$(grep "\S" <<< "$Maskmethodlist")"
  while read Line; do
    [ "$Error" ] && break
    maskarg_parse "$Line"
    
    # avoid [double] creating of existing masks
    Maskready=""
    maskexist "$Maskbasename"                          && Maskready="yes" || rm -f $(masklist "$Maskbasename")
    grep -q -x "$Maskbasename" <<< "$Maskbasenamelist" && Maskready="yes"
    
    [ -z "$Maskready" ] && {
      Maskgenerator="$Maskgenerator 
$(focus_maskmethod "$Method")"
        
      [ "$Diff" ] && Maskgenerator="$Maskgenerator
  mpr:sourcegray
    -compose Difference -composite"
    
      [ "$Negate" ] && Maskgenerator="$Maskgenerator
    -negate"
    
      [ "${Close1:-1}x${Close2:-1}" != "1x1" ] && Maskgenerator="$Maskgenerator
    -morphology Close:${Close2:-1} Octagon:${Close1:-4}"

      Maskgenerator="$Maskgenerator 
    -write $Cachedir/$Maskbasename.NUMBER.tif"
      [ "$Showimageprocessing" ] && Maskgenerator="$Maskgenerator
    -auto-level -write SHOWIMAGE"
      Maskgenerator="$Maskgenerator
    -delete 0"
    }
    
    Maskbasenamelist="$Maskbasenamelist
$Maskbasename"
  done <<< "$Maskmethodlist"
  
  Maskgenerator="$(sed "1,/SHOWIMAGE/{s%SHOWIMAGE%$Showimage%}" <<< "$Maskgenerator")"
  Maskgenerator="$(sed "/SHOWIMAGE/d" <<< "$Maskgenerator")"
  
  grep -q morphology <<< "$Maskgenerator" && verbose "Mask generator kernels:
$($Magickbin xc: -write mpr:sourceimage -define morphology:showkernel=1 $Maskgenerator null: 2>&1)
"    

  # --evaluate
  for Mode in $Evaluate_needlist; do
    [ "$Error" ] && break
    Imagename="$Cachedir/evaluate.$Mode.$Firstimagemd5.tif"
    [ -e "$Imagename" ] || {
      evaluate_split $Mode $Imagename $Sourceimagelist || break
    }
  done
  # --compose
  for Mode in $Compose_needlist; do
    [ "$Error" ] && break
    Imagename="$Cachedir/compose.$Mode.$Firstimagemd5.tif"
    [ -e "$Imagename" ] || {
      verbose "--compose=$Mode: Generating compose image"
      $Magickbin $Cachedir/evaluate.min.$Firstimagemd5.tif $Cachedir/evaluate.max.$Firstimagemd5.tif           -compose $Mode -composite $Imagename || error "Error compositing $Mode: $Image"
      showimage "$Imagename"
    }
    Imagename="$Cachedir/compose.$Mode.swap.$Firstimagemd5.tif"
    [ -e "$Imagename" ] || {
      verbose "--compose=$Mode,swap: Generating compose image"
      $Magickbin $Cachedir/evaluate.min.$Firstimagemd5.tif $Cachedir/evaluate.max.$Firstimagemd5.tif -swap 0,1 -compose $Mode -composite $Imagename || error "Error compositing $Mode -swap: $Image"
      showimage "$Imagename"
    }
  done
  # M,m
  for Mode in $Difference_needlist; do
    case $Mode in
      minmaxdiff)
        [ -e "$Multiplyminmaximage" ] || {
          $Magickbin \
            $Cachedir/evaluate.min.$Firstimagemd5.tif \
            $Cachedir/evaluate.max.$Firstimagemd5.tif \
              -compose Difference -composite \
              $Grayscaleconverter \
              -blur 0x5 \
              -auto-level \
            $Multiplyminmaximage || error "Error generating $Multiplyminmaximage"
          showimage $Multiplyminmaximage
        }
      ;;
      medianmeandiff)
        [ -e "$Multiplymedianmeanimage" ] || {
          $Magickbin \
            $Cachedir/evaluate.mean.$Firstimagemd5.tif \
            $Cachedir/evaluate.median.$Firstimagemd5.tif \
              -compose Difference -composite \
              $Grayscaleconverter \
              -blur 0x5 \
              -auto-level \
            $Multiplymedianmeanimage || error "Error generating $Multiplymedianmeanimage"
        }
      ;;
    esac
  done

  # Generate masks
  Startzeit="$(date +%s)"
  Count=0
  grep -q "NUMBER" <<< "$Maskgenerator" || verbose "Skipping mask generation"
  grep -q "NUMBER" <<< "$Maskgenerator" && for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
            
    Command="$Magickbin
  $Sourceimage
    -alpha off
    -depth 16
    -write mpr:sourceimage
    -delete 0
$(sed s/NUMBER/$Number/g <<<"$Maskgenerator")"
    
    Command="$Command
  null:"
          
    [ "$Count" = "1" ] && verbose "Generating masks with:
$(grep "\S" <<< "$Command")"

    $Command || error "Failure in mask generation"
    
    #showimage $Testimage
    showimage "$Showimage"
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Contrast mask $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done
  
  while read Line; do
    [ "$Error" ] && break
    maskarg_parse "$Line"
    # get -level min/max values for contrast masks
    [ "$Level" = "yes" ] && {
      Maskmax=$Cachedir/$Maskbasename.max.tif
      Maskmin=$Cachedir/$Maskbasename.min.tif
      [ -e "$Maskmax" ] || {
        evaluate_split max $Maskmax $(masklist "$Maskbasename") || break
      }
      Levelmax="$($Magickbin "$Maskmax" -format '%[fx:maxima*100]' info:)"
      [ -e "$Maskmin" ] || {
        evaluate_split min $Maskmin $(masklist "$Maskbasename") || break
      }
      Levelmin="$($Magickbin "$Maskmin" -format '%[fx:minima*100]' info:)"
      maskarg_store
    }
    # less
    [ "$Less" ] && {
      [ "$Level" = "yes" ] && level_masks
      Levelmin=""
      Levelmax=""
      maskarg_store
      Image="$Cachedir/$Maskbasename.prepare-less.tif"
      Maskmax="$Cachedir/$Maskbasename.lessmask.tif"
      [ -e "$Maskmax" ] || {
        focus_fuse --lessthanmax $Less --maskmax $Maskmax $Image $Cachedir/$Maskbasename.* || break
      }
      Darkenmask="$Maskmax"
      maskarg_store
    }
    # soft
    [ "$Soft" ] && {
      Softready="${Less:-noless}"
      Image="$Cachedir/$Maskbasename.soft-$Softready.tif"
      [ -e "$Image" ] || {
        focus_fuse --soft $Image $Cachedir/$Maskbasename.* || break
      }
      Levelmin=""
      Levelmax=""
      Darkenmask=""
      maskarg_store
      maskarg_parse "$Line,SOFTREADY=$Softready" # new $Maskbasename with $Softready
      maskexist "$Maskbasename" || {
        rm -f $(masklist "$Maskbasename")
        maskfromimage $Image $Cachedir/$Maskbasename || break  ### FIXME issue with --cache
      }
    }
  done <<< "$Maskmethodlist"

  return ${Error:-0}
}
focus_maskmethod() {
  # Mask generating ImageMagick options
  # Most of them are based on edge detection: http://www.imagemagick.org/Usage/convolve/#edgedet
  local Method Sourceimage
  local Maskgenerator
    
  Method="${1:-none}"
    
  case $Method in
    blur)
      # Compare two blurred images with different sigma.
      # Concept and result is similar to Difference of Gaussian (DoG). Using -gaussian-blur gives same as DoG.
      # Code based on https://im.snibgo.com/simpalign.htm#twoBlrDiff.bat
      Maskgenerator="
  ( mpr:sourcegray -blur ${Radius1:-0}x${Sigma1:-0.75} -write mpr:mask1 -delete 0 )"
      case "$Radius2$Sigma2" in
        "") 
          Maskgenerator="$Maskgenerator
  mpr:sourcegray mpr:mask1"
        ;;
        *) 
          Maskgenerator="$Maskgenerator
  ( mpr:sourcegray -blur ${Radius2:-0}x${Sigma2:-1.2} -write mpr:mask2 -delete 0 )
  mpr:mask1 mpr:mask2"
        ;;
      esac
      Maskgenerator="$Maskgenerator
    -compose Difference -composite"
# -compose Mathematics -define compose:args=0,-4,4,0.5 -composite
# -grayscale RMS"
    ;;
    channel)
      Maskgenerator="
  mpr:sourceimage
    -colorspace $Word1 -channel $Word2 -separate"
    ;;
    comet) ### FIXME saturate drops some angles
      Maskgenerator="
    -define morphology:compose=${Word1:-Lighten}
  mpr:sourcegray -morphology Convolve Comet:${Radius1:-0}x${Sigma1:-5}:>
  mpr:sourcegray
    -compose difference -composite"
    ;;
    compass)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=50%!
    -define morphology:compose=Lighten
    -define convolve:bias=50%
    -morphology Convolve Compass:>"
#-compose Difference -composite" # sort of interesting.
    ;;
    compose)
      case $Swap in
        "")
          Maskgenerator="
  ( mpr:sourcegray -alpha off )
  ( $Cachedir/compose.$Word1.$Firstimagemd5.tif $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
        ;;
        *)
          Maskgenerator="
  ( mpr:sourcegray -alpha off )
  ( $Cachedir/compose.$Word1.swap.tif $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
        ;;
      esac
    ;;
    diffstat)
      Maskgenerator=""
      [ "$Word1" = "source" ] && Maskgenerator="$Maskgenerator mpr:sourcegray" || Maskgenerator="$Maskgenerator
  ( mpr:sourcegray -statistic ${Word1:-median} ${Radius1:-5} )"
      [ "$Word2" = "source" ] && Maskgenerator="$Maskgenerator mpr:sourcegray" || Maskgenerator="$Maskgenerator
  ( mpr:sourcegray -statistic ${Word2:-mean} ${Radius1:-5} )"
Maskgenerator="$Maskgenerator
    -compose Difference -composite"
    ;;
    evaluate)
      Maskgenerator="
  ( mpr:sourcegray -alpha off )
  ( $Cachedir/evaluate.$Word1.$Firstimagemd5.tif $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    GAUSSexperimental) 
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=-100,200%
    -morphology Convolve Gaussian:${Radius1:-0}x${Sigma1:-0.75}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    CROSSMORPHexperimental)
      Maskgenerator="
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:${Radius1:-3}x1+1+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:${Radius1:-3}x1+${Radius1:-3}+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:1x${Radius1:-3}+0+1 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:1x${Radius1:-3}+0+${Radius1:-3} )
    -evaluate-sequence min"
    ;;
    CROSSMORPH2experimental)
      Maskgenerator="
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:${Radius1}x$((Radius1/2))+0+$((Radius1/4)) )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:${Radius1}x$((Radius1/2))+$((Radius1-1))+$((Radius1/4)) )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:$((Radius1/2))x$((Radius1))+$((Radius1/4))+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Radius2:-1} Rectangle:$((Radius1/2))x$((Radius1))+$((Radius1/4))+$((Radius1-1)) )
    -evaluate-sequence min"
    ;;
    experimental)
      Maskgenerator="
  mpr:sourcegray
    -threshold 80%
    -blur 0x5
    -auto-level
    -negate"
    ;;
    free)
      Maskgenerator="
  mpr:sourcegray 
    $Word1"
    ;;
    freediff)
      Maskgenerator="
  mpr:sourcegray 
    $Word1
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    freichen)
      case $Word1 in
        "")
          Maskgenerator="
  (
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:1>
  )
  (
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:2>
  )
    -compose Screen
    -composite"
        ;;
        *)
          Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=10%
    -morphology Convolve FreiChen:${Word1:-0}>"
        ;;
      esac
    ;;
    gaussian) 
      case $Sigma2 in
        "")
          Maskgenerator="
  ( mpr:sourcegray -gaussian-blur ${Radius1:-0}x${Sigma1:-0.75} )
  mpr:sourcegray
    -compose Difference -composite"
        ;;
        *) # DoG: Difference of Gaussian
          Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100,100%
    -morphology Convolve DoG:${Radius1:-0},${Sigma1:-0.75},${Sigma2:-1.2}
  mpr:sourcegray
    -compose Difference -composite"
        ;;
      esac
    ;;
    halo)
      Maskgenerator="
  mpr:sourcegray
    -threshold $(calc "100-${Radius1:-20}")%
    -blur 0x${Sigma1:-5}
    -auto-level
    -negate"
    ;;
    image)
      Maskgenerator="
  ( mpr:sourcegray -alpha off )
  ( $Word1 $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    kirsch)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=screen
    -define convolve:bias=15%
    -morphology Convolve Kirsch:>"
    ;;
    laplacian)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:bias=5%
    -define convolve:scale=100%!
    -morphology Convolve Laplacian:${Word1:-0}>"
    ;;
    log)  # LoG: Laplacian of Gaussian
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100,100%
    -morphology Convolve LoG:${Radius1:-0}x${Sigma1:-0.75}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    morphology)
      Maskgenerator="
  mpr:sourcegray
    -morphology ${Word1:-edge}:${Radius2:-1} Octagon:${Radius1:-2}"
    ;;
    none)
      Maskgenerator="mpr:sourcegray"
    ;;
    prewitt)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=screen
    -define convolve:bias=10%
    -morphology Convolve Prewitt:>"
    ;;
    roberts)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100%
    -define morphology:compose=screen
    -define convolve:bias=10%
    -morphology Convolve Roberts:@"
    ;;
    sobel)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100%!
    -define convolve:bias=10%
    -define morphology:compose=screen
    -morphology Convolve Sobel:>"
    ;;
    statistic)
      Maskgenerator="
  mpr:sourcegray
    -statistic ${Word1:-standarddeviation} ${Radius1:-2}x${Radius1:-2}"
    ;;
    unsharp)
      Maskgenerator="
  mpr:sourcegray -unsharp ${Radius1:-0}x${Sigma1:-5}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    wavelet)
      Maskgenerator="
  mpr:sourcegray 
    -wavelet-denoise ${Radius1:-10}%
  mpr:sourcegray
    -compose Difference -composite"
    ;;
  esac
    
  grep . <<< "$Maskgenerator"
}
focus_merge_masks() {
  # Merge different masks.
  
  local Sourcemask
  local Weightscaleoption Mergemethod
  local Count Number
  local Command
  local Mergemethod Mergeneeded Methodmask
  local Startzeit Dauer Restzeit
  
  Mergemethod="screen"

  Mergeneeded="no"
  [ "$Maskmethodnumber" -gt "1" ] && Mergeneeded="yes"
  [ "${Weightscale:-0}" != "0" ]  && Mergeneeded="yes" 

  Startzeit="$(date +%s)"
  Count=0
  for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    
    Sourcemask="$Cachedir/sourcemask.${Number}.tif"
        
    # -weightscale
    [ "${Weightscale:-0}" -lt "0" ] && Weightscaleoption="+level 0,$(awk "BEGIN { print 100 + $Weightscale*$Count/$Imagenumber }")%"
    [ "${Weightscale:-0}" -gt "0" ] && Weightscaleoption="+level 0,$(awk "BEGIN { print 100 - $Weightscale*$((Imagenumber-Count))/$Imagenumber }")%"
    
    Command="
$Magickbin"
    Command="$Command
  ( -size ${Imagewidth}x${Imageheight} xc:black )"
  
    while read Line; do
      maskarg_parse "$Line"
      Methodmask="$Cachedir/$Maskbasename.$Number.tif"
      
      #[ "${Levelmin:-0}%,${Levelmax:-100}%" != "0%,100%" ] && Mergeneeded="yes" 
      [ "$Multiplymedianmean" ]                            && Mergeneeded="yes" 
      [ "$Multiplyminmax" ]                                && Mergeneeded="yes" 
      [ "$Darkenmask" ]                                    && Mergeneeded="yes" 
      [ "$Mergeneeded" = "no" ] && break
      Command="$Command
  ( 
  $Methodmask
    -level ${Levelmin:-0}%,${Levelmax:-100}%"
      [ "$Darkenmask" ] && Command="$Command
  $Darkenmask
    -compose Darken -composite"
      [ "$Multiplyminmax" ] && Command="$Command
  $Multiplyminmaximage
    -compose Multiply -composite"
      [ "$Multiplymedianmean" ] && Command="$Command
  $Multiplymedianmeanimage
    -compose Multiply -composite"
      Command="$Command
    +level 0%,$(calc ${Weight:-100} / ${Maskmethodnumber:-1})% 
  )
    -compose $Mergemethod -composite"
    done <<< "$Maskmethodlist"
        
    Command="$Command
    -write mpr:sourcemask
    -delete 0"
    
    # --weightscale
    [ "${Weightscale:-0}" != "0" ] && Command="$Command
  mpr:sourcemask
    $Weightscaleoption
    -write mpr:sourcemask
    -delete 0"
    Command="$Command
  mpr:sourcemask
    $Tifstore 
  $Sourcemask"
  
    case $Mergeneeded in
      yes)
        [ "$Count" = "1" ] && verbose "Merging masks with:
$(grep "\S" <<< "$Command")"
   
        $Command || error "Error while merging masks"
      ;;
      no)
        [ "$Count" = "1" ] && verbose "Skipping merge, just copying $Methodmask to $Sourcemask"
        cp $Methodmask $Sourcemask || error "Error while merging/copying $Methodmask"
      ;;
    esac
      
    showimage "$Sourcemask"
    #showimage $Testimage
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Merging $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done
  [ "$Error" ] && return "${Error:-0}"
    
  return ${Error:-0}
}
focus_sharpness_layer() {
  # --layers: Layered TIF with sharpness layers
  local Graylevel Graylevel1 Graylevel2 Pixelnumber Pixelcount Image Layerimage Layerimagelist Layerminpixel Graylevels Histogramm
  local Layercount Count
  local Startzeit Dauer Restzeit
  local Maskmax
  
  Maskmax="$Cachedir/mask.max.tif"
  evaluate_split max $Maskmax $Cachedir/sourcemask*
  Histogramm="$($Magickbin $Maskmax -depth 16 -define histogram:unique-colors=true -format %c histogram:info:-)"
  Graylevels="$(awk '{print $3}' <<< "$Histogramm" | wc -l)"
  Layerminpixel="$(( Imagewidth*Imageheight/(Layers-1) ))"
  
  verbose "Creating $Layers layers of sharpness areas"
  
  Count=0
  Layercount=0
  Startzeit="$(date +%s)"
  Pixelcount=0
  Pixelnumber=0
  while read Line; do
    [ "$Error" ] && break
    Count=$((Count+1))
    
    Graylevel="$(awk '{print $3}' <<< "$Line")"
    Pixelnumber="$(awk '{print $1}' <<< "$Line")"
    Pixelnumber="${Pixelnumber%:}"
    Pixelcount="$((Pixelcount+Pixelnumber))"
    
    [ "$Pixelcount" -lt "$Layerminpixel" ] && {
      Graylevel1="${Graylevel1:-$Graylevel}"
    }
    
    { [ "$Pixelcount" -gt "$Layerminpixel" ] || [ "$Count" = "$Graylevels" ] ; } && {
      Layercount="$((Layercount+1))"
      Layerimage="$Cachedir/layer_sharpness.$(printnum $Layercount).tif"
      Graylevel2="${Graylevel2:-$Graylevel}"
      Command="
$Magickbin
  $Maskmax
    -depth 16
    -color-threshold "${Graylevel1:-$Graylevel2}"-"$Graylevel"
    -write mpr:layermask
    -delete 0
  $Resultimage
  mpr:layermask
    -colorspace sRGB
    -alpha Off -compose CopyOpacity -composite
    -background blue -alpha background
    $Tifstore
  $Layerimage"
  
      $Command || {
        note "Error in generating sharpness layers"
        break
      }
      
      Layerimagelist="$Layerimagelist $Layerimage"
      
      [ "$Graylevel2" = "$Graylevel" ] && {
        Graylevel1=""
        Pixelcount="0"
      } || {
        Graylevel1="$Graylevel"
        Pixelcount="$Pixelnumber"
      }
      
      showimage $Layerimage
      Dauer="$(( $(date +%s)-Startzeit))"
      Restzeit="$(( Dauer*(Graylevels-Count) / Count ))"
      verbose "Layer $Layercount/$Layers. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
    }
    Graylevel2="$Graylevel"
  done <<< "$Histogramm"
    
  [ "$Error" ] && return $Error
  
  verbose "Creating layered result of sharpness areas"
  Image="$(rev <<< "$Outputimage" | cut -d. -f2- | rev).layered_sharpness.tif"
  $Magickbin -type TrueColorAlpha $Maskmax $Layerimagelist $Tifstore "$Image" || note "Failed to create layered sharpness result image."
  
  return "${Error:-0}"
}
level_masks() {
  local Startzeit Dauer Restzeit
  local Count Mask
    
  Startzeit="$(date +%s)"
  Count=0
  for Mask in $Cachedir/$Maskbasename* ; do
    [ "$Error" ] && break
    Count="$((Count+1))"
            
    Command="
$Magickbin
  $Mask
    -level ${Levelmin}%,${Levelmax}%
    -write mpr:sourcemask
    -delete 0"
        
    [ "$Close1" ] && Command="$Command
  mpr:sourcemask
    -morphology Close:${Close2:-1} Octagon:${Close1:-2}
    -write mpr:sourcemask
    -delete 0"
    
    Command="$Command
  mpr:sourcemask
    -write $Mask
    -delete 0
  null:"
  
  [ "$Count" = "1" ] && verbose "Leveling masks with:
$(grep "\S" <<< "$Command")"
  
    $Command || error "Failure in leveling $Method masks"
  
    showimage "$Mask"
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Leveling $Method $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done
  return "${Error:-0}"
}
maskfromimage() {
  # Generate masks based on comparision with a single image
  local Imagename Maskbasename Multiplyimage=
  local Startzeit Dauer Restzeit
  local Count Number
  
  [ "${1:-}" = "--multiply" ] && shift && Multiplyimage="${1:-}" && shift
  Imagename="${1:-}"
  Maskbasename="${2:-}"
  
  Startzeit="$(date +%s)"
  Count=0
  for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    Maskname="$Maskbasename.${Number}.tif"
        
    Command="$Magickbin
  ( $Sourceimage $Grayscaleconverter -alpha off )
  ( $Imagename   $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    [ "$Multiplyimage" ] && Command="$Command
  $Multiplyimage
    -compose Multiply -composite"
    Command="$Command
  $Maskname"
         
    $Command || error "Failure in mask generation of comparision with $Imagename"
  
    [ "$Count" = "1" ] && verbose "Generating masks with:
$(grep "\S" <<< "$Command")"

    showimage $Maskname
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Image comparision mask $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done
}
mkimg_black() {
  local Size
  Size="${2:-}"
  [ -z "$Size" ] && Size="${Imagewidth:-100}x${Imageheight:-100}"
  $Magickbin -size "$Size" xc:black                  -type Grayscale      $Tifstore "${1:-black.tif}"       || error "Failed to create black image."
}
mkimg_transparent() {
  local Size
  Size="${2:-}"
  [ -z "$Size" ] && Size="${Imagewidth:-100}x${Imageheight:-100}"
  $Magickbin -size "$Size" xc:blue -transparent blue -type TrueColorAlpha $Tifstore "${1:-transparent.tif}" || error "Failed to create transparent image ${1:-}."
}

### main

trap_sigint() {
  error "Received SIGINT"
}
declare_variables() {
  
  Basename=""
  Cachedir=""
  Composefactor="" ### FIXME
  Compose_needlist=""
  Cutsoft=""
  Difference_needlist=""
  Evaluate_needlist=""
  Error=""
  Firstimage=""
  Firstimagemd5=""
  Firstimagemd5file=""
  Freemem=""
  Grayscale=""
  Grayscaleconverter=""
  Grayscalenumber=""
  Image=""
  Imageformat="tif"
  Imageheight=""
  Imagelistmemsize=""
  Imagememsize=""
  Imagenumber=""
  Imagewidth=""
  Layers=""  
  Magickbin=""
  Magickpixelmemory=""
  Magickversion=""
  Maskmethodcount=""
  Maskmethodlist=""
  Maskmethodnumber=""
  Multiplymedianmeanimage=""
  Multiplyminmaximage=""
  Outputimage=""
  Preservecache=""
  Revertimagelist=""
  Showimageprocessing=""
  Softmode=""
  Sourceimage=""
  Sourceimagelist=""
  Startzeit="$(date +%s)"
  Testimage=""
  Testsetup=""
  Tifstore="+repage -quality 100% -compress lzw"
  Verbose=""
  Weightscale=""
  
  # Vars for [=ARG]
  Close1=""
  Close2=""
  Darkenmask=""
  Diff=""
  Less=""
  Level=""
  Levelmin=""
  Levelmax=""
  Multiplymedianmean=""
  Multiplyminmax=""
  Method=
  Negate=""
  Radius1=""
  Radius2=""
  Sigma1=""
  Sigma2=""
  Soft=""
  Softready=""
  Swap=""
  Weight=""
  Word1=""
  Word2=""
  
  return 0
}
parse_options() {
  local Shortoptions Longoptions Parsedoptions Parsererror Parsererrorfile Maskgeneratorargument
  
  Shortoptions="ho:vV"
  
  Longoptions="basename::,cache::,help,verbose,version,output:,showimage,test::"
  Longoptions="$Longoptions,cutsoft::,grayscale:,layers::,revert,softmode,weightscale::"
  Longoptions="$Longoptions,channel::,chroma::,compose::,darkness::,evaluate::,halo::,image::,lightness::,saturation::"
  Longoptions="$Longoptions,blur::,comet::,compass::,diffstat::,gaussian::,freichen::,kirsch::,laplacian::,log::,morphology::,none::,prewitt::,roberts::,sobel::,statistic::,unsharp::,wavelet::"  
  Longoptions="$Longoptions,experimental::,free::,freediff::"
  
  Parsererrorfile="/tmp/imfuse.parserserror.$RANDOM"
  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@" 2>"$Parsererrorfile")"
  [ -e $Parsererrorfile ] && Parsererror="$(cat "$Parsererrorfile")" && rm "$Parsererrorfile"
  [ "$Parsererror" ] && error "$Parsererror"
  eval set -- "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    [ "$Error" ] && break
    case "${1:-}" in
         --basename)          Basename="${2:-auto}"     ; shift ;;
         --cache)             Preservecache="yes"       ; Cachedir="${2:-auto}" ; shift ;;
         --cutsoft)           Cutsoft="${2:-auto}"      ; shift ;;
         --grayscale)         Grayscale="${2:-auto}"    ; shift ;;
      -h|--help)              usage                     ; exit 0 ;;
         --layers)            Layers="${2:-auto}"       ; shift ;;
      -o|--output)            Outputimage="${2:-}"      ; shift ;;
         --revert)            Revertimagelist="yes"     ;;
      -V|--showimage)         Showimageprocessing="yes" ;;
         --softmode)          Softmode="yes"            ;;
         --test)              Testsetup="${2:-test}"    ; shift ;;
      -v|--verbose)           Verbose="yes"             ;;
         --version)           echo "imfuse v$Version"   ; exit 0 ;;
         --weightscale)       Weightscale="${2:-auto}"  ; shift ;;
      
--blur|--channel|--chroma|--comet|--compass|--compose|--darkness|--diffstat|--evaluate|\
--experimental|--free|--freediff|\
--freichen|--gaussian|--halo|--image|--kirsch|--laplacian|--lightness|--log|--morphology|--none|\
--prewitt|--roberts|--saturation|--sobel|--statistic|--unsharp|--wavelet)
        Method="${1#--}"
        Maskgeneratorargument="${2:-}" && shift
        Maskmethodnumber="$((Maskmethodnumber+1))"
        Maskmethodcount="$Maskmethodnumber"
        maskarg_parse "$Maskgeneratorargument"
        maskarg_store "$Maskmethodcount"
      ;;
      
      --) ;;
      *)
        Sourceimagelist="$Sourceimagelist
$(realpath "${1:-}")" 
        [ -f "${1:-}" ] || error "File not found: ${1:-}"
      ;;
    esac
    shift
  done
  return ${Error:-0}
}  
check_options() {

  Maskmethodlist="$(grep "\S" <<< "$Maskmethodlist")"
  # default method if none is specified
  [ -z "$Maskmethodlist" ] && {
    Maskmethodnumber="1"
    Maskmethodcount="1"
    Method="diffstat"
    Radius1="5"
    Level="yes"
    maskarg_store "$Maskmethodcount"
  }
  while read Line; do
    maskarg_parse "$Line"
  
    case $Method in
      blur|gaussian)
        [ -z "$Sigma1" ] && Sigma1="0.75"
        [ "$Sigma2" = "auto" ] && Sigma2="$(calc "$Sigma1 * 1.6")"
        Level="yes"
        maskarg_donttake swap word1 word2
      ;;
      channel)
        [ -z "$Word1" ] && Word1="HSL"
        [ -z "$Word2" ] && Word2="2"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap
      ;;
      chroma)
        Method="channel"
        Word1="HCL"
        Word2="1"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap
      ;;
      comet)
        #[ -z "$Word1" ] && Word1="Lighten"
        #Word1="$(lowercase "$Word1")"
        #grep -q -x -i "$Word1" <<< "$($Magickbin -list compose)" || {
        #  error "--$Method=$Word1: unknown argument.
  #Please choose one out of '$Magickbin -list compose'
  #Recommended: Darken, Lighten"
        #}
        [ -z "$Sigma1" ]       && Sigma1="5"
        Level="yes"
        maskarg_donttake radius1 radius2 sigma2 swap word1 word2
      ;;
      compass)
        Level="yes"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap word1 word2
      ;;
      compose)
        [ -z "$Word1" ] && Word1="overlay"
        Word1="$(lowercase "$Word1")"
        grep -q -x -i "$Word1" <<< "$($Magickbin -list compose)" || {
          error "--$Method=$Word1: unknown argument.
  Please choose one out of '$Magickbin -list compose'
  or compare ImageMagick option -compose."
        }
        Evaluate_needlist="$Evaluate_needlist max min"
        Compose_needlist="$Compose_needlist $Word1"
        maskarg_donttake radius1 radius2 sigma1 sigma2 word2
      ;;
      diffstat)
        case ${Word1,,} in
          ""|auto)                Word1="" ;;
          0|source|none)          Word1="source" ;;
          1|gradient|grad)        Word1="gradient" ;;
          2|maximum|max)          Word1="maximum" ;;
          3|mean)                 Word1="mean" ;;
          4|median)               Word1="median" ;;
          5|minimum|min)          Word1="minimum" ;;
          6|mode)                 Word1="mode" ;;
          7|nonpeak)              Word1="nonpeak" ;;
          8|9|rms|rootmeansquare) Word1="rms" ;;
          10|standarddeviation|standard_deviation|standard-deviation|dev) 
                                  Word1="standarddeviation" ;;
          *) error "--diffstat: Unknown mode $Word1" ;;
        esac
        case ${Word2,,} in
          ""|auto)                Word2="" ;;
          1|gradient|grad)        Word2="gradient" ;;
          2|maximum|max)          Word2="maximum" ;;
          3|mean)                 Word2="mean" ;;
          4|median)               Word2="median" ;;
          5|minimum|min)          Word2="minimum" ;;
          6|mode)                 Word2="mode" ;;
          7|nonpeak)              Word2="nonpeak" ;;
          8|9|rms|rootmeansquare) Word2="rms" ;;
          10|standarddeviation|standard_deviation|standard-deviation|dev)
                                  Word2="standarddeviation" ;;
          *) error "--diffstat: Unknown mode $Word2" ;;
        esac
        [ -z "$Radius1" ]       && Radius1="5"
        Level="yes"
        maskarg_donttake radius2 sigma1 sigma2 swap
      ;;
      darkness)
        Method="channel"
        Word1="HSL"
        Word2="2"
        Negate="yes"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap
      ;;
      
      evaluate)
        [ -z "$Word1" ] && Word1="max"
        Word1="$(lowercase "$Word1")"
        grep -q -x -i "$Word1" <<< "$($Magickbin -list evaluate)" || {
          error "--$Method=$Word1: unknown argument.
  Please choose one out of '$Magickbin -list evaluate'
  or compare ImageMagick option -evaluate-sequence."
        }
        Evaluate_needlist="$Evaluate_needlist $Word1"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap word2
      ;;
      experimental) ;;
      free)
        #[ -z "$Word1" ] && Word1="-sharpen 0x3"
        Level="yes"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap word2
      ;;
      freediff)
        [ -z "$Word1" ] && Word1="-sharpen 0x3"
        Level="yes"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap word2
      ;;    
      freichen)
        Level="yes"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap word2
      ;;
      halo)
        maskarg_donttake radius2 sigma2 swap word1 word2
      ;;
      laplacian)
        Level="yes"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap word2
      ;;
      lightness)
        Method="channel"
        Word1="HSL"
        Word2="2"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap
      ;;
      log)
        [ -z "$Sigma1" ]       && Sigma1="0.75"
        Level="yes"
        maskarg_donttake radius2 sigma2 swap word1 word2
      ;;
      image)
        [ -e "$Word1" ] || error "--image needs an image file name as argument."
        Method="image"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap word2
      ;;
      kirsch)
        Level="yes"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap word1 word2
      ;;
      morphology)
        Word1="$(lowercase "$Word1")"
        [ -z "$Word1" ] && Word1="edge"
        grep -q -x -i "${Word1:-}" <<< "$($Magickbin -list morphology)" || {
          error "--$Method=$Word1: unknown argument.
  Please choose one out of '$Magickbin -list morphology'
  or compare ImageMagick option -morphology."
        }
        [ -z "$Radius1" ] && Radius1="2"
        # FIXME Radius2/Iteration
        case $Word1 in
          edge|edgein|edgeout|tophat|bottomhat) ;;
          *) Diff="yes" ;;
        esac
        [ "$Word1" = "edge" ] && Word1=""
        Level="yes"
        maskarg_donttake radius2 sigma1 sigma2 swap word2
      ;;
      none)
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap word1 word2
      ;;
      prewitt)
        Level="yes"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap word1 word2
      ;;
      roberts)
        Level="yes"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap word1 word2
      ;;
      saturation)
        Method="channel"
        Word1="HSL"
        Word2="1"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap
      ;;
      sobel)
        Level="yes"
        maskarg_donttake radius1 radius2 sigma1 sigma2 swap word1 word2
      ;;
      statistic)
        Word1="$(lowercase "$Word1")"
        case $Word1 in
          ""|auto)                Word1="standarddeviation" ;;
          1|gradient|grad)        Word1="gradient" ;;
          2|maximum|max)          Word1="maximum" ;;
          3|mean)                 Word1="mean" ;;
          4|median)               Word1="median" ;;
          5|minimum|min)          Word1="minimum" ;;
          6|mode)                 Word1="mode" ;;
          7|nonpeak)              Word1="nonpeak" ;;
          8|9|rms|rootmeansquare) Word1="rms" ;;
          10|standarddeviation|standard_deviation|standard-deviation|dev) 
                                  Word1="standarddeviation" ;;
          *) error "--statistic: Unknown mode $Word1" ;;
        esac
        [ -z "$Radius1" ] && Radius1="2"
        case $Word1 in
          gradient|standarddeviation|"") ;;
          *) Diff="yes" ;;
        esac
        [ "$Word1" = "standarddeviation" ] && Word1=""
        Level="yes"
        maskarg_donttake radius2 sigma1 sigma2 swap word2
      ;;
      unsharp)
        #[ -z "$Radius1" ] && Radius1="0"
        #[ -z "$Sigma1" ]  && Sigma1="2"
        Level="yes"
        maskarg_donttake radius2 sigma2 swap word1 word2
      ;;
      wavelet)
        [ -z "$Radius1" ] && Radius1="5"
        Level="yes"
        maskarg_donttake radius2 sigma1 sigma2 swap word1 word2
      ;;
    esac
    maskarg_store "$Maskmethodcount"
  done <<< "$Maskmethodlist"
  
  # --weightscale
  case $Weightscale in
    "")   ;;
    auto) Weightscale="50" ;;
    *)    Weightscale="$(percentrm "$Weightscale")" ;;
  esac
  
  # --factor ### FIXME
  [ "$Composefactor" = "auto" ] && {
    case $Method in
      compose)
        case $Maskgeneratorargument in
          blend|colordodge|lighten*|lineardodge|plus|screen) 
            Composefactor="0.5" ;;
          bumpmap|colorburn|colordodge|darken*|linearburn|multiply) 
            Composefactor="2" ;;
          overlay|pegtoplight|pinlight|softburn|softlight)
            Composefactor="1" ;;
          difference|hardlight|linearlight|freeze|reflect|stamp|vividlight)
            Composefactor="1" ;;
          colorize|displace|distort|divide*|exclusion|hardmix|interpolate|minus*|modul*|negate|saturate|softdodge) 
            Composefactor="1" ;;
          atop|blur|changemask|clear|copy*|darken|darkenintensity|dissolve|dst*|hue|in|intensity|mathematics|none|out|over|replace|src*|stereo|xor)
            Composefactor="1" ;;
          *) 
            Composefactor="1" ;;
        esac
      ;;
      *) Composefactor=1 ;;
    esac
    note "Setting --factor=$Composefactor"
  }
  
  # --grayscale
  case ${Grayscale,,} in
    ""|auto)           Grayscale="RMS" ;;
  esac
  case ${Grayscale,,} in
    0|none)            Grayscalenumber=0 ; Grayscale="none" ;;
    1|rec601luma)      Grayscalenumber=1 ; Grayscale="Rec601Luma" ;;
    2|rec601luminance) Grayscalenumber=2 ; Grayscale="Rec601Luminance" ;;
    3|rec709luma)      Grayscalenumber=3 ; Grayscale="Rec709Luma" ;;
    4|rec709luminance) Grayscalenumber=4 ; Grayscale="Rec709Luminance" ;;
    5|brightness)      Grayscalenumber=5 ; Grayscale="Brightness" ;;
    6|lightness)       Grayscalenumber=6 ; Grayscale="Lightness" ;;
    7|average)         Grayscalenumber=7 ; Grayscale="Average" ;;
    8|ms)              Grayscalenumber=8 ; Grayscale="MS" ;;
    9|rms)             Grayscalenumber=9 ; Grayscale="RMS" ;;
    *)
      error "--grayscale: Unknown argument: $Grayscale"
    ;;
  esac
  case $Grayscale in
    ""|none) Grayscaleconverter="" ;;
    *)       Grayscaleconverter="-grayscale $Grayscale" ;;
  esac
  
  # --layers
  case $Layers in
    auto) Layers="24" ;;
  esac
  
  # --cutsoft
  case $Cutsoft in
    "") ;;
    auto) Cutsoft="2" ;;
    *) ;;
  esac

  #### Files ####

  # --cachedir
  [ -z "$Cachedir" ]       && Cachedir="$(pwd)/cache.imfuse"
  [ "$Cachedir" = "auto" ] && Cachedir="$(pwd)/cache.imfuse"
  Cachedir="$(sed s%'~'%$HOME% <<< "$Cachedir")"
  Cachedir="$(realpath -m "$Cachedir")"
  
  [ -z "$Sourceimagelist" ] && error "No images specified"
  Sourceimagelist="$(grep .     <<< "$Sourceimagelist")"
  Sourceimagelist="$(sort -V -r <<< "$Sourceimagelist")"
  
  # --revert
  [ "$Revertimagelist" = "yes" ] && Sourceimagelist="$(tac <<< "$Sourceimagelist")"
  
  # --basename
  case $Basename in
    "")   Basename="imfuse" ;;
    auto) Basename="$(basename "$(pwd)")" ;;
  esac
  [ "$Basename" != "$(unspecialstring "$Basename")" ] && error "--basename: Name must not contain special chars or whitespace: '$Basename'"
  
  # --output
  Resultimage="$Basename"
 
  [ "$Softmode" ] && Resultimage="${Resultimage}.soft"
  [ "$Revertimagelist" = "yes" ] && Resultimage="${Resultimage}.rev"
  case $Grayscalenumber in
    9) ;;
    *) Resultimage="${Resultimage}.gray$Grayscalenumber" ;;
  esac
  case $Cutsoft in
    0|"") ;;
    *) Resultimage="${Resultimage}.cs$Cutsoft" ;;
  esac
  case $Weightscale in
    ""|0) ;;
    *) Resultimage="${Resultimage}.ws$Weightscale" ;;
  esac
        
  while read Line; do
    maskarg_parse "$Line"   
    Resultimage="$Resultimage-${Method}="
    [ "$Multiplyminmax" ]     && Resultimage="$Resultimage,M"
    [ "$Multiplymedianmean" ] && Resultimage="$Resultimage,m"
    [ "$Weight" ]  && Resultimage="$Resultimage,w$Weight"
    [ "$Radius1" ] && Resultimage="$Resultimage,r$Radius1"
    [ "$Sigma1" ]  && Resultimage="$Resultimage,s$Sigma1"
    [ "$Radius2" ] && Resultimage="$Resultimage,R$Radius2"
    [ "$Sigma2" ]  && Resultimage="$Resultimage,s$Sigma2"
    [ "$Soft" ]    && Resultimage="$Resultimage,soft"
    [ "$Less" ]    && Resultimage="$Resultimage,less$Less"
    [ "$Close1" ]  && Resultimage="$Resultimage,c$Close1"
    [ "$Close2" ]  && Resultimage="${Resultimage}x$Close2"
    [ "$Swap" ]    && Resultimage="$Resultimage,swap"
    [ "$Negate" ]  && Resultimage="$Resultimage,neg"
    [ "$Method" != "image" ] && [ "$Word1" ] && Resultimage="$Resultimage,$(unspecialstring "$Word1")"
    [ "$Word2" ]   && Resultimage="$Resultimage,$(unspecialstring "$Word2")"
  done <<< "$Maskmethodlist"
  Resultimage="$(sed "s/=,/=/g ; s/=-/-/g  ; s/=$//g" <<< "$Resultimage")"
  Resultimage="$(sed "s/=,/=/g ; s/=\./=/g ; s/=$//g" <<< "$Resultimage")"
        
  [ "$Testsetup" ] && Resultimage="${Resultimage}.$Testsetup"
    
  Resultimage="${Resultimage}.${Imageformat}"
    
  [ -z "$Outputimage" ] && {
    Outputimage="$(realpath -m "./$Resultimage")" 
    note "Setting --output=$Outputimage"
  }
  Outputimage="$(realpath "$Outputimage")"
  Resultimage="$Cachedir/$Resultimage"
  
  return ${Error:-0}
}
maskarg_parse() {
  local Key Line
  Close1=""
  Close2=""
  Diff=""
  Less=""
  Level=""
  Levelmin=""
  Levelmax=""
  #Method=
  Darkenmask=""
  Multiplymedianmean=""
  Multiplyminmax=""
  Negate=""
  Radius1=""
  Radius2=""
  Sigma1=""
  Sigma2=""
  Soft=""
  Softready=""
  Swap=""
  Weight=""
  Word1=""
  Word2=""
  while read -d, Line; do
    grep -q "=" <<< "$Line" && {
      Key="$(cut   -d= -f1    <<< "$Line")"
      Value="$(cut -d= -f2 -s <<< "$Line")"
      :
    } || {
      Key="$(digitrm "$Line")"
      Value="$(sed "s/${Key:-NOKEY}//"  <<< "$Line")"
    }
    case $Key in
      "%"|"w"|"w%")       Weight="$Value" ;;
      "r")                Radius1="$Value" ;;
      "R")                Radius2="${Value:-auto}" ;;
      "s")                Sigma1="$Value" ;;
      "S")                Sigma2="${Value:-auto}" ;;
      "swap")             Swap="swap" ;;
      "soft")             Soft="soft" ;;
      "SOFTREADY")        Softready="${Value:-soft}" ;;
      "d"|"diff")         Diff="s" ;;
      "less")             Less="${Value:-auto}" ;;
      "M")                Multiplyminmax="M"
        Difference_needlist="$Difference_needlist minmaxdiff"
        Evaluate_needlist="$Evaluate_needlist min max" ;;
      "m")                Multiplymedianmean="m"
        Difference_needlist="$Difference_needlist medianmeandiff"
        Evaluate_needlist="$Evaluate_needlist median mean" ;;
      "n"|"neg"|"negate") Negate="neg" ;;
      "c"|"close"|"cx"|"closex") 
        Value="$(tr -d "close" <<< "$Line")"
        Close1=$(cut -dx    -f1 <<< "$Value")
        Close2=$(cut -dx -s -f2 <<< "$Value")
        Close1="$(digitonly "$Close1")"
        Close2="$(digitonly "$Close2")"
        Close1="${Close1:-4}"
      ;;
      "CLOSE1")           Close1="$Value" ;;
      "CLOSE2")           Close2="$Value" ;;
      "LEVEL")            Level="yes" ;;
      "LEVELMIN")         Levelmin="$Value" ;;
      "LEVELMAX")         Levelmax="$Value" ;;
      "DARKENMASK")       Darkenmask="$Value" ;;
      "NUM")              Maskmethodcount="$Value" ;;
      "METHOD")           Method="$Value" ;;
      *|WORD1|WORD2) ### FIXME
        [ -z "$Word1" ] && Word1="$Line" || Word2="$Line" 
        Word1="${Word1#WORD1=}"
        Word2="${Word2#WORD2=}"
      ;;
    esac
  done <<< "${1:-},"
  [ "$Less" = "auto" ] && case $Method in
    blur)       Less="15" ;;
    diffstat)   Less="5" ;;
    compass)    Less="4" ;;
    freichen)   Less="4" ;;
    gaussian)   Less="15" ;;
    kirsch)     Less="2" ;;
    log)        Less="15" ;;
    morphology) Less="20" ;;
    sobel)      Less="2" ;;
    wavelet)    Less="60" ;;
    *)          Less="8" ;;
  esac
  Maskbasename="mask.$Method.r$Radius1.R$Radius2.s$Sigma1.S$Sigma2.$(unspecialstring "$Word1").$(unspecialstring "$Word2").c$Close1.$Close2.$Diff.$Negate.$Swap.$Softready.$Firstimagemd5"
}
maskarg_donttake() {
  while [ $# -gt 0 ]; do
    case ${1:-} in
      weight)  [ "$Weight" ]        && error "--$Method does not take argument w (weight)"              && Weight="" ;;
      radius1) [ "$Radius1" ]       && error "--$Method does not take argument r (radius1)"             && Radius1="" ;;
      radius2) [ "$Radius2" ]       && error "--$Method does not take argument R (radius2)"             && Radius2="" ;;
      sigma1)  [ "$Sigma1" ]        && error "--$Method does not take argument s (sigma1)"              && Sigma1="" ;;
      sigma2)  [ "$Sigma2" ]        && error "--$Method does not take argument S (sigma2)"              && Sigma2="" ;;
      soft)    [ "$Soft" ]          && error "--$Method does not take argument soft"                    && Soft="" ;;
      swap)    [ "$Swap" ]          && error "--$Method does not take argument swap"                    && Swap="" ;;
      close)   [ "$Close1$Close2" ] && error "--$Method does not take argument c (close)"               && Close1="" && Close2="" ;;
      word1)   [ "$Word1" ]         && error "--$Method does not take a word argument ($Word1)"         && Word1="" ;;
      word2)   [ "$Word2" ]         && error "--$Method does not take a second word argument ($Word2)"  && Word2="" ;;
      negate)  [ "$Negate" ]        && error "--$Method does not take argument n (negate)"              && Negate="" ;;
    esac
    shift
  done
}
maskarg_store() {
  Maskmethodcount="${1:-$Maskmethodcount}"
  Newoption="NUM=$Maskmethodcount"
  Newoption="$Newoption,METHOD=$Method"
  #Newoption="$Newoption,BASENAME=mask.$Maskmethodcount.$Method"
  [ "$Weight" ]             && Newoption="$Newoption,w=$Weight"
  [ "$Radius1" ]            && Newoption="$Newoption,r=$Radius1"
  [ "$Radius2" ]            && Newoption="$Newoption,R=$Radius2"
  [ "$Sigma1" ]             && Newoption="$Newoption,s=$Sigma1"
  [ "$Sigma2" ]             && Newoption="$Newoption,S=$Sigma2"
  [ "$Less" ]               && Newoption="$Newoption,less=$Less"
  [ "$Close1" ]             && Newoption="$Newoption,CLOSE1=$Close1"
  [ "$Close2" ]             && Newoption="$Newoption,CLOSE2=$Close2"
  [ "$Word1" ]              && Newoption="$Newoption,WORD1=$Word1"
  [ "$Word2" ]              && Newoption="$Newoption,WORD2=$Word2"
  [ "$Diff" ]               && Newoption="$Newoption,diff"
  [ "$Soft" ]               && Newoption="$Newoption,soft"
  [ "$Softready" ]          && Newoption="$Newoption,SOFTREADY=$Softready"
  [ "$Negate" ]             && Newoption="$Newoption,negate"
  [ "$Swap" ]               && Newoption="$Newoption,swap"
  [ "$Darkenmask" ]         && Newoption="$Newoption,DARKENMASK=$Darkenmask"
  [ "$Multiplyminmax" ]     && Newoption="$Newoption,M"
  [ "$Multiplymedianmean" ] && Newoption="$Newoption,m"
  [ "$Level" ]              && Newoption="$Newoption,LEVEL"
  [ "$Levelmin" ]           && Newoption="$Newoption,LEVELMIN=$Levelmin"
  [ "$Levelmax" ]           && Newoption="$Newoption,LEVELMAX=$Levelmax"
  Maskmethodlist="$(sed "/NUM=$Maskmethodcount,/d" <<< "$Maskmethodlist")"
  Maskmethodlist="$Maskmethodlist
$Newoption"
  Maskmethodlist="$(grep "\S" <<< "$Maskmethodlist")"
}
main() {
  trap trap_sigint SIGINT
  set -u
  
  declare_variables
  
  command -v convert >/dev/null && Magickbin="convert"
  command -v magick  >/dev/null && Magickbin="magick"
  [ -z "$Magickbin" ] && error "Neither command convert nor magick found. Please install ImageMagick."
  Magickversion="$($Magickbin -version)"
  grep -q " Q8 "   <<< "$Magickversion" && Magickpixelmemory="4"
  grep -q " Q16 "  <<< "$Magickversion" && Magickpixelmemory="8"
  grep -q " HDRI " <<< "$Magickversion" && Magickpixelmemory="16"
  [ "$Error" ] && return 1
  
  Freemem="$(freememory)"
  [ -z "$Freemem" ] && {
    note "WARNING: failed to estimate free memory.
  Blindly guessing 1000 MB."
    Freemem="1000000"
  }
  
  parse_options "$@"
  check_options
  verbose "Mask options:
$Maskmethodlist
"
  [ "$Error" ] && return 1
  
  Sourceimagelist="$(grep -v -x "" <<< "$Sourceimagelist")"
  Imagenumber="$(grep -c "." <<< "$Sourceimagelist")"
  Imagenumberlength="${#Imagenumber}"
  
  Image="$(head -n1 <<< "$Sourceimagelist")"
  Imagewidth="$($Magickbin  -format '%w' "$Image" info:)"
  Imageheight="$($Magickbin -format '%h' "$Image" info:)"
  Imagememsize="$((Imagewidth*Imageheight*Magickpixelmemory/1000))"
  Imagememsize="$((Imagememsize*125/100))" # by observation. Alpha channel? Meta data?
  Imagelistmemsize="$((Imagenumber*Imagememsize))"
  Image=""
  
  verbose "Image number: $Imagenumber
  Image width:  $Imagewidth
  Image height: $Imageheight
  Image memory size:      $Imagememsize kb
  Image list memory size: $Imagelistmemsize kb
  Free Memory:            $Freemem kb"

  Testimage="$Cachedir/test.tif"
    
  mkdir -p $Cachedir || error "Error creating cache folder $Cachedir"
  
  Firstimage="$(head -n1 <<< "$Sourceimagelist")" 
  Firstimagemd5="$(md5sum "$(head -n1 <<< "$Firstimage")" | cut -d' ' -f1)"
  Firstimagemd5file="$Cachedir/md5"
  [ "$(cat "$Firstimagemd5file" 2>/dev/null)" != "$Firstimagemd5" ] && rm $Cachedir/* 2>/dev/null
  echo "$Firstimagemd5" > "$Firstimagemd5file"
  [ "$Error" ] && return 1
  
  Multiplyminmaximage="$Cachedir/difference.minmaxdiff.$Firstimagemd5.tif"
  Multiplymedianmeanimage="$Cachedir/difference.meanmediandiff.$Firstimagemd5.tif"
  
  focus_generate_masks                  || return 1
  focus_merge_masks                     || return 1
  case $Softmode in
    "") focus_fuse        $Resultimage  || return 1 ;;
    *)  focus_fuse --soft $Resultimage  || return 1 ;;
  esac
  [ "$Layers" ] && focus_sharpness_layer
      
  [ "$Error" ] && return 1

  $Magickbin "$Resultimage" $Tifstore "$Outputimage"  || error "Error storing result in $Outputimage"
  showimage "$Outputimage"
  note "Ready after $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")
$Outputimage"
    
  return "${Error:-0}"
}

main "$@"
[ -z "$Preservecache" ] && [ -d "$Cachedir" ] && rm -R "$Cachedir"
exit "${Error:-0}"
