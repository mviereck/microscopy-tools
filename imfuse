#! /bin/bash

# imfuse
Version="0.2"

usage() {
  echo "imfuse v$Version - combine focus stackshot images to an overall sharp image.
Aims to be similar to enfuse, but with the help of ImageMagick.

Dependencies:
  imagemagick      Mandatory (command 'convert' or 'magick').
  geeqie           Optional, used by option -V, --showimage.
  enfuse           Optional, used by option --enfuse.

Usage:
  imfuse [OPTIONS] -- image1 image2 image3 ...

General options:
     --cachedir=DIR          Specify a cache folder.
 -h, --help                  Show this help and exit.
     --layers [=NUMBER]      Additonally store two layered TIFF images
                             with segregated source part and sharpness layers.
                             NUMBER is number of sharpness layers. Default: 25
                             Does not work with --compose or --evaluate.
 -o, --output=FILE           Specify result image.
 -v, --verbose               Show verbose output.
     --version               Show imfuse version and exit.
 -V, --showimage             Show intermediate results with geeqie.
 
imfuse provides two basic ways to get overall sharp results.
The traditional way is mask comparision with the mask generating methods below.
The most recommended traditional mask method is --statistic=standarddeviation.
Another, faster attempt compares max and min images and combines them
with the compositing methods.                            Default: --compose

Compositing methods:
     --compose [=MODE]       Composes a result with mode MODE based on a max
                             and a min calculation of the source images.
                             Compare IM option -compose. Default: overlay
                             MODE can be one of '$(basename $Magickbin) -list compose'
                             Some MODEs of interest:
                               bumpmap colorburn difference linearburn 
                               linearlight modulate multiply overlay pegtoplight
                             Takes options:
                               --swap       
                             Hint: Generate max+min images with --evaluate and
                             provide only them to --compose to speed it up.
     --evaluate [=MODE]      Evaluates a result of all source images with
                             mode MODE.                  Default: max
                             MODE can be one of '$(basename $Magickbin) -list evaluate'
                             Compare IM option -evaluate-sequence.
                             Most of interest:
                               max      Brightest pixels in sequence. 
                                        Fast and pretty result.
                               mean     Average pixel values in sequence. 
                                        Useful to combine imfuse results.
                               median   Middle pixel values in sequence. 
                                        Useful to combine imfuse results.
                               min      Darkest pixels in sequence.
                             
Mask generating methods:
     --blur                  Blur edge detection. Takes options: 
                               --radius                  Default: 0
                               --sigma1                  Default: 0.5
                             Difference calculation with option:
                               --radius2                 Default: 0
                               --sigma2                  Default: 1.6*sigma1
     --compass               Compass edge detection. 
     --enfuse [=ENFUSEARGS]  Uses external binary enfuse for mask generation.
                             Takes options: 
                               --radius                  Default: 5
                             Optionally add custom enfuse options ENFUSEARGS.
                             One of interest is '--hard-mask'.
                             Option --radius sets --contrast-window-size=RADIUS.
     --free='IMOPTION'       Custom ImageMagick option IMOPTION 
                             for mask generation.        Default: '-edge 2'
     --freichen              Frei-Chen edge detection.
     --gaussian              Gaussian blur edge detection.
                             Takes options: 
                               --radius                  Default: 0
                               --sigma1                  Default: 0.5
                             Difference (DoG) calculation with option:
                               --sigma2                  Default: sigma1*1.6
     --kirsch                Kirsch edge detection. 
     --laplacian [=MODE]     Laplacian edge detection.
                             MODE is the kernel number to use.
     --log                   Laplacian of Gaussian.
                             Takes options: 
                               --radius                  Default: 0
                               --sigma1                  Default: 0.5
                             Difference calculation with options:
                               --radius2                 Default: 0
                               --sigma2                  Default: sigma1*1.6
     --mediff                Difference of mean and median statistics.
                             Takes options:
                               --radius                  Default: 5
                             Difference calculation with option:
                               --radius2                 Default: radius1*3/2
     --prewitt               Prewitt edge detection. 
     --roberts               Roberts edge detection. 
     --sobel                 Sobel edge detection. 
     --statistic [=MODE]     ImageMagick option -statistic.
                             Takes options:
                               --radius                  Default: 2
                             Difference calculation with option:
                               --radius2                 Default: radius1*3/2
                             Argument MODE is one of:
                                      gradient|grad
                                      maximum|max
                                      mean
                                      median
                                      minimum|min
                                      mode
                                      nonpeak
                                      rms
                                      standarddeviation|dev
                             Default: standarddeviation
     --unsharp               Difference of -unsharp.
                             Takes options: 
                               --radius                  Default: 0
                               --sigma1                  Default: 3
                               --sigma2                  Default: 1.6*sigma1
                                      

Method settings: (Effect depends on method, see above.)
 -r, --radius=RADIUS1        Automatically chooses a radius if RADIUS=0
 -R, --radius2=RADIUS2       Second radius for difference masks.  
 -s, --sigma=SIGMA1          Sigma for some mask generating methods.
 -S, --sigma2=SIGMA2         Second sigma for difference masks. 
     --swap                  Invert order of max/min in --compose.
                             Changes result of some but not all compose modes.
 
Method independent adjustments:
 -g, --gamma [=GAMMA]        Adjust gamma of result. GAMMA>1 brightens the image,
                             GAMMA<1 darkens the image.  Default GAMMA: auto
     --grayscale=ARG         Grayscale converting method before mask generation.
                             ARG is one of: (number or name)
                   0 none
                   1 Rec601Luma       0.298839R' + 0.586811G' + 0.114350B'
                   2 Rec601Luminance  0.298839R  + 0.586811G  + 0.114350B
                   3 Rec709Luma       0.212656R' + 0.715158G' + 0.072186B'
                   4 Rec709Luminance  0.212656R  + 0.715158G  + 0.072186B
                   5 Brightness       max(R', G', B')
                   6 Lightness        (min(R', G', B') + max(R', G', B')) / 2.0
                   7 Average          (R' + G' + B') / 3.0
                   8 MS               (R'^2 + G'^2 + B'^2) / 3.0
                   9 RMS              sqrt( (R'^2 + G'^2 + B'^2) / 3.0 )
                             Compare IM options -grayscale and -intensity.
                             Does not affect --compose or --evaluate.
     --noise [=ARG]          Mask noise filter.          Default ARG: 3
                             Does not affect --compose or --evaluate.
 -t, --threshold [=PERCENT]  Do not use pixels less significant than PERCENT%.
                             You might prefer --layers.  Default PERCENT: 5
                             Does not affect --compose or --evaluate.
"
}

### Messages

error() {
  [ -z "$Error" ] && echo "imfuse ERROR: $*
" >&2
  Error=1
  #exit 1
}
note() {
  [ -z "$Error" ] && echo "imfuse note: $*"
  return 0
}
verbose() {
  [ "$Verbose" = "yes" ] && echo "imfuse: $*"
  return 0
}
showimage() {
  [ "$Showimage" = "yes" ] && geeqie -t -r File:"${1:-}" &
  return 0
}

### Misc

freememory() {
  local Freemem Line Zram
  Freemem="$(LC_ALL=C free | grep "Mem:" | awk '{print $7}')"
  while read Line; do
    Zram="$(awk '{print ($3 - $4)}' <<< "$Line")"
    Zram="$((Zram/1000))"
    Freemem="$((Freemem + Zram))"
  done < <(/sbin/swapon --bytes | grep zram)
  Freemem="$((Freemem*100/95))"
  echo $Freemem
}
lowercase() {
    # Usage: lowercase "string"
    printf '%s\n' "${1,,}"
}
printnum(){
  # print number $1 with leading zeroes.
  # $1 number
  # $2 digits. Default: 3
  printf %0${2:-3}d "${1:-0}"
}
trap_sigint() {
  error "Received SIGINT"
}

### Image processing

compose_stepx() {
  local Stacklist Imagenumber Stackcount Stackdir Step Image1 Image2 Image3
  Stacklist="$Imagelist"
  Imagenumber="$(grep -c . <<< "$Stacklist")"
  while :; do
    [ "$Error" ] && break
    Stackcount="$((Stackcount+1))"
    echo $Stackcount
    Stackdir=$Cachedir/stack$Stackcount
    mkdir -p $Stackdir
    Imagenumber="$(grep -c . <<< "$Stacklist")"
    [ "$Imagenumber" -lt "2" ] && break
    for Step in $(seq $((Imagenumber/2)) ); do
      [ "$Error" ] && break
      Image1="$(head -n+$Step       <<< "$Stacklist" | tail -n1)"
      Image2="$(head -n+$((Step+1)) <<< "$Stacklist" | tail -n1)"
      [ -z "$Image2" ] && break
      Image3="$(head -n+$((Step+2)) <<< "$Stacklist" | tail -n1)"
      [ "$((Step*2+1))" = "$Imagenumber" ] || Image3=""
      $Magickbin \
        $Image1 $Image2 $Image3 \
          \( -clone 0--1 -evaluate-sequence max -write mpr:max \) \
          \( -clone 0--1 -evaluate-sequence max -write mpr:min \) \
          -delete 0--1 \
        mpr:max mpr:min $Swapcompose \
          -compose multiply -composite -gamma 2 \
        $Tifstore \
        $Stackdir/composite.$Step.tif
      showimage $Stackdir/composite.$Step.tif
    done
    Stacklist="$(ls $Stackdir/* | sort -V)"
  done
}

compose_step2() {

  Stackcount=0
  Startzeit="$(date +%s)"
  for Step in 0 $(seq $((Imagenumber/$Stepsize)) ); do
    [ "$Error" ] && break
    Stackcount="$((Stackcount+1))"
    Stacklist="$(tail -n+$((Stepsize*Step+1)) <<< "$Imagelist" | head)"
    [ -z "$Stacklist" ] && break
    $Magickbin $Stacklist -evaluate-sequence max $Cachedir/max.$Stackcount.tif
    $Magickbin $Stacklist -evaluate-sequence min $Cachedir/min.$Stackcount.tif
    $Magickbin $Cachedir/max.$Stackcount.tif $Cachedir/min.$Stackcount.tif -compose overlay -composite $Cachedir/overlay.$Stackcount.tif
    showimage $Cachedir/overlay.$Stackcount.tif
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-((Step+1)*Stepsize)) / ((Step+1)*Stepsize) ))"
    [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
    note "compose: Duration: $(date -u -d @$Dauer +"%T"); Estimated time left: $(date -u -d @$Restzeit +"%T") ($Restzeit)"
  done
  $Magickbin $Cachedir/overlay* -evaluate-sequence max $Cachedir/max.overlay.tif
  $Magickbin $Cachedir/overlay* -evaluate-sequence max $Cachedir/min.overlay.tif
  $Magickbin $Cachedir/max.overlay.tif $Cachedir/min.overlay.tif -compose overlay -composite $Cachedir/overlay.overlay.tif
  showimage $Cachedir/overlay.overlay.tif
}
evaluate_split() {

  local Imagelist Resultimage Mode
  local Startzeit Dauer Restzeit
  local Image Split Splitpercent Showsplit Part Partimage Partimagelist
  local Startzeit Dauer Restzeit Count
  
  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  while [ $# -gt 0 ]; do
    Imagelist="$Imagelist
${1:-}"
    shift
  done
  Imagelist="$(tail -n+2 <<< "$Imagelist")"
  
  Split="$((Imagelistmemsize/Freemem +1))"
  
  verbose "Generating $Mode image $(basename "$Resultimage") in $Split parts."
  case $Split in
    1) 
      $Magickbin $Imagelist -evaluate-sequence $Mode $Tifstore $Resultimage || error "Error in evaluate_split / $Mode"
    ;;
    *)
      Startzeit="$(date +%s)"
      Splitpercent="$((100/Split))"
      Showsplit="$(printnum $(( (Split+1)/2 )) 3)"
      Count="0"
      for Image in $Imagelist; do
        [ "$Error" ] && break
        Count="$((Count+1))"
        verbose "Splitting image $Count / $Imagenumber into $Split pieces due to low memory: $(basename $Image)"
        $Magickbin $Image -crop 100%x${Splitpercent}% $Tifstore $Cachedir/split%03d.$(basename $Image).tif || error "Error in evaluate_split / crop"
        showimage $Cachedir/split${Showsplit}.$(basename $Image).tif
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
      done
      Startzeit="$(date +%s)"
      for Part in $(seq 0 $((Split-1))) ; do
        [ "$Error" ] && break
        verbose "Evaluating part $((Part+1)) / $Split"
        Partimage=$Cachedir/$Mode.part$Part.tif
        $Magickbin $Cachedir/split$(printnum $Part 3).*.tif -evaluate-sequence $Mode $Tifstore $Partimage || error "Error in evaluate_split / evaluating parts"
        Partimagelist="$Partimagelist $Partimage"
        showimage $Partimage
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Split-Part+1) / (Part+1) ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
      done
      [ "$Error" ] && return 1
      $Magickbin $Partimagelist -append $Tifstore $Resultimage  || error "Error in evaluate_split / appending parts"
    ;;
  esac
  showimage $Resultimage
  return "${Error:-0}"
}
fuse_focus_stackshot()  {
  # fuse focus image stackshot.
  # Based on snibgo's focus stacking script at http://im.snibgo.com/focstack.htm
  
  local Count Number Line
  local Sourcemask Maskmax Sourcemasklist Enfusemasklist
  local Maskgenerator
  local Startzeit Dauer Restzeit
  local Color Pixelnumber Pixelcount Layerimage Layerimagelist Colornumber
  
  Maskgenerator="$(maskfilter)"
  Maskmax="$Cachedir/mask.max.tif"
    
  # --negate
  [ "$Negate" = "yes" ] && {
    Maskgenerator="-negate 
$Maskgenerator"
  }

  Maskgenerator="$Grayscaleconverter
$Maskgenerator"

  [ "$Noise" ] && Maskgenerator="$Maskgenerator
-statistic nonpeak $Noise"
    
  verbose "Generating masks with:
$Maskgenerator"
    
  # Generate masks
  Startzeit="$(date +%s)"
  Count=0
  case $Method in
    enfuse)
      enfuse --contrast-weight=1 --saturation-weight=0 --exposure-weight=0 \
               --save-masks="$Cachedir/enfuse-softmask-%n.tif":"$Cachedir/enfuse-hardmask-%n.tif" \
               --contrast-window-size=$Radius1 \
               -o enfuse-out.tif \
               --verbose \
               $Maskgeneratorargument \
               $Imagelist \
               2>&1 | grep -v -E 'no usable resolution|loading next image|will assume 300 dpi|assuming all pixels|does not have an alpha channel' #|| error "Error in enfuse"
               
      grep -q "hard-mask" <<< "$Maskgeneratorargument" && {
        Enfusemasklist="$(find $Cachedir/enfuse-hardmask* | sort -V)"
      } || {
        Enfusemasklist="$(find $Cachedir/enfuse-softmask* | sort -V)"
      }
      Count="0"
      while read Line; do
        Count="$((Count+1))"
        Number="$(printnum $Count $Imagenumberlength)"
        Sourcemask="$Cachedir/mask.${Number}.tif"
        $Magickbin "$Line" -depth 16 $Tifstore "$Sourcemask"
        Sourcemasklist="$Sourcemasklist $Sourcemask"
      done <<< "$Enfusemasklist"
    ;;
    *)
      for Sourceimage in $Imagelist; do
        [ "$Error" ] && break
        Count="$((Count+1))"
        Number="$(printnum $Count $Imagenumberlength)"
        Sourcemask="$Cachedir/mask.${Number}.tif"
        
        $Magickbin $Sourceimage -depth 16 $Maskgenerator -alpha off $Tifstore $Sourcemask || error "Error in source mask generation"
        showimage $Sourcemask
    
        Sourcemasklist="$Sourcemasklist $Sourcemask"
    
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
        verbose "$Method: Generating mask $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
      done
    ;;
  esac
  [ "$Error" ] && return "${Error:-0}"
  
  # max of masks to level single masks
  evaluate_split max $Maskmax $Sourcemasklist || return 1
  
    Imageproperties="$($Magickbin "$Maskmax" -format '
Imagemean=%[mean]
Imagequantumrange=%[fx:quantumrange]
Imageautogamma=%[fx:log(mean)/log(0.5)]
Imageminlevel=%[fx:minima*100]
Imagemaxlevel=%[fx:maxima*100]
Imageminlevelred=%[fx:minima.r*100]
Imagemaxlevelred=%[fx:maxima.r*100]
Imageminlevelgreen=%[fx:minima.g*100]
Imagemaxlevelgreen=%[fx:maxima.g*100]
Imageminlevelblue=%[fx:minima.b*100]
Imagemaxlevelblue=%[fx:maxima.b*100]
' info:)"

  verbose "Image properties of $Maskmax: 
$Imageproperties"
  eval $Imageproperties
  
  # Level masks into visible range. Technically not needed, but helpful for human analysis. Also needed for --threshold.
  Startzeit="$(date +%s)"
  Count=0
  for Image in $Sourcemasklist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    $Magickbin $Image -depth 16 -level ${Imageminlevel}%,${Imagemaxlevel}% +level 1%,99% $Tifstore $Image || error "Error in leveling masks"
    showimage $Image
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Leveling $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
  done
  [ "$Error" ] && return "${Error:-0}"

  # max of masks to compare single masks
  evaluate_split max $Maskmax $Sourcemasklist || return 1
  cp $Maskmax $Maskmax.strip.tif
  
  #Stripmask=no
  
  Startzeit="$(date +%s)"
  Count=0
  for Sourceimage in $Imagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    Sourcemask="$Cachedir/mask.${Number}.tif"
    
    #cp $Sourcemask $Sourcemask.bak.tif
    
    # Load maskmax and sourcemask into memory. Apply threshold if given.
    Command="$Magickbin \
      $Maskmax.strip.tif \
        -write mpr:maskmax \
        -delete 0 \
      $Sourcemask \
        -black-threshold ${Threshold:-0}% \
        -write mpr:sourcemask \
        -delete 0"
    # keep only parts of source mask that fit maskmax (greatest sharpness in stack)
    # remove source mask from maskmax to avoid overwrite by later masks with same sharpness areas.
    [ "$Stripmask" = "yes" ] && Command="$Command \
      mpr:sourcemask mpr:maskmax \
        -compose MinusDst -composite -fill white +opaque black -negate \
        -write mpr:sourcemask \
        -delete 0
      mpr:sourcemask mpr:maskmax \
        -evaluate-sequence max \
        -write $Maskmax.strip.tif \
        -delete 0"
    # get part of source image
    # clean transparent area 
    Command="$Command \
      $Sourceimage mpr:sourcemask \
        -alpha Off -compose CopyOpacity -composite \
        -write mpr:sourcepart \
        -delete 0 \
      mpr:sourcepart \
        -background blue -alpha background \
        -write mpr:sourcepart \
        -delete 0"
    # save source image parts for layered tif
    [ "$Storelayers" ] && Command="$Command \
      mpr:sourcepart \
        -type TrueColorAlpha \
        $Tifstore -write $Sourcemask \
        -delete 0"
    Command="$Command \
      $Resultimage mpr:sourcepart \
        -compose Over -composite \
        -type TrueColorAlpha \
      $Tifstore $Resultimage"
    $Command
            
    showimage $Resultimage
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "$Method $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
  done
  
  [ "$Storelayers" ] && {
    verbose "Creating layered result with parts in use of source images"
    Image="$(rev <<< "$Outputimage" | cut -d. -f2- | rev).layered_parts.tif"
    $Magickbin $Backgroundimage $Sourcemasklist $Tifstore "$Image" || note "Failed to create layered parts result image."
  }
  
  [ "$Storelayers" ] && {
    Colornumber="$($Magickbin $Maskmax -depth 16 -define histogram:unique-colors=true -format %c histogram:info:- | awk '{print $3}' | wc -l)"
    Layerminpixel="$(( Imagewidth*Imageheight/(Layernumber-1) ))"
    verbose "Creating $Layernumber layers of sharpness areas"
    Count=0
    Layercount=0
    Startzeit="$(date +%s)"
    Pixelcount=0
    Pixelnumber=0
    while read Line; do
      Count=$((Count+1))
      [ "$Error" ] && break
      Color="$(awk '{print $3}' <<< "$Line")"
      Pixelnumber="$(awk '{print $1}' <<< "$Line")"
      Pixelnumber="${Pixelnumber%:}"
      Pixelcount="$((Pixelcount+Pixelnumber))"
      [ "$Pixelcount" -lt "$Layerminpixel" ] && {
        Color1="${Color1:-$Color}"
      }
      { [ "$Pixelcount" -gt "$Layerminpixel" ] || [ "$Count" = "$Colornumber" ] ; } && {
        Layercount="$((Layercount+1))"
        Layerimage="$Cachedir/layer_sharpness.$(printnum $Layercount).tif"
        $Magickbin \
          $Maskmax \
            -depth 16 \
            -color-threshold "${Color1:-$Color}"-"$Color" \
            -write mpr:layermask \
            -delete 0 \
          $Resultimage mpr:layermask \
            -colorspace sRGB \
            -alpha Off -compose CopyOpacity -composite \
            -background blue -alpha background \
          $Tifstore $Layerimage || {
            note "Error in generating sharpness layers"
            break
        }
        Layerimagelist="$Layerimagelist $Layerimage"
        Color1=""
        Pixelcount="0"
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Colornumber-Count) / Count ))"
        verbose "Layer $Layercount/$Layernumber. Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
        showimage $Layerimage
      }
        
    done < <($Magickbin $Maskmax -depth 16 -define histogram:unique-colors=true -format %c histogram:info:-)
    verbose "Creating layered result of sharpness areas"
    Image="$(rev <<< "$Outputimage" | cut -d. -f2- | rev).layered_sharpness.tif"
    $Magickbin $Backgroundimage -type TrueColorAlpha $Layerimagelist $Tifstore "$Image" || note "Failed to create layered sharpness result image."
  }
  
  return "${Error:-0}"
}
bak() {

    Command="$Magickbin \
      $Maskmax.strip.tif \
        -write mpr:maskmax \
        -delete 0 \
      $Sourcemask \
        -black-threshold ${Threshold:-0}% \
        -write mpr:sourcemask \
        -delete 0 \
      mpr:sourcemask mpr:maskmax \
        -compose MinusDst -composite -fill white +opaque black -negate \
        -write mpr:sourcemask \
        -delete 0"
    Command="$Command
      mpr:sourcemask mpr:maskmax \
        -evaluate-sequence max \
        -write $Maskmax.strip.tif \
        -delete 0"
    Command="$Command
      $Sourceimage mpr:sourcemask \
        -alpha Off -compose CopyOpacity -composite \
        -write mpr:sourcemask \
        -delete 0 \
      mpr:sourcemask \
        -background blue -alpha background \
        -write mpr:sourcemask \
        -delete 0 \
      $Resultimage mpr:sourcemask \
        -colorspace sRGB \
        -compose Over -composite \
      $Tifstore \
      $Resultimage"
    $Command

  ###########
  
    # Only keep parts of source mask that are same with max mask. -> Only the sharpest parts of this mask will be used, sharper or equal than later masks.
    $Magickbin $Sourcemask -black-threshold ${Threshold:-0}% $Maskmax -compose MinusDst -composite -fill white +opaque black -negate $Sourcemask
    # Disable already used parts of mask to avoid overwrite by later masks.
    $Magickbin $Sourcemask $Maskmax -evaluate-sequence max $Maskmax
    
    $Magickbin $Sourceimage $Sourcemask -alpha Off -compose CopyOpacity -composite $Sourcemask
    $Magickbin $Sourcemask -background blue -alpha background $Sourcemask
    $Magickbin $Resultimage $Sourcemask -compose Over -composite $Resultimage 
    
    ############################

    cp $Sourcemask $Sourcemask.bak.tif
    # Only keep parts of source mask that are same with max mask. -> Only the sharpest parts of this mask will be used, sharper or equal than later masks.
    $Magickbin $Sourcemask -black-threshold ${Threshold:-0}% $Maskmax -compose MinusDst -composite -fill white +opaque black $Sourcemask
    # Disable already used parts of mask to avoid overwrite by later masks.
    $Magickbin $Sourcemask -negate $Maskmax -evaluate-sequence max $Maskmax
    
    showimage $Resultimage
    $Magickbin \
          $Sourceimage $Resultimage $Sourcemask \
            -alpha off -compose Over -composite $Writeresultcount \
            "$Resultimage" || error "Error in fuse"
            
}
fuse_focus_stackshotBAK()  {
  # fuse focus image stackshot.
  # Based on snibgo's focus stacking script at http://im.snibgo.com/focstack.htm
  
  local Count Number Firstimage 
  local Sourcemask Resultmask Diffmask Resultcount Sourcecount
  local Maskgenerator Maskgenerator2
  local Writesourcemask Writeresultmask Writediffmask Writesourcecount Writeresultcount
  local Startzeit Dauer Restzeit
  
  # Use first image as base of result
  Firstimage="$(head -n1 <<< "$Imagelist")"
  $Magickbin "$Firstimage" "$Resultimage" || error "Error while reading first image"
  
  showimage "$Resultimage"
  
  # Interate on rest of image list
#  Count=1
#  for Sourceimage in $(grep -v -x "$Firstimage" <<< "$Imagelist"); do
  Startzeit="$(date +%s)"
  Count=0
  for Sourceimage in $Imagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    Sourcemask="$Cachedir/${Number}.mask.source.tif"
    Resultmask="$Cachedir/${Number}.mask.result.tif"
    Resultcount="$Cachedir/${Number}.result.tif"
    Diffmask="$Cachedir/${Number}.mask.diff.tif"
    [ "$Savemask" = "yes" ] && {
      Writesourcemask="-write $Sourcemask"
      Writeresultmask="-write $Resultmask"
      Writeresultcount="-write $Resultcount"
      Writediffmask="-write $Diffmask"
    }
    
    verbose "Processing Image $Count / $Imagenumber with method $Method in fuse mode $Mode: $(basename $Sourceimage)" 
    
    # Mask generating ImageMagick options
    # Most of them are based on edge detection: http://www.imagemagick.org/Usage/convolve/#edgedet
    Maskgenerator=""
    Maskgenerator2=""
    case $Method in
      blur)
        # Compare two blurred images with different sigma.
        # Concept and result is similar to Difference of Gaussian (DoG). Using -gaussian-blur gives same as DoG.
        # Code based on https://im.snibgo.com/simpalign.htm#twoBlrDiff.bat
        Maskgenerator="( -clone 0 -blur ${Radius1}x${Sigma1} )
                       -compose Difference -composite"
#                       -grayscale RMS"
      ;;
      blur1)
        # Compare two blurred images with different sigma.
        # Concept and result is similar to Difference of Gaussian (DoG). Using -gaussian-blur gives same as DoG.
        # Code based on https://im.snibgo.com/simpalign.htm#twoBlrDiff.bat
        Maskgenerator="( -clone 0 -blur ${Radius1}x${Sigma1} )
                       ( -clone 0 -blur ${Radius1}x${Sigma2} )
                       -delete 0
                       -compose Difference -composite"
#                       -grayscale RMS"
      ;;
      blur2)
        Maskgenerator="( -clone 0 -blur ${Radius1}x${Sigma1} )
                       ( -clone 0 -blur ${Radius1}x${Sigma2} )
                       -delete 0
                       -compose Mathematics -define compose:args=0,-4,4,0.5 -composite
                       -grayscale RMS"
      ;;
      compass)
        Maskgenerator="-define convolve:scale=50%!
                       -define convolve:bias=50%
                       -morphology Convolve Compass" ### FIXME
      ;;
      gaussian) # DoG: Difference of Gaussian
        # This will generate a 'DoG' or "Difference of Gaussians" kernel in which 
        # the gaussian generated by 'sigma1' will have the gaussian generated by 'sigma2' subtracted from it. 
        # Normally 'sigma2' is the larger so that the 'central peak' of the kernel is positive. 
        # Reversing the two numbers will effectivally negate the resulting kernel. 
        # By generating two 'Gaussian' kernels of slightly different sigma values (in a ratio of approximatally 1.6), 
        # and subtracting them from each other you can actually generate a close approximation of a Laplacian of a Gaussian. 
        Maskgenerator="-define convolve:bias=50%
                       -morphology Convolve DoG:$Radius1,$Sigma1,$Sigma2"
      ;;
      enfuse) # masks generated by enfuse instead by ImageMagick
        (
          cd "$Cachedir" 
          enfuse --contrast-weight=1 --saturation-weight=0 --exposure-weight=0 \
               --save-masks \
               --contrast-window-size=$Radius1 \
               -o enfuse-out.tif \
               $Maskgeneratorargument \
               "$Sourceimage" "$Resultimage" \
               2>&1 | grep -v -E 'no usable resolution|loading next image|will assume 300 dpi|assuming all pixels|does not have an alpha channel'
          grep -q "hard-mask" <<< "$Maskgeneratorargument" && {
            mv hardmask-1.tif $Sourcemask
            mv hardmask-2.tif $Resultmask
          } || {
            mv softmask-1.tif $Sourcemask
            mv softmask-2.tif $Resultmask
          }
          rm softmask-1.tif softmask-2.tif hardmask-1.tif hardmask-2.tif enfuse-out.tif 2>/dev/null
        )
        # workaround to put results into magick command
        Maskgenerator=" -delete 0 $Sourcemask" 
        Maskgenerator2="-delete 0 $Resultmask"
      ;;
      experimental)
        Maskgenerator="-write mpr:source
        
                       -define convolve:scale=!
                       -define convolve:bias=50%
                       -define morphology:compose=Lighten
                       -morphology Convolve Sobel:>
                       
                       -write mpr:mask1
                       -delete 0
                       
                       mpr:source 
                       -statistic standard_deviation ${Radius1}x${Radius1} )
                       
                       -write mask2
                       -delete 0
                       
                       mpr:mask1 mpr:mask2
                       -compose multiply -composite"
      ;;
      free)
        Maskgenerator="$Maskgeneratorargument"
      ;;
      freichen)
        Maskgenerator="-define convolve:scale=50%!
                       -define morphology:compose=Lighten
                       -define convolve:bias=50%
                       -morphology Convolve FreiChen:>" ### FIXME allow more modes
      ;;
      kirsch)
        Maskgenerator="-define convolve:scale=50%!
                       -define convolve:bias=50%
                       -morphology Convolve Kirsch" ### FIXME
      ;;
      laplacian)
        Maskgenerator="-define convolve:bias=50%
                       -define convolve:scale=!
                       -morphology Convolve Laplacian:$Maskgeneratorargument"
      ;;
      log)  # LoG: Laplacian of Gaussian
        Maskgenerator="-define convolve:bias=50% \
                       -morphology Convolve LoG:${Radius1}x${Sigma1}"
      ;;
      prewitt)
        Maskgenerator="-define convolve:scale=50%!
                       -define convolve:bias=50%
                       -morphology Convolve Prewitt" ### FIXME
      ;;
      roberts)
        Maskgenerator="-define morphology:compose=Lighten
                       -define convolve:bias=50%
                       -morphology Convolve Roberts:@"
      ;;
      sobel)
        Maskgenerator="-define convolve:scale=!
                       -define convolve:bias=50%
                       -define morphology:compose=Lighten
                       -morphology Convolve Sobel:>"
      ;;
      statistic)
        Maskgenerator="-statistic $Maskgeneratorargument ${Radius1}x${Radius1}"
      ;;
      unsharp)
        Maskgenerator="( -clone 0 -unsharp ${Radius1}x${Sigma1} )
                       ( -clone 0 -unsharp ${Radius1}x${Sigma2} )
                       -delete 0
                       -compose Difference -composite
                       -grayscale RMS"
      ;;
    esac
    Maskgenerator2="${Maskgenerator2:-$Maskgenerator}" # workaround for --enfuse. Otherwise Maskgenerator==Maskgenerator2
    Maskgenerator="$(echo $Maskgenerator)"
    Maskgenerator2="$(echo $Maskgenerator2)"
    
    # --negate
    [ "$Negate" = "yes" ] && {
      Maskgenerator="-negate $Maskgenerator"
      Maskgenerator2="-negate $Maskgenerator2"    
    }

    Maskgenerator="-grayscale RMS $Maskgenerator"    
    Maskgenerator2="-grayscale RMS $Maskgenerator2"    

    # Apply masks to fuse current source image with intermediate result image
    case $Mode in
      1)
        # prefer source over result
        $Magickbin \
          $Sourceimage \
            -write mpr:sourceimage \
            $Maskgenerator \
            -write mpr:sourcemask $Writesourcemask \
            -delete 0 \
          $Resultimage \
            -write mpr:resultimage \
            $Maskgenerator2 \
            -write mpr:resultmask $Writeresultmask \
            -delete 0 \
          mpr:sourcemask mpr:resultmask \
            -compose MinusDst -composite -fill white +opaque black -write mpr:diffmask $Writediffmask \
            -delete 0 \
          mpr:sourceimage mpr:resultimage mpr:diffmask \
            -alpha off -compose Over -composite $Writeresultcount \
            "$Resultimage" || error "Error in fuse"
        showimage $Resultimage
      ;;
      2)
        # prefer result over source
        $Magickbin \
          $Sourceimage \
            -write mpr:sourceimage \
            $Maskgenerator \
            -write mpr:sourcemask $Writesourcemask \
            -delete 0 \
          $Resultimage \
            -write mpr:resultimage \
            $Maskgenerator2 \
            -write mpr:resultmask $Writeresultmask \
            -delete 0 \
          mpr:resultmask mpr:sourcemask \
            -compose MinusDst -composite -fill white +opaque black \
            -write mpr:diffmask $Writediffmask \
            -delete 0 \
          mpr:resultimage mpr:sourceimage mpr:diffmask \
            -alpha off -compose Over -composite $Writeresultcount \
            "$Resultimage" || error "Error in fuse"
        showimage $Resultimage
      ;;
      3)
        # enfuse source masks
        $Magickbin \
          $Sourceimage \
            $Maskgenerator \
            $Sourcemask || error "Error in mask generation"
        showimage $Sourcemask
      ;;
      4)
        # enfuse diff masks
        $Magickbin \
          $Sourceimage \
            $Maskgenerator \
            -write mpr:sourcemask $Writesourcemask \
            -delete 0 \
          $Resultimage \
            $Maskgenerator2 \
            -write mpr:resultmask $Writeresultmask \
            -delete 0 \
          mpr:sourcemask mpr:resultmask \
            -compose MinusDst -composite -fill white +opaque black \
            $Diffmask
        showimage $Diffmask
      ;;
      5)
        # combine mode 1+2: multiply max+min
        $Magickbin \
          $Sourceimage \
            -write mpr:sourceimage  \
            $Maskgenerator  \
            -write mpr:sourcemask \
            -delete 0 \
          $Resultimage \
            -write mpr:resultimage \
            $Maskgenerator2 \
            -write mpr:resultmask \
            -delete 0 \
          mpr:sourcemask mpr:resultmask \
            -compose MinusDst -composite -fill white +opaque black  \
            -write mpr:diffmask \
            -delete 0 \
          mpr:sourceimage mpr:resultimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result1 \
            -delete 0 \
          mpr:resultmask mpr:sourcemask \
            -compose MinusDst -composite -fill white +opaque black \
            -write mpr:diffmask                   \
            -delete 0 \
          mpr:resultimage mpr:sourceimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result2 \
            -delete 0 \
          mpr:result1 mpr:result2 \
            -evaluate-sequence min \
            -write mpr:resultmin \
            -delete 0 \
          mpr:result1 mpr:result2 \
            -evaluate-sequence max \
            -write mpr:resultmax \
            -delete 0 \
          mpr:resultmin mpr:resultmax \
            -evaluate-sequence multiply \
            -gamma 2 \
          "$Resultimage" || error "Error in fuse"
        showimage $Resultimage
      ;;
      6)
        # combine mode 1+2: max
        $Magickbin \
          $Sourceimage \
            -write mpr:sourceimage  \
            $Maskgenerator  \
            -write mpr:sourcemask \
            -delete 0 \
          $Resultimage \
            -write mpr:resultimage \
            $Maskgenerator2 \
            -write mpr:resultmask \
            -delete 0 \
          mpr:sourcemask mpr:resultmask \
            -compose MinusDst -composite -fill white +opaque black  \
            -write mpr:diffmask \
            -delete 0 \
          mpr:sourceimage mpr:resultimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result1 \
            -delete 0 \
          mpr:resultmask mpr:sourcemask \
            -compose MinusDst -composite -fill white +opaque black \
            -write mpr:diffmask                   \
            -delete 0 \
          mpr:resultimage mpr:sourceimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result2 \
            -delete 0 \
          mpr:result1 mpr:result2 \
            -evaluate-sequence max \
          "$Resultimage" || error "Error in fuse"
        showimage $Resultimage
      ;;
      7)
        # combine mode 1+2: min
        $Magickbin \
          $Sourceimage \
            -write mpr:sourceimage  \
            $Maskgenerator  \
            -write mpr:sourcemask \
            -delete 0 \
          $Resultimage \
            -write mpr:resultimage \
            $Maskgenerator2 \
            -write mpr:resultmask \
            -delete 0 \
          mpr:sourcemask mpr:resultmask \
            -compose MinusDst -composite -fill white +opaque black  \
            -write mpr:diffmask \
            -delete 0 \
          mpr:sourceimage mpr:resultimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result1 \
            -delete 0 \
          mpr:resultmask mpr:sourcemask \
            -compose MinusDst -composite -fill white +opaque black \
            -write mpr:diffmask                   \
            -delete 0 \
          mpr:resultimage mpr:sourceimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result2 \
            -delete 0 \
          mpr:result1 mpr:result2 \
            -evaluate-sequence min \
          "$Resultimage" || error "Error in fuse"
        showimage $Resultimage
      ;;
      8)
        # combine mode 1+2: overlay max+min
        $Magickbin \
          $Sourceimage \
            -write mpr:sourceimage  \
            $Maskgenerator  \
            -write mpr:sourcemask \
            -delete 0 \
          $Resultimage \
            -write mpr:resultimage \
            $Maskgenerator2 \
            -write mpr:resultmask \
            -delete 0 \
          mpr:sourcemask mpr:resultmask \
            -compose MinusDst -composite -fill white +opaque black  \
            -write mpr:diffmask \
            -delete 0 \
          mpr:sourceimage mpr:resultimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result1 \
            -delete 0 \
          mpr:resultmask mpr:sourcemask \
            -compose MinusDst -composite -fill white +opaque black \
            -write mpr:diffmask                   \
            -delete 0 \
          mpr:resultimage mpr:sourceimage mpr:diffmask \
            -alpha off -compose Over -composite \
            -write mpr:result2 \
            -delete 0 \
          mpr:result1 mpr:result2 \
            -evaluate-sequence min \
            -write mpr:resultmin \
            -delete 0 \
          mpr:result1 mpr:result2 \
            -evaluate-sequence max \
            -write mpr:resultmax \
            -delete 0 \
          mpr:resultmin mpr:resultmax \
            -compose overlay -composite \
          "$Resultimage" || error "Error in fuse"
        showimage $Resultimage
      ;;
    esac
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Duration: $(date -u -d @$Dauer +"%T"); estimated time left: $(date -u -d @$Restzeit +"%T")"
  done
  [ "$Error" ] && return "${Error:-0}"
  case $Mode in
    3)
      enfuse --load-masks=$Cachedir/%n.mask.source.tif -o $Resultimage $Imagelist || error "Error in enfuse"
    ;;
    4)
      enfuse --load-masks=:$Cachedir/%n.mask.diff.tif --hard-mask  -o $Resultimage $Imagelist || error "Error in enfuse"
    ;;
  esac
  
  return "${Error:-0}"
}

maskfilter() {
    # Mask generating ImageMagick options
    # Most of them are based on edge detection: http://www.imagemagick.org/Usage/convolve/#edgedet
    Maskgenerator=""
    Maskgenerator2=""
    case $Method in
      blur)
        # Compare two blurred images with different sigma.
        # Concept and result is similar to Difference of Gaussian (DoG). Using -gaussian-blur gives same as DoG.
        # Code based on https://im.snibgo.com/simpalign.htm#twoBlrDiff.bat
        Maskgenerator="
( -clone 0
-blur ${Radius1}x${Sigma1} 
)"
        [ "$Radius2$Sigma2" ] && Maskgenerator="$Maskgenerator
( -clone 0
-blur ${Radius2:-$Radius1}x${Sigma2:-$Sigma1} 
)
-delete 0"
        Maskgenerator="$Maskgenerator
-compose Difference -composite"
# -compose Mathematics -define compose:args=0,-4,4,0.5 -composite
# -grayscale RMS"
      ;;
      compass)
        Maskgenerator="
( -clone 0
-define convolve:scale=50%!
-define convolve:bias=50%
-morphology Convolve Compass
)
-delete 0"
#-compose Difference -composite" # sort of interesting.
      ;;
      gaussian) 
        case $Sigma2 in
          "")
            Maskgenerator="
( -clone 0
-gaussian-blur ${Radius1}x${Sigma1} 
)
-compose Difference -composite"
          ;;
          *) # DoG: Difference of Gaussian
        # This will generate a 'DoG' or "Difference of Gaussians" kernel in which 
        # the gaussian generated by 'sigma1' will have the gaussian generated by 'sigma2' subtracted from it. 
        # Normally 'sigma2' is the larger so that the 'central peak' of the kernel is positive. 
        # Reversing the two numbers will effectivally negate the resulting kernel. 
        # By generating two 'Gaussian' kernels of slightly different sigma values (in a ratio of approximatally 1.6), 
        # and subtracting them from each other you can actually generate a close approximation of a Laplacian of a Gaussian.
            Maskgenerator="-define convolve:bias=50%
-morphology Convolve DoG:$Radius1,$Sigma1,$Sigma2"
          ;;
        esac
      ;;
      experimental)
        Maskgenerator="
( -clone 0 -statistic mean   ${Radius:-5} )
( -clone 0 -statistic median ${Radius:-5} )
-delete 0
-compose Difference -composite"
      ;;
      free)
        Maskgenerator="$Maskgeneratorargument"
      ;;
      freichen)
        Maskgenerator="-define convolve:scale=50%!
                       -define morphology:compose=Lighten
                       -define convolve:bias=50%
                       -morphology Convolve FreiChen:>" ### FIXME allow more modes
      ;;
      kirsch)
        Maskgenerator="
-define convolve:scale=50%!
-define convolve:bias=50%
-morphology Convolve Kirsch" ### FIXME
      ;;
      laplacian)
        Maskgenerator="
-define convolve:bias=50%
-define convolve:scale=!
-morphology Convolve Laplacian:$Maskgeneratorargument"
      ;;
      log)  # LoG: Laplacian of Gaussian
        Maskgenerator="
( -clone 0
-define convolve:bias=50%
-morphology Convolve LoG:${Radius1}x${Sigma1}
)"
        [ "$Radius2$Sigma2" ] && Maskgenerator="$Maskgenerator
( -clone 0
-define convolve:bias=50%
-morphology Convolve LoG:${Radius2:-$Radius1}x${Sigma2:-$Sigma1}
)
-delete 0
-compose Difference -composite"
        [ -z "$Radius2$Sigma2" ] && Maskgenerator="$Maskgenerator
-delete 0"
      ;;
      mediff)
        Maskgenerator="
-write mpr:source
-delete 0
( mpr:source -statistic mean   ${Radius1} )
( mpr:source -statistic median ${Radius1} )
-compose Difference -composite
-write mpr:diff1"
        [ "$Radius2" ] && Maskgenerator="$Maskgenerator
-delete 0
( mpr:source -statistic mean   ${Radius2} )
( mpr:source -statistic median ${Radius2} )
-compose Difference -composite
-write mpr:diff2
-delete 0
mpr:diff1 mpr:diff2
-compose Difference -composite
"
      ;;
      prewitt)
        Maskgenerator="
-define convolve:scale=50%!
-define convolve:bias=50%
-morphology Convolve Prewitt" ### FIXME
      ;;
      roberts)
        Maskgenerator="
-define morphology:compose=Lighten
-define convolve:bias=50%
-morphology Convolve Roberts:@"
      ;;
      sobel)
        Maskgenerator="
-define convolve:scale=!
-define convolve:bias=50%
-define morphology:compose=Lighten
-morphology Convolve Sobel:>"
      ;;
      statistic)
        Maskgenerator="
( -clone 0
-statistic $Maskgeneratorargument ${Radius1}x${Radius1}
)"
        [ "$Radius2" ] && Maskgenerator="$Maskgenerator
( -clone 0
-statistic $Maskgeneratorargument ${Radius2}x${Radius2}
)"
        Maskgenerator="$Maskgenerator
-delete 0"
        [ "$Radius2" ] && Maskgenerator="$Maskgenerator
-compose Difference -composite"
      ;;
      unsharp)
        Maskgenerator="( -clone 0 -unsharp ${Radius1}x${Sigma1} )
                       -compose Difference -composite"
      ;;
      unsharp2)
        Maskgenerator="-unsharp ${Radius1}x${Sigma1}"
      ;;
      unsharpXXX)
        Maskgenerator="( -clone 0 -unsharp ${Radius1}x${Sigma1} )
                       ( -clone 0 -unsharp ${Radius1}x${Sigma2} )
                       -delete 0
                       -compose Difference -composite
                       -grayscale RMS"
      ;;
    esac
  grep . <<< "$Maskgenerator"
}

### main

declare_variables() {
  Background=""
  Backgroundimage=""
  Cachedir=""
  Compress=""
  Error=""
  Freemem=""
  Gamma=""
  Grayscale=""
  Grayscaleconverter=""
  Grayscalenumber=""
  Image=""
  Imageformat="tif"
  Imageheight=""
  Imagelist=""
  Imagelistmemsize=""
  Imagememsize=""
  Imagenumber=""
  Imagewidth=""
  Layernumber=""
  Layerminpixel="10000"
  Layers=""
  Magickbin=""
  Magickpixelmemory=""
  Magickversion=""
  Method=""
  Maskgeneratorargument=""
  Mode=""
  Negate="no"
  Noise=""
  Outputimage=""
  Revertimagelist="no"
  Savemask="no"
  Showimage="no"
  Startzeit="$(date +%s)"
  Stepsize=""
  Storelayers=""
  Stripmask="yes"
  Swapcompose=""
  Threshold=
  Tifstore="+repage -type TrueColorAlpha -quality 100% -compress lzw"
  Radius1=""
  Radius2=""
  Sigma1=""
  Sigma2=""
  Verbose="no"
  return 0
}
parse_options() {
  local Shortoptions Longoptions Parsedoptions Parsererror Parsererrorfile
  
  Shortoptions="b::g::hn::o:r:R::s:S::t::vV"
  Longoptions="cachedir:,help,verbose,version,output:,showimage"
  Longoptions="$Longoptions,background::,grayscale:,gamma::,layers::,negate,noise::,radius:,radius1:,radius2::,revert,sigma:,sigma1:,sigma2::,swap,threshold::"
  Longoptions="$Longoptions,blur::,compass::,compose::,gaussian::,enfuse::,evaluate::,experimental::,free::,freichen::,kirsch::,laplacian::,log::,mediff::,prewitt::,roberts::,sobel::,statistic::,unsharp::"  

  Parsererrorfile="/tmp/imfuse.parserserror.$RANDOM"
  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@" 2>"$Parsererrorfile")"
  [ -e $Parsererrorfile ] && Parsererror="$(cat "$Parsererrorfile")" && rm "$Parsererrorfile"
  [ "$Parsererror" ] && error "$Parsererror"
  eval set -- "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    [ "$Error" ] && break
    case "${1:-}" in
      -h|--help)             usage ; exit 0 ;;
      -b|--background)       Background="${2:-auto}" ; shift ;;
      --cachedir)            Cachedir="${2:-}" ; Savemask="yes" ; shift ;;
      -g|--gamma)            Gamma="${2:-auto}" ; shift ;;
         --grayscale)        Grayscale="${2:-auto}" ; shift ;;
         --layers)           Storelayers="yes" ; Layernumber="${2:-auto}" ; shift ;;
      --negate)              Negate="yes" ;;
      -n|--noise)            Noise="${2:-auto}" ; shift ;;
      -o|--output)           Outputimage="${2:-}" ; shift ;;
      -r|--radius|--radius1) Radius1="${2:-}" ; shift ;;
      -R|--radius2)          Radius2="${2:-auto}" ; shift ;;
      --revert)              Revertimagelist="yes" ;;
      -s|--sigma|--sigma1)   Sigma1="${2:-}" ; shift ;;
      -S|--sigma2)           Sigma2="${2:-auto}" ; shift ;;
       --swap)               Swapcompose="-swap 0,1" ;;
      -t|--threshold)        Threshold="${2:-auto}" ; shift ;;
      -v|--verbose)          Verbose="yes" ;;
         --version)          echo "imfuse v$Version"; exit 0 ;;
      -V|--showimage)        Showimage="yes" ;;
      --blur|--compass|--compose|--gaussian|--enfuse|--evaluate|--experimental|--free|--freichen|--kirsch|--laplacian|--log|--mediff|--prewitt|--roberts|--sobel|--statistic|--unsharp)
        Method="${1#--}"
        Maskgeneratorargument="${2:-}"  && shift
      ;;  
      --) ;;
      *)
        Imagelist="$Imagelist
$(realpath "${1:-}")" 
        [ -f "${1:-}" ] || error "File not found: ${1:-}"
      ;;
    esac
    shift
  done
  return ${Error:-0}
}
check_options() {
  [ -z "$Imagelist" ] && error "No images specified"
  
  # Method
  case $Method in
    enfuse)
      #error "--enfuse: Not implemented yet"
      command -v enfuse >/dev/null || error "--enfuse: command enfuse not found. Please install enfuse."
    ;;
    "")
      Method="compose"
      note "Setting --$Method"
    ;;
  esac  
  
  # Method argument
  case $Method in
    compose)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="overlay"
        note "Setting --$Method=$Maskgeneratorargument"
      }
      grep -q -x -i "$Maskgeneratorargument" <<< "$($Magickbin -list compose)" || {
        error "--$Method=$Maskgeneratorargument: unknown argument.
  Please choose one out of '$Magickbin -list compose'
  or compare IM option -compose."
      }
      Maskgeneratorargument="$(lowercase "$Maskgeneratorargument")"
    ;;
    enfuse) ;;
    evaluate)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="max"
        note "Setting --$Method=$Maskgeneratorargument"
      }
      grep -q -x -i "$Maskgeneratorargument" <<< "$($Magickbin -list evaluate)" || {
        error "--$Method=$Maskgeneratorargument: unknown argument.
  Please choose one out of '$Magickbin -list evaluate'
  or compare IM option -evaluate-sequence."
      }
      Maskgeneratorargument="$(lowercase "$Maskgeneratorargument")"
    ;;
    experimental) ;;
    laplacian)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="0"
        note "Setting --$Method=$Maskgeneratorargument"
      }
    ;;
    free)
      [ -z "$Maskgeneratorargument" ] && {
        Maskgeneratorargument="-edge 2"
        note "Setting --$Method='$Maskgeneratorargument'"
      }
    ;;
    statistic)
      case $Maskgeneratorargument in
        gradient|maximum|minimum|mean|median|mode|nonpeak|rms|standarddeviation) ;;
        dev|standard-deviation)  Maskgeneratorargument="standarddeviation" ;;
        grad) Maskgeneratorargument="gradient" ;;
        max)  Maskgeneratorargument="maximum" ;;
        min)  Maskgeneratorargument="minimum" ;;
        "")
          Maskgeneratorargument="standarddeviation"
          note "Setting --$Method=$Maskgeneratorargument"
        ;;
        *)
          note "--statistic: unknown argument $Maskgeneratorargument.
  Setting --$Method=standarddeviation"
          Maskgeneratorargument="standarddeviation"
        ;;
      esac
    ;;
    *)
      [ -n "$Maskgeneratorargument" ] && {
        note "Arguments not used in --$Method=$Maskgeneratorargument"
        Maskgeneratorargument=""
      }
    ;;
  esac
  
  # --background
  case $Method in
    evaluate|compose) 
      [ "$Background" ] && {
        note "--background has no effect with --$Method"
        Background=""
      }
    ;;
    *)
      [ "$Background" ] && [ -z "$Threshold" ] && note "--background: With --threshold=0 the background will be covered entirely."
      case $Background in
        "")   [ "$Threshold" ] && Background="transparent" || Background="black" ;;
        auto) Background="mean" ;;
        none) Background="transparent" ;;
      esac
    ;;
  esac
    
  # --grayscale
  case ${Grayscale,,} in
    ""|auto)           Grayscale="RMS" ;;
  esac
  case ${Grayscale,,} in
    0|none)            Grayscalenumber=0 ; Grayscale="none" ;;
    1|rec601luma)      Grayscalenumber=1 ; Grayscale="Rec601Luma" ;;
    2|rec601luminance) Grayscalenumber=2 ; Grayscale="Rec601Luminance" ;;
    3|rec709luma)      Grayscalenumber=3 ; Grayscale="Rec709Luma" ;;
    4|rec709luminance) Grayscalenumber=4 ; Grayscale="Rec709Luminance" ;;
    5|brightness)      Grayscalenumber=5 ; Grayscale="Brightness" ;;
    6|lightness)       Grayscalenumber=6 ; Grayscale="Lightness" ;;
    7|average)         Grayscalenumber=7 ; Grayscale="Average" ;;
    8|ms)              Grayscalenumber=8 ; Grayscale="MS" ;;
    9|rms)             Grayscalenumber=9 ; Grayscale="RMS" ;;
    *)
      note "--grayscale=$Grayscale: Unknown argument for --grayscale.
  Setting --grayscale=RMS"
      Grayscale="RMS"
    ;;
  esac
  case $Grayscale in
    ""|none) Grayscaleconverter="" ;;
    *)       Grayscaleconverter="-grayscale $Grayscale" ;;
  esac
  
  # --layers
  case $Layernumber in
    auto) Layernumber="25" ;;
  esac
  
  # --noise
  case $Noise in
    auto) Noise="3" ;;
  esac
  
  # --radius1
  [ -z "$Radius1" ] && case $Method in
    blur|gaussian|log|unsharp)
      Radius1="0"
    ;;
    enfuse)
      Radius1="5"
      note "Setting --radius=$Radius1"
    ;;
    mediff)
      Radius1="5"
      note "Setting --radius=$Radius1"
    ;;
    statistic)
      Radius1="2"
      note "Setting --radius=$Radius1"
    ;;
  esac
  case $Method in
    enfuse)
      [ "$Radius1" -lt "3" ] && {
        note "--enfuse needs a radius of at least 3.
  Setting --radius=3"
      }
      [ "$((Radius1%2))" -eq 0 ] && {
        Radius1="$((Radius1+1))"
        note "--enfuse needs an odd value for --radius.
  Setting --radius=$Radius1"
      }
    ;;
    statistic|mediff)
      [ "$Radius1" -lt "2" ] && {
        Radius1="2"
        note "--$Method: Radius must be at least 2.
  Setting --radius=$Radius1"
      }
    ;;
  esac
  
  # --radius2
  [ "$Radius2" ] && case $Method in
    statistic|mediff)
      [ "$Radius2" = "$Radius1" ] && {
        note "--radius2=$Radius2 is same as --radius1=$Radius1.
  Setting --radius2=auto"
        Radius2="auto"
      }
    ;;
    freichen|kirsch|laplacian|prewitt|roberts|sobel)
      note "--radius2 is not supported by --$Method"
      Radius2=""
    ;;
  esac
  [ "$Radius2" = "auto" ] && case $Method in
    statistic|mediff)
      Radius2="$((Radius1*3/2))"
      note "Setting --radius2=$Radius2"
    ;;
    blur|gaussian|log|unsharp)
      Radius2="$Radius1"
      note "Setting --radius2=$Radius2"
    ;;
  esac
  
  # --sigma1
  case $Method in
    experimental) ;;
    blur|gaussian|log|unsharp)
      [ -z "$Sigma1" ] && {
        Sigma1="0.5"
        note "Setting --sigma=$Sigma1"
      }
    ;;
    *)
      [ -n "$Sigma1" ] && {
        note "Not used with --method=$Method: --sigma=$Sigma1"
        Sigma1=""
      }
    ;;
  esac
  
  # --sigma2
  case $Method in
    experimental) ;;
    blur|gaussian|unsharp)
      [ "$Sigma2" = "auto" ] && {
        Sigma2="$(awk "BEGIN {print $Sigma1 * 1.6}")"
        note "Setting --sigma2=$Sigma2"
      }
      [ "$Sigma1" = "$Sigma2" ] && note "--sigma2 is same as --sigma1.
  This is likely wrong."
    ;;
    *)
      [ -n "$Sigma2" ] && {
        note "Not used with --method=$Method: --sigma2=$Sigma2"
        Sigma2=""
      }
    ;;
  esac
  
  # --threshold
  case $Threshold in
    auto)
      Threshold="5"
      note "Setting --threshold=$Threshold"
    ;;
  esac
  [ "$Threshold" ] && case $Method in
    evaluate|compose) 
      note "--threshold has no effect with --$Method"
      Threshold=""
    ;;
  esac
  
  # --cachedir
  [ -z "$Cachedir" ] && Cachedir="$(pwd)/imfuse.$RANDOM"
  Cachedir="$(sed s%'~'%$HOME% <<< "$Cachedir")"
  Cachedir="$(realpath -m "$Cachedir")"
  
  #### Files ####
  
  # --revert
  [ "$Revertimagelist" = "yes" ] && Imagelist="$(tac <<< "$Imagelist")"
  
  # --output
    case $Method in
      blur|gaussian|log|unsharp)    Resultimage="imfuse.${Method}.${Radius1}x${Sigma1}"
        [ "$Radius2$Sigma2" ] &&    Resultimage="${Resultimage}-${Radius2:-$Radius1}x${Sigma2:-$Sigma2}" ;;
      compose|evaluate|laplacian)   Resultimage="imfuse.${Method}.${Maskgeneratorargument}" ;;
      enfuse)                       Resultimage="imfuse.${Method}.r${Radius1}";;
      mediff   )                    Resultimage="imfuse.${Method}.r${Radius1}" 
        [ "$Radius2" ] &&           Resultimage="${Resultimage}-r${Radius2}" ;;
      statistic)                    Resultimage="imfuse.${Method}.${Maskgeneratorargument}.r${Radius1}" 
        [ "$Radius2" ] &&           Resultimage="${Resultimage}-r${Radius2}" ;;
      *)                            Resultimage="imfuse.${Method}" ;;
    esac
    case $Method in
      compose) [ "$Swapcompose" ] && Resultimage="${Resultimage}.swap";;
      evaluate) ;;
      #*) Resultimage="${Resultimage}.m${Mode}" ;;
    esac
    case $Threshold in
      0|"") ;;
      *) Resultimage="${Resultimage}.t$Threshold" ;;
    esac
    case $Grayscalenumber in
      9) ;;
      *) Resultimage="${Resultimage}.g$Grayscalenumber" ;;
    esac
    case $Noise in
      "") ;;
      *) Resultimage="${Resultimage}.n$Noise" ;;
    esac
    case $Gamma in
      "") ;;
      auto) Resultimage="${Resultimage}.G" ;;
      *)    Resultimage="${Resultimage}.G$Gamma" ;;
    esac
    Resultimage="${Resultimage}.${Imageformat}"
    
  [ -z "$Outputimage" ] && {
    Outputimage="$(realpath -m "./$Resultimage")" 
    note "Setting --output=$Outputimage"
  }
  Outputimage="$(realpath "$Outputimage")"
  Resultimage="$Cachedir/$Resultimage"
    
  verbose "--$Method=$Maskgeneratorargument
--cachedir=$Cachedir
--gamma=$Gamma
--grayscale=$Grayscale
--layers=$Layernumber
--mode=$Mode
--noise=$Noise
--output=$Outputimage
--radius=$Radius1
--radius2=$Radius2
--sigma=$Sigma1
--sigma2=$Sigma2
--threshold=$Threshold
"
  return ${Error:-0}
}
main() {
  #set -eu
  trap trap_sigint SIGINT
  
  declare_variables
  
  command -v convert >/dev/null && Magickbin="convert"
  command -v magick  >/dev/null && Magickbin="magick"
  [ -z "$Magickbin" ] && error "Neither command convert nor magick found. Please install ImageMagick."
  Magickversion="$($Magickbin -version)"
  grep -q " Q8 "   <<< "$Magickversion" && Magickpixelmemory="4"
  grep -q " Q16 "  <<< "$Magickversion" && Magickpixelmemory="8"
  grep -q " HDRI " <<< "$Magickversion" && Magickpixelmemory="16"
  [ "$Error" ] && return 1
  
  Freemem="$(freememory)"
  [ -z "$Freemem" ] && {
    note "WARNING: failed to estimate free memory.
  Blindly guessing 1000 MB."
    Freemem="1000000"
  }
  
  parse_options "$@"
  check_options
  [ "$Error" ] && return 1
  
  Imagelist="$(grep -v -x "" <<< "$Imagelist")"
  Imagenumber="$(grep -c "." <<< "$Imagelist")"
  Imagenumberlength="${#Imagenumber}"
  
  Image="$(head -n1 <<< "$Imagelist")"
  Imagewidth="$($Magickbin  -format '%w' "$Image" info:)"
  Imageheight="$($Magickbin -format '%h' "$Image" info:)"
  Imagememsize="$((Imagewidth*Imageheight*Magickpixelmemory/1000))"
  Imagelistmemsize="$((Imagenumber*Imagememsize))"
  Image=""
  
  verbose "Image number: $Imagenumber
  Image width:  $Imagewidth
  Image height: $Imageheight
  Image memory size:      $Imagememsize kb
  Image list memory size: $Imagelistmemsize kb
  Free Memory:            $Freemem kb"
  
  Backgroundimage="$Cachedir/background.tif"
  
  mkdir -p $Cachedir || error "Error creating cache folder $Cachedir"
  rm $Cachedir/*
  [ "$Error" ] && return 1
 
  case $Method in
    evaluate)
      evaluate_split $Maskgeneratorargument $Resultimage $Imagelist || error "Error in --$Method=$Maskgeneratorargument"
    ;;
    compose)
      case $Stepsize in
        ""|0|all)
          [ "$Freemem" -lt "$Imagelistmemsize" ] && {
            verbose "--compose: Generating max image"
            evaluate_split max $Cachedir/max.tif $Imagelist
            verbose "--compose: Generating min image"
            evaluate_split min $Cachedir/min.tif $Imagelist
            verbose "--compose: compositing $Maskgeneratorargument"
           $Magickbin \
             $Cachedir/max.tif $Cachedir/min.tif $Swapcompose \
               -compose $Maskgeneratorargument -composite \
             $Tifstore \
             $Resultimage || error "Error in --$Method=$Maskgeneratorargument"
          } || {
            $Magickbin \
              $(echo $Imagelist) \
                \( -clone 0--1 -evaluate-sequence max -write mpr:max -delete 0--1 \) \
                \( -clone 0--1 -evaluate-sequence min -write mpr:min -delete 0--1 \) \
                -delete 0--1 \
              mpr:max mpr:min $Swapcompose \
                -compose $Maskgeneratorargument -composite \
              $Tifstore \
              $Resultimage || error "Error in --$Method=$Maskgeneratorargument"
          }
        ;;
        *)
          compose_step
        ;;
      esac
    ;;
    *)
      case $Background in
        max|min|mean|median)
          evaluate_split $Background $Backgroundimage $Imagelist || return 1
        ;;
        transparent|none)
          $Magickbin -size ${Imagewidth}x${Imageheight} xc:blue -transparent blue +level-colors black -type TrueColorAlpha $Tifstore $Backgroundimage || error "Failed to create transparent background image."
          #$Magickbin $(head -n1 <<< "$Imagelist") -alpha Transparent +level-colors "black"  -colorspace sRGB  $Resultimage || error "Failed to create transparent background image."
        ;;
        *)
          #$Magickbin $(head -n1 <<< "$Imagelist") -alpha Opaque +level-colors "$Background" -colorspace sRGB  $Resultimage || error "Failed to create background image with color $Background."
          $Magickbin -size ${Imagewidth}x${Imageheight} xc:"$Background" -type TrueColorAlpha $Tifstore $Backgroundimage
        ;;
      esac
      cp "$Backgroundimage" "$Resultimage"
      case $Background in
        transparent|none|"") Backgroundimage="" ;;
      esac
      showimage "$Resultimage"
      fuse_focus_stackshot  || error "Error while fusing stackshot"
    ;;
  esac
  [ "$Error" ] && return 1
  
  # --gamma
  case $Gamma in
    "") ;;
    auto) $Magickbin "$Resultimage" -auto-gamma     $Tifstore "$Resultimage" || error "Error in --gamma=$Gamma" ;;
    *)    $Magickbin "$Resultimage" -gamma "$Gamma" $Tifstore "$Resultimage" || error "Error in --gamma=$Gamma" ;;
  esac
  [ "$Error" ] && return 1
  
  $Magickbin "$Resultimage" $Tifstore "$Outputimage"  || error "Error storing result in $Outputimage"
  showimage "$Outputimage"
  note "Ready after $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")"
    
  return "${Error:-0}"
}

main "$@"
[ "$Savemask" = "no" ] && [ -d "$Cachedir" ] && rm -R "$Cachedir"
exit "${Error:-0}"
