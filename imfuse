#! /bin/bash

# imfuse
Version="0.8.8-beta"

# ToDo:
# --compose et al: result less good than expected. max/lighten min/darken issue?
# mkclut_uniform() fails with b&w masks -> clut and result black
# check --kirsch
# drop --unsharp?

usage() {
  echo "imfuse v$Version
Combines focus stackshot images to one overall sharp image.

Usage:
  imfuse [OPTIONS] -- image1 image2 image3 ...

imfuse assumes that the alphanumerical order of the input images goes
from front to back; for the other way around use option --revert.

Dependencies:
  ImageMagick 7       Mandatory (command 'magick').
  enfuse              Optional, needed for options --enfuse and --bg=enfuse.
  geeqie              Optional, needed for option -V, --showimage.
  viewnior            Optional, needed for option -W to show result image.
  exiftool            Optional, needed for option --exif to transfer metadata.
  focus-stack         Optional, needed for option --align.
                        https://github.com/PetteriAimonen/focus-stack
  xclip               Optional, to send result file name to clipboard.

General options:
     --align              Align images.
     --basename [=NAME]   Base name [+path] for output image. 
     --cache [=DIR]       Store generated masks and images in directory DIR.
                          They can be reused in later runs of imfuse.
                          Default DIR: ./cache.imfuse
     --exif [=IMAGE]      Transfer exif meta data from IMAGE or first image.
     --force              Force imfuse to run even if output image exists.
 -h, --help               Show this help and exit.
     --layered            Store backgrounds and single substacks in layered TIF.
     --limit-memory=ARG   Limit amount of used memory. Default: 80%
                          ARG can be a % value or an absolute value for MB.
 -o, --output=FILE        Result image file name. See also --basename.
     --revert             Revert order of source images.
     --savemask [=FILE]   Store contrast mask in file FILE.
     --version            Show imfuse version and exit.
 -V, --showimage          Show intermediate results with image viewer geeqie.
     --video              Generate a video of shown intermediate images.
 -W                       Show result with image viewer viewnior.

The options below can take additionally arguments [=ARG].
Multiple arguments are comma-separated. Example: --morphology=r3,blur

Arguments taken by all mask generating options:
  w         Weight of mask. Percent value from 0 to 100.
            Of interest if specifying more than one mask generation method.
            Example: --morphology --saturation=w25
            This will generate two masks. The saturation mask will only have
            noteable effect where the morphology mask strength is below 25%.
  t         Threshold (removal) of low contrast areas.
  T         Threshold (removal) of high contrast areas.
  C=        Colorspace to use instead of default sRGB. Compare --colorspace.
  c         Colorspace channel to use. Counting up from 0 for first channel.
            Example: C=HSL,c2 will use the saturation channel from HSL.
  I=        Image creation and comparision. For possible args see --background.
            Example: --statistic=E=max will generate a mask from an evaluated
            max image that was compared with the source image.
            Compare step 2b: Mask generation - image comparision masks.
  neg       Negate / invert the mask. Most of interest for color channels.
  level [=yes|no] Equalize histogram distribution to get compareable masks.
            Default is yes except for channel and image comparision options.
Arguments additionally taken by some options:
  r         Radius. Must be an integer value.
  R         Second radius.
  s         Sigma. Takes also non-integer values like 0.75.
  S         Second Sigma.
  p         A percent value.
  P         Second percent value
  n         An integer value.
  N         Second integer value.
  (word)    Some options take one or two word arguments.

Generally spoken, increased radius or sigma enhances contrast, reduces noise,
looses details and increases undesired seams. There's always a tradeoff.
The default values are set rather low and mostly profit from increasing.
Think of radius and sigma as of brush sizes.

Step 1: Color conversion
  By default imfuse uses colorspace sRGB and does not convert to grayscale.
  Normally you don't need to adjust these options.

 --colorspace [=ARG]  Define the colorspace from where to generate the
                      masks. Experimental option, less useful yet.
                      ARG takes arguments:
                        c       channel
                        C       colorspace          Default: sRGB
                      Some of interest: C=sRGB, C=RGB, C=Jzazbz:0  LAB: 0 HSL: 1  HCL: 1
                      For further colorspaces and their channels see:
                      https://legacy.imagemagick.org/Usage/color_basics
                      and 'magick -list colorspace'.
 --grayscale [=ARG]   Convert images to grayscale before mask generation.
                      Compare ImageMagick options -grayscale and -intensity. 
                      ARG takes argument:
                        (word)  mode                Default: Rec709Luma
                      Converting to grayscale for mask generation can speed up
                      image processing, but the result might be less accurate.

Step 2a: Mask generation - contrast masks
  Options can be specified multiple times. The order does not matter.
  Most of interest: --morphology, --statistic, --wavelet

 --blur [=ARG]        Blur edge detection. 
                      Similar to --gaussian, but faster and less accurate.
                      ARG additionally takes argument: 
                        r       radius              Default: 0
                        s       sigma               Default: 0.75
                      Adjust only sigma, radius 0 is adjusted automatically.
 --cmd [=ARG]         Custom ImageMagick option to create a mask.
                      ARG additionally takes argument:
                        (word)   string
                      string can be e.g. '-edge 2'. Avoid comma , in string.
                      There's also the use case without a command at all
                      but setting arguments C=, c or I= only.
 --cmddiff [=ARG]     Custom ImageMagick option to create a mask.
                      ARG takes argument:
                        (word)   string
                      string can be e.g. '-blur 0x5'. Avoid comma , in string.
                      The resulting mask  will be a '-compose Difference' 
                      comparision from command result with source image.
 --comet [=ARG]       Comet edge detection. Compares rotated mean areas.
                      ARG additionally takes arguments: 
                        r       radius              Default: 0
                        s       sigma               Default: 5
                        (word)  mode                Default: Lighten
                      mode can be one of 'magick -list compose'
                      Recommended: Lighten, Darken.
                      Adjust only sigma, radius 0 is adjusted automatically.
 --compass [=ARG]     Compass edge detection.
 --dog [=ARG]         Difference of Gaussian.
                      ARG additionally takes arguments: 
                        r       radius              Default: 0
                        s       sigma1              Default: 0.4
                        S       sigma2              Default: 1.6*sigma1
                      Adjust only sigma, radius 0 is adjusted automatically.
 --diffstat [=ARG]    Compares two local statistics of source images. 
                      Uses ImageMagick option -statistic. Compare --statistic.
                      ARG additionally takes arguments: 
                        r       radius              Default: 3
                        (word)  mode1               Default: median
                        (word)  mode2               Default: mean
                      mode1 and mode2 can be out of 'magick -list evaluate'.
 --freichen [=ARG]    Frei-Chen edge detection.
                      ARG additionally takes arguments: 
                        (word)  modenumber
                      Possible modenumbers at:
                      http://www.imagemagick.org/Usage/convolve/#freichen
                      Default: A combination of modes 1 and 2.
 --gaussian [=ARG]    Gaussian blur edge detection. 
                      Similar to --blur, but slower and more accurate.
                      ARG additionally takes argument: 
                        r       radius              Default: 0
                        s       sigma               Default: 0.3
                      Adjust only sigma, radius 0 is adjusted automatically.
 --kirsch [=ARG]      Kirsch edge detection. 
 --laplacian [=ARG]   Laplacian edge detection.
                      ARG additionally takes argument: 
                        (word)  modenumber          Default: 3
                      Possible modenumbers at:
                      http://www.imagemagick.org/Usage/convolve/#laplacian
 --log [=ARG]         Laplacian of Gaussian.
                      ARG additionally takes argument: 
                        r       radius              Default: 0
                        s       sigma               Default: 0.2
                      Adjust only sigma, radius 0 is adjusted automatically.
 --morphology [=ARG]  Morphology edge detection.
                      ARG additionally takes arguments: 
                        r       radius              Default: 2
                        R       kernel iteration    Default: 1
                        (word1) mode                Default: edgeout
                        (word2) kernel              Default: octagon
                      mode can be one of 'magick -list morphology'.
                        try: tophat, edge, dilate, smooth.
                      kernel can be one of 'magick -list kernel'.
                        https://imagemagick.org/Usage/morphology/#kernel
 --prewitt [=ARG]     Prewitt edge detection. 
 --roberts [=ARG]     Roberts edge detection. 
 --sobel [=ARG]       Sobel edge detection. 
 --statistic [=ARG]   ImageMagick option -statistic.
                      ARG additionally takes arguments: 
                        r       radius              Default: 2
                        (word)  mode                Default: standarddeviation
                      Argument mode is one of (number or name):
                        1|gradient|grad
                        2|maximum|max
                        3|mean
                        4|median
                        5|minimum|min
                        6|mode
                        7|nonpeak
                        8|9|rms|rootmeansquare
                        10|standarddeviation|dev
                      Get an impressive strong contrast with a high radius.
 --unsharp [=ARG]     Difference of -unsharp.
                      ARG additionally takes argument: 
                        r       radius              Default: 0
                        s       sigma               Default: 2
                      Adjust only sigma, radius 0 is adjusted automatically.
 --wavelet [=ARG]     Based on ImageMagick option -wavelet-denoise.
                      ARG additionally takes argument:
                        p       percent             Default: 5

Step 2b: Mask generation - image comparision masks
  Options can be specified multiple times. The order does not matter.
  All options are converted to option --cmd with arguments I=<name>,level=no
  Most of interest: --enfuse

 --compose [=ARG]     Composes evaluated min,max of source images with MODE.
                      ARG additionally takes argument:
                        (word)   mode               Default: overlay
                      Adding a '2', e.g. '--compose=overlay2' swaps min,max
                      to max,min and can give a different result.
                      mode can be one of 'magick -list compose'
                      Some modes of interest:
                        overlay interpolate colordodge hardlight reflect 
                        softburn softlight linearlight pegtoplight
 --enfuse [=ARG]      Image comparision with a basic enfuse result.
 --evaluate [=ARG]    Evaluates from all source images with mode MODE and
                      compares the result with each source image.
                      ARG additionally takes arguments:
                        (word)   mode               Default: max
                      mode can be one of 'magick -list evaluate'
                      Compare --max, --min, --mean, --median.
 --max [=ARG]         Same as --evaluate=max. Brightest pixels of stack.
                      Result is similar to --lightness.
 --mean [=ARG]        Same as --evaluate=mean. Average of pixels in stack.
 --median [=ARG]      Same as --evaluate=median. Median pixel of stack.
 --min [=ARG]         Same as --evaluate=min. Darkest pixels of stack.
                      Result is similar to --darkness.

Step 2c: Mask generation - colorspace channel masks
  Options can be specified multiple times. The order does not matter.
  All options are variations of --channel and are converted to option --cmd.
  Most of interest: --darkness

 --channel [=ARG]     Use a colorspace channel as mask.
                      ARG takes the general mask arguments:
                        C        colorspace
                        c        colorspace channel
                        neg      negate
                        level    leveling           Default: no
                      Colorspace can be one of 'magick -list colorspace'
                      The color channel is a number from 0..31.
                      Compare 'magick -list colorspace'.
 --chroma [=ARG]      Chroma channel from HCL colorspace.
 --darkness [=ARG]    Negated lightness channel from HSL colorspace.
                      Dark result, similar to --min.
 --lightness [=ARG]   Lightness channel from HSL colorspace. 
                      Bright result, similar to --max.
 --saturation [=ARG]  Saturation channel from HSL colorspace.

Step 3: Mask merging
  The contrast masks generated in step 2 are merged into one per image.
  Furthermore they can be adjusted with --mask* options.
  Options beginning with --mask* can be specified multiple times.
  The order of --mask* options matters, prefer to use in the shown order.

 --maskstat [=ARG]    Apply a statistic method for each mask pixel
                      to adjust it according to its neighborhood.
                      Option is applied to contrast masks only.
                      ARG takes arguments:
                        r        radius             Default: 6
                        (word)   statistic mode     Default: mean
                      word1 can be one of 'magick -list statistic'.
                      Modes of interest: mean, median, gradient.
 --maskmorph [=ARG]   Closes gaps between nearby contrast lines setting the 
                      area in between to the same contrast weight.
                      ARG takes arguments:
                        r        radius             Default: 2
                        R        kernel iteration   Default: 2
                        (word1)  mode               Default: close
                        (word2)  kernel             Default: Octagon
                      radius is the kernel radius.
                      kernel iteration multiplies the kernel radius.
                      mode can be one of 'magick -list morphology'.
                        try: open, close, erode, dilate, smooth.
                      kernel can be one of 'magick -list kernel'.
                        https://imagemagick.org/Usage/morphology/#kernel
                      CPU expensive option. Iterating the kernel is cheaper
                      than using a greater radius.
 --maskwave [=ARG]    Remove noise in masks. Can close gaps, but can also
                      create artefacts in very low contrast areas.
                      ARG takes arguments:
                        p        percent            Default: 20%
                      For percent value compare option -wavelet-denoise.
 --maskblur [=ARG]    Blur masks to enhance contrast and close minor gaps.
                      ARG takes arguments:
                        s        sigma              Default: 1
 --maskcmd [=ARG]     Custom ImageMagick option to apply on merged masks.
                      ARG takes argument:
                        (word)   string
                      string can be e.g. '-blur 0x5'. Avoid comma , in string.
 --merge [=ARG]       Compose mode to merge multiple masks.
                      ARG takes arguments:
                        (word)   mode               Default: Screen
                      mode can be one of 'magick -list compose'.
                      Of interest: Plus Interpolate Multiply Exclusion Blend
 --level [=ARG]       Levels merged masks into visible spectrum from 0%..100%
                      to provide the following focus and postprocessing
                      option arguments a full range from 0%..100%.
                      This option is enabled by default if needed.
                      ARG takes argument:
                        (word)   mode               Default: all
                      mode can be one of:
                        all:      Level all masks.
                        substack: Level only merged masks in current substack.
                        off:      Do not level merged masks.
                      mode 'substack' should only be used to speed up test runs
                      with different mask merging options within one single
                      substack. Only mode 'all' reliably provides valid values.
                      mode 'off' will make no difference in only few cases.

Step 4: Stack fusion
  The source images are processed with the merged masks,
  the overall sharp image will be generated.
  The order of --cut* options matters, prefer to use in the shown order.
  The --cut* options except --cutless can be specified multiple times.

 --cutless [=ARG]     Strenghtens less contrasted objects in front of strong
                      contrasted background objects.
                      ARG takes argument:
                        p        percent            Default: 20%
                      Percent is the minimal intermediate contrast
                      difference between background and foreground object.
                      If unsharp areas appear, use a greater percent value.
                      If the foreground object still has holes, use a lower 
                      percent value or try some of the --mask* options.
 --cutmorph [=ARG]    Change shape of cut mask. Default mode 'erode' shrinks
                      the cut mask to eliminate undesired fringes.
                      ARG takes arguments:
                        r        radius             Default: 1
                        R        kernel iteration   Default: 1
                        (word1)  mode               Default: erode
                        (word2)  kernel             Default: Octagon
                      radius is the kernel radius.
                      kernel iteration multiplies the kernel radius.
                      mode can be one of 'magick -list morphology'.
                        try: open, close, erode, dilate, smooth.
                      kernel can be one of 'magick -list kernel'.
                        https://imagemagick.org/Usage/morphology/#kernel
                      CPU expensive option. Iterating the kernel is cheaper
                      than using a greater radius.
 --cutsoft [=ARG]     Similar to --cutblur, but paint default sharp cut mask
                      over blurred cut mask.
                      ARG takes argument:
                        s        sigma              Default: 2
 --cutblur [=ARG]     Blur cut masks in final focus montage.
                      ARG takes argument:
                        s        sigma              Default: 2
 --cutcmd [=ARG]      Custom ImageMagick option to apply on cut mask.
                      ARG takes argument:
                        (word)   string
                      string can be e.g. '-blur 0x5'. Avoid comma , in string.
 --cutwave [=ARG]     Soften the cut mask. Result looses a bit of sharpness,
                      but looks more friendly overall, and covers small issues.
                      ARG takes arguments:
                        p        percent            Default: 75%
                      For percent value compare option -wavelet-denoise.
                      Use along with --maskwave and --maskblur.
 --substacks [=ARG]   Split stack into different stacks (called substacks)
                      and fuse them separately. Can be specified multiple times.
                      ARG takes arguments:
                        r        radius             Default: 5%
                        p        percent1           Default: 14%
                        P        percent2
                        n        number1
                        N        number2
                        (word)   kurt
                      You can specify single substacks or generate a set of 
                      substacks. Please specify either percents or numbers.
                      - Given only one of percent or number, imfuse will
                        generate a set of substacks accordingly.
                         - word 'kurt' starts all substacks with image 1.
                      - If you specify two of percents or numbers, one single
                        substack within the given range of images is generated.
                      - radius specifies how many images neigboured substacks
                        should share. A percent value for radius is allowed.
                      Use --threshold or --alpha for transparent substacks.
                      The substacks will be composed over each other onto
                      a background (to specify with --background).
                      See also --layered to store the single substacks as layers.
                      That allows manual rework of the results in gimp.
 --soft [=ARG]        Enable soft fusion mode. Different concept than 
                      default maximum contrast montage. Images are multiplied 
                      with their contrast masks and added altogether as a whole.
                      ARG takes arguments:
                        p        percent1          Default: 2%
                        P        percent2          Default: 100%
                        (word)   mode              Default: Plus
                      Increasing percent1 increases softness of low contrast.
                      Increasing percent2 increases sharpness of high contrast.
                      mode can be one of 'magick -list compose'. Of interest:
                        Plus Screen
                      Does not support --cutless, --cutblur, --cutsoft.

Step 5: Post processing
  The order of the options on cli matters. Noteably --alpha with percent values
  different from =0%,100% affects the following percent arguments.
  All options can be specified multiple times if that makes sense.

 --alpha [=ARG]       Generate transparent image using the contrast mask as 
                      alpha channel (=transparency channel).
                      Good method to reduce noise in low contrast areas.
                      The semitransparent result is composed over --background.
                      ARG takes arguments:
                        p        percent1          Default: 0%
                        P        percent2          Default: 100%
                      percent1 affects the low contrast areas with
                       a useful range of -100%..+50%.
                      percent2 affects the high contrast areas with
                       a useful range of +100%..+200%.
                      Higher values make less transparent.
                      The percent values are applied as '+level p%xP%'
                      on the transparency alpha channel.
 --finalblur [=ARG]   Soft blur of bokeh in low contrast areas.
                      ARG takes arguments:
                        t        threshold         Default: 50%
                        s        sigma1            Default: 3
                        S        sigma2            Default: 2
                      Blurs low contrast areas below threshold with sigma1.
                      If sigma2 is given, the cut border between bokeh and 
                      foreground is blurred for a soft transition.
 --finalblur2 [=ARG]  Soft blur of bokeh in low contrast areas.
                      Other than --finalblur it blurs according to the contrast
                      mask strengh. Low contrast is blurred more than high.
                      ARG takes arguments:
                        r        radius            Default: 4
                        t        threshold         Default: 50
 --threshold [=ARG]   Make low (or high) contrast area transparent.
                      ARG takes arguments:
                        t        threshold1        Default: 50%
                        T        threshold2        Default: 100%
                        s        sigma             Default: 0
                      threshold1 removes low contrast areas below a percent.
                      threshold2 removes high contrast areas above a percent.
                      sigma blurs the cut border.

Step 6: Background
  Background for transparent images.
  Can be specified multiple times for option --layered.

 --bg, --background [=ARG]  Specify a background to paint on.
                      ARG takes argument:
                        (word)   background        Default: enfuse
                      background can be one out of:
                        enfuse
                        transparent
                        magick -list color
                        magick -list evaluate (compare --evaluate)
                        magick -list compose  (compare --compose)
                      Try:  enfuse mean max min
                            colorize colorize2 pinlight pinlight2
                            interpolate overlay pegtoplight reflect
"
}

### Messages

error() {
  echo "
imfuse ERROR: $*
" >&2
  kill -s SIGINT $Imfusepid
}
note() {
  echo "imfuse: $*" >&2
  return 0
}
verbose() {
  [ "$Verbose" = "yes" ] && echo "imfuse: $*" >&2
  return 0
}
showimage() {
  local Frame
  [ "$Showimageprocessing" = "yes" ] && geeqie -t -r --File:"${1:-}" 2>/dev/null &
  #[ "$Showimageprocessing" ] && bash imgview "${1:-}"
  [ "$Video" ] && {
#    Videoframecount="$((Videoframecount+1))"
    Videoframecount="$(ls "$Cachedir"/videoframe????.* | sort -V | tail -n1)"
    Videoframecount="$(basename "$Videoframecount")"
    Videoframecount="${Videoframecount//[^0-9]/}"
    Videoframecount="$(sed "s/^0*//" <<< "$Videoframecount")"
    Videoframecount="$(calc "$Videoframecount+1")"
    Frame="$Cachedir/videoframe$(printnum "$Videoframecount").tif"
    #ln -s "${1:-}" "$Frame"
    cp "${1:-}" "$Frame" ### FIXME ln -s where possible
  }
  return 0
}
traperror() {
  error "traperror(): Command at Line ${2:-} returned with error code ${1:-}:
  ${4:-}
  ${3:-} - ${5:-}"
}

### Misc

calc() {
  LC_ALL=C awk "BEGIN {print $* }"
}
checkmagicklist() {
  local Check
  [ "${3:-}" = "print" ] && Check="" || Check="-q"
  $Magickbin -list "${1:-}" | grep -w -i "^${2:-XXX}" | head -n1 | awk '{print $1}' | grep $Check -w -i "^${2:-XXX}"
}
compare() {
  # compare floating number with < > =
  local Arg1 Arg2 Operator
  Arg1="${1:-}"
  Operator="${2}"
  Arg2="${3:-}"
  case "$Operator" in
    "<"|"lt"|"-lt")      Operator="<" ;;
    ">"|"gt"|"-gt")      Operator=">" ;;
    "="|"eq"|"-eq"|"==") Operator="==" ;;
  esac
  [ -n "$(LC_ALL=C awk "BEGIN{if ($Arg1 $Operator $Arg2) print \"yes\"}")" ]
}
digitonly() {
  #sed "s/[^0-9.]//g" <<< "${1:-}"
  echo "${1//[^0-9.]/}"
}
digitrm() {
  #sed "s/[0-9.]//g" <<< "${1:-}"
  echo "${1//[0-9.-]/}"
}
generate_key() {
  # generate a unique key value from current time and nanoseconds
  date +%s.%N
}
lowercase() {
    # Usage: lowercase "string"
    printf '%s\n' "${1,,}"
}
md5cut() {
  # print last 6 digits
  tr "\n" " " <<< "$*" | md5sum | cut -c27-32
}
numberofpercent() {
  Number="${1:-}"
  Number="${Number//%}"
  Number="$((Number*Sourceimagenumber/100))"
  [ "$Number" -lt "1" ]            && Number=1
  [ "$Number" -gt "$Sourceimagenumber" ] && Number="$Sourceimagenumber"
  echo "$Number"
}
percentrm() {
  # remove % from string
  #sed s/%//g <<< "${1:-}"
  echo "${1//%/}"
}
printnum(){
  # print number $1 with leading zeroes.
  # $1 number
  # $2 digits. Default: 4
  [ "${1:-}" = "NUMBER" ] && echo "NUMBER" && return 0 
  printf %0${2:-4}d "${1:-0}"
}
printsameline() {
  # print $1 without newline at begin of current line
  echo -ne "${1:-}\033[0K\r" >&2
}
printtotalmemory() {
  # print total memory including zram
  local Memory Line Zram
  Memory="$(LC_ALL=C free | grep "Mem:" | LC_ALL=C awk '{print $2}')"
  while read Line; do
    Zram="$(LC_ALL=C awk 'BEGIN {OFMT = "%.0f"} {print $3}' <<< "$Line")"
    Zram="$(LC_ALL=C awk 'BEGIN {OFMT = "%.0f"} {print $1 / 1000}' <<< "$Zram")"
    Memory="$((Memory + Zram))"
  done < <(/sbin/swapon --bytes | grep zram ||:)
  echo $Memory
}
unspecialstring() {
  # Replace all characters except those described in tr string with a '-'.
  printf %s "${1:-}" | LC_ALL=C tr -c "a-zA-Z0-9.,=-_" "-"
}

### Debugging helpers

forcemask() {
  note "Forcing mask generation"
  rm -f "$Cachedir"/mask.${1:-}*
  forcelevel
}
forcelevel() {
  note "Forcing leveling"
  rm -f "$Cachedir"/level.${1:-}*
  forcemerge
}
forcemerge() {
  note "Forcing merge"
  rm -f "$Cachedir"/*merge*
  forcefocus
}
forcefocus() {
  note "Forcing focus"
  rm -f "$Cachedir"/focus*
  rm -f "$Cachedir"/substackresult*
}
forcepost() {
  note "Forcing focus postprocessing"
  rm -f "$Cachedir"/substackresult*-post*
}

#### run commands on all CPUs

multicore() {
  # Run multiple processes in parallel, but not more than $Multicore_maxprocesses
  # $1 Command
  # $2 Image to show if $1 is finished
  # $3 Memory needed by the process
  # Run multicore_wait afterwards to wait for the last processes to finish.

  local Process Command
  local Mem_needed Zram

  [ "${1:-}" = "-t1" ] && {
    shift
    [ "$Multicore_processcount" -gt 0 ] && {
      multicore_wait || return 1
    }
  }

  [ "$Multicore_processcount" = "$Multicore_maxprocesses" ] && {
    multicore_wait || return 1
  }
  [ "$Multicore_processcount" = "0" ] && {
    Multicore_memorymax="$(printfreememory)"
    Multicore_memorymax="$((Multicore_memorymax*8/10))"
  }
  Mem_needed=0
  for Process in $(seq $Multicore_maxprocesses); do
    Mem_needed="$(awk "BEGIN {print $Mem_needed + ${Multicore_memory[$Process]:-0} }" )"
  done
  Mem_needed="$((Mem_needed+${3:-0}))"
  [ "$Mem_needed" -gt "$Multicore_memorymax" ] && {
    note "multicore: Low memory. Waiting for $Multicore_processcount running processes to finish. Need: $(( ${3:-0}/1000 )) (overall $((Mem_needed/1000))) MB, Available: $((Multicore_memorymax/1000)) MB"
    [ "$Mem_needed" -gt "$Multicore_memorymax" ] && [ "$Multicore_processcount" = "0" ] && note "multicore: Likely hard disk cache will be used and slow down the calculation."
    multicore_wait || return 1
  }

  ifcmdbreak && return 1

  Multicore_processcount=$((Multicore_processcount +1))

  Command="$(cut -d ' ' -f1 <<< "${1:-}")"
  case $(type -t "$Command") in
    file) Command="nice ${1:-}" ;;
    *)    Command="${1:-}" ;;
  esac

  #verbose "multicore: ${1:-}"
  eval "$Command &"

  Multicore_process[Multicore_processcount]=$!
  Multicore_image[Multicore_processcount]="${2:-}"
  Multicore_memory[Multicore_processcount]="${3:-0}"

  return 0
}
multicore_wait() {
  local Process Error=
  for Process in $(seq ${Multicore_maxprocesses:-0}); do
    [ "${Multicore_process[$Process]}" ] && {
      multicore_waitprocess "${Multicore_process[$Process]}" || {
        multicore_break
        Error=1
      }
      [ "$Error" ] && break
      [ "${Multicore_image[$Process]}" ] && showimage "${Multicore_image[$Process]}"
    }
    Multicore_process[$Process]=""
    Multicore_image[$Process]=""
    Multicore_memory[$Process]="0"
  done
  [ "$Error" ] && return 1
  Multicore_processcount=0
  return 0
}
multicore_waitprocess() {
  local Error=
  while sleep 0.2 ; do
    ps -p "${1:-}" >/dev/null || break
    ifcmdbreak && Error=1
    [ "$Error" ] && break
  done
  [ "$Error" ] && return 1
  wait "${1:-}"
  return $?
}
multicore_break() {
  local Process
  for Process in $(seq ${Multicore_maxprocesses:-0}); do
    [ "${Multicore_process[$Process]}" ] && {
      verbose "multicore_break: Sending SIGINT to $(ps -p ${Multicore_process[$Process]})"
      kill "${Multicore_process[$Process]}"
      wait "${Multicore_process[$Process]}"
      Multicore_process[$Process]=""
      Multicore_image[$Process]=""
      Multicore_memory[$Process]="0"
    }
  done
}
multicore_init() {
  # declare global variables
  local Process
  Multicore_maxprocesses="$(nproc)"
  Multicore_maxprocesses="${Multicore_maxprocesses:-1}"
  Multicore_maxprocesses="$((Multicore_maxprocesses * 2))"
  for Process in $(seq $Multicore_maxprocesses); do
    Multicore_process[$Process]=""
    Multicore_image[$Process]=""
    Multicore_memory[$Process]="0"
  done
  Multicore_processcount=0
  Multicore_minram=250000
  Multicore_maxprocesses=$Multicore_maxprocesses
}
ifcmdbreak() {
  [ -e "$Cachedir/exit" ]
  #return 1
}
printfreememory() {
  # print current free memory including zram
  local Memory Line Zram
  Memory="$(LC_ALL=C free | grep "Mem:" | LC_ALL=C awk '{print $7}')"
  while read Line; do
    Zram="$(LC_ALL=C awk 'BEGIN {OFMT = "%.0f"} {print ($3 - $4)}' <<< "$Line")"
    Zram="$(LC_ALL=C awk 'BEGIN {OFMT = "%.0f"} {print $1 / 1000}' <<< "$Zram")"
    #Memory="$((Memory + Zram))"
  done < <(/sbin/swapon --bytes | grep zram ||:)
  echo $Memory
}

### Files

check_outputname() {
  # Generate a unique output name showing options

  Resultbasename=""
  [ "$Align" = "yes" ] && Resultbasename="${Resultbasename}--align"

  # step colorspace
  maskarg_single "colorspace" && Resultbasename="${Resultbasename}--col=${Imarguments[$Argcount]%TYPE*}"
  # step grayscale
  maskarg_single "grayscale" && Resultbasename="${Resultbasename}--gray=${Imarguments[$Argcount]%TYPE*}"

  # step mask generation
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      mask)
        Resultbasename="${Resultbasename}--${Argmethod}=${Imarguments[$Count]%TYPE*}"
      ;;
    esac
  done

  # step merge
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      merge)
        Resultbasename="${Resultbasename}--${Argmethod}=${Imarguments[$Count]%TYPE*}"
      ;;
    esac
  done
  maskarg_single "merge"   && Resultbasename="${Resultbasename}--merge=${Imarguments[$Argcount]%TYPE*}"
  maskarg_single "level"   && Resultbasename="${Resultbasename}--level=${Imarguments[$Argcount]%TYPE*}"

  # step focus
  maskarg_single "soft"    && Resultbasename="${Resultbasename}--soft=${Imarguments[$Argcount]%TYPE*}"
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      focus)
        Resultbasename="${Resultbasename}--${Argmethod}=${Imarguments[$Count]%TYPE*}"
      ;;
    esac
  done

  # step substacks
  [ "$Substackautoall" = "no" ] && for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      substack)
        Resultbasename="${Resultbasename}--${Argmethod}=${Imarguments[$Count]%TYPE*}"
      ;;
    esac
  done

  # step postprocessing
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      postfocus)
        Resultbasename="${Resultbasename}--${Argmethod}=${Imarguments[$Count]%TYPE*}"
      ;;
    esac
  done

  # step background
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      background)
        Resultbasename="${Resultbasename}--bg=${Imarguments[$Count]%TYPE*}"
      ;;
    esac
  done

  # misc
  [ -n "$Revertimagelist" ]   && Resultbasename="${Resultbasename}--rev"
  [ "$Storelayered" = "yes" ] && Resultbasename="${Resultbasename}--layered"
  [ -n "$Testsetup" ]         && Resultbasename="${Resultbasename}--test$Testarg"

  Fusemd5sum="$(md5cut "$Sourcemd5 ${Imoptions[@]} ${Imarguments[@]} $Testsetup$Testarg" )"

  Resultbasename="${Resultbasename#,}_md${Fusemd5sum}"
  Resultbasename="$(unspecialstring "$Resultbasename")"
  Resultbasename="$(sed "s/w100,//g ; s/w100//g ; s/,--/--/g ; s/,_/_/g ; s/=--/--/g ; s/=,/,/g ; s/=_/_/g ; s/=\./\./g" <<< "$Resultbasename")"

  [ -z "${Outputdir:-}" ] && Outputdir="./"
  case $Outputimage in
    "") Outputimage="$Outputdir/${Outputbasename:-"imfuse"}${Resultbasename}.${Imageformat}" ;;
    *) [ "$(basename "$Outputimage")" = "$Outputimage" ] && Outputimage="${Outputdir}/{$Outputimage}" ;;
  esac
  [ "$Video" ] && Video="$Outputimage.webm"

  # --savemask
  [ "$Savemask" = "auto" ] && Savemask="$Outputimage.mask.tif"

  return 0
}
load_sourceimages() {
  # Load source images into imagemagick registry
  # (Can also happen in align())
  local Sourceimage Count Number Command
  local Firstimage Lastimage

  Firstimage="${1:-1}"
  Lastimage="${2:-$Sourceimagenumber}"

  sendmagickmessage "STOPWATCH"
  for Count in $(seq $Lastimage -1 $Firstimage); do
    Number="$(printnum "$Count")"

    case "$Loadsourceimages" in
      yes)
        [ -z "${Imsourceimagelist[$Count]:-}" ] && {
          Imsourceimagelist[$Count]="mpr:sourceimage.$(printnum $Count)"

          sendmagickmessage "PROGRESS:Loading source image: ${Sourceimagelist[$Count]} ETA:$Count"
          Command="
  '${Sourceimagelist[$Count]}'
    -alpha off
    -depth 16
    -write '$(sourceimagename $Count)'
    -delete 0"
          cmd "$Command"
        }
      ;;
      no)
        Imsourceimagelist[$Count]="${Sourceimagelist[$Count]}"
      ;;
    esac
  done
  [ "$Loadsourceimages" = "yes" ] && sendmagickmessage "/PROGRESS"
  cmd_waitforready

  return 0
}
maskarray() {
  local Basename
  local -n List="${4:-}"
  local Firstimage Lastimage
  Firstimage="${2:-1}"
  Lastimage="${3:-$Sourceimagenumber}"
  Basename="${1:-}"
  for Count in $(seq $Sourceimagenumber); do
    List[$Count]="$(maskname "$Basename" $Count)"
  done
}
masklist() {
  local Basename List=
  local Firstimage Lastimage
  Basename="${1:-}"
  Firstimage="${2:-1}"
  Lastimage="${3:-$Sourceimagenumber}"
  for Count in $(seq "$Firstimage" "$Lastimage"); do
    List="$List '$(maskname "$Basename" "$Count")'"
  done
  echo "$List"
}
sourceimagename() {
  # print source image name number $1.
  # might be an mpr: or a file depending on $Loadsourceimages.
  echo "${Imsourceimagelist[${1:-}]}"
}
maskexist() {
  local Count
  local Firstimage Lastimage=

  Firstimage="${2:-1}"
  [ -n "${2:-}" ] && [ -z "${3:-}" ] && Lastimage="$Firstimage"
  [ -z "$Lastimage" ]                && Lastimage="${3:-$Sourceimagenumber}"

  case "$Masktocache" in
    yes)
      for Count in $(seq $Firstimage $Lastimage); do
        [ -e "$Cachedir/mask.${1:-}.$(printnum "$Count").${Masksuffix}" ] || return 1
      done
      return 0
    ;;
    no)
      return 1
    ;;
  esac
}
maskname() {
  [ -z "${1:-}" ] && error "maskname(): maskbasename is empty: ${1:-} ${2:-}"
  [ -z "${2:-}" ] && error "maskname(): number not given: ${1:-} ${2:-}"
  case "$Masktocache" in
    yes)
      echo "$Cachedir/mask.${1:-}.$(printnum "${2:-}").${Masksuffix}"
    ;;
    no)
      echo "mpr:${1:-}.$(printnum "${2:-}")"
    ;;
  esac
}

### image processing helpers

align() {
  # align with focus-stack
  # https://github.com/PetteriAimonen/focus-stack

  local Log Line Image Count Command
  local X Y W H Lmax=0 Tmax=0 Rmin=10000000 Bmin=10000000
  local Aligndir

  Log="$Cachedir/align.log"
  Aligndir="$Cachedir/aligned.$Sourcemd5"
  mkdir -p "$Aligndir"

  note "Aligning source images with external tool focus-stack."
  focus-stack --verbose --output="$Aligndir/" --align-only --no-contrast --no-whitebalance ${Sourceimagelist[@]} >"$Log" || return 1

  # calculate smallest valid area common to all aligned images
  while read Line; do
    Line="$(cut -d' ' -f4- <<< "$Line")"
    X="$(digitonly "$(cut -d, -f1 <<< "$Line")" )"
    Y="$(digitonly "$(cut -d, -f2 <<< "$Line")" )"
    W="$(digitonly "$(cut -d, -f3 <<< "$Line")" )"
    H="$(digitonly "$(cut -d, -f4 <<< "$Line")" )"
    [ "$X" -gt "$Lmax" ] && Lmax="$X"
    [ "$Y" -gt "$Tmax" ] && Tmax="$Y"
    [ "$((X+W))" -lt "$Rmin" ] && Rmin="$((X+W))"
    [ "$((Y+H))" -lt "$Bmin" ] && Bmin="$((X+W))"
  done < <(grep "valid area" "$Log" ||:)
  X="$Lmax"
  Y="$Tmax"
  W="$((Rmin-Lmax-1))"
  H="$((Bmin-Tmax-1))"

  # crop aligned images to valid area, store as mpr source images
  sendmagickmessage "STOPWATCH"
  for Count in $(seq $Sourceimagenumber -1 1); do
    Image="${Sourceimagelist[$Count]}"
    Number="$(printnum "$Count")"
    Image="$Aligndir/$(basename "$Image")"
    Sourceimagelist[$Count]="$Image"
    case "$Loadsourceimages" in
      yes)
        Imsourceimagelist[$Count]="mpr:sourceimage.$(printnum $Count)"
      ;;
      no)
        Imsourceimagelist[$Count]="$Image"
      ;;
    esac

    sendmagickmessage "PROGRESS:Cropping aligned images ${W}x${H}+${X}+${Y}: $Image ETA:$Count"

    Command="
  '$Image'
    -crop ${W}x${H}+${X}+${Y}
    -write '$(sourceimagename $Count)'
    $(showimagecode "$(sourceimagename $Count)")
    -delete 0"
    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"
  cmd_waitforready

  Sourcemd5="$(md5cut "$(ls -f -l --full-time ${Sourceimagelist[@]})" )"

  case "$Loadsourceimages" in
    yes)
      Sourceimagesalreadyloaded="yes"
      #rm -r "$Aligndir" # enfuse would need it
    ;;
  esac

  return 0
}
alphalevel() {
  local Command Image Mask Percent1 Percent2
  local Longoptions Parsedoptions

  Longoptions="image:,mask:,percent1:,percent2:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --image)        Image="${2:-}"    ; shift ;;
      --mask)         Mask="${2:-}"     ; shift ;;
      --percent1)     Percent1="${2:-}" ; shift ;;
      --percent2)     Percent2="${2:-}" ; shift ;;
    esac
    shift
  done

  [ -z "$Image" ] && return 1
  Percent1="${Percent1:-0}"
  Percent2="${Percent2:-100}"

  Command="
  ## alphalevel()
  '$Image'
    -write mpr:image
    -delete 0"
  case "$Mask" in
    "")
      Command="$Command
  mpr:image
    -channel alpha
    -separate
    -write mpr:mask
    -delete 0"
    ;;
    *)
      Command="$Command
  '$Mask'
    -write mpr:mask
    -delete 0"
    ;;
  esac

  Command="$Command
  mpr:mask
    +level ${Percent1}%x${Percent2}%
    -write mpr:mask
    -delete 0"

  case "$Mask" in
    "") ;;
    *)
      Command="$Command
  mpr:mask
    -write '$Mask'
    -delete 0"
    ;;
  esac

  Command="$Command
  mpr:image
  mpr:mask
    -alpha off
    -compose CopyOpacity -composite
    $Tifstorealpha
    -write '$Image'
    -delete 0"

  Command="$Command
  +set registry:image
  +set registry:mask"

  Command="$Command
  ## /alphalevel()"

  cmd "$Command"
  cmd_waitforready
  return 0
}
clut_gaussian() {
  # create gaussian clut image $1 with sigma $2
  local Command Clutimage Sigma
  Clutimage="${1:-}"
  Sigma="${2:-1}"
  Command="
  -size 1x1
  xc:white
    -bordercolor Black
    -border 2x0
    -filter gaussian
    -define filter:sigma=$Sigma
    -resize 512x256!
    -crop 50%x100%+0+0
    -auto-level
    -write '$Clutimage'
    -delete -1"
  cmd "$Command"
  cmd_waitforready
}
enfuse_split() {
  local Resultimage Enfuseoptions
  local Command Count
  local Firstimage Lastimage
  local Mem_free Mem_needed
  local Splitimagelist= Splitimagename Splitresult= Splitcache Split Splits Splitheight
  local Startzeit

  Resultimage="${1:-}"
  Firstimage="${2:-1}"
  Lastimage="${3:-$Sourceimagenumber}"

  Mem_free="$(printfreememory)"
  Mem_needed="$(( (Lastimage-Firstimage+1) * Imagewidth*Imageheight * 2 * 32 / (8*1024)))"
  Enfuseoptions="--contrast-weight=1 --saturation-weight=0 --exposure-weight=0 --hard-mask"

  sendmagickmessage "NOTE:Generating image with external tool enfuse"
  Startzeit="$(date +%s)"
  Splits="$((Mem_needed / Mem_free +1))"

  case "$Splits" in
    1)
      ### Single run attempt
      nice enfuse $Enfuseoptions -o "$Resultimage" "${Sourceimagelist[@]:$Firstimage:$Lastimage}" 2>&1 | grep -v -E "loading next image|assuming all pixels should contribute|does not have an alpha channel|TIFFDecoder" || error "Failed to generate enfuse image"
    ;;
    *)
      ### Splitting attempt
      note "enfuse: Splitting source images due to low memory."
      load_sourceimages "$Firstimage" "$Lastimage"

      Splitheight=$((Imageheight/Splits))
      Splitcache="$Cachedir/enfuse.split"
      mkdir -p "$Splitcache"

      for Split in $(seq $Splits); do
        Splitgeometry[$Split]="${Imagewidth}x$((Splitheight + $([ "$Split" -lt "$Splits" ] && echo 20 || echo 0) ))+0+$(( (Split-1) * Splitheight ))"
      done

      sendmagickmessage "STOPWATCH"
      for Count in $(seq "$Firstimage" "$Lastimage"); do

        sendmagickmessage "PROGRESS:enfuse: Splitting source images into $Splits parts: ${Sourceimagelist[$Count]} ETA:$Count"

        Command="
  '${Sourceimagelist[$Count]}'
    -write mpr:sourceimage
    -delete 0"
        for Split in $(seq $Splits); do
          Splitimagename="$Splitcache/split.$(printnum $Count).${Split}.png"
          Command="$Command
  mpr:sourceimage
    -crop ${Splitgeometry[$Split]}
    +repage
    -write '${Splitimagename}'
    -delete 0"
          Splitimagelist[$Split]="${Splitimagelist[$Split]:-} $Splitimagename"
        done
        #cmd "$Command"
        multicore "$Magickbin $(tr -d "\n" <<< "$Command") -exit"
      done
      multicore_wait
      sendmagickmessage "/PROGRESS"
      #cmd_waitforready

      for Split in $(seq $Splits); do
        note "Running enfuse step $Split / $Splits"
        Splitresult[$Split]="$Splitcache/splitresult${Split}.png"
        nice enfuse $Enfuseoptions -o "${Splitresult[$Split]}" ${Splitimagelist[$Split]} 2>&1 | grep -v -E "loading next image|assuming all pixels should contribute|does not have an alpha channel|TIFFDecoder" || error "Failed to generate enfuse image"
        showimage "${Splitresult[$Split]}"
      done

      sendmagickmessage "NOTE:enfuse: Appending splits to result"
      Command="
  mpr:black
    -write mpr:append
    -delete 0"
      for Split in $(seq $Splits); do
        Command="$Command
  mpr:append
    +repage
    -gravity NorthWest
  '${Splitresult[$Split]}'
    +repage
    -gravity NorthWest
    -geometry +0+$(( (Split -1) * Splitheight ))
    -compose Over -composite
    -write mpr:append
    -delete 0"
      done
      Command="$Command
  mpr:append
    $Tifstore
    -write '$Resultimage'
    $(showimagecode "$Resultimage")
    -delete 0
  +set registry:append"
      cmd "$Command"
      cmd_waitforready

      rm -r "$Splitcache"
    ;;
  esac

  note "enfuse_split()[$Splits] ready after: $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")"
  return 0
}
evaluate() {
  local Imagelist Imagenumber=0 Resultimage Mode
  local Command

  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  while [ $# -gt 0 ]; do
    Imagenumber="$((Imagenumber+1))"
    Imagelist[$Imagenumber]="${1:-}"
    shift
  done

  sendmagickmessage "NOTE:Evaluating $Mode: $Resultimage"

  [ "$Loadsourceimages" = "no" ] && {
    case "$Mode" in
      max|min|mean)
        #evaluate_splitlist "$Mode" "$Resultimage" "${Imagelist[@]}"
        evaluate_iterative "$Mode" "$Resultimage" "${Imagelist[@]}"
        return 0
      ;;
    esac
  }

  Command="
  # evaluate() $Mode: $Resultimage
  $(printf "'%s' " "${Imagelist[@]}")
    -alpha off
    -evaluate-sequence $Mode
    $Tifstore
    -write '$Resultimage'
    $(showimagecode "$Resultimage")
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  return 0
}
evaluate_iterative() {
  # supports min, max, mean
  # loads images one by one instead all of them

  local Imagelist Imagenumber=0 Resultimage Mode
  local Command

  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  while [ $# -gt 0 ]; do
    Imagenumber="$((Imagenumber+1))"
    Imagelist[$Imagenumber]="${1:-}"
    shift
  done
  case "$Mode" in
    max) Mode="lighten" ;;
    min) Mode="darken" ;;
  esac

  Command="
  '${Imagelist[1]}'"
  case "$Mode" in
    darken|lighten)
      for Count in $(seq 2 $Imagenumber); do
        Command="$Command
  '${Imagelist[$Count]}'
    -format 'PROGRESS:Evaluating $Count / $Imagenumber: ${Imagelist[$Count]}\n'
    -write info:
    -compose $Mode -composite
    $(showimagecode)"
      done
    ;;
    mean)
      for Count in $(seq 2 $Imagenumber); do
        Command="$Command
  '${Imagelist[$Count]}'
    -alpha off
    -format 'PROGRESS:Evaluating $Count / $Imagenumber: ${Imagelist[$Count]}\n'
    -write info:
    -compose blend
    -set option:compose:args $(calc 100/$Count)
    -composite
    $(showimagecode)"
      done
    ;;
    *)
      error "evaluate_iterative(): Unsupported mode: $Mode"
    ;;
  esac
  Command="$Command
    -write '$Resultimage'
    -delete 0"
  cmd "$Command"
  cmd_waitforready
  sendmagickmessage "/PROGRESS"

  return 0
}
evaluate_splitlist() {

  local Imagelist Imagenumber=0 Resultimage Mode
  local Command
  local Split Splits Splitresult Splitfirstimage Splitlastimage
  local Mem_free Mem_needed

  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  while [ $# -gt 0 ]; do
    Imagenumber="$((Imagenumber+1))"
    Imagelist[$Imagenumber]="${1:-}"
    shift
  done

  Splits="$(nproc)"
  Mem_free="$(printfreememory)"
  Mem_free="$((Mem_free * 8/10))"
  Mem_needed="$((Imagenumber * Imagememsize))"

  while [ "$((Mem_needed / Splits))" -gt "$Mem_free" ]; do
    Splits="$((Splits +1))"
  done
  [ "$Splits" -lt "1" ] && Splits=1
  Splits="$((Splits+1))"

  for Split in $(seq $Splits); do
    Splitfirstimage[$Split]="$(( (Split-1)*Imagenumber/Splits +1))"
    Splitlastimage[$Split]="$(( (Split)*Imagenumber/Splits +1))"
    [ "${Splitlastimage[$Split]}" -gt "$Imagenumber" ] && Splitlastimage[$Split]="$Imagenumber"
    Splitresult[$Split]="$Cachedir/evalsplit_$Mode.$Split.mpc"
  done

  sendmagickmessage "NOTE:evaluating in $Splits tasks outside of script"

  for Split in $(seq $Splits); do
#  -limit memory ${Mem_free}KB
#  -define registry:temporary-path='$Cachedir'
    Command="$Magickbin
  $(printf "'%s' " "${Imagelist[@]:${Splitfirstimage[$Split]}:${Splitlastimage[$Split]}}")
    -evaluate-sequence $Mode
    -write '${Splitresult[$Split]}'
    -delete 0
    -exit"
    multicore "$(tr -d "\n" <<< "$Command")" "${Splitresult[$Split]}" "$(( Imagememsize * (${Splitlastimage[$Split]}-${Splitfirstimage[$Split]}+1) ))"
  done
  multicore_wait

  Command="
  '${Splitresult[@]}'
    -evaluate-sequence $Mode
    -write '$Resultimage'
    -delete 0"
  cmd "$Command"
  cmd_waitforready
}
exiftransfer() {
  # Transfer exif data from image $1 to image $2
  # Does not transfer image size information.
  # Sets orientation tag to horizontal / no rotation.
  # Several warnings are supressed.
  local Sourceimage Destinationimage Exifargs
  
  Sourceimage="${1:-}"
  Destinationimage="${2:-}"
  Exifargs="$(exiftool -a -u -g1 -args "$Sourceimage")"
  Exifargs="$(LC_ALL=C grep -v -E -- \
    '-ExifTool|-System:|-File:|ImageWidth|ImageHeight|ImageSize|Compression|Orientation|Resolution' <<< "$Exifargs" \
    | sed "s/'/'\"'\"'/g ; s/=/='/ ; s/\$/'/" )"
  eval exiftool -ignoreMinorErrors -overwrite_original_in_place $Exifargs -Orientation=Horizontal "$Destinationimage" 2>&1 | grep -v -E 'Warning|files updated'
}
finalblur() {
  local Image Mask Percent Sigma1 Sigma2 Command
  local Longoptions Parsedoptions

  Longoptions="image:,mask:,percent:,sigma1:,sigma2:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --image)   Image="${2:-}"   ; shift ;;
      --mask)    Mask="${2:-}"    ; shift ;;
      --percent) Percent="${2:-}" ; shift ;;
      --sigma1)  Sigma1="${2:-}"  ; shift;;
      --sigma2)  Sigma2="${2:-}"  ; shift ;;
      --) ;;
    esac
    shift
  done
  Sigma1="${Sigma1:-1}"
  Sigma2="${Sigma2:-0}"
  Percent="${Percent:-50}"

  Command="
  # --finalblur
  '$Image'
    -write mpr:image
    -delete 0
  '$Mask'
    -write mpr:maxmask
    -delete 0
  mpr:maxmask
    -threshold ${Percent:-10}%
    -negate
    -write mpr:cutmask
    -delete 0"
    Command="$Command
  mpr:image
    -alpha off
    -blur 0x$Sigma1
    -write mpr:bokeh
    -delete 0
  mpr:bokeh
  ( mpr:cutmask -blur 0x$Sigma2 )
    -alpha off
    -compose CopyOpacity -composite
    -write mpr:partsource_blurred
    -delete 0
  mpr:image
  mpr:partsource_blurred
    -compose Over -composite
    -write '$Image'
    $(showimagecode)
    -delete 0
  +set registry:bokeh
  +set registry:cutmask
  +set registry:image
  +set registry:maxmask
  +set registry:partsource_blurred"

  cmd "$Command"
  cmd_waitforready
  return 0
}
finalblur2() {
  # --finalblur2

  local Longoptions Parsedoptions
  local Image Threshold Blur Mask
  local Command

  Longoptions="image:,mask:,percent:,blur:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --blur)    Blur="${2:-}"      ; shift ;;
      --image)   Image="${2:-}"     ; shift ;;
      --mask)    Mask="${2:-}"      ; shift ;;
      --percent) Threshold="${2:-}" ; shift ;;
      --) ;;
    esac
    shift
  done

  Command="
  # --finalblur
  '$Image'
    -write mpr:image
    -delete 0
  '$Mask'
    -write mpr:mask
    -delete 0
  mpr:mask
    -white-threshold ${Threshold}%
    -negate
    -write mpr:mask
    -delete 0
  mpr:image
  mpr:mask
    -compose Blur
    -set option:compose:args ${Blur}x${Blur}
    -composite
    -write '$Image'
    $(showimagecode "$Image")
    -delete 0
"
  cmd "$Command"
  cmd_waitforready
}
generate_image() {
  local Mode Imagename= Swap Imagetype= Showname= Showmode= Command Size 
  local Generalimage= Skip=
  local Longoptions Parsedoptions
  local Firstimage Lastimage

  Longoptions="first:,last:,mode:,name:,showname,showmode"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --first)    Firstimage="${2:-}" ; shift ;;
      --last)     Lastimage="${2:-}"  ; shift ;;
      --mode)     Mode="${2:-}"       ; shift ;;
      --name)     Imagename="${2:-}"  ; shift ;;
      --showname) Showname="yes"      ;;
      --showmode) Showmode="yes"      ;;
    esac
    shift
  done

  Firstimage="${Firstimage:-1}"
  Lastimage="${Lastimage:-$Sourceimagenumber}"
  Size="${Imagewidth}x${Imageheight}"

  checkmagicklist color                     "$Mode"   && Imagetype="color"    && Mode="$(checkmagicklist "$Imagetype" "$Mode" print)"
  checkmagicklist evaluate                  "$Mode"   && Imagetype="evaluate" && Mode="$(checkmagicklist "$Imagetype" "$Mode" print)"
  checkmagicklist compose  "$(tr -d "2" <<< "$Mode")" && Imagetype="compose"  && Mode="$(checkmagicklist "$Imagetype" "$Mode" print)"
  case "$Mode" in
    enfuse)                                              Imagetype="enfuse" ;;
  esac

  [ -z "$Imagename" ] && {
    Generalimage="yes"
    case "$Imagetype" in
      enfuse)     Imagename="$Cachedir/enfuse.${Firstimage}..${Lastimage}.$Sourcemd5.tif" ;;
      evaluate)   Imagename="$Cachedir/evaluate.${Firstimage}..${Lastimage}.$Mode.$Sourcemd5.mpc" ;;
      compose)    Imagename="$Cachedir/compose.${Firstimage}..${Lastimage}.$Mode.$Sourcemd5.mpc" ;;
      color)      Imagename="mpr:$Mode" ;;
    esac
  }

  [ -z "$Imagename" ] && {
    note "generate_image() ERROR: No image name given and none created
  based on possibly unknown image mode: '$Mode'"
    return 1
  }

  [ "$Showmode" ] && {
    echo "$Mode"
    return 0
  }
  [ "$Showname" ] && {
    echo "$Imagename"
    return 0
  }

  [ "$Generalimage" = "yes" ] && case $Imagetype in
    color) ;;
    *) [ -e "$Imagename" ] && Skip="yes" ;;
  esac

  sendmagickmessage "NOTE:Generating image $Imagename"
  [ "$Skip" = "yes" ] && {
    sendmagickmessage "NOTE:Skipping image generation, already exists: $Imagename"
    return 0
  }

  case "$Imagetype" in
    enfuse)
      enfuse_split "$Imagename" ${Firstimage} ${Lastimage}
    ;;
    evaluate)
      load_sourceimages
      evaluate "$Mode" "$Imagename" "${Imsourceimagelist[@]:$Firstimage:$Lastimage}"
    ;;
    compose)
      grep -q "2" <<< "$Mode" && Swap="-swap 0,1" || Swap=""
      Mode="$(tr -d "2" <<< "$Mode")"
      generate_image --mode min --first $Firstimage
      generate_image --mode max --last $Lastimage

      Command="
  '$(generate_image --showname --mode min --first $Firstimage --last $Lastimage)'
  '$(generate_image --showname --mode max --first $Firstimage --last $Lastimage)'
    -alpha off
    $Swap
    -compose $Mode -composite
    -write '$Imagename'
    $(showimagecode "$Imagename")
    -delete 0"

      cmd "$Command"
      cmd_waitforready
    ;;
    color)
      Command="
  -size $Size
  canvas:$Mode
    $Tifstorealpha
    -write '$Imagename'
    -delete 0"
      cmd "$Command"
      cmd_waitforready
    ;;
  esac

  return 0
}
generate_video() {
  note "Generating video $Video"
  Videoframerate=5
  #nice ffmpeg -y -hide_banner -nostdin  -r $Videoframerate -f image2 -start_number 1 -i $Framedir/frame%04d.$Imageformat $Destinationfile || note "ERROR in video generation"
  [ -f "$Video" ] && rm "$Video"
  nice ffmpeg -y -hide_banner -nostdin  -r $Videoframerate -f image2 -start_number 1 -i "$Cachedir/videoframe%04d.$Imageformat" "$Video" || note "ERROR in video generation"
  rm "$Cachedir"/videoframe*
  ffplay "$Video"
}
level_masks() {
  local Maskbasename Maskmax Maskmin Maskmd5 Clutimage Resultmask Clut=
  local Count Mask Levelmin Levelmax
  local Longoptions Parsedoptions
  local Firstimage Lastimage
  local Masklist

  Longoptions="first:,last:,name:,output:,clut::"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --first)    Firstimage="${2:-}"     ; shift ;;
      --last)     Lastimage="${2:-}"      ; shift ;;
      --name)     Maskbasename="${2:-}"   ; shift ;;
      --output)   Outputbasename="${2:-}" ; shift ;;
      --clut)     Clut="${2:-yes}"        ; shift ;;
    esac
    shift
  done

  Maskbasename="${Maskbasename:-NO_MASK_SPECIFIED}"
  Firstimage="${Firstimage:-1}"
  Lastimage="${Lastimage:-$Sourceimagenumber}"
  Outputbasename="${Outputbasename:-"$Maskbasename"}"
  Clut="${Clut:-no}"
  maskarray "$Maskbasename" "$Firstimage" "$Lastimage" Masklist
  Maskmax="mpr:maskmax"
  Maskmin="mpr:maskmin"
  Clutimage="mpr:clut"

  sendmagickmessage "NOTE:Leveling $Maskbasename"

  evaluate max "$Maskmax" "${Masklist[@]}"
  Levelmax="$(getmagickinfo "$Maskmax" '%[fx:maxima*100]')"
  Levelmin="$(maskarg_defaultvalue $Argmethod levelmin)"
  echo "max:$Argmethod:$Levelmax" >> ~/imfuse.statistic.level
  [ -z "$Levelmin" ] && {
    evaluate min $Maskmin "${Masklist[@]}"
    Levelmin="$(getmagickinfo "$Maskmin" '%[fx:minima*100]')"
    echo "min:$Argmethod:$Levelmin" >> ~/imfuse.statistic.level
  }

  [ "$Clut" = "no" ] && compare "$Levelmin" lt "1" && compare "$Levelmax" gt "99" && [ "$Maskbasename" = "$Outputbasename" ] && {
    sendmagickmessage "NOTE:Skipping level, range is greater than 1%..99%"
    return 0
  }

  Command="
  '$Maskmax'
    -level ${Levelmin}%,${Levelmax}%
    -write '$Maskmax'
    -delete 0"
  cmd "$Command"
  cmd_waitforready
  mkclut_uniform "$Maskmax" "$Clutimage"

  sendmagickmessage "STOPWATCH"
  for Count in $(seq $Lastimage -1 $Firstimage); do
    sendmagickmessage "PROGRESS:Mask leveling ${Levelmin}%,${Levelmax}%: $Maskbasename ETA:$Count"

    Command="
  '$(maskname "$Maskbasename" "$Count")'
    -level ${Levelmin}%,${Levelmax}%"
    [ "$Clut" = "yes" ] && Command="$Command
  '$Clutimage'
    -clut"
    Command="$Command
    -write '$(maskname "$Outputbasename" "$Count")'
    $(showimagecode "$(maskname "$Outputbasename" "$Count")")
    -delete 0"

    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"
  cmd_waitforready

  return 0
}
maskfromimage() {
  # Generate masks with basename $2 based on comparision with a single image $1
  local Imagename Maskbasename Sourceimage Maskname
  local Command Count

  Imagename="${1:-}"
  Maskbasename="${2:-}"

  sendmagickmessage "NOTE:Generating mask comparing with image $Imagename"
  sendmagickmessage "STOPWATCH"
  for Count in $(seq $Sourceimagenumber); do
    Maskname="$(maskname "$Maskbasename" "$Count")"
    Sourceimage="$(sourceimagename $Count)"

    sendmagickmessage "PROGRESS:image comparision mask: $Imagename ETA:$Count"

    Command="
  '$Imagename' 
    -write mpr:image
    -delete 0
  mpr:image
    -channel alpha
    -separate
    -write mpr:alpha
    -delete 0
  mpr:image
    $Grayscaleconverter
  ( '$Sourceimage' $Grayscaleconverter )
    -compose Difference -composite
    -alpha off 
    -negate
    -write mpr:diffmask
    -delete 0
  mpr:diffmask
### FIXME
#  mpr:alpha
#    -compose multiply -composite
    -write '$Maskname'
    $(showimagecode "$Maskname")
    -delete 0"

    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"
  cmd_waitforready

  return 0
}
mkclut_uniform() {
  # Generate a clut image to uniform distribution in level_masks()
  # Contains code from http://www.fmwconcepts.com/imagemagick/redist with friendly permission from Fred Weinhaus.
  local Referenceimage Clutimage Netpbm Netpbmdata
  local Histogramarray Colorcountarray Totalpixel Lutlist Expo Quantumrange Factor
  local Command Key1 Key2 Count

  Referenceimage="${1:-}"
  Clutimage="${2:-}"

  Quantumrange="$(getmagickinfo $Referenceimage "%[fx:quantumrange]")"
  Expo="$(getmagickinfo rose: "%[fx:e]")" 

  Key1="$(generate_key)"
  Key2="$(generate_key)"
  Command="
  '$Referenceimage'
    -colorspace gray
    -depth 8
    -format '\n$Key1\n%c$Key2\n'
    -write histogram:info:-
    -delete 0"
  cmd "$Command"
  cmd_waitforready
  Histogramarray="$(sed -n "/$Key1/,/$Key2/p" "$Magickfifolog" | sed '1d ; $d')"
  Histogramarray=($(echo "$Histogramarray" | sed -n  's/[ ]*\([0-9]*\).*gray[(]\([0-9]*\).*$/\1 \2/p' \
                                           | LC_ALL=C awk     '{ bin[int($2)] += $1; } 
                                                      END { for (i=0;i<256;i++) {hist = bin[i]+0; print hist; } } ' ) )
  Colorcountarray=($(echo ${Histogramarray[*]} | LC_ALL=C awk '{ split($0,count," ") }
                                                       END { for (i=0;i<256;i++) { cum += count[i]; print cum } }' ))
  Totalpixel=${Colorcountarray[255]}
  Factor="$(getmagickinfo rose: "%[fx:$Quantumrange/$Totalpixel]")"
  Lutlist="$(for ((Count=0; Count<256; Count++)); do
    echo "${Colorcountarray[$Count]}"
  done | LC_ALL=C awk -v Factor="$Factor" '{ print int(Factor*$1); }')"

  Netpbm="P2 256 1 $Quantumrange $Lutlist"
  Netpbmdata="$(base64 <<< "$Netpbm")"
  sendmagickmessage "Content of encoded NetPBM clut image: $(echo "$Netpbm" | tr "\n" " ")"
  Command="
  'inline:data:image/netpbm;base64,
$Netpbmdata
'
    -scale 256x1\!
    -write '$Clutimage'
    -delete 0"
  cmd "$Command"
  cmd_waitforready
  return 0
}
threshold() {
  local Mask Image= Blackthreshold Whitethreshold Thresholdblur Cutmask= Cutimage=
  local Command
  local Longoptions Parsedoptions

  Longoptions="image:,mask:,percent1:,percent2:,blur:,cutmask::,cutimage::"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --blur)     Thresholdblur="${2:-}"  ; shift ;;
      --mask)     Mask="${2:-}"           ; shift ;;
      --image)    Image="${2:-}"          ; shift ;;
      --percent1) Blackthreshold="${2:-}" ; shift ;;
      --percent2) Whitethreshold="${2:-}" ; shift ;;
      --cutmask)  Cutmask="${2:-"soft"}"  ; shift ;;
      --cutimage) Cutimage="${2:-"soft"}" ; shift ;;
    esac
    shift
  done

  Blackthreshold="${Blackthreshold:-0}"
  Whitethreshold="${Whitethreshold:-100}"
  Thresholdblur="${Thresholdblur:-0}"

  Command="
  '$Mask'
    -alpha off
    -write mpr:mask
    -delete 0
  mpr:mask
    -threshold ${Blackthreshold}%
    -write mpr:blackthreshold
    -delete 0
  mpr:mask
    -threshold $((Whitethreshold))%
    -negate
    -write mpr:whitethreshold
    -delete 0
  mpr:blackthreshold
  mpr:whitethreshold
    -compose Darken -composite
    -write mpr:threshold
    -delete 0"
  [ "$Thresholdblur" -gt "0" ] && Command="$Command
  mpr:threshold
    -blur 0x$Thresholdblur
    -write mpr:threshold
    -delete 0"
  case "$Cutmask" in
    soft)
      Command="$Command
  mpr:mask
  mpr:threshold
    -compose Lighten -composite
    -write mpr:mask
    -delete 0
  mpr:mask
    -write '$Mask'
    -delete 0"
    ;;
    hard)
      Command="$Command
  mpr:threshold
    -write '$Mask'
    -delete 0"
    ;;
  esac
  case "$Cutimage" in
    soft)
      Command="$Command
  mpr:mask
  mpr:threshold
    -compose Lighten -composite
    -write mpr:mask
    -delete 0
  '$Image'
  mpr:mask
    -alpha off
    -compose CopyOpacity -composite
    -write '$Image'
    -delete 0"
    ;;
    hard)
      Command="$Command
  '$Image'
  mpr:threshold
    -alpha off
    -compose CopyOpacity -composite
    -write '$Image'
    -delete 0"
    ;;
  esac
  Command="$Command
  +set registry:mask
  +set registry:threshold
  +set registry:whitethreshold
  +set registry:blackthreshold"

  cmd "$Command"
  cmd_waitforready
  return 0
}

# core focus stack routines

focus_maskmethod() {
  # Mask generating ImageMagick options
  # Most of them are based on edge detection: http://www.imagemagick.org/Usage/convolve/#edgedet
  local Method Sourceimage Enfuseimage
  local Maskgenerator=
  local Firstimage Lastimage

  Method="${1:-}"
  Firstimage="${2:-1}"
  Lastimage="${3:-$Sourceimagenumber}"

  case $Method in
    blur)
      Maskgenerator="
  # --blur
  mpr:sourcegray
    -blur ${Argradius1:-0}x$Argsigma1
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    cmd)
      Maskgenerator="
  # --cmd='$Argword1'
  mpr:sourcegray 
    $Argword1"
    ;;
    cmddiff)
      Maskgenerator="
  # --cmddiff='$Argword1'
  mpr:sourcegray 
    $Argword1
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    comet)
      Maskgenerator="
  # --comet
  mpr:sourcegray 
    -define morphology:compose=${Argword1:-Lighten}
    -morphology Convolve Comet:${Argradius1:-0}x${Argsigma1}:>
  mpr:sourcegray
    -compose difference -composite"
    ;;
    compass)
      Maskgenerator="
  # --compass
  mpr:sourcegray
    -define convolve:scale=50%!
    -define morphology:compose=Lighten
    -define convolve:bias=50%
    -morphology Convolve Compass:>"
    #-compose Difference -composite" # sort of interesting.
    ;;
    diffstat)
      Maskgenerator="
  # --diffstat"
      [ "$Argword1" = "source" ] && {
        Maskgenerator="$Maskgenerator
  mpr:sourcegray"
      } || {
        Maskgenerator="$Maskgenerator
  ( mpr:sourcegray -statistic ${Argword1:-median} ${Argradius1} )"
      }
      [ "$Argword2" = "source" ] && {
        Maskgenerator="$Maskgenerator
  mpr:sourcegray"
      } || {
        Maskgenerator="$Maskgenerator
  ( mpr:sourcegray -statistic ${Argword2:-mean} ${Argradius1} )"
Maskgenerator="$Maskgenerator
    -compose Difference -composite"
      }
    ;;
    dog) # DoG: Difference of Gaussian
      Maskgenerator="
  # --dog
  mpr:sourcegray
    -define convolve:scale=100,100%
    -morphology Convolve DoG:${Argradius1:-0},${Argsigma1},${Argsigma2}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    GAUSSexperimental) 
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=-100,200%
    -morphology Convolve Gaussian:${Argradius1:-0}x${Argsigma1:-0.75}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    CROSSMORPHexperimental)
      Maskgenerator="
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1:-3}x1+1+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1:-3}x1+${Argradius1:-3}+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:1x${Argradius1:-3}+0+1 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:1x${Argradius1:-3}+0+${Argradius1:-3} )
    -evaluate-sequence min"
    ;;
    CROSSMORPH2experimental)
      Maskgenerator="
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1}x$((Argradius1/2))+0+$((Argradius1/4)) )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1}x$((Argradius1/2))+$((Argradius1-1))+$((Argradius1/4)) )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:$((Argradius1/2))x$((Argradius1))+$((Argradius1/4))+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:$((Argradius1/2))x$((Argradius1))+$((Argradius1/4))+$((Argradius1-1)) )
    -evaluate-sequence min"
    ;;
    experimental)
      Maskgenerator="
  # --experimental
  ( mpr:sourcegray -colorspace HSB -channel 1 -separate +channel )
    -statistic standarddeviation ${Argradius1:-2}x${Argradius1:-2}"
    ;;
    freichen)
      case $Argword1 in
        "")
          Maskgenerator="
  # --freichen
  (
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:1>
  )
  (
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:2>
  )
    -compose Screen
    -composite"
        ;;
        *)
          Maskgenerator="
  # --freichen=$Argword1
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=10%
    -morphology Convolve FreiChen:${Argword1:-0}>"
        ;;
      esac
    ;;
    gaussian)
      Maskgenerator="
  # --gaussian ${Argradius1:-0}x${Argsigma1}
  mpr:sourcegray
    -gaussian-blur ${Argradius1:-0}x${Argsigma1}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    kirsch)
      Maskgenerator="
  # --kirsch
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=screen
    -define convolve:bias=15%
    -morphology Convolve Kirsch:>"
    ;;
    laplacian)
      Maskgenerator="
  # --laplacian
  mpr:sourcegray
    -define convolve:bias=5%
    -define convolve:scale=100%!
    -morphology Convolve Laplacian:${Argword1:-0}>"
    ;;
    log)  # LoG: Laplacian of Gaussian
      Maskgenerator="
  # --log
  mpr:sourcegray
    -define convolve:scale=100,100%
    -morphology Convolve LoG:${Argradius1:-0}x${Argsigma1}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    morphology)
      Maskgenerator="
  # --morphology
  mpr:sourcegray
    -morphology ${Argword1}:${Argradius2} ${Argword2:-Octagon}:${Argradius1}"
    ;;
    prewitt)
      Maskgenerator="
  # --prewitt
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=screen
    -define convolve:bias=10%
    -morphology Convolve Prewitt:>"
    ;;
    roberts)
      Maskgenerator="
  # --roberts
  mpr:sourcegray
    -define convolve:scale=100%
    -define morphology:compose=screen
    -define convolve:bias=10%
    -morphology Convolve Roberts:@"
    ;;
    sobel)
      Maskgenerator="
  # --sobel
  mpr:sourcegray
    -define convolve:scale=100%!
    -define convolve:bias=10%
    -define morphology:compose=screen
    -morphology Convolve Sobel:>"
    ;;
    statistic)
      Maskgenerator="
  # --statistic
  mpr:sourcegray
    -statistic ${Argword1} ${Argradius1}x${Argradius1}"
    ;;
    unsharp)
      Maskgenerator="
  # --unsharp
  mpr:sourcegray -unsharp ${Argradius1:-0}x${Argsigma1}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    wavelet)
      Maskgenerator="
  # --wavelet
  mpr:sourcegray 
    -wavelet-denoise ${Argpercent1}%
  mpr:sourcegray
    -compose Difference -composite"
    ;;
  esac

  grep . <<< "$Maskgenerator" ||:
}
focus_generate_masks() {
  local Maskgenerator Maskgenerator_all= Basenamelist= Maskready= Maskmax Mode Line Imagename Command= Maskmd5 Count
  local Longoptions Parsedoptions
  local Firstimage Lastimage

  Longoptions="first:,last:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --first)    Firstimage="${2:-}" ; shift ;;
      --last)     Lastimage="${2:-}"  ; shift ;;
    esac
    shift
  done

  Firstimage="${Firstimage:-1}"
  Lastimage="${Lastimage:-$Sourceimagenumber}"
  # Generate Code for mask generation
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"

    [ "$Argtype" = "mask" ] && {
      Maskgenerator=""

      [ -n "$Argcolorspace" ] || [ -n "$Argchannel" ] || [ -n "$Argimage" ] && {
        Maskgenerator="$Maskgenerator
  # backup for =C,c,E
  mpr:sourcegray
    -write mpr:sourcegray.bak
    -delete 0
  mpr:sourceimage
    -write mpr:sourceimage.bak
    -delete 0"
      }

      [ -n "$Argimage" ] && {
        generate_image --mode "$Argimage" --first "$Firstimage" --last "$Lastimage"
        Maskgenerator="$Maskgenerator
  # =E
  mpr:sourceimage
  $(generate_image --mode "$Argimage" --showname --first "$Firstimage" --last "$Lastimage")
    -compose Difference -composite
    -negate
    -write mpr:sourceimage
    $Grayscaleconverter
    -write mpr:sourcegray
    -delete 0"
      }

      [ -n "$Argcolorspace" ] || [ -n "$Argchannel" ] && {
        Maskgenerator="$Maskgenerator
  # =C,c
  (
    mpr:sourceimage
      -colorspace ${Argcolorspace:-"$Colorspace"}"
        [ -n "$Argchannel" ] && Maskgenerator="$Maskgenerator
      # =c
      -channel $Argchannel
      -separate
      +channel"
        Maskgenerator="$Maskgenerator
  )
    -write mpr:sourceimage
    -write mpr:sourcegray
    -delete 0"
      }
      Maskgenerator="$Maskgenerator
$(focus_maskmethod "$Argmethod" $Firstimage $Lastimage)"

      [ "$Argdiff" ] && Maskgenerator="$Maskgenerator
  # =diff
  mpr:sourcegray
    -compose Difference -composite"

      [ "$Argnegate" ] && Maskgenerator="$Maskgenerator
  # =neg
  -negate"

      Maskmd5="$(md5cut "$Arglevel $Colorspace $Colorspacechannel $Grayscaleconverter $Maskgenerator $Sourcemd5")"
      Argbasename="$Argmethod.$Maskmd5"
      #Argbasename="${Argmethod}${Argoptions}.$Sourcemd5"
      maskarg_store "$Count"

      ## avoid [double] creating of existing masks
      Maskready="no"
      maskexist "$Argbasename" $Firstimage $Lastimage && {
        Maskready="yes"
        sendmagickmessage "NOTE:Skipping mask generation, already exists: $Argbasename"
      }
      grep -q -x "$Argbasename" <<< "$Basenamelist" && Maskready="yes"
      Basenamelist="$Basenamelist
$Argbasename"

      [ "$Maskready" = "no" ] && {
        case "$Argmethod" in
          channel|saturation|chroma|lightness|darkness) ;;
          compose)                      generate_image --mode "$Argword1"               --first $Firstimage --last $Lastimage;;
          enfuse)                       generate_image --mode "enfuse"                  --first $Firstimage --last $Lastimage ;;
          evaluate|min|max|mean|median) generate_image --mode "${Argword1:-$Argmethod}" --first $Firstimage --last $Lastimage ;;
          image) ;;
        esac
        Maskgenerator_all="$Maskgenerator_all
$Maskgenerator
    -write '$(maskname "$Argbasename" NUMBER)'
    $(showimagecode "$(maskname "$Argbasename" NUMBER)")
    -delete 0"
      }

      [ -n "$Argcolorspace" ] || [ -n "$Argchannel" ] || [ -n "$Argimage" ] && {
        Maskgenerator="$Maskgenerator
  # restore backup for =C,c,E
  mpr:sourceimage.bak
    -write mpr:sourceimage
    +set registry:sourceimage.bak
    -delete 0
  mpr:sourcegray.bak
    -write mpr:sourcegray
    +set registry:sourcegray.bak
    -delete 0"
      }
    }
  done

  # Generate masks
  [ -n "$Maskgenerator_all" ] && {
    sendmagickmessage "NOTE:Generating masks"
    grep -q "NUMBER" <<< "$Maskgenerator_all" && load_sourceimages $Firstimage $Lastimage
    sendmagickmessage "STOPWATCH"

    # Generate command to generate masks
    for Count in $(seq $Lastimage -1 $Firstimage); do

      sendmagickmessage "PROGRESS:Mask generation ETA:$Count"

      Command="
  ( '$(sourceimagename $Count)'
      -colorspace $Colorspace"
      [ -n "$Colorspacechannel" ] && Command="$Command
      -channel $Colorspacechannel
      -separate
      +channel"
      Command="$Command
  )
    -alpha off
    -write mpr:sourceimage
    -delete 0
  mpr:sourceimage"

      # --grayscale
      [ "$Grayscaleconverter" ] && Command="$Command
      # --grayscale
      $Grayscaleconverter"
      Command="$Command
    -write mpr:sourcegray
    -delete 0"

      Command="$Command
${Maskgenerator_all//NUMBER/$(printnum $Count)}"

      cmd "$Command"
    done

    sendmagickmessage "/PROGRESS"
    cmd_waitforready
    Command="
    +set registry:sourceimage
    +set registry:sourcegray"
    cmd "$Command"
    cmd_waitforready
  }

  # level and uniform masks
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    [ "$Argtype" = "mask" ] && {
      [ "$Arglevel" != "no" ] && {
        [ "$Masktocache" = "yes" ] && [ -e "$Cachedir/level.$Argbasename" ] && {
          sendmagickmessage "NOTE:Skipping mask leveling, already done: $Argbasename"
        } || {
          level_masks --name="$Argbasename" --first="$Firstimage" --last="$Lastimage" --clut
          [ "$Masktocache" = "yes" ] && :> "$Cachedir/level.$Argbasename"
        }
      }
    }
  done

  return 0
}
focus_merge_masks() {
  # Merge different masks.

  local Mergemask Mergecode Methodnumber= Mergemethod
  local Weightmax
  local Command Count
  local Firstimage Lastimage

  [ "$Maskmethodnumber" = "0" ] && {
    note "Skipping merge, no mask options are specified."
    return 0
  }

  Firstimage="${1:-1}"
  Lastimage="${2:-$Sourceimagenumber}"

  # --level
  maskarg_single "level" && {
    case "$Argword1" in
      all)
        Firstimage="1"
        Lastimage="$Sourceimagenumber"
      ;;
      substack)
      ;;
      off)
      ;;
    esac
  }

  sendmagickmessage "NOTE:Merging masks"
  Mergemaskbasename="mergemask"

  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      mask)
        LC_ALL=C awk 'BEGIN {exit !('${Argweight:-100}' >= '${Weightmax:-0}')}' && Weightmax="${Argweight:-100}"
        Methodnumber="$((Methodnumber+1))"
      ;;
    esac
  done
  Weightmax=100

  maskarg_single "merge" ||:
  Mergemethod="${Argword1:-"Screen"}"
  case "${Mergemethod,,}" in ### FIXME check further modes
    multiply)
      Mergecode="
  mpr:white
    -alpha off"
    ;;
    *|screen)
      Mergecode="
  mpr:black
    -alpha off"
    ;;
  esac

  ### code for mask merging

  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      mask)
        #Mergemaskbasename="$Mergemaskbasename-$Argmethod"
        Mergecode="$Mergecode
  (
  $(maskname "$Argbasename" NUMBER)
    # =t (threshold)
    -black-threshold ${Argthreshold1:-0}%
    -white-threshold ${Argthreshold2:-100}%
    # =w (weight)
    +level 0%,$(calc "(100 * ${Argweight:-100}) / ( $Weightmax * $Methodnumber )" )%
  )
    -compose $Mergemethod -composite"
      ;;
    esac
  done
  Mergecode="$Mergecode
    -write mpr:mergemask
    -delete 0"

  ### code for mask postprocessing

  for Count in $(seq $Imoptionsnumber); do
    maskarg_parse "$Count"
    case "$Argtype" in
      merge)
        #Mergemaskbasename="$Mergemaskbasename-${Imoptions[$Count]}${Imarguments[$Count]%,TYPE*}"
        Mergecode="$Mergecode
  mpr:mergemask"
        case "${Imoptions[$Count]}" in

          maskblur)
            Mergecode="$Mergecode
    # --maskblur
    -blur 0x$Argsigma1"
          ;;

          maskcmd)
            Mergecode="$Mergecode
    # --maskcmd
    $Argword1"
          ;;

          maskmorph)
    Mergecode="$Mergecode
    # --maskmorph
    -morphology $Argword1:$Argradius2 ${Argword2:-Octagon}:$Argradius1"
          ;;

          maskstat)
            Mergecode="$Mergecode
    # --maskstat
    -statistic $Argword1 $Argradius1"
            case "${Argword1,,}" in
              contrast|mode|standarddeviationX)
                Mergecode="$Mergecode
  mpr:mergemask
    -alpha off
    -compose Difference -composite"
              ;;
            esac
          ;;

          maskwave)
            Mergecode="$Mergecode
    # --maskwave
    -wavelet-denoise ${Argpercent1:-30}%"
          ;;

        esac
        Mergecode="$Mergecode
    -write mpr:mergemask
    -delete 0"
      ;;
    esac
  done

  ### run

  Mergemaskbasename="$Mergemaskbasename.$(md5cut "$Mergecode $Sourcemd5" )"
  #Mergemaskbasename="$(unspecialstring "$Mergemaskbasename")"

  maskexist "$Mergemaskbasename" "$Firstimage" "$Lastimage"  && {
    note "Skipping merge, $Mergemaskbasename $Firstimage..$Lastimage already exists"
  } || {
    # merge masks
    sendmagickmessage "STOPWATCH"
    for Count in $(seq $Lastimage -1 $Firstimage); do
      Mergemask="$(maskname "$Mergemaskbasename" $Count)"

      sendmagickmessage "PROGRESS:Mask merging $Mergemaskbasename ETA:$Count"

      Command="
$(sed "s/NUMBER/$(printnum $Count)/g" <<< "$Mergecode" )
  mpr:mergemask
    $Tifstore 
    -write '$Mergemask'
    $(showimagecode "$Mergemask")
    -delete 0"

      maskexist "$Mergemaskbasename" "$Count" || cmd "$Command"
    done
    sendmagickmessage "/PROGRESS"
    cmd_waitforready
  }

  # --level
  maskarg_single "level" && {
    case "$Argword1" in
      off)  Newbasename="$Mergemaskbasename" ;;
      substack) Newbasename="level${Firstimage}..${Lastimage}_$Mergemaskbasename" ;;
      all)  Newbasename="levelall_$Mergemaskbasename" ;;
    esac
    case "$Argword1" in
      off) ;;
      substack|all)
        [ "$Masktocache" = "yes" ] && [ -e "$Cachedir/$Newbasename" ] && {
          sendmagickmessage "NOTE:--level=$Argword1: Skipping, mask is already leveled."
        } || {
          level_masks --name="$Mergemaskbasename" --output="$Newbasename" --first="$Firstimage" --last="$Lastimage"
          [ "$Masktocache" = "yes" ] && :> "$Cachedir/$Newbasename"
        }
        Mergemaskbasename="$Newbasename"
      ;;
    esac
  }

  return 0
}
focus_hard() {
  # Finally: focus stacking

  local Resultimage Maskmaxcopy=
  local Firstimage Lastimage
  local Focusimagebasename Focusimagefile Focusimagemaskfile
  local Command Count
  local Longoptions Parsedoptions
  local Focuscode=

  Longoptions="maskmax:,output:,firstimage:,lastimage:"

  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --output)       Resultimage="${2:-}" ; shift ;;
      --maskmax)      Maskmaxcopy="${2:-}" ; shift ;;
      --firstimage)   Firstimage="${2:-}"  ; shift ;;
      --lastimage)    Lastimage="${2:-}"   ; shift ;;
      --) ;;
    esac
    shift
  done

  Firstimage="${Firstimage:-1}"
  Lastimage="${Lastimage:-$Sourceimagenumber}"

  sendmagickmessage "NOTE:Focus montage hard"

  # Code for --cut* options
  Focuscode="
  mpr:cutmask
    -alpha off
    -write mpr:cutmask_hard"
  for Count in $(seq $Imoptionsnumber); do
    maskarg_parse "$Count"
    case "$Argtype" in
      focus)
        case "$Argmethod" in

          cutblur)
            Focuscode="$Focuscode
    # --cutblur: blur cut mask
    -blur 0x${Cutblur:-1}"
          ;;

          cutcmd)
            Focuscode="$Focuscode
    # --cutcmd
    $Argword1"
          ;;

          cutless)
            Focuscode="$Focuscode
  ##### --cutless
    -write mpr:cutmask_max
    -delete 0

  # get part of actual maskmax
  mpr:resultmask
  mpr:cutmask_max
    -alpha Off -compose CopyOpacity -composite
    -write mpr:maskmax_part
    -delete 0

  # paint actual maskmax part into lessmask
  mpr:lessthanmax
  mpr:maskmax_part
    -compose Over -composite
    -write mpr:lessthanmax
    -delete 0

  # get area of source mask that is stronger (+offset) than lessmask)
  mpr:sourcemask 
  ( mpr:lessthanmax -evaluate Add ${Argpercent1}% )
    -compose MinusSrc -composite
    -fill white +opaque black 
    -write mpr:cutmask_less
    -delete 0

  # reduce max in maskmax where --lessthanmax takes over
  mpr:sourcemask
  mpr:cutmask_less
    -compose CopyOpacity -composite
    -write mpr:sourcemask_part
    -delete 0
  mpr:resultmask
  mpr:sourcemask_part
    -compose Over -composite
    -write mpr:resultmask
    -delete 0

  # darken lessmask with current source mask to get a mask with decreasing sharpness after a max peak
  mpr:lessthanmax
  mpr:sourcemask
    -compose Darken -composite
    -write mpr:lessthanmax
    -delete 0

  # get area of source mask equal or sharper than current max (same code as above, but now with less-adjusted maskmax.
  mpr:sourcemask
  mpr:resultmask
    -compose MinusDst -composite -fill white +opaque black
    -alpha off
    -negate
    -write mpr:cutmask
    -delete 0

  mpr:cutmask
  ####/ --cutless"
          ;;

          cutmorph)
            Focuscode="$Focuscode
    # --cutmorph
    -morphology ${Argword1}:${Argradius2} ${Argword2:-Octagon}:${Argradius1}"
          ;;

          cutsoft)
            Focuscode="$Focuscode
    # --cutsoft: add a blur around cut mask
    -blur 0x$Argsigma1
  mpr:cutmask
    -compose Lighten -composite"
          ;;

          cutwave)
            Focuscode="$Focuscode
    # --cutwave
    -wavelet-denoise ${Argpercent1}%"
          ;;

        esac
      ;;
    esac
  done
  Focuscode="$Focuscode
    -write mpr:cutmask
    -delete 0"
#    $(showimagecode mpr:cutmask)

  Focusimagebasename="focus-hard.$Firstimage..$Lastimage.$(md5cut "$(masklist "$Mergemaskbasename") $Focuscode")"
  Focusimagefile="$Cachedir/$Focusimagebasename.tif"
  Focusimagemaskfile="$Cachedir/$Focusimagebasename.mask.tif"

  [ -e "$Focusimagefile" ] && {
    sendmagickmessage "NOTE:Skipping focus_hard(), image already exists."
    Command="
  '$Focusimagefile'
    $Tifstore
    -write mpr:resultimage
    -write '$Resultimage'
    -delete 0"
    [ -n "$Maskmaxcopy" ] && Command="$Command
  '$Focusimagemaskfile'
    $Tifstore
    -write mpr:resultmask
    -write '$Maskmaxcopy'
    -delete 0"
    cmd "$Command"
    cmd_waitforready
    return 0
  }

  load_sourceimages $Firstimage $Lastimage

  Command="
  mpr:transparent
    -write mpr:resultimage
    -delete 0
  mpr:black
    -alpha off
    -write mpr:resultmask
    -delete 0"
  maskarg_single "cutless" && Command="$Command
  mpr:transparent
    -write mpr:lessthanmax
    -delete 0"
  cmd "$Command"

  sendmagickmessage "STOPWATCH"
  for Count in $(seq $Lastimage -1 $Firstimage); do

    sendmagickmessage "PROGRESS:Focus montage ETA:$Count"

    Command="
  # Load images
  '$(sourceimagename $Count)'
    -alpha off
    -write mpr:sourceimage
    -delete 0
  '$(maskname "$Mergemaskbasename" "$Count")'
    -alpha off
    -write mpr:sourcemask
    -delete 0

  # stepwise increase maskmax
  mpr:sourcemask
  mpr:resultmask
    -compose Lighten -composite
    -write mpr:resultmask
    -delete 0

  # get area of source mask equal or sharper than current max
  mpr:resultmask
  mpr:sourcemask
    -compose MinusSrc -composite -fill white +opaque black
    -alpha off
    -negate
    -grayscale RMS
    -write mpr:cutmask
    -delete 0"

    # add --cut* options
    Command="$Command
  $Focuscode"

    Command="$Command
  # get part of source image
  mpr:sourceimage
  mpr:cutmask
    -alpha off -compose CopyOpacity -composite
    -write mpr:sourcepart
    -delete 0

  # add part of source to result
  mpr:resultimage
  mpr:sourcepart
    -compose Over -composite
    -write mpr:resultimage
    $(showimagecode "mpr:resultimage")
    -delete 0"

    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"

  Command="
  # store result image and mask
  mpr:resultimage
    $Tifstorealpha
    -write '$Resultimage'
    -write '$Focusimagefile'
    -delete 0
  mpr:resultmask
    $Tifstore
    -write '$Focusimagemaskfile'
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  [ "$Maskmaxcopy" ] && {
    Command="
  # copy max mask
  mpr:resultmask
    -write '$Maskmaxcopy'
    -delete 0"
    cmd "$Command"
    cmd_waitforready
  }

  Command="
  +set registry:cutmask
  +set registry:cutmask_less
  +set registry:cutmask_max
  +set registry:lessthanmax
  +set registry:maskmax
  +set registry:maskmax_part
  +set registry:sourceimage
  +set registry:sourcemask
  +set registry:sourcemask_part
  +set registry:sourcepart"
  cmd "$Command"
  cmd_waitforready
  #+set registry:resultimage

  return 0
}
focus_soft() {
  local Resultimage Maskmaxcopy
  local Level Composemode
  local Firstimage Lastimage
  local Count Command
  local Focusimagebasename Focusimagefile Focusimagemaskfile
  local Longoptions Parsedoptions

  Longoptions="composemode:,maskmax:,output:,level:,firstimage:,lastimage:"

  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --output)       Resultimage="${2:-}" ; shift ;;
      --level)        Level="${2:-}"       ; shift ;;
      --maskmax)      Maskmaxcopy="${2:-}" ; shift ;;
      --firstimage)   Firstimage="${2:-}"  ; shift ;;
      --lastimage)    Lastimage="${2:-}"   ; shift ;;
      --composemode)  Composemode="${2:-}" ; shift ;;
      --) ;;
    esac
    shift
  done

  Firstimage="${Firstimage:-1}"
  Lastimage="${Lastimage:-$Sourceimagenumber}"
  Level="${Level:-"0%x100%"}"
  Composemode="${Composemode:-Plus}"

  sendmagickmessage "NOTE:Focus montage soft"

  Addsource="mpr:addsource"

  Focusimagebasename="focus-soft.$(percentrm "$Level").$Firstimage..$Lastimage.$(md5cut "$(masklist "$Mergemaskbasename") $Level $Composemode")"
  Focusimagefile="$Cachedir/$Focusimagebasename.tif"
  Focusimagemaskfile="$Cachedir/$Focusimagebasename.mask.tif"

  [ "$Force" = "focus" ] && forcefocus
  [ -e "$Focusimagefile" ] && {
    sendmagickmessage "NOTE:Skipping focus_soft(), image already exists."
    Command="
  '$Focusimagefile'
    $Tifstore
    -write mpr:resultimage
    -write '$Resultimage'
    -delete 0"
    [ -n "$Maskmaxcopy" ] && Command="$Command
  '$Focusimagemaskfile'
    $Tifstore
    -write mpr:resultmask
    -write '$Maskmaxcopy'
    -delete 0"
    cmd "$Command"
    cmd_waitforready
    return 0
  }

  load_sourceimages $Firstimage $Lastimage

  Command="
  mpr:black
    -alpha off
    -depth 16
    -write mpr:addmask
    -delete 0
  mpr:black
    -alpha off
    -depth 16
    -write mpr:addsource
    -delete 0"
  cmd "$Command"

  sendmagickmessage "STOPWATCH"
  for Count in $(seq $Lastimage -1 $Firstimage); do
    Sourcemask="$(maskname "$Mergemaskbasename" "$Count")"
    Sourceimage="$(sourceimagename $Count)"

    sendmagickmessage "PROGRESS:Focus montage soft ETA:$Count"

    Command="
  $Sourceimage
    -depth 16
    -alpha off
    -write mpr:sourceimage
    -delete 0
  $Sourcemask
    -depth 16
    -write mpr:mask
    -delete 0"

    Command="$Command
  mpr:mask
    +level $Level
    -evaluate Divide $Sourceimagenumber
    -write mpr:mask
    -delete 0
  mpr:addmask
  mpr:mask
    -compose $Composemode -composite
    -write mpr:addmask
    -delete 0
  mpr:addsource
  ( mpr:sourceimage mpr:mask -compose Multiply -composite )
    -evaluate-sequence Add
    -write mpr:sourceadd
    -write mpr:addsource
    -delete 0"

    [ "$Showimageprocessing" ] && {
      Command="$Command
  # create result only for --show
  mpr:addsource
  mpr:addmask
    -compose DivideSrc -composite
    -write mpr:resultimage
    $(showimagecode "mpr:resultimage")
    -delete 0"
    }

    Command="$Command
  +set registry:$Sourceimage
  +set registry:$Sourcemask"

    cmd "$Command"
  done
  sendmagickmessage "/PROGRESS"
  Command="
  mpr:addsource
  mpr:addmask
    -compose DivideSrc -composite
    -write mpr:resultimage
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  mkclut_uniform "mpr:addmask" "mpr:clut" ### FIXME --substacks
  Command="
  mpr:addmask
  mpr:clut
    -clut
    -write '$Focusimagemaskfile'
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  [ "$Maskmaxcopy" ] && {
    cp "$Focusimagemaskfile" "$Maskmaxcopy"
  }

  Command="
  mpr:resultimage
    $Tifstore 
    -write '$Focusimagefile'
    -write '$Resultimage'
    $(showimagecode "$Focusimagefile")
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  Command="
  +set registry:addmask
  +set registry:addsource
  +set registry:clut
  +set registry:mask
  +set registry:sourceadd
  +set registry:sourceimage"
  cmd "$Command"
  cmd_waitforready
  #+set registry:resultimage

  return 0
}
focus_main() {
  local Substackstep
  local Command Count Startzeit
  local Substackmaskmax Substackmaskmin
  local Backgroundnumber Backgroundtype Backgroundimage
  local Transparentlayers=

  Startzeit="$(date +%s)"
  focus_generate_masks
  focus_merge_masks
  sendmagickmessage "NOTE:Generating masks ready after: $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")"
  [ "$Maskmethodnumber" -gt "0" ] && { 
    for Substackstep in $(seq $Substacknumber -1 1); do
      Substackresult[$Substackstep]="$Cachedir/substackresult.$Resultbasename.substack$Substackstep.mpc"
      Substackmask[$Substackstep]="$Cachedir/substackresult.$Resultbasename.substack$Substackstep-mask.mpc"
      sendmagickmessage "NEWLINE"
      sendmagickmessage "NOTE:Generating substack $Substackstep / $Substacknumber: ${Substackfirstimage[$Substackstep]}..${Substacklastimage[$Substackstep]}"

      Startzeit="$(date +%s)"
      #focus_merge_masks "${Substackfirstimage[$Substackstep]}" "${Substacklastimage[$Substackstep]}" ### FIXME leveling?
      sendmagickmessage "NOTE:Mask merging ready after: $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")"

      # focus
      Startzeit="$(date +%s)"
      case $Softmode in
        "no")
          focus_hard --maskmax "${Substackmask[$Substackstep]}" --output "${Substackresult[$Substackstep]}" \
                     --firstimage="${Substackfirstimage[$Substackstep]}" --lastimage="${Substacklastimage[$Substackstep]}"
        ;;
        "yes")
          maskarg_single "soft" ||:
          focus_soft --maskmax "${Substackmask[$Substackstep]}" --output "${Substackresult[$Substackstep]}" \
                     --firstimage="${Substackfirstimage[$Substackstep]}" --lastimage="${Substacklastimage[$Substackstep]}" \
                     --level "${Argpercent1}%x${Argpercent2}%" --compose="$Argword1"
        ;;
      esac
      sendmagickmessage "NOTE:focus ready after: $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")"
    done

    Startzeit="$(date +%s)"
    for Substackstep in $(seq $Substacknumber -1 1); do
      sendmagickmessage "NOTE:Postprocessing substack $Substackstep / $Substacknumber: ${Substackfirstimage[$Substackstep]}..${Substacklastimage[$Substackstep]}"
      Substackresultpost[$Substackstep]="$Cachedir/substackresult.$Resultbasename.substack$Substackstep-post.mpc"
      Substackmaskpost[$Substackstep]="$Cachedir/substackresult.$Resultbasename.substack$Substackstep-post-mask.mpc"

      [ -e "${Substackresultpost[$Substackstep]}" ] && {
        sendmagickmessage "NOTE:Skipping --alpha --threshold --finalblur, already done."
      } || {

        Command="
'${Substackresult[$Substackstep]}'
  -write '${Substackresultpost[$Substackstep]}'
  -delete 0
'${Substackmask[$Substackstep]}'
  -write '${Substackmaskpost[$Substackstep]}'
  -delete 0"
        cmd "$Command"

        for Count in $(seq "$Imoptionsnumber"); do
          maskarg_parse "$Count"
          Option="${Imoptions[$Count]}"
          case "$Argtype" in
            postfocus)
              sendmagickmessage "NOTE:Applying --${Imoptions[$Count]}=${Imarguments["$Count"]%,TYPE*}"
              case "$Option" in
                alpha)
                  alphalevel --image "${Substackresultpost[$Substackstep]}" --mask "${Substackmaskpost[$Substackstep]}" \
                             --percent1 "${Argpercent1}" --percent2 "${Argpercent2}%"
                ;;
                finalblur)
                  finalblur  --image "${Substackresultpost[$Substackstep]}" --mask "${Substackmaskpost[$Substackstep]}" \
                             --percent "$Argthreshold1" --sigma1 "$Argsigma1" --sigma2 "$Argsigma2"
                ;;
                finalblur2)
                  finalblur2 --image "${Substackresultpost[$Substackstep]}" --mask "${Substackmaskpost[$Substackstep]}" \
                             --percent "$Argthreshold1" --blur "$Argradius1"
                ;;
                threshold)
                  threshold  --image "${Substackresultpost[$Substackstep]}" --mask "${Substackmaskpost[$Substackstep]}" \
                             --percent1 "$Argthreshold1" --percent2 "$Argthreshold2" --blur "$Argsigma1" \
                             --cutimage="hard"
                ;;
              esac
            ;;
          esac
        done
      }
    done
  }
  cmd_waitforready
  sendmagickmessage "NOTE:Postprocessing ready after: $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")"

  Command="
  # composing substack results
  mpr:transparent
    -alpha set
    -write mpr:resultimage
    -delete 0
  mpr:resultimage"
  for Substackstep in $(seq $Substacknumber -1 1); do
    Command="$Command
  '${Substackresultpost[$Substackstep]}'
    -compose Over -composite
    $(showimagecode)"
  done
  Command="$Command
    -write mpr:resultimage
    $(showimagecode)
    -delete 0"
  cmd "$Command"
  cmd_waitforready

  # --background
  Backgroundnumber="0"
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    case "$Argtype" in
      background)
        sendmagickmessage "NOTE:Processing --${Imoptions[$Count]}=${Imarguments["$Count"]%,TYPE*}"
        Backgroundnumber="$((Backgroundnumber+1))"
        Backgroundimage[$Backgroundnumber]="$(generate_image --showname --mode "$Argword1")"
        generate_image --mode "$Argword1"
      ;;
    esac
  done

  # --layered
  case "$Storelayered" in
    yes)
      sendmagickmessage "NOTE:Generating layered tif"
      { maskarg_single "threshold" || maskarg_single "alpha" ; } && Transparentlayers="yes"
      generate_image --mode cyan
      generate_image --mode magenta
      generate_image --mode yellow
      generate_image --mode green
      Command="
  # --layered
  mpr:resultimage
  mpr:cyan
  mpr:magenta
  mpr:yellow
  mpr:green"
      for Count in $(seq "$Backgroundnumber"); do
        Command="$Command
  '${Backgroundimage[$Count]}'"
      done
      for Substackstep in $(seq $Substacknumber -1 1); do
        [ "$Transparentlayers" = "yes" ] && Command="$Command
  '${Substackresult[$Substackstep]}'"
        Command="$Command
  '${Substackresultpost[$Substackstep]}'"
      done
      Command="$Command
    $Tifstorealpha
    #-define tiff:write-layers=yes
    -write '$Outputimage'
    $(showimagecode "$Outputimage")
    -delete 0"
    ;;

    no)
      Command="
  mpr:transparent"
      for Count in $(seq "$Backgroundnumber"); do
        Command="$Command
  '${Backgroundimage[$Count]}'
    -compose Over -composite"
      done
      Command="$Command
  mpr:resultimage
    -compose Over -composite
    -write mpr:resultimage
    -delete 0
  mpr:resultimage
    $Tifstorealpha
    -write '$Outputimage'
    -delete 0"
    ;;
  esac

  cmd "$Command"
  cmd_waitforready

  [ "$Maskmethodnumber" = "0" ] && [ "$Backgroundnumber" = "0" ] && note "No mask option and no background has been specified.
  imfuse has generated an empty transparent result image.
  Suggestion: Try at least '--background=enfuse', or short: --bg"

  # --savemask
  [ "$Savemask" ] && {
    cmd "  # --savemask"
    evaluate max "$Savemask" ${Substackmaskpost[$Substackstep]}
  }

  return 0
}

### mask args
maskarg_add() {
  Imoptionsnumber="$((Imoptionsnumber+1))"
  Argmethod="${1#--}"
  [ "$Argmethod" = "background" ] && Argmethod="bg"
  Imoptions[$Imoptionsnumber]="$Argmethod"
  Imarguments[$Imoptionsnumber]="${2:-}"
  maskarg_parse "$Imoptionsnumber"
  maskarg_store "$Imoptionsnumber"
}
maskarg_parse() {
  local Key Line Value

  eval $Arglist
  Argmethod="${Imoptions[${1:-}]}"
  Argcount="${1:-}"

  while read -d, Line; do
    grep -q "=" <<< "$Line" && {
      Key="$(cut   -d= -f1    <<< "$Line")"
      Value="$(cut -d= -f2 -s <<< "$Line")"
      :
    } || {
      Key="$(digitrm "$Line")"
      Value="$(sed "s/${Key:-NOKEY}//"  <<< "$Line")"
    }
    case $Key in
      "w"|"w%")           Argweight="$(percentrm "$Value")" ;;
      "r"|"r%")           [ -z "$Argradius1" ]  && Argradius1="$Value" || Argradius2="$Value" ;;
      "R")                Argradius2="${Value}" ;;
      "s")                [ -z "$Argsigma1" ]   && Argsigma1="$Value"  || Argsigma2="$Value" ;;
      "S")                Argsigma2="${Value}" ;;
      "p"|"%"|"p%")       [ -z "$Argpercent1" ] && Argpercent1="$(percentrm "$Value")" || Argpercent2="$(percentrm "$Value")" ;;
      "P"|"P%")           Argpercent2="$(percentrm "$Value")" ;;
      "t")                Argthreshold1="$(percentrm "$Value")" ;;
      "T")                Argthreshold2="$(percentrm "$Value")" ;;
      "n")                [ -z "$Argnumber1" ]   && Argnumber1="$Value"  || Argnumber2="$Value" ;;
      "N")                Argnumber2="$(percentrm "$Value")" ;;
      "I")                Argimage="$Value" ;;
      "C")                Argcolorspace="$Value" ;;
      "c")                Argchannel="$Value" ;;
      "neg")              Argnegate="yes" ;;
      "level")            Arglevel="$Value" ;;
      "TYPE")             Argtype="$Value" ;;
      "DIFF")             Argdiff="yes" ;;
      "BASENAME")         Argbasename="$Value" ;;
      *|WORD1|WORD2)
        [ -z "$Argword1" ] && Argword1="$Line" || Argword2="$Line" 
        Argword1="${Argword1#WORD1=}"
        Argword2="${Argword2#WORD2=}"
      ;;
    esac
  done <<< "${Imarguments[${1:-}]},"
  Argoptions="${Imarguments[${1:-}]}"

  return 0
}
maskarg_store() {
  Argoptions=""
  Argcount="${1:-}"
  [ "$Argweight" ]             && Argoptions="$Argoptions,w$Argweight"
  [ "$Argradius1" ]            && Argoptions="$Argoptions,r$Argradius1"
  [ "$Argradius2" ]            && Argoptions="$Argoptions,R$Argradius2"
  [ "$Argsigma1" ]             && Argoptions="$Argoptions,s$Argsigma1"
  [ "$Argsigma2" ]             && Argoptions="$Argoptions,S$Argsigma2"
  [ "$Argpercent1" ]           && Argoptions="$Argoptions,p$Argpercent1"
  [ "$Argpercent2" ]           && Argoptions="$Argoptions,P$Argpercent2"
  [ "$Argnumber1" ]            && Argoptions="$Argoptions,n$Argnumber1"
  [ "$Argnumber2" ]            && Argoptions="$Argoptions,N$Argnumber2"
  [ "$Argthreshold1" ]         && Argoptions="$Argoptions,t$Argthreshold1"
  [ "$Argthreshold2" ]         && Argoptions="$Argoptions,T$Argthreshold2"
  [ "$Argimage" ]               && Argoptions="$Argoptions,I=$Argimage"
  [ "$Argcolorspace" ]         && Argoptions="$Argoptions,C=$Argcolorspace"
  [ "$Argchannel" ]            && Argoptions="$Argoptions,c$Argchannel"
  [ "$Argnegate" ]             && Argoptions="$Argoptions,neg"
  [ "$Arglevel" ]              && Argoptions="$Argoptions,level=$Arglevel"
  [ "$Argword1" ]              && Argoptions="$Argoptions,$Argword1"
  [ "$Argword2" ]              && Argoptions="$Argoptions,$Argword2"
  [ "$Argtype" ]               && Argoptions="$Argoptions,TYPE=$Argtype"
  [ "$Argdiff" ]               && Argoptions="$Argoptions,DIFF"
  [ "$Argbasename" ]           && Argoptions="$Argoptions,BASENAME=$Argbasename"
  Argoptions="${Argoptions#,}"
  Imarguments[$Argcount]="$Argoptions"
}
maskarg_defaultvalue() {
  case "${2:-}" in
    channel)
      case "${1:-}" in
        colorspace) ;;
        channel) ;;
        chroma)     echo "1" ;;
        darkness)   echo "2" ;;
        lightness)  echo "2" ;;
        saturation) echo "1" ;;
      esac
    ;;
    colorspace)
      case "${1:-}" in
        colorspace) echo "sRGB" ;;
        channel) ;;
        chroma)     echo "HCL" ;;
        darkness)   echo "HSL" ;;
        lightness)  echo "HSL" ;;
        saturation) echo "HSL" ;;
      esac
    ;;
    image)
      case "${1:-}" in
        enfuse)     echo "enfuse" ;;
        max)        echo "max" ;;
        mean)       echo "mean" ;;
        median)     echo "median" ;;
        min)        echo "min" ;;
      esac
    ;;
    level)
      case "$Argmethod" in
        channel)    echo "no" ;;
        chroma)     echo "no" ;;
        compose)    echo "no" ;;
        darkness)   echo "no" ;;
        enfuse)     echo "no" ;;
        evaluate)   echo "no" ;;
        lighten)    echo "no" ;;
        max)        echo "no" ;;
        mean)       echo "no" ;;
        median)     echo "no" ;;
        min)        echo "no" ;;
        saturation) echo "no" ;;
      esac
    ;;
    levelmin)
      case "${1:-}" in
        blur)       echo "0" ;;
        comet)      echo "0" ;;
        compass)    echo "45" ;;
        dog)        echo "0" ;;
        diffstat)
          case "$Argword1,$Argword2" in
            "median,mean") echo "0" ;;
            "min,max")     echo "0" ;;
          esac
        ;;
        freichen)
          case $Argword1 in
            "")     echo "33.6584" ;;
            15)     echo "19" ;;
          esac
        ;;
        gaussian)   echo "0" ;;
        #kirsch)     echo "" ;;
        laplacian)
          case $Argword1 in
            3)      echo "0" ;;
          esac
        ;;
        log)        echo "0" ;;
        morphology) echo "0" ;;
        prewitt)    echo "34.3893" ;;
        #roberts)    echo "7.64782%,100%" ;;
        sobel)      echo "34.3893" ;;
        statistic)
          case $Argword1 in
            standarddeviation) echo "0" ;;
          esac
        ;;
        #unsharp
        wavelet)    echo "0" ;;
        *)          echo "" ;;
      esac
    ;;
    negate)
      case "${1:-}" in
        darkness) echo "yes" ;;
      esac
    ;;
    percent1)
      case "${1:-}" in
        alpha)      echo "0" ;;
        cutless)    echo "20" ;;
        cutwave)    echo "75" ;;
        maskwave)   echo "20" ;;
        soft)       echo "2" ;;
        wavelet)    echo "5" ;;
        *)          echo "" ;;
      esac
    ;;
    percent2)
      case "${1:-}" in
        alpha)      echo "100" ;;
        soft)       echo "100" ;;
        *)          echo "" ;;
      esac
    ;;
    radius1)
      case "${1:-}" in
        #blur)       echo "" ;; # 0
        #comet)      echo "" ;; # 0
        compass)    echo "" ;;
        diffstat)   echo "3" ;;
        #dog)        echo "" ;; # 0
        freichen)   echo "" ;;
        #gaussian)   echo "" ;; # 0
        kirsch)     echo "" ;;
        laplacian)  echo "" ;;
        #log)        echo "" ;; # 0
        morphology) echo "1" ;;
        prewitt)    echo "" ;;
        roberts)    echo "" ;;
        sobel)      echo "" ;;
        statistic)  echo "2" ;;
        #unsharp)    echo "" ;; # 0

        cutmorph)   echo "1" ;;
        finalblur2) echo "4" ;;
        maskmorph)  echo "2" ;;
        maskstat)   echo "6" ;;
        *)          echo "" ;;
      esac
    ;;
    radius2)
      case "${1:-}" in
        cutmorph)   echo "1" ;;
        maskmorph)  echo "2" ;;
        morphology) echo "1" ;;
        *)          echo "" ;;
      esac
    ;;
    sigma1)
      case "${1:-}" in
        blur)       echo "0.3" ;;
        comet)      echo "5" ;;
        compass)    echo "" ;;
        diffstat)   echo "" ;;
        dog)        echo "0.4" ;;
        freichen)   echo "" ;;
        gaussian)   echo "0.3" ;;
        kirsch)     echo "" ;;
        laplacian)  echo "" ;;
        log)        echo "0.2" ;;
        morphology) echo "" ;;
        prewitt)    echo "" ;;
        roberts)    echo "" ;;
        sobel)      echo "" ;;
        statistic)  echo "" ;;
        unsharp)    echo "2" ;;
        wavelet)    echo "" ;;

        cutblur)    echo "2" ;;
        cutsoft)    echo "2" ;;
        finalblur)  echo "3" ;;
        maskblur)   echo "2" ;;
        threshold)  echo "0" ;;
        *)          echo "" ;;
      esac
    ;;
    sigma2)
      case "${1:-}" in
        dog)       echo "$(calc "${Argsigma1:-0.3} * 1.6")" ;;
        finalblur) echo "2" ;;
      esac
    ;;
    threshold1)
      case "${1:-}" in
        finalblur)  echo "50" ;;
        finalblur2) echo "50" ;;
        threshold)  echo "50" ;;
      esac
    ;;
    threshold2)
      case "${1:-}" in
        threshold) echo "" ;;
      esac
    ;;
    type)
      case "${1:-}" in
        blur|cmd|cmddiff|comet|compass|diffstat|dog|freichen|gaussian|kirsch|laplacian|log|morphology|prewitt|roberts|sobel|statistic|unsharp|wavelet)
          echo "mask"
        ;;
        channel|chroma|darkness|lightness|saturation)
          echo "mask"
        ;;
        image|enfuse|compose|evaluate|min|max|mean|median)
          echo "mask"
        ;;
        experimental)
          echo "mask"
        ;;
        maskblur|maskcmd|maskmorph|maskstat|maskwave)
          echo "merge"
        ;;
        cutblur|cutcmd|cutless|cutmorph|cutsoft|cutwave)
          echo "focus"
        ;;
        alpha|finalblur|finalblur2|threshold)
          echo "postfocus"
        ;;
        bg)
          echo "background"
        ;;
        colorspace|grayscale|level|merge|soft)
          echo "single"
        ;;
        substacks)
          echo "substack"
        ;;
        *)
          error "maskarg_defaultvalue(): Unknown type for method ${1:-}"
        ;;
      esac
    ;;
    wave)
      echo "30"
    ;;
    word1)
      case "${1:-}" in
        comet)      echo "lighten" ;;
        compose)    echo "overlay" ;;
        diffstat)   echo "median" ;;
        evaluate)   echo "max" ;;
        freichen)   echo "" ;;
        laplacian)  echo "3" ;;
        morphology) echo "edgeout" ;;
        statistic)  echo "standarddeviation" ;;

        bg)         echo "enfuse" ;;
        cutmorph)   echo "erode" ;;
        grayscale)  echo "Rec709Luma" ;;
        level)      echo "all" ;;
        maskmorph)  echo "close" ;;
        maskstat)   echo "mean" ;;
        merge)      echo "screen" ;;
        soft)       echo "plus" ;;
      esac
    ;;
    word2)
      case "${1:-}" in
        diffstat)   echo "mean" ;;
        maskmorph|morphology|cutmorph) echo "" ;;
      esac
    ;;
  esac
}
maskarg_checkallowed() {
  local Method Option Arg
  Method="${1:-}"
  Option="${2:-}"
  Arg="${3:-}"

  case "$Option" in
    channel)
      case "$Argtype" in
        mask) ;;
        *) 
          case "${1:-}" in
            colorspace) ;;
            *) error "$Method does not take argument colorspace channel: c$Arg" ;;
          esac
        ;;
      esac
    ;;
    colorspace)
      case "$Argtype" in
        mask)
          checkmagicklist colorspace "$Arg" || error "--$Method: unknown colorspace for C=: $Arg 
  Please choose one out of 'magick -list colorspace'"
          Argcolorspace="$(checkmagicklist colorspace "$Arg" print)"
        ;;
        *) 
          case "${1:-}" in
            colorspace) 
              checkmagicklist colorspace "$Arg" || error "--$Method: unknown colorspace for C=: $Arg 
  Please choose one out of 'magick -list colorspace'"
              Argcolorspace="$(checkmagicklist colorspace "$Arg" print)"
            ;;
            *) error "$Method does not take argument colorspace: C=$Arg" ;;
          esac
        ;;
      esac
    ;;
    image)
      case "$Argtype" in
        mask)
          generate_image --mode "$Arg" --showname >/dev/null || error "--$Method: unknown image generation format for Option -I='$Arg'.
  Please choose one out of:
  enfuse max min mean median
  'magick -list evaluate'
  'magick -list compose'
  'magick -list color"
          Argimage="$(generate_image --mode "$Argimage" --showmode)"
        ;;
        *) error "$Method does not take argument image comparision: I=$Arg" ;;
      esac
    ;;
    level)
      case "$Argtype" in
        mask)
          case "$Arg" in
            yes|no) ;;
            *) error "level does not take value '$Arg'. Allowed values are yes|no" ;;
          esac
        ;;
        *) error "$Method does not take argument level: level=$Arg" ;;
      esac
    ;;
    negate)
      case "$Argtype" in
        mask) ;;
        *) error "$Method does not take argument negate." ;;
      esac
    ;;
    number1|number2)
      case "$Method" in
        substacks) ;;
        *) error "$Method does not take argument number: n$Arg" ;;
      esac
    ;;
    percent1)
      case "$Method" in
        alpha|cutless|cutwave|maskwave|soft|wavelet) ;;
        substacks) ;;
        *) error "$Method does not take argument percent1: p$Arg" ;;
      esac
    ;;
    percent2)
      case "$Method" in
        alpha) ;;
        soft) ;;
        substacks) ;;
        *) error "$Method does not take argument percent2: P$Arg" ;;
      esac
    ;;
    radius1)
      case "$Method" in
        morphology|cutmorph|maskmorph) ;;
        diffstat|statistic|maskstat) ;;
        finalblur2) ;;
        substacks) ;;
        *) error "$Method does not take argument radius1: r$Arg" ;;
      esac
    ;;
    radius2)
      case "$Method" in
        morphology|cutmorph|maskmorph) ;;
        *) error "$Method does not take argument radius2: R$Arg" ;;
      esac
    ;;
    sigma1)
      case "$Method" in
        blur|comet|dog|gaussian|log|unsharp) ;;
        cutblur|cutsoft|finalblur|maskblur|threshold) ;;
        *) error "$Method does not take argument sigma1: s$Arg" ;;
      esac
    ;;
    sigma2)
      case "$Method" in
        dog|finalblur) ;;
        *) error "$Method does not take argument sigma2: S$Arg" ;;
      esac
    ;;
    threshold1)
      case "$Argtype" in
        mask) ;;
        *)
          case "$Method" in
            finalblur|finalblur2|threshold) ;;
            *) error "$Method does not take argument threshold1: t$Arg" ;;
          esac
        ;;
      esac
    ;;
    threshold2)
      case "$Argtype" in
        mask) ;;
        *)
          case "$Method" in
            threshold) ;;
            *) error "$Method does not take argument threshold2: T$Arg" ;;
          esac
        ;;
      esac
    ;;
    weight)
      case "$Argtype" in
        mask) ;;
        *) error "$Method does not take argument weight: w$Arg" ;;
      esac
    ;;
    word1)
      case "$Method" in
        bg)
          generate_image --mode "$Arg" --showname >/dev/null || error "--background: unknown image generation mode: '$Arg'.
  Please choose one out of:
  enfuse max min mean median
  'magick -list evaluate'
  'magick -list compose'
  'magick -list color"
          Argword1="$(generate_image --mode "$Arg" --showmode)"
        ;;
        grayscale)
          checkmagicklist intensity "$Arg" || error "--$Method: unknown colorspace: $Arg
  Please choose one out of 'magick -list intensity'"
          Argword1="$(checkmagicklist intensity "$Arg" print)"
        ;;
        freichen|laplacian) ;;
        colorspace) 
          checkmagicklist colorspace "$Arg" || error "--$Method: unknown colorspace: $Arg
  Please choose one out of 'magick -list colorspace'"
          Argword1="$(checkmagicklist colorspace "$Arg" print)"
        ;;
        level)
          case "$Arg" in
            all|substack|off) ;;
            *) error "$Method does not take argument: $Arg" ;;
          esac
        ;;
        compose|comet|merge|soft)
          checkmagicklist compose "$Arg" || error "--$Method: unknown argument for word1: $Arg
  Please choose one out of 'magick -list compose'"
          Argword1="$(checkmagicklist compose "$Arg" print)"
        ;;
        evaluate)
          checkmagicklist evaluate "$Arg" || error "--$Method: unknown argument for word1: $Arg
  Please choose one out of 'magick -list evaluate'"
          Argword1="$(checkmagicklist evaluate "$Arg" print)"
        ;;
        cmd|cmddiff|cutcmd|maskcmd) ;;
        morphology|cutmorph|maskmorph)
          checkmagicklist "morphology" "$(tr -d '2' <<< "$Arg")" || error "--$Method:  unknown argument for word1: $Arg
  Please choose one out of 'magick -list morphology'"
          Argword1="$(checkmagicklist morphology "$Arg" print)"
        ;;
        substacks) 
          case "$Arg" in
            kurt) ;;
            *) error "--$Method does not take argument: $Arg" ;;
          esac
        ;;
        statistic|diffstat|maskstat)
          checkmagicklist statistic "$Arg" || error "--$Method: unknown argument for word1: $Arg
  Please choose out of 'magick -list statistic'"
          Argword1="$(checkmagicklist statistic "$Arg" print)"
        ;;
        *) error "$Method does not take argument word1: $Arg" ;;
      esac
    ;;
    word2)
      case "$Method" in
        colorspace) ;;
        diffstat)
          checkmagicklist statistic "$Arg" || error "--$Method: unknown argument for word1: $Arg
  Please choose out of 'magick -list statistic'"
          Argword2="$(checkmagicklist statistic "$Arg" print)"
        ;;
        morphology|cutmorph|maskmorph)
          checkmagicklist kernel "$Arg" || error "--$Method: unknown kernel: $Arg
  Please choose out of 'magick -list kernel'"
          Argword2="$(checkmagicklist kernel "$Arg" print)"
        ;;
        *) error "$Method does not take argument word2: $Arg" ;;
      esac
    ;;
  esac

  return 0
}
maskarg_checkpercent() {
  # Allow percent values to be given without a leading 'p'. Few options only.
  [ -z "$Argpercent1" ] && [ -n "$Argword1" ] && {
    Argpercent1="$Argword1"
    Argword1=""
  }
  [ -n "$Argpercent1" ] && [ -n "$Argword1" ] && {
    error "Option does not take percent value along with a word argument"
    return 1
  }
  
  [ "$Argpercent1" = "auto" ] || [ "$Argpercent1" = "$(digitonly "$Argpercent1")" ] || {
    error "Invalid percent value: $Argpercent1"
    return 1
  }
}
maskarg_checksigma() {
  # Allow sigma values to be given without a leading 's'. Few options only.
  [ -z "$Argsigma1" ] && [ -n "$Argword1" ] && {
    Argsigma1="$Argword1"
    Argword1=""
  }
  [ -n "$Argsigma1" ] && [ -n "$Argword1" ] && {
    error "Option does not take sigma value along with a word argument"
    return 1
  }
  [ "$Argsigma1" = "auto" ] || [ "$Argsigma1" = "$(digitonly "$Argsigma1")" ] || {
    error "Invalid sigma value: $Argsigma1"
    return 1
  }
}
maskarg_single() {
  # provide arguments of an option $1 that can be specified only once
  local Count=
  eval $Arglist
  for Count in $(seq "$Imoptionsnumber"); do
    [ "${Imoptions[$Count]}" = "${1:-}" ] && maskarg_parse "$Count" && break
  done
  [ "${Imoptions[$Count]}" = "${1:-}" ]
}

### magick -script interaction

cmd() {
  local Command
  Command="${1:-}"
  [ -n "$Magickfifo" ] && {
    echo "$Command" >> "$Magickfifo"
    echo "$Command" >> "$Magickscriptlog"
    echo "$Command" >> "/tmp/imfuse.log"
  }
  return 
}
cmd_waitforkeyvalue() {
  # wait for keyword $1 in output of magick. Prints output after first :
  local Key Line
  Key="${1:-}"
  tail -f "$Magickfifolog" | while read Line; do
    grep -q "$Key" <<< "$Line" && break
  done
  echo "$(cut -d: -f2- <<< "$Line")"
  return 0
}
cmd_waitforready() {
  # wait for magick command toolchain to be ready
  local Command Count File Line Key
  Key="$(generate_key)"
  sendmagickmessage "$Key"
  cmd_waitforkeyvalue "$Key" >/dev/null
  return
}
readmagickmessage() {
  # read and parse messages from magick
  local Line Code Content
  local Stopwatch Etacount Etanumber Etaduration Etatime Etaline Etapos
  local Esc Colnorm Colgreenbg

  Esc="$(printf '\033')"
  Colnorm="${Esc}[0m"
  Colgreenbg="${Esc}[42m"

  tail -f "$Magickfifolog" | while read Line; do
    Code="$(cut -d: -f1 <<< "$Line")"
    Content="$(cut -d: -f2- <<< "$Line")"

    Columns="${COLUMNS:-80}"
    grep -q "ETA:" <<< "$Content" && {
      Columns="$((Columns))"
      Etacount="${Content#*ETA:}"
      grep -q "/" <<< "$Etacount" && Etanumber="${Etacount#*/}"
      Etacount="${Etacount%/*}"
      Etanumber="${Etanumber:-$Sourceimagenumber}"
      Etaduration="$(( $(date +%s) - Stopwatch ))"
      Etatime="$(( Etacount * Etaduration / (Etanumber-Etacount+1) ))"
      Etaline="$Etacount/$Etanumber ETA: $(date -u -d @$Etatime +"%T"), DUR: $(date -u -d @$Etaduration +"%T")"
      Content="${Content%ETA:*}$Etaline"
      Content="$(printf "%-${Columns}s" "$Content")"
      Content="$(cut -c1-${Columns} <<< "imfuse: $Content")"
      Etapos="$((Columns*Etacount/Etanumber))"
      Content="${Colgreenbg}${Content:0:$Etapos}${Colnorm}${Content:$Etapos}"
    }

    case "$Code" in
      PROGRESS)
        printsameline "$Content"
      ;;
      /PROGRESS|NEWLINE)
        echo "$Colnorm" >&2
      ;;
      NOTE)
        note "$Content"
      ;;
      SHOW)
        showimage "$Content"
      ;;
      STOPWATCH)
        Stopwatch="$(date +%s)"
      ;;
    esac
    grep -q error <<< "$Line" && {
      note "magick ERROR:
$Line"
      break
    }
  done
}
sendmagickmessage() {
  # send message $1 to output of magick
  local Command=
  case "$(cut -d: -f1 <<< "${1:-}")" in
    PROGRESS)
      Command="$Command
# $(cut -d: -f2- <<< "${1:-}")"
    ;;
    NOTE)
      Command="$Command
#### $(cut -d: -f2- <<< "${1:-}") ####
#"
    ;;
    *)
      Command="$Command
  # sending message ${1:-}"
    ;;
  esac
  Command="$Command
  rose:
    -format '${1:-}\n'
    -write info:
    -delete -1"
  cmd "$Command"
  return 0
}
showimagecode() {
  local Image Imageformat
  # magick code to store current image and print a showimage message for readmagickmessage()
  [ "$Showimageprocessing" ] && {
    Image="${1:-}"
    Imageformat="$(rev <<< "$Image" | cut -d. -f1 | rev)"
    [ "$(cut -c1-4 <<< "$Image")" = "mpr:" ] && Imageformat="mpr"
    case "$Imageformat" in
      ""|"mpr"|"mpc"|"miff")
        echo "# show image
    -compress none
    -write '$Showimage'
    -format 'SHOW:$Showimage\n'
    -write info:"
      ;;
      *)
        sendmagickmessage "SHOW:$Image"
      ;;
    esac
  }
  return 0
}
getmagickinfo() {
  # get info output for image $1 in format $2
  local Key1 Key2 Command
  Key1="$(generate_key)"
  Key2="$(generate_key)"
  Command="
  # get info ${2:-} about image ${1:-}
  '${1:-}'
    -format '$Key1\n${2:-}\n$Key2\n'
    -write info:
    -delete -1"
  cmd "$Command"
  cmd_waitforready
  cmd_waitforkeyvalue "$Key2" >/dev/null
  sed -n "/$Key1/,/$Key2/p" "$Magickfifolog" | sed '1d ; $d'
}

### main

trap_sigint() {
  local Count=0
  trap - ERR
  set +x
  note "Received SIGINT"
  [ -n "$Magickscriptpid" ] && kill "$Magickscriptpid"
  multicore_break
  finish 130
}
finish() {
  local Count=0
  trap - ERR
  set +x

  multicore_wait
  break 2>/dev/null
  cmd '-exit'
  while ps -p "$Magickscriptpid" >/dev/null 2>&1; do
    sleep 1
    Count="$((Count+1))"
    [ "$Count" -gt "3" ] && printsameline "Waiting infinitely since $Count seconds for magick pid $Magickscriptpid to terminate"
  done
  echo "" >&2

  [ -n "$Magickmessagepid" ] && kill "$Magickmessagepid"
  exec 3>&-
  rm -f $Magickfifo $Magickfifolog >/dev/null 2>&1

  #[ -f "$Magickscriptlog" ] && cp "$Magickscriptlog" .

  [ -f "${Showimage:-}" ] && rm "$Showimage"
  [ "$Keepcache" = "no" ] && [ -d "$Cachedir" ] && rm -R "$Cachedir"

  #jobs
  trap - SIGINT
  trap - EXIT
  exit "${1:-0}"
}
declare_variables() {
  Arglist='
  Argbasename=""
  Argchannel=""
  Argcolorspace=""
  Argcount=""
  Argdiff=""
  Argimage=""
  Arglevel=""
  Argmethod=""
  Argnegate=""
  Argnumber1=""
  Argnumber2=""
  Argoptions=""
  Argpercent1=""
  Argpercent2=""
  Argradius1=""
  Argradius2=""
  Argsigma1=""
  Argsigma2=""
  Argthreshold1=""
  Argthreshold2=""
  Argtype=""
  Argweight=""
  Argword1=""
  Argword2=""
  '
  eval $Arglist

  Align=""
  Cachedir=""
  Colorspace=""
  Colorspacechannel=""
  Exifsourceimage=""
  Firstimage=""
  Force=""
  Freemem=""
  Grayscale=""
  Grayscaleconverter=""
  Grayscalenumber=""
  Image=""
  Imageformat="tif"
  Imageheight=""
  Imagelistmemsize=""
  Imagememsize=""
  Imagewidth=""
  Imarguments=""
  Imfusepid="$$"
  Imoptions=""
  Imoptionsnumber="0"
  Imsourceimagelist=""
  Keepcache="no"
  Limitmemory=""
  Line=""
  Loadsourceimages=""
  Magickbin=""
  Magickfifo=""
  Magickfifolog=""
  Magickmessagepid=""
  Magickpixelmemory=""
  Magickscriptlog=""
  Magickscriptpid=""
  Magickversion=""
  Maskmethodnumber="0"
  Masksuffix="mpc"
  Masktocache="no"
  Mergemaskbasename=""
  Outputbasename=""
  Outputdir=""
  Outputimage=""
  Parsedoptions=""
  Revertimagelist=""
  Resultbasename=""
  Savemask=""
  Showimage=""
  Showimageprocessing=""
  Showname=""
  Substackautoall="no"
  Substackfirstimage=""
  Substacklastimage=""
  Substackmask=""
  Substackmaskpost=""
  Substackoptcount="0"
  Substackoptarg=""
  Substackoverlap=""
  Substackresult=""
  Substackresultpost=""
  Substacknumber="0"
  Substacksize=""
  Substackstep=""
  Softmode="no"
  Sourceimage=""
  #Sourceimagelist=""
  Sourceimagenumber="0"
  Sourceimagesalreadyloaded=""
  Sourcemd5=""
  Startzeit="$(date +%s)"
  Storelayered="no"
  Testarg=""
  Testimage=""
  Testsetup=""
  Tifstore="+repage -quality 100% -compress lzw"
  Tifstorealpha="$Tifstore -type TrueColorAlpha"
  Untrap=""
  Verbose=""
  Video=""
  Videoframecount=""
  Viewnior=""

  return 0
}
parse_options() {
  local Shortoptions Longoptions Parsedoptions

  Shortoptions="ho:vVW"
  Longoptions="basename:,cache::,exif::,force::,help,limit-memory::,mask2cache,output:,savemask::,showimage,showname,test::,verbose,version,video"
  Longoptions="$Longoptions,align,revert"
  Longoptions="$Longoptions,colorspace::,grayscale::"
  Longoptions="$Longoptions,blur::,comet::,compass::,diffstat::,dog::,gaussian::,freichen::,kirsch::,laplacian::,log::,morphology::,prewitt::,roberts::,sobel::,statistic::,unsharp::,wavelet::"  
  Longoptions="$Longoptions,compose::,enfuse::,evaluate::,max::,mean::,median::,min::"
  Longoptions="$Longoptions,channel::,chroma::,darkness::,lightness::,saturation::"
  Longoptions="$Longoptions,cmd::,cmddiff::,experimental::"
  Longoptions="$Longoptions,level::,maskblur::,maskcmd::,maskmorph::,maskstat::,maskwave::,merge::"
  Longoptions="$Longoptions,cutblur::,cutcmd::,cutless::,cutmorph::,cutsoft::,cutwave::,substacks::,soft::"
  Longoptions="$Longoptions,alpha::,finalblur::,finalblur2::,threshold::"
  Longoptions="$Longoptions,background::,bg::,layered"

  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@")" || error "Error while parsing options."
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --align)             Align="yes"                         ;;
      --basename)          Outputbasename="${2:-auto}"         ; shift ;;
      --cache)             Cachedir="${2:-auto}"               ; shift ;;
      --exif)              Exifsourceimage="${2:-auto}"        ; shift ;;
      --force)             Force="${2:-yes}"                   ; shift ;;
      -h|--help)           usage                               ; finish 0 ;;
      --layered)           Storelayered="yes"                  ;;
      --limit-memory)      Limitmemory="${2:-"80%"}"           ; shift ;;
      --mask2cache)        Masktocache="yes"                   ;;
      -o|--output)         Outputimage="${2:-}"                ; shift ;;
      --revert)            Revertimagelist="-r"                ;;
      --savemask)          Savemask="${2:-auto}"               ; shift ;;
      -V|--showimage)      Showimageprocessing="yes"           ;;
      --showname)          Showname="yes"                      ;;
      --test)              Testsetup="test" ; Testarg="${2:-}" ; shift ;;
      -v|--verbose)        Verbose="yes"                       ;;
      --version)           echo "imfuse v$Version"             ; finish 0 ;;
      --video)             Video="auto"                        ;;
      -W)                  Viewnior="yes"                      ;;

--cmd|--cmddiff|--experimental\
--blur|--comet|--compass|--diffstat|--dog|--freichen|--gaussian|--kirsch|--laplacian|--log|--morphology|--prewitt|--roberts|--sobel|--statistic|--unsharp|--wavelet|\
--channel|--chroma|--darkness|--lightness|--saturation|\
--compose|--enfuse|--evaluate|--max|--mean|--median|--min|\
\
--colorspace|--grayscale|\
--maskblur|--maskcmd|--maskmorph|--maskstat|--maskwave|--level|--merge|\
--cutblur|--cutcmd|--cutless|--cutmorph|--cutsoft|--cutwave|--soft|\
--alpha|--finalblur|--finalblur2|--threshold|\
--bg|--background|\
--substacks)
                           maskarg_add "${1:-}" "${2:-}"       ; shift
      ;;
      --) ;;
      *)
        [ -f "${1:-}" ] || error "File not found: ${1:-}"
        Sourceimagenumber="$((Sourceimagenumber+1))"
        Sourceimagelist[$Sourceimagenumber]="${1:-}"
      ;;
    esac
    shift
  done
  #IFS=$'\n' Sourceimagelist=( '' $(sort -V $Revertimagelist <<< "${Sourceimagelist[@]:-}") ) ; unset IFS
  IFS=$'\n' Sourceimagelist=( '' $(sort -V $Revertimagelist <<< "${Sourceimagelist[*]:-}")) ; unset IFS
  unset Sourceimagelist[0]
  return 0
}
check_options() {
  # parse arguments, check validity, set defaults

  local Arg Part1 Part2 Weightsum= Weightrest Masknoweightcount= Singleoptionlist=
  local Firstimage Lastimage Substacksize Position
  local Lessthanmaxoption

  [ "$Sourceimagenumber" = "0" ] && error "No source images provided."

  # magick
  Magickbin="$(command -v magick)"
  false && [ -e "/usr/lib/x86_64-linux-gnu/libtcmalloc_minimal.so.4.5.6" ] && {
    # https://imagemagick.org/script/openmp.php
    # https://goog-perftools.sourceforge.net/doc/tcmalloc.html
    Magickbin="env LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libtcmalloc_minimal.so.4.5.6 $Magickbin"
  }
  [ -z "$Magickbin" ] && error "Command 'magick' not found. Please install ImageMagick version 7."

  # --cache
  [ -n "$Cachedir" ] && {
    Masktocache="yes"
    Keepcache="yes"
    [ "$Cachedir" = "auto" ] && Cachedir=""
  }
  Cachedir="$(sed s%'~'%$HOME% <<< "$Cachedir")"
  case "$Masktocache" in
    yes) [ -z "$Cachedir" ] && Cachedir="./cache.imfuse" ;;
    no)  [ -z "$Cachedir" ] && Cachedir="./cache.imfuse.$Imfusepid" ;;
  esac
  mkdir -p "$Cachedir"   || error "Error creating cache folder $Cachedir"
  Testimage="$Cachedir/test.png"
  Resultmask="$Cachedir/result.max.tif"

  # mask options
  for Count in $(seq "$Imoptionsnumber"); do
    maskarg_parse "$Count"
    Argtype="$(maskarg_defaultvalue "$Argmethod" type)"
    [ -z "$Argchannel"  ]    && Argchannel="$(maskarg_defaultvalue    "$Argmethod" channel)"
    [ -z "$Argcolorspace"  ] && Argcolorspace="$(maskarg_defaultvalue "$Argmethod" colorspace)"
    [ -z "$Argimage"  ]      && Argimage="$(maskarg_defaultvalue      "$Argmethod" image)"
    [ -z "$Arglevel"  ]      && Arglevel="$(maskarg_defaultvalue      "$Argmethod" level)"
    [ -z "$Argnegate"  ]     && Argnegate="$(maskarg_defaultvalue     "$Argmethod" negate)"
    [ -z "$Argpercent1" ]    && Argpercent1="$(maskarg_defaultvalue   "$Argmethod" percent1)"
    [ -z "$Argpercent2" ]    && Argpercent2="$(maskarg_defaultvalue   "$Argmethod" percent2)"
    [ -z "$Argradius1" ]     && Argradius1="$(maskarg_defaultvalue    "$Argmethod" radius1)"
    [ -z "$Argradius2" ]     && Argradius2="$(maskarg_defaultvalue    "$Argmethod" radius2)"
    [ -z "$Argsigma1" ]      && Argsigma1="$(maskarg_defaultvalue     "$Argmethod" sigma1)"
    [ -z "$Argsigma2" ]      && Argsigma2="$(maskarg_defaultvalue     "$Argmethod" sigma2)"
    [ -z "$Argthreshold1" ]  && Argthreshold1="$(maskarg_defaultvalue "$Argmethod" threshold1)"
    [ -z "$Argthreshold2" ]  && Argthreshold2="$(maskarg_defaultvalue "$Argmethod" threshold2)"
    [ -z "$Argword1" ]       && Argword1="$(maskarg_defaultvalue      "$Argmethod" word1)"
    [ -z "$Argword2" ]       && Argword2="$(maskarg_defaultvalue      "$Argmethod" word2)"
    [ -n "$Argchannel" ]     && maskarg_checkallowed "$Argmethod" channel    "$Argchannel"
    [ -n "$Argcolorspace" ]  && maskarg_checkallowed "$Argmethod" colorspace "$Argcolorspace"
    [ -n "$Argimage" ]       && maskarg_checkallowed "$Argmethod" image      "$Argimage"
    [ -n "$Arglevel" ]       && maskarg_checkallowed "$Argmethod" level      "$Arglevel"
    [ -n "$Argnegate" ]      && maskarg_checkallowed "$Argmethod" negate     "$Argnegate"
    [ -n "$Argnumber1" ]     && maskarg_checkallowed "$Argmethod" number1    "$Argnumber1"
    [ -n "$Argnumber2" ]     && maskarg_checkallowed "$Argmethod" number2    "$Argnumber2"
    [ -n "$Argradius1" ]     && maskarg_checkallowed "$Argmethod" radius1    "$Argradius1"
    [ -n "$Argradius2" ]     && maskarg_checkallowed "$Argmethod" radius2    "$Argradius2"
    [ -n "$Argsigma1" ]      && maskarg_checkallowed "$Argmethod" sigma1     "$Argsigma1"
    [ -n "$Argsigma2" ]      && maskarg_checkallowed "$Argmethod" sigma2     "$Argsigma2"
    [ -n "$Argpercent1" ]    && maskarg_checkallowed "$Argmethod" percent1   "$Argpercent1"
    [ -n "$Argpercent2" ]    && maskarg_checkallowed "$Argmethod" percent2   "$Argpercent2"
    [ -n "$Argthreshold1" ]  && maskarg_checkallowed "$Argmethod" threshold1 "$Argthreshold1"
    [ -n "$Argthreshold2" ]  && maskarg_checkallowed "$Argmethod" threshold2 "$Argthreshold2"
    [ -n "$Argweight" ]      && maskarg_checkallowed "$Argmethod" weight     "$Argweight"
    [ -n "$Argword1" ]       && maskarg_checkallowed "$Argmethod" word1      "$Argword1"
    [ -n "$Argword2" ]       && maskarg_checkallowed "$Argmethod" word2      "$Argword2"

    case "$Argtype" in
      mask)
        Maskmethodnumber="$((Maskmethodnumber+1))"
      ;;
      single)
        grep -q -w "$Argmethod" <<< "$Singleoptionlist" && error "Option --$Argmethod can be specified only once."
        Singleoptionlist="$Singleoptionlist $Argmethod"
      ;;
    esac

    case $Argmethod in
      freichen)
        case $Argword1 in
          10|12|19) Argdiff=yes ;;
        esac
      ;;
      morphology)
        case ${Argword1,,} in
          close) ;;
          edge|edgein|edgeout|tophat|bottomhat) ;;
          *) Argdiff="yes" ;;
        esac
      ;;
      soft)
        Softmode="yes"
      ;;
      statistic)
        case ${Argword1,,} in
          gradient|standarddeviation|"") Argdiff="" ;;
          *)                             Argdiff="yes" ;;
        esac
      ;;
    esac

    # convert to --cmd
    case "$Argmethod" in
      channel|chroma|darkness|lightness|saturation)
        Imoptions["$Count"]="cmd"
      ;;
      enfuse|max|min|mean|median)
        Imoptions["$Count"]="cmd"
      ;;
      compose|evaluate)
        Imoptions["$Count"]="cmd"
        Argimage="$Argword1"
        Argword1=""
      ;;
    esac

    maskarg_store "$Count"
  done

  for Count in $(seq "$Imoptionsnumber"); do
    verbose "${Imoptions[$Count]}=${Imarguments[$Count]}"
  done

  # w, weight
  for Count in $(seq $Imoptionsnumber); do
    maskarg_parse "$Count"
    case $Argtype in
      mask)
        Weightsum="$((Weightsum + Argweight))"
        [ -z "$Argweight" ]   && Masknoweightcount="$((Masknoweightcount+1))"
      ;;
    esac
  done
  Weightrest="$((100-Weightsum))"
  LC_ALL=C awk 'BEGIN {exit !('${Weightsum:-100}' > 100)}' && error "Sum of weight arguments exceed 100%."
  for Count in $(seq $Imoptionsnumber); do
    maskarg_parse "$Count"
    case $Argtype in
      mask)
        [ -z "$Argweight" ] && {
          LC_ALL=C awk 'BEGIN {exit !('${Weightrest:-0}' <= 0)}' && error "Sum of weight arguments exceed 100%, nothing left for --$Argmethod."
          Argweight="$(calc "$Weightrest / $Masknoweightcount ")"
        }
        maskarg_store "$Count"
      ;;
    esac
  done

  # --align
  [ "$Align" = "yes" ] && {
    command -v focus-stack >/dev/null || {
      error "--align: focus-stack not found.
  Please install focus-stack.
  https://github.com/PetteriAimonen/focus-stack"
    }
  }

  # --basename
  case $Outputbasename in
    auto) Outputbasename="$(basename "$(pwd)")" ;;
  esac
  [ -d "$Outputbasename" ] && {
    Outputdir="$Outputbasename"
    Outputbasename=""
  } || {
    Outputdir="$(dirname "$Outputbasename")"
    Outputbasename="$(basename "$Outputbasename")"
  }

  # --colorspace
  maskarg_single "colorspace" && {
    Colorspace="${Argcolorspace:-"sRGB"}"
    Colorspacechannel="${Argchannel}"
  }
  Colorspace="${Colorspace:-"sRGB"}"

  # --grayscale
  maskarg_single "grayscale"  && Grayscale="-grayscale $Argword1"

  # --level
  maskarg_single "level" || {
    { maskarg_single maskblur || maskarg_single maskcmd || maskarg_single maskmorph || maskarg_single maskstat || maskarg_single maskwave ;} && {
      eval $Arglist
      Argmethod="level"
      Argtype="single"
      Argword1="all"
      Imoptionsnumber="$((Imoptionsnumber+1))"
      Imoptions[$Imoptionsnumber]="$Argmethod"
      maskarg_store "$Imoptionsnumber"
    }
  }

  # --showimage
  [ "$Showimageprocessing" ] && {
    command -v geeqie >/dev/null || {
      note "-V, --showimage: geeqie not found.
  Please install geeqie."
      Showimageprocessing=""
    }
  }

  # --substacks
  for Count in $(seq "$Imoptionsnumber"); do
    [ "${Imoptions[$Count]}" = "substacks" ] && Substackoptcount="$((Substackoptcount+1))"
  done
  [ "$Maskmethodnumber" -gt "0" ] && [ "$Substackoptcount" = "0" ] && {
    eval $Arglist
    Imoptionsnumber="$((Imoptionsnumber+1))"
    Imoptions[$Imoptionsnumber]="substacks"
    Imarguments[$Imoptionsnumber]="n1,N$Sourceimagenumber,TYPE=substack"
    maskarg_parse "$Imoptionsnumber"
    maskarg_store "$Imoptionsnumber"
    Substackautoall="yes"
  }
  for Count in $(seq "$Imoptionsnumber"); do
    [ "${Imoptions[$Count]}" = "substacks" ] && {
      maskarg_parse "$Count"
      [ -z "$Argnumber1" ] && [ -n "$Argpercent1" ] && Argnumber1="$(numberofpercent "$Argpercent1")"
      [ -z "$Argnumber2" ] && [ -n "$Argpercent2" ] && Argnumber2="$(numberofpercent "$Argpercent2")"
      grep -q "%" <<< "$Argradius1" && Argradius1="$(numberofpercent "$Argradius1")"
      [ -z "$Argnumber2" ] && [ -z "$Argradius1" ]  && Argradius1="$(numberofpercent "5")" # default radius 5%
      [ -z "$Argnumber1" ] && Argnumber1="$(numberofpercent "14")"                         # default 7 substacks
      maskarg_store "$Count"
      # single substack
      [ -n "$Argnumber1" ] && [ -n "$Argnumber2" ] && {
        Argradius1="${Argradius1:-0}"
        Firstimage="$((Argnumber1-Argradius1))"
        Lastimage="$((Argnumber2+Argradius1))"
        [ "$Firstimage" -lt "1" ]                 && Firstimage="1"
        [ "$Lastimage" -gt "$Sourceimagenumber" ] && Lastimage="$Sourceimagenumber"
        Substacknumber="$((Substacknumber+1))"
        Substackfirstimage[$Substacknumber]="$Firstimage"
        Substacklastimage[$Substacknumber]="$Lastimage"
      }

      # generate set of substacks
      [ -n "$Argnumber1" ] && [ -z "$Argnumber2" ] && {
        Substacksize="$Argnumber1"
        Position="0"
        while [ "${Lastimage:-0}" -lt "$Sourceimagenumber" ]; do
          Firstimage="$((Position-Argradius1))"
          Lastimage="$((Position+Substacksize+Argradius1))"
          [ "$Firstimage" -lt "1" ]                 && Firstimage="1"
          [ "$Argword1" = "kurt" ]                  && Firstimage="1"
          [ "$Lastimage" -gt "$Sourceimagenumber" ] && Lastimage="$Sourceimagenumber"
          Substacknumber="$((Substacknumber+1))"
          Substackfirstimage[$Substacknumber]="$Firstimage"
          Substacklastimage[$Substacknumber]="$Lastimage"
          Position="$((Position+Substacksize))"
        done
      }
    }
  done

  # --soft
  [ "$Softmode" = "yes" ] && {
    maskarg_single "cutblur"  && Softmode="error"
    maskarg_single "cutcmd"   && Softmode="error"
    maskarg_single "cutless"  && Softmode="error"
    maskarg_single "cutsoft"  && Softmode="error"
    maskarg_single "cutwave"  && Softmode="error"
    [ "$Softmode" = "error" ] && error "Option --soft does not support options
  --cutblur, --cutsoft, --cutless."
  }

  return 0
}
main_setup() {

  # check magick version
  Magickversion="$($Magickbin -version)"

  # Bytesperpixel*(channels)*unknownfactor
  grep -q " Q8 "        <<< "$Magickversion" && Magickpixelmemory="$(calc "1*(5) *1.2")"
  grep -q " Q8-HDRI "   <<< "$Magickversion" && Magickpixelmemory="$(calc "2*(5) *1.2")"
  grep -q " Q16 "       <<< "$Magickversion" && Magickpixelmemory="$(calc "2*(5) *1.2")"
  grep -q " Q16-HDRI "  <<< "$Magickversion" && Magickpixelmemory="$(calc "4*(5) *1.2")"
  grep -q " Q32 "       <<< "$Magickversion" && Magickpixelmemory="$(calc "4*(5) *1.2")"
  grep -q " Q32-HDRI "  <<< "$Magickversion" && Magickpixelmemory="$(calc "8*(5) *1.2")"
  Magickversion="$(head -n1 <<< "$Magickversion" | cut -d' ' -f3)"

  # check RAM
  Freemem="$(printfreememory)"
  [ -z "$Freemem" ] && {
    note "WARNING: failed to estimate free memory.
  Blindly guessing 1GB."
    Freemem="1000000"
  }
  Limitmemory="${Limitmemory:-"80%"}"
  grep -q "%" <<< "$Limitmemory" && {
    Limitmemory="$(tr -d "%" <<< "$Limitmemory")"
    Limitmemory="$((Freemem*Limitmemory/100))"
  } || {
    Limitmemory="$((Limitmemory*1000))"
  }

  # Image properties
  Sourceimagenumberlength="${#Sourceimagenumber}"
  Image="${Sourceimagelist[1]}"
  Imagewidth="$($Magickbin identify -format '%w' "$Image")"
  Imageheight="$($Magickbin identify -format '%h' "$Image")"
  Imagememsize="$((Imagewidth*Imageheight*Magickpixelmemory/1000))"
  Imagememsize="$((Imagememsize*125/100))" # by observation. Alpha channel?
  Imagelistmemsize="$((Sourceimagenumber*Imagememsize))"

  Sourcemd5="$(md5cut "$( ls -l --full-time "${Sourceimagelist[@]}" )" )"
  echo "$Sourcemd5" > "$Cachedir/md5"
  Showimage="${XDG_RUNTIME_DIR:-$Cachedir}/imfuse.showimage.tif"

  # check if source images should be loaded to RAM
  [ "$((Imagelistmemsize))" -lt "$((Limitmemory/2))" ] && Loadsourceimages="yes" || Loadsourceimages="no"

  # --output, --basename
  check_outputname

  # --showname
  [ "$Showname" = "yes" ] && {
    echo "$Outputimage"
    finish
  }

  verbose "
  imfuse Version:                     $Version
  Imagemagick version:                $Magickversion
  Image number:                       $Sourceimagenumber
  Image width:                        $Imagewidth px
  Image height:                       $Imageheight px
  Image memory size (estimated):      $Imagememsize KB
  Image list memory size (estimated): $((Imagelistmemsize/1024)) MB
  Memory total (including zram):      $(($(printtotalmemory)/1000)) MB
  Memory currently free:              $((Freemem/1000)) MB
  Memory limit for imagemagick:       $((Limitmemory/1000)) MB
  Loading source images to RAM:       $Loadsourceimages"
  note "Options:
$Resultbasename"

  # start magick -script in background
  Magickfifo="$Cachedir/magickfifo.$Imfusepid"
  Magickfifolog="$Cachedir/magickmessage.$Imfusepid.log"
  Magickscriptlog="$Cachedir/magickscript.log"
  :> "$Magickscriptlog"
  :> /tmp/imfuse.log
  mkfifo "$Magickfifo"
  exec 3<>"$Magickfifo"
  nice magick -limit memory ${Limitmemory}KB -define registry:temporary-path="$Cachedir" -script - <&3 >"$Magickfifolog" 2>&1 & Magickscriptpid="$!"
  readmagickmessage & Magickmessagepid="$!"

  # --force
  [ -f "$Outputimage" ] && [ -z "$Force" ] && {
    showimage "$Outputimage"
    [ "$Viewnior" ] && viewnior "$Outputimage" &
    note "Output image already exists with matching md5sum.
  You can force imfuse to run nonetheless with option --force."
    echo $Outputimage
    exit
    return 0
  }

  # start geeqie
  Command="
# $Resultbasename
# $(date)
  ( wizard:
      -colorspace $Colorspace"
      [ -n "$Colorspacechannel" ] && Command="$Command
      -channel $Colorspacechannel
      -separate
      +channel"
      Command="$Command
  )
    $Grayscaleconverter
    -statistic standard_deviation 2
    -auto-level
    -write '$Showimage'
    -delete 0"
  cmd "$Command"
  cmd_waitforready
  [ "$Showimageprocessing" = "yes" ] && nohup geeqie -t -r --File:"$Showimage" </dev/null >/dev/null 2>&1

  return 0
}
main() {
#  shopt -s inherit_errexit
  set -Eu
  trap trap_sigint SIGINT
  trap finish      EXIT
  trap 'traperror $? $LINENO $BASH_LINENO "$BASH_COMMAND" $(printf "::%s" ${FUNCNAME[@]})'  ERR
  Untrap="
trap - SIGINT
trap - EXIT
trap - ERR"
  shopt -s lastpipe

  declare_variables
  parse_options "$@"
  check_options
  main_setup
  multicore_init

  # --force
  [ "$Force" = "mask" ]  && forcemask
  [ "$Force" = "merge" ] && forcemerge
  [ "$Force" = "level" ] && forcelevel
  [ "$Force" = "focus" ] && forcefocus
  [ "$Force" = "post" ]  && forcepost

  # --align
  [ "$Align" = "yes" ] && {
    align || error "Error in align()."
  }

  # Generate helper images
  generate_image --mode "black"
  generate_image --mode "white"
  generate_image --mode "transparent"

  # run
  focus_main

  # --exif: transfer EXIF metadata from first image to result
  [ "$Exifsourceimage" ] && {
    [ "$Exifsourceimage" = "auto" ] && { 
      Exifsourceimage="${Sourceimagelist[1]}"
      [ "$Revertimagelist" ] && Exifsourceimage="${Sourceimagelist[$Imagenumber]}"
    }
    exiftransfer "$Exifsourceimage" "$Outputimage"
  }

  showimage "$Outputimage"
  note "Ready after $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")"
  cmd "-exit"
  echo "$Outputimage"
  command -v xclip >/dev/null && echo -n "$Outputimage" | xclip -i -selection clipboard

  # -W
  [ "$Viewnior" ] && nohup viewnior "$Outputimage" </dev/null >/dev/null 2>&1 &

  # --video
  [ "$Video" ]    && generate_video

  return 0
}
main "$@"
finish
