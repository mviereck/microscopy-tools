#! /bin/bash

# imfuse
Version="0.6.5.0-beta"

usage() {
  echo "imfuse v$Version
Combines focus stackshot images to one overall sharp image.
Aims to be similar to enfuse, but based on ImageMagick.

Note that imfuse expects already aligned input images.
It assumes that the alphanumerical order of the input images goes from
top to bottom; for the other way around use option --revert.

Dependencies:
  imagemagick         Mandatory (command 'convert' or 'magick').
  enfuse              Recommended, needed for some options.
  geeqie              Optional, used by option -V, --showimage.
  exiftool            Optional, to transfer metadata from first image to result.

Usage:
  imfuse [OPTIONS] -- image1 image2 image3 ...

General options:
 --basename           Base name [+path] for output image. 
 --cache [=DIR]       Preserve cache files, can be partially reused by imfuse.
                      Optionally specify a cache folder DIR.
 --exif [=IMAGE]      Transfer exif meta data from IMAGE or first input image.
 -h, --help           Show this help and exit.
 --layers [=NUMBER]   Additonally store a layered TIFF image where
                      the layers contain different sharpness areas.
                      NUMBER is number of sharpness layers.  Default: 24
 -o, --output=FILE    Result image file name.
 --threads            Number of parallel threads to run at once.
                      Default: number of CPU's (nproc).
 -v, --verbose        Show verbose output.
     --version        Show imfuse version and exit.
 -V, --showimage      Show intermediate results with image viewer geeqie.

The mask generating options below can take additionally arguments [=ARG].
Multiple arguments are comma-separated. 
  Example: --morphology=r3,less20,close,maskblur --saturation=w50
Arguments taken by all mask options:
  w         Mask weight. Percent value from 0 to 100.
            Of interest if specifying more than one mask generation method.
            Example: --morphology --saturation=w25
            This will generate two masks. The saturation mask will only have
            noteable effect where the morphology mask strength is below 25%.
  c, close  Compare option --close, here applied for single mask only.
  less      Compare option --less, here applied for single mask only.
  soft      Compare option --soft, here applied for single mask only.
  maskblur  Compare option --maskblur, here applied for single mask only.
  denoise   Compare option --denoise, here applied for single mask only.
  negate    Negate/invert the mask. Rarely needed.
  t         Threshold of mask below percent. Default without value: t10
Arguments taken by few options only:
  r         Radius. Must be an integer value.
            Increased radius mostly causes less noise, less details and
            more contrast. Smaller radius causes more details and more noise.
            (Options taking a sigma argument have a radius of 0 by default,
            which means that a radius fitting the sigma value will be 
            calculated automatically by imagemagick.)
  s         Sigma. Takes non-integer values like 0.75.
            Increased sigma mostly causes less noise, less details and
            more contrast. Smaller sigma causes more details and more noise.
  S         Second Sigma. Taken only optionally by --dog.
  p         Percent value.
  swap      Taken only by --composite.
  (words)   Some options take one or two word arguments.


Contrast mask options:
 --blur [=ARG]        Blur edge detection. 
                      Similar to --gaussian, but faster and less accurate.
                      ARG additionally takes arguments: 
                        r       radius               Default: 0
                        s       sigma                Default: 0.75
 --comet [=ARG]       Comet edge detection. Compares rotated mean areas.
                      ARG additionally takes arguments: 
                        r       radius               Default: 0
                        s       sigma                Default: 5
                        (word)  MODE                 Default: Lighten
                      MODE can be one of '$(basename $Magicklist) -list compose'
                      Recommended: Lighten, Darken.
 --compass [=ARG]     Compass edge detection. 
 --dog [=ARG]         Difference of Gaussian. 
                      ARG additionally takes arguments: 
                        r       radius               Default: 0
                        s       sigma                Default: 0.3
                        S       sigma2               Default: 1.6*sigma1
 --diffstat [=ARG]    Compares two local statistics of source images. 
                      Uses ImageMagick option -statistic. Compare --statistic.
                      ARG additionally takes arguments: 
                        r       radius               Default: 3
                        (word)  STAT1                Default: median
                        (word)  STAT2                Default: mean
                      Possible STAT1 and STAT2:
                        0|none|source
                        1|gradient|grad
                        2|maximum|max
                        3|mean
                        4|median
                        5|minimum|min
                        6|mode
                        7|nonpeak
                        8|9|rms|rootmeansquare
                        10|standarddeviation|dev
                      Most interesting alternative is a max,min difference.
 --free [=ARG]        Custom ImageMagick option for mask generation.
                      ARG is an arbitrary ImageMagick command, but must not
                      contain a comma.               Default: '-sharpen 0x3'
 --freediff [=ARG]    Custom ImageMagick option for mask generation.
                      The resulting mask  will be a '-compose Difference' 
                      comparision with the source image.
                      ARG is an arbitrary ImageMagick command, but must not
                      contain a comma.
 --freichen [=ARG]    Frei-Chen edge detection. 
                      ARG additionally takes arguments: 
                        (word)  MODENUMBER
                      Possible MODENUMBERs at:
                      http://www.imagemagick.org/Usage/convolve/#freichen
                      Default: A combination of modes 1 and 2.
 --gaussian [=ARG]    Gaussian blur edge detection. 
                      Similar to --blur, but slower and more accurate.
                      ARG additionally takes arguments: 
                        r       radius               Default: 0
                        s       sigma                Default: 0.3
 --kirsch [=ARG]      Kirsch edge detection. 
 --laplacian [=ARG]   Laplacian edge detection.
                      ARG additionally takes arguments: 
                        (word)  MODENUMBER           Default: 3
                      Possible MODENUMBERs at:
                      http://www.imagemagick.org/Usage/convolve/#laplacian
 --log [=ARG]         Laplacian of Gaussian.
                      ARG additionally takes arguments: 
                        r       radius               Default: 0
                        s       sigma                Default: 0.2
 --morphology [=ARG]  Morphology edge detection.
                      ARG additionally takes arguments: 
                        r       radius               Default: 2
                        (word)  MODE                 Default: edge
                      MODE can be one of '$(basename $Magicklist) -list morphology'
                      Some MODEs of interest:
                        edge, dilateintensity, smooth
 --prewitt [=ARG]     Prewitt edge detection. 
 --roberts [=ARG]     Roberts edge detection. 
 --sobel [=ARG]       Sobel edge detection. 
 --statistic [=ARG]   ImageMagick option -statistic.
                      ARG additionally takes arguments: 
                        r       radius               Default: 2
                        (word)  STAT                 Default: standarddeviation
                      Argument STAT is one of (number or name):
                        1|gradient|grad
                        2|maximum|max
                        3|mean
                        4|median
                        5|minimum|min
                        6|mode
                        7|nonpeak
                        8|9|rms|rootmeansquare
                        10|standarddeviation|dev
                      Get an impressive strong contrast with a high radius.
 --unsharp [=ARG]     Difference of -unsharp.
                      ARG additionally takes arguments: 
                        r       radius               Default: 0
                        s       sigma                Default: 2
 --wavelet [=ARG]     Based on ImageMagick option -wavelet-denoise.
                      ARG additionally takes arguments:
                        p       percent               Default: 10

Image comparision mask options: (Intended for artefact removal)
 --compose [=ARG]     Composes min and max of source images with MODE.
                      Compare ImageMagick option -compose. 
                      For 'min' and 'max' compare option --evaluate.
                      ARG additionally takes arguments:
                        (word)   MODE                Default: overlay
                        swap     Compose max,min instead of min,max
                                 Makes a difference for some, but not
                                 all compose MODEs.
                      MODE can be one of '$(basename $Magicklist) -list compose'
                      Some MODEs of interest:
                        bumpmap colorburn difference linearburn 
                        linearlight modulate multiply overlay pegtoplight
 --enfuse [=ARG]      Image comparision with a basic enfuse result.
 --evaluate [=ARG]    Evaluates all source images with mode MODE.
                      Compare ImageMagick option -evaluate-sequence.
                      ARG additionally takes arguments:
                        (word)   MODE                Default: max
                      MODE can be one of '$(basename $Magicklist) -list evaluate'
                      Most of interest:
                        max      Brightest pixels in sequence. 
                        mean     Average pixel values in sequence. 
                        median   Middle pixel values in sequence. 
                        min      Darkest pixels in sequence.
 --halo [=ARG]        Remove light halo of white background (overexposure).
                      ARG additionally takes arguments:
                        p        percent             Default: 25
                        r        radius              Default: 2
                        s        sigma               Default: 5
                      Greater percent removes more light.
                      sigma is a -blur sigma for a soft cut.
                      radius is a kernel radius.
                      Needs high 'weight' values even greater than 100.
                      Well to combine with --darkness.
                      Alternative option: --fakehdr
 --image [=ARG]       Loads an image and generates masks based on 
                      similarity with source images.
                      ARG additionally takes arguments:
                        (word)   An image file name
                           
Colorspace channel mask options: (Intended for artefact removal)
(All are variations of --channel, most of interest is --saturation)
 --channel            Use a colorspace channel as mask.
                      ARG additionally takes arguments:
                        (word)   Colorspace           Default: HSL
                        (word)   Color channel        Default: 1
                      Colorspace can be one of '$(basename $Magicklist) -list colorspace'
                      The color channel is a number from 0..31.
 --chroma             Chroma channel from HCL colorspace.
 --darkness           Negated lightness channel from HSL colorspace.
                      (Similar to --evaluate=min)
 --lightness          Lightness channel from HSL colorspace.
                      (Similar to --evaluate=max)
 --saturation         Saturation channel from HSB colorspace.

Mask generation and fusion adjustments:
 --background BG      Specify a background to paint on. Default: mean
                      BG can be an image name or one of:
                        saturation enfuse min max mean median
                        $Magicklist -list color
                        $Magicklist -list evaluate
                        $Magicklist -list compose
                      Well to combine with --soft. Possible use with threshold.
 --close [=ARG]       Closes gaps between nearby contrast lines to mark the 
                      area in between as strong contrast, too. Default: 2x2
                      First value is a kernel radius, second a kernel iteration.
                      Can reduce artefacts in partial transparent objects.
                      Helps e.g. to strengthen thin shiny objects like hairs.
                      For big values rather use c2x8 or c4x4 instead of c16,
                      the result will be similar but faster.
 --maskblur [=SIGMA]  Contrast enhancement. Applied to contrast masks only.
                      SIGMA is a blur sigma value. Default SIGMA: 1
 --cutblur [=SIGMA]   Blur cut masks in final montage. Default SIGMA: 2
 --denoise [=%]       Experimental option to remove noise in low contrast areas.
                      The percent value is a threshold. Rather use --soft.
 --fakehdr [=%]       Balances over- and underexposed areas. Default %: 50
                      Remaining artefacts at borders of overexposured areas
                      might be fixed with --saturation. Alternative: --halo
 --finalblur [=w%,sigma]  Blur low contrast areas with a contrast strenght 
                      up to w%. Default w% depends on first specified mask, 
                      default sigma is 1.
 --grayscale=MODE     Grayscale converting method before mask generation.
                      Compare ImageMagick option -grayscale. Default: RMS
                      MODE is one of: (number or name)
                0 none             No grayscale conversion. Barely tested.
                1 Rec601Luma       0.298839R' + 0.586811G' + 0.114350B'
                2 Rec601Luminance  0.298839R  + 0.586811G  + 0.114350B
                3 Rec709Luma       0.212656R' + 0.715158G' + 0.072186B'
                4 Rec709Luminance  0.212656R  + 0.715158G  + 0.072186B
                5 Brightness       max(R', G', B')
                6 Lightness        (min(R', G', B') + max(R', G', B')) / 2.0
                7 Average          (R' + G' + B') / 3.0
                8 MS               (R'^2 + G'^2 + B'^2) / 3.0
                9 RMS              sqrt( (R'^2 + G'^2 + B'^2) / 3.0 )
 --less [=%]          Strenghtens less contrasted objects in front of strong
                      contrasted background. 
                      Well to combine with --close and / or --cutblur.
                      ARG is a percent value as a minimum intermediate contrast
                      difference. Default value depends on first mask method.
                      (If also using color channel or image comparision masks,
                      rather use 'less' as a mask argument than globally.)
 --soft [=%]          Enable soft fuse mode. Takes a percent argument.
                      Best method to reduce noise in low contrast areas.
                      High % is very soft. Strenght of value depends on mask.
                      A semitransparent result is composed over the background.
                      Default background is 'enfuse'. Others are worth a test.
                           
Basics:                   
Fusing a focus stack aims to generate an overall sharp image of several single
captures that only show partial sharp areas.
Sharp areas show more contrast and detail than blurry unsharp areas.

So one important part is to find areas with a lot of contrast and detail.
This is done with the contrast mask options. From each source image the area
with more contrast than all other source images will be part of the result.

Artefacts / stack failures:
The attempt to get the strongest contrast areas out of the source images
has some weaknesses and can lead to artefacts.

 - Low contrast noise artefacts:
  All contrast mask methods give unsatisfying results in areas that have low 
  contrast on all source images of the stack.
  Possibilities:
   - Option --soft gives a quite satisfying result for low contrast noise areas.
     Example: '--diffstat --soft' or '--diffstat=soft'
   - Another possibility to soften the noise is option --finalblur.
     Example: '--diffstat --finalblur=w15,s2'
   - Combining the contrast mask with a color saturation mask.
     Example: '--diffstat --saturation=w15'
     (Weight argument 'w15' causes the saturation mask to take effect only 
     in low contrast areas (<=15%) of the '--diffstat' mask.)
  
 - Objects in foreground with background artefacts:
  Sometimes objects in background result in a stronger contrast mask than
  objects in foreground. The foreground object will be incomplete.
  This can be fixed with option '--less' and '--close'.
  
Examples:
Have a folder 'stackshot' containing all stack source images.
Go to the folder above 'stackshot'.
  Run imfuse with:
    imfuse -V --cache --diffstat stackshot/*
  You might be unsatisfied with low contrast areas. Try:
    imfuse -V --cache --diffstat --saturation=w25      stackshot/*
    imfuse -V --cache --diffstat --soft                stackshot/*
  You might have incomplete foreground objects. Try:
    imfuse -V --cache --diffstat --soft --less --close stackshot/*
"
}

### Messages

error() {
  [ -z "$Error" ] && echo "imfuse ERROR: $*
" >&2
  Error=1
  #exit 1
}
note() {
  [ -z "$Error" ] && echo "imfuse note: $*
" >&2
  return 0
}
verbose() {
  [ "$Verbose" = "yes" ] && echo "imfuse: $*" >&2
  return 0
}
showimage() {
  [ "$Showimageprocessing" = "yes" ] && geeqie -t -r File:"${1:-}"
  #[ "$Showimageprocessing" = "yes" ] && display -remote "${1:-}" &
  return 0
}

### Misc

calc() {
  awk "BEGIN {print $* }"
}
comma2whitespace() {
  #sed "s/,/ /g" <<< "${1:-}"
  echo "${1//,/ /}"
}
digitonly() {
  #sed "s/[^0-9.]//g" <<< "${1:-}"
  echo "${1//[^0-9.]/}"
}
digitrm() {
  #sed "s/[0-9.]//g" <<< "${1:-}"
  echo "${1//[0-9.]/}"
}
freememory() {
  local Freemem Line Zram
  Freemem="$(LC_ALL=C free | grep "Mem:" | awk '{print $7}')"
  while read Line; do
    Zram="$(awk '{print ($3 - $4)}' <<< "$Line")"
    Zram="$((Zram/1000))"
    Freemem="$((Freemem + Zram))"
  done < <(/sbin/swapon --bytes | grep zram)
  Freemem="$((Freemem*100/80))"
  echo $Freemem
}
lowercase() {
    # Usage: lowercase "string"
    printf '%s\n' "${1,,}"
}
md5cut() {
  # print last 6 digits
  md5sum <<< "${1:-}" | cut -c27-32
}
percentrm() {
  # remove % from string
  #sed s/%//g <<< "${1:-}"
  echo "${1//%/}"
}
printnum(){
  # print number $1 with leading zeroes.
  # $1 number
  # $2 digits. Default: 3
  printf %0${2:-3}d "${1:-0}"
}
unspecialstring() {
  # Replace all characters except those described in "a-zA-Z0-9_" with a '-'. 
  # Replace newlines, too.
  # Remove leading and trailing '-'
  # Avoid double '--'
  # Return empty string if only special chars are given.
  printf %s "${1:-}" | LC_ALL=C tr -cs "a-zA-Z0-9._" "-" | sed -e 's/^-// ; s/-$//'
}

### Files

checkmagicklist() {
  $Magicklist -list "${1:-}" | cut -d' ' -f1 | grep -q -x -i "${2:-XXX}"
}
maskexist() {
  local Basename Masklist
  Basename="${1:-$Argbasename}"
  Masklist="$(masklist "$Basename")"
  Masknumber="$(grep -c . <<< "$Masklist")"
  [ "$Masknumber" = "$Imagenumber" ] && return 0 || return 1
}
masklist() {
  local Basename List
  Basename="${1:-$Argbasename}"
  ls $Cachedir/$Basename.* 2>/dev/null
  #List="$(find $Cachedir -regextype sed -regex "$Cachedir/${Basename}.[0-9]\{$Imagenumberlength\}.tif")"
  #echo "$List" >&2
  #echo "$List"
  #find $Cachedir -regextype sed -regex "$Cachedir/${Basename}.[0-9]\{$Imagenumberlength\}.tif"
}

### image processing helpers

denoisecode() {
  echo "
    -write mpr:denoisemask
    -delete 0
  mpr:denoisemask
    -threshold ${1:-10}%
    -negate
    -transparent white
    -write mpr:cutmask
    -delete 0
  mpr:denoisemask
    -wavelet-denoise 50%
  mpr:cutmask
    -alpha off -compose CopyOpacity -composite
    -write mpr:blurlowcontrast
    -delete 0
  mpr:denoisemask
  mpr:blurlowcontrast
    -compose over -composite
"
}
evaluate() {
  local Sourceimagelist Resultimage Mode
  local Startzeit Dauer Restzeit
  local Split
  
  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  Sourceimagelist=""
  while [ $# -gt 0 ]; do
    Sourceimagelist="$Sourceimagelist
${1:-}"
    shift
  done
  Sourceimagelist="$(grep . <<< "$Sourceimagelist")"
  
  Split="$((Imagelistmemsize/Freemem +1))"
  
  Startzeit="$(date +%s)"
  case $Split in
    1)
      $Magickbin $Sourceimagelist -evaluate-sequence $Mode $Tifstore $Resultimage || error "Error in evaluate(): $Mode"
    ;;
    *)
      case $Mode in
        min|max|mean)
          evaluate_stepwise "$Mode" "$Resultimage" $Sourceimagelist
        ;;
        *)
          evaluate_split "$Mode" "$Resultimage" $Sourceimagelist
        ;;
      esac
    ;;
  esac
  Dauer="$(( $(date +%s)-Startzeit))"
  verbose "evaluate() $Mode duration: $(date -u -d @$Dauer +"%T")"
}
evaluate_split() {
  # -evaluate-sequence for images exceeding RAM
  # If needed, splits source images in smaller parts and puts them together after evaluating them
  # Slow, but reliable.
  # Needs global $Freemem

  local Sourceimagelist Resultimage Mode
  local Image Split Splitpercent Showsplit Part Partimage Partimagelist=
  local Startzeit Dauer Restzeit Count
  
  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  Sourceimagelist=""
  while [ $# -gt 0 ]; do
    Sourceimagelist="$Sourceimagelist
${1:-}"
    shift
  done
  Sourceimagelist="$(grep . <<< "$Sourceimagelist")"
  
  Split="$((Imagelistmemsize/Freemem +1))"

  note "Generating $Mode image $(basename "$Resultimage") in $Split parts."
  case $Split in
    1) 
      Startzeit="$(date +%s)"
      $Magickbin $Sourceimagelist -evaluate-sequence $Mode $Tifstore $Resultimage || error "Error in evaluate_split / $Mode"
      Dauer="$(( $(date +%s)-Startzeit))"
      verbose "Duration: $(date -u -d @$Dauer +"%T")"
    ;;
    *)
      Startzeit="$(date +%s)"
      Splitpercent="$((100/Split))"
      Showsplit="$(printnum $(( (Split+1)/2 )) 3)"
      Count="0"
      for Sourceimage in $Sourceimagelist; do
        [ "$Error" ] && break
        Count="$((Count+1))"
        verbose "Splitting image $Count / $Imagenumber into $Split pieces due to low memory: $(basename $Sourceimage)"
        $Magickbin $Sourceimage -crop 100%x${Splitpercent}% $Tifstore $Cachedir/split%03d.$(basename $Sourceimage).tif || error "Error in evaluate_split / crop"
        showimage $Cachedir/split${Showsplit}.$(basename $Sourceimage).tif
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
      done
      Startzeit="$(date +%s)"
      for Part in $(seq 0 $((Split-1))) ; do
        [ "$Error" ] && break
        verbose "Evaluating part $((Part+1)) / $Split"
        Partimage=$Cachedir/$Mode.part$Part.tif
        $Magickbin $Cachedir/split$(printnum $Part 3).*.tif -evaluate-sequence $Mode $Tifstore $Partimage || error "Error in evaluate_split / evaluating parts"
        Partimagelist="$Partimagelist $Partimage"
        showimage $Partimage
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Split-Part+1) / (Part+1) ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
      done
      [ "$Error" ] && return 1
      $Magickbin $Partimagelist -append $Tifstore $Resultimage  || error "Error in evaluate_split / appending parts"
    ;;
  esac
  showimage $Resultimage
  return "${Error:-0}"
}
evaluate_stepwise() {
  # same as evaluate-sequence max or min,
  # but loads images one by one into ram instead of altogether.
  # $1 mode. Supported: max min 
  # $2 result image
  # $@ source images
  
  local Mode Composemode Resultimage Sourceimagelist Command Line Firstimage Count
  local Startzeit Dauer

  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  Firstimage="${1:-}" ; shift
  Sourceimagelist=""
  while [ $# -gt 0 ]; do
    Sourceimagelist="$Sourceimagelist
${1:-}"
    shift
  done
  Sourceimagelist="$(grep . <<< "$Sourceimagelist")"
  
  case $Mode in
    max) Composemode="Lighten" ;;
    min) Composemode="Darken" ;;
    mean) ;;
    *) 
      error "evaluate_stepwise(): Unsupported mode: $Mode"
      return 1
    ;;
  esac
  
  case $Mode in
    min|max)
      Command="$Magickbin
  $Firstimage"
      while read Line; do
        Command="$Command
  $Line
    -compose $Composemode -composite"
      done <<< "$Sourceimagelist"
      Command="$Command 
  $Resultimage"
    ;;
    mean)
      Command="$Magickbin
  $Firstimage"
      Count=1
      while read Line; do
        Count="$((Count+1))"
        Command="$Command
  $Line
    -compose blend
    -set option:compose:args $(calc 100/$Count)
    -composite"
      done <<< "$Sourceimagelist"
      Command="$Command
  $Resultimage"
    ;;
  esac

  Startzeit="$(date +%s)"
  verbose "evaluate_stepwise(): $Mode $Resultimage"
  $Command || {
    error "Error in evaluate_stepwise():
$Command"
  return 1
  }
  Dauer="$(( $(date +%s)-Startzeit))"
  verbose "Duration: $(date -u -d @$Dauer +"%T")"
}
exiftransfer() {
  # Transfer exif data from image $1 to image $2
  # Does not transfer image size information.
  # Sets orientation tag to horizontal / no rotation.
  # Several warnings are supressed.
  local Sourceimage Destinationimage Exifargs
  
  Sourceimage="${1:-}"
  Destinationimage="${2:-}"
  Exifargs="$(exiftool -a -u -g1 -args "$Sourceimage")"
  Exifargs="$(LC_ALL=C grep -v -E -- \
    '-ExifTool|-System:|-File:|ImageWidth|ImageHeight|ImageSize|Compression|Orientation|Resolution' <<< "$Exifargs" \
    | sed "s/'/'\"'\"'/g ; s/=/='/ ; s/\$/'/" )"
  eval exiftool -ignoreMinorErrors -overwrite_original_in_place $Exifargs -Orientation=Horizontal "$Destinationimage" 2>&1 | grep -v -E 'Warning|files updated'
}
fakehdr() {
  # simulate a HDR image with multiple exposures combined to one image with balanced light.
  # To achieve this some brightened and darkened images are generated with IM and combined with enfuse.

  #local $Batchlocal
  #local $Imagelocal
  local Darkfactor Brightfactor Darkpercent Brightpercent
  local Error=
  local Method Percent
  local Imagecount Imagebasename Convertline Output Basename
  
  #parse_batchoptions "$@" || return 1
  #setup_imagelist         || return 1
  
  Percent="${1:-50}" && shift
  Percent="${Percent%"%"}"
  Method="${Method:-level}"
  #Method=gamma
  Basename="fakehdr${Percent}.$Method.$Sourcemd5"
  maskexist "$Basename" && {
    verbose "Skipping fakehdr, already exists: $Basename"
    return 0
  }
  
  Darkpercent="$(awk   "BEGIN {print  100-$Percent}")"
  Brightpercent="$(awk "BEGIN {print  100+$Percent}")"
  Darkfactor="$(awk    "BEGIN {print (100-$Percent)/100}")"
  Brightfactor="$(awk  "BEGIN {print (100+$Percent)/100}")"
  #Brightfactor="$(awk  "BEGIN {print  1/$Darkfactor}")"

  Imagecount=0
  for Sourceimage in $Sourceimagelist; do
    Imagecount=$((Imagecount+1))
    Number="$(printnum $Imagecount $Imagenumberlength)"
    Imagebasename="$(basename $Sourceimage)"
    Convertline="$Magickbin $Sourceimage -write mpr:image +delete"  
    #Convertline="$Convertline     ( mpr:image                                           -write $Cachedir/$Imagebasename.exp.source.tif )" 
    case $Method in
      brightness)    
        Convertline="$Convertline ( mpr:image -brightness-contrast  ${Percent}%  -write $Cachedir/$Imagebasename.exp.bright.tif  )" 
        Convertline="$Convertline ( mpr:image -brightness-contrast -${Percent}%  -write $Cachedir/$Imagebasename.exp.dark.tif   )" 
      ;;
      modulate)    
        Convertline="$Convertline ( mpr:image -modulate ${Brightpercent}%               -write $Cachedir/$Imagebasename.exp.bright.tif  )" 
        Convertline="$Convertline ( mpr:image -modulate ${Darkpercent}%                 -write $Cachedir/$Imagebasename.exp.dark.tif   )" 
      ;;
      multiply)    
        Convertline="$Convertline ( mpr:image -evaluate multiply ${Brightfactor}        -write $Cachedir/$Imagebasename.exp.bright.tif  )" 
        Convertline="$Convertline ( mpr:image -evaluate multiply ${Darkfactor}          -write $Cachedir/$Imagebasename.exp.dark.tif   )" 
      ;;
      levelgamma)    
        Convertline="$Convertline ( mpr:image -level 0%x${Darkpercent}%,${Brightfactor} -write $Cachedir/$Imagebasename.exp.bright.tif  )" 
        Convertline="$Convertline ( mpr:image +level 0%x${Darkpercent}%,${Brightfactor} -write $Cachedir/$Imagebasename.exp.dark.tif   )" 
      ;;
      level)    
        Convertline="$Convertline ( mpr:image -level 0%x${Darkpercent}%                 -write $Cachedir/$Imagebasename.exp.bright.tif  )" 
        Convertline="$Convertline ( mpr:image +level 0%x${Darkpercent}%                 -write $Cachedir/$Imagebasename.exp.dark.tif   )" 
      ;;
      gamma)
        Convertline="$Convertline ( mpr:image -gamma ${Brightfactor}                    -write $Cachedir/$Imagebasename.exp.bright.tif  )" 
        Convertline="$Convertline ( mpr:image -gamma ${Darkfactor}                      -write $Cachedir/$Imagebasename.exp.dark.tif   )" 
      ;;
    esac
    Convertline="$Convertline xc:white null:"
    echo $Convertline
    multicore "$Convertline" || Error=1
    multicore_wait || Error=1
    [ "$Error" ] && break
    Output="$Cachedir/$Basename.$Number.$Imagebasename"
    multicore "enfuse $Sourceimage $(find $Cachedir/${Imagebasename}.exp* | tr "\n" " ") -o $Output --saturation-weight=0 --gray-projector=average && \
               exiftool -overwrite_original -tagsfromfile $Sourceimage -Orientation= -all:all $Output" "$Output" || Error=1
    [ "$Error" ] && break
    showpercent $Imagecount $Imagenumber
  done
  multicore_wait || return 1
  return ${Error:-0}
}
flatten() {
  local Resultimage Image Command
  
  Resultimage="${1:-}"
  shift
  
  Command="$Magickbin
  $Resultimage
    -alpha set"
    
  for Image in "$@"; do
    Command="$Command
  $Image
    -compose Over -composite"
  done
  
  Command="$Command
    $Tifstorealpha
  $Resultimage"
    
  $Command
}
generate_composite() {
  local Mode Imagename
  
  # --evaluate
  for Mode in $Evaluate_needlist; do
    [ "$Error" ] && break
    Imagename="$Cachedir/evaluate.$Mode.$Sourcemd5.tif"
    [ -e "$Imagename" ] || evaluate $Mode $Imagename $Sourceimagelist
  done
  # --compose
  for Mode in $Compose_needlist; do
    [ "$Error" ] && break
    Imagename="$Cachedir/compose.$Mode.$Sourcemd5.tif"
    [ -e "$Imagename" ] || {
      note "--compose=$Mode: Generating compose image $Imagename"
      $Magickbin $Cachedir/evaluate.min.$Sourcemd5.tif $Cachedir/evaluate.max.$Sourcemd5.tif           -compose $Mode -composite $Imagename || error "Error compositing $Mode: $Image"
      showimage "$Imagename"
    }
    Imagename="$Cachedir/compose.$Mode.swap.$Sourcemd5.tif"
    [ -e "$Imagename" ] || {
      note "--compose=$Mode,swap: Generating compose image $Imagename"
      $Magickbin $Cachedir/evaluate.min.$Sourcemd5.tif $Cachedir/evaluate.max.$Sourcemd5.tif -swap 0,1 -compose $Mode -composite $Imagename || error "Error compositing $Mode -swap: $Image"
      showimage "$Imagename"
    }
  done
}
layered_sharpness() {
  # --layers: Layered TIF with sharpness layers
  local Graylevel Graylevel1 Graylevel2 Pixelnumber Pixelcount Image Layerimage Layerimagelist Layerminpixel Graylevels Histogramm
  local Layercount Count
  local Startzeit Dauer Restzeit
  local Maskmax
  
  Maskmax="$Cachedir/mask.max.tif"
  evaluate max $Maskmax $Cachedir/sourcemask*
  Histogramm="$($Magickbin $Maskmax -depth 16 -define histogram:unique-colors=true -format %c histogram:info:-)"
  Graylevels="$(awk '{print $3}' <<< "$Histogramm" | wc -l)"
  Layerminpixel="$(( Imagewidth*Imageheight/(Layers-1) ))"
  
  verbose "Creating $Layers layers of sharpness areas"
  
  Count=0
  Layercount=0
  Startzeit="$(date +%s)"
  Pixelcount=0
  Pixelnumber=0
  while read Line; do
    [ "$Error" ] && break
    Count=$((Count+1))
    
    Graylevel="$(awk '{print $3}' <<< "$Line")"
    Pixelnumber="$(awk '{print $1}' <<< "$Line")"
    Pixelnumber="${Pixelnumber%:}"
    Pixelcount="$((Pixelcount+Pixelnumber))"
    
    [ "$Pixelcount" -lt "$Layerminpixel" ] && {
      Graylevel1="${Graylevel1:-$Graylevel}"
    }
    
    { [ "$Pixelcount" -gt "$Layerminpixel" ] || [ "$Count" = "$Graylevels" ] ; } && {
      Layercount="$((Layercount+1))"
      Layerimage="$Cachedir/layer_sharpness.$(printnum $Layercount).tif"
      Graylevel2="${Graylevel2:-$Graylevel}"
      Command="
$Magickbin
  $Maskmax
    -depth 16
    -color-threshold ${Graylevel1:-$Graylevel2}-$Graylevel
    -write mpr:layermask
    -delete 0
  $Resultimage
  mpr:layermask
    -colorspace sRGB
    -alpha Off -compose CopyOpacity -composite
    -background blue -alpha background
    $Tifstore
  $Layerimage"
  
      $Command || {
        note "Error in generating sharpness layers"
        break
      }
      
      Layerimagelist="$Layerimagelist $Layerimage"
      
      [ "$Graylevel2" = "$Graylevel" ] && {
        Graylevel1=""
        Pixelcount="0"
      } || {
        Graylevel1="$Graylevel"
        Pixelcount="$Pixelnumber"
      }
      
      showimage $Layerimage
      Dauer="$(( $(date +%s)-Startzeit))"
      Restzeit="$(( Dauer*(Graylevels-Count) / Count ))"
      verbose "Layer $Layercount/$Layers. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
    }
    Graylevel2="$Graylevel"
  done <<< "$Histogramm"
    
  [ "$Error" ] && return $Error
  
  verbose "Creating layered result of sharpness areas"
  Image="$(rev <<< "$Outputimage" | cut -d. -f2- | rev).layered_sharpness.tif"
  #$Magickbin -type TrueColorAlpha $Maskmax $Layerimagelist $Tifstore "$Image" || note "Failed to create layered sharpness result image."
  $Magickbin $Maskmax $Layerimagelist $Tifstorealpha "$Image" || note "Failed to create layered sharpness result image."
  
  return "${Error:-0}"
}
level_check() {
  local Maskmax Maskmin Level
  local Histogramm Threshold Threshold_pixel Pixelnumber Pixelcount
  local Maxpossible Minpossible

  Level="$(maskarg_defaultvalue $Argmethod level)"
  [ "$Level" ] && {
    #Arglevelmin="$(cut -d, -f1 <<< "$Level" | tr -d '%')"
    #Arglevelmax="$(cut -d, -f2 <<< "$Level" | tr -d '%')"
    note "level_check(): default: $Level for $Argbasename"
    #return 0
  }
  
  Maskmax=$Cachedir/$Argbasename-max.tif
  Maskmin=$Cachedir/$Argbasename-min.tif

  evaluate max $Maskmax $(masklist "$Argbasename") || return 1
  Arglevelmax="$($Magickbin "$Maskmax" -format '%[fx:maxima*100]' info:)"
  
  #Arglevelmin="$(maskarg_defaultvalue $Argmethod levelmin)"
  [ -z "$Arglevelmin" ] && {
    evaluate min $Maskmin $(masklist "$Argbasename") || return 1
    Arglevelmin="$($Magickbin "$Maskmin" -format '%[fx:minima*100]' info:)"
 }
    
  note "level_check(): ${Arglevelmin}%,${Arglevelmax}% for $Argbasename"
  echo "level_check(): ${Arglevelmin}%,${Arglevelmax}% for $Argbasename" >> ~/.config/stackshots/level.results
  
  # eperimental
  [ -z "$Argmaskstrength" ] && {   ### FIXME vulnerable check that masks has been leveled already
    Maxpossible="$(maskarg_defaultvalue $Argmethod levelmax)"
    Minpossible="$(maskarg_defaultvalue $Argmethod levelmin)"
    [ "$Maxpossible" ] && [ "$Minpossible" ] && {
      Argmaskstrength="$(calc "($Arglevelmax - $Arglevelmin) / ($Maxpossible - $Minpossible)")"
    }
  }
  Argmaskstrength=1
  
  return ${Error:-0}
}
level_masks() {
  local Maskmax Maskmin Maskmd5
  local Startzeit Dauer Restzeit
  local Count Mask Masklist Levelmin Levelmax
  
  case $# in
    0)
      Masklist="$(masklist "$Argbasename")"
      Levelmin="$Arglevelmin"
      Levelmax="$Arglevelmax"
    ;;
    *)
      Masklist="$@"
      Maskmd5="$(md5cut "$(ls --full-time $Masklist)" )"
      Maskmax=$Cachedir/level-max.$Maskmd5.tif
      Maskmin=$Cachedir/level-min.$Maskmd5.tif
      #[ -e "$Maskmax" ] || {
        evaluate max $Maskmax $Masklist || return 1
      #}
      #[ -e "$Maskmin" ] || {
        evaluate min $Maskmin $Masklist || return 1
      #}
      Levelmax="$($Magickbin "$Maskmax" -format '%[fx:maxima*100]' info:)"
      Levelmin="$($Magickbin "$Maskmin" -format '%[fx:minima*100]' info:)"
    ;;
  esac
  
  [ "${Levelmin}%,${Levelmax}%" = "0%,100%" ] && {
    verbose "Skipping level_masks(), already 0%,100%"
    return 0
  }
  
  Startzeit="$(date +%s)"
  Count=0
  for Mask in $Masklist ; do
    [ "$Error" ] && break
    Count="$((Count+1))"
            
    Command="
$Magickbin
  $Mask
    -level ${Levelmin}%,${Levelmax}%
  $Mask"
  
  [ "$Count" = "1" ] && verbose "Leveling masks with:
$(grep "\S" <<< "$Command")"
  
    #$Command || error "Failure in leveling $Argmethod masks"
    multicore "$Command" || error "Failure in leveling masks"
  
    showimage "$Mask"
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Leveling $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done
  multicore_wait || error "Failure in leveling masks"
  [ "$Testsetup" ] && redist
  return "${Error:-0}"
}
maskfromimage() {
  # Generate masks based on comparision with a single image
  local Imagename Maskbasename
  local Startzeit Dauer Restzeit
  local Count Number Error=
  
  Imagename="${1:-}"
  Maskbasename="${2:-}"
  
  Startzeit="$(date +%s)"
  Count=0
  for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    Maskname="$Maskbasename.${Number}.tif"
    
  #( $Sourceimage $Grayscaleconverter -alpha off )
  #( $Imagename   $Grayscaleconverter -alpha off )
    Command="$Magickbin
  $Imagename 
    -write mpr:image
    -delete 0
  mpr:image
    -channel alpha
    -separate
    -write mpr:alpha
    -delete 0
  mpr:image
    $Grayscaleconverter
  ( $Sourceimage $Grayscaleconverter )
    -compose Difference -composite
    -alpha off 
    -negate
    -write mpr:diffmask
    -delete 0
  mpr:diffmask
  mpr:alpha
    -compose multiply -composite
    -write $Maskname
  -delete 0
    xc:white null:"
         
    #$Command || error "Failure in mask generation of comparision with $Imagename"
    multicore "$Command" "$Maskname" || error "Failure in mask generation of comparision with $Imagename"
  
    [ "$Count" = "1" ] && verbose "Generating masks with:
$(grep "\S" <<< "$Command")"

    #showimage $Maskname
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Image comparision mask $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done
  multicore_wait || error "Failure in mask generation of comparision with $Imagename"
  return ${Error:-0}
}
mkimg_black() {
  local Size
  Size="${2:-}"
  [ -z "$Size" ] && Size="${Imagewidth:-100}x${Imageheight:-100}"
  $Magickbin -size "$Size" xc:black                  -type Grayscale      $Tifstore "${1:-black.tif}"       || error "Failed to create black image."
}
mkimg_color() {
  local Size
  Size="${2:-}"
  [ -z "$Size" ] && Size="${Imagewidth:-100}x${Imageheight:-100}"
  $Magickbin -size "$Size" xc:${3:-black}            -type TrueColor      $Tifstore "${1:-color.tif}"       || error "Failed to create colored image."
}
mkimg_transparent() {
  # Generate transparent image $1 with size $2
  local Size
  Size="${2:-}"
  [ -z "$Size" ] && Size="${Imagewidth:-100}x${Imageheight:-100}"
  verbose "Generating transparent image:
  $Magickbin -size $Size canvas:transparent -type TrueColorAlpha ${1:-transparent.tif}"
  $Magickbin -size "$Size" canvas:transparent -type TrueColorAlpha "${1:-transparent.tif}"
}

redist() {
  local Masklist Maskmd5 Maskmax Clutimage
  local histArr ccountArr totpix maxval fact lutlist
  case $# in
    0) Masklist="$(masklist "$Argbasename")" ;;
    *) Masklist="$@" ;;
  esac
  
  Maskmd5="$(md5cut "$(ls --full-time $Masklist)" )"
  Maskmax=$Cachedir/redist-max.$Maskmd5.tif
  evaluate max $Maskmax $Masklist || return 1
      
  maxval=65535

  Clutimage="$Cachedir/clut.$Maskmd5.miff"

  #cumHistogram 
  histArr=(`convert $Maskmax -colorspace gray -depth 8 -format "%c" histogram:info:- \
  | sed -n 's/[ ]*\([0-9]*\).*gray[(]\([0-9]*\).*$/\1 \2/p' |\
  awk '
  # AWK to generate a zero filled histogram
  { bin[int($2)] += $1; } 
  END { for (i=0;i<256;i++) {hist = bin[i]+0; print hist; }
  } '`)

  ccountArr=(`echo ${histArr[*]} |\
  awk '# AWK to generate a cumulative histogram
  { split($0,count," ") }
  END { for (i=0;i<256;i++) { cum += count[i]; print cum } } '`)
  totpix=${ccountArr[255]}
  
  
  # genUniformLutArr
  # special function to generate lut for Uniform Distribution which is just the cumulative histogram normalized to max value 
  # the uniform distribution has an integral which is f(x)=x
  # this means that the cumulative distribution of the image is its own lut and only needs to be scaled
  # get raw cumulative histogram
  fact=`convert xc: -format "%[fx:$maxval/$totpix]" info:`
  lutlist=$(for ((i=0; i<256; i++)); do
    echo "${ccountArr[$i]}"
  done |\
  awk -v fact="$fact" '{ print int(fact*$1); }')
  
  # now convert lutArr into lut image
  # Use NetPBM (PGM format implied intermediate image)
  # note, (somewhere in IM between 6.7.5.5 and 6.7.8.2) PGM is linear

  echo "P2 256 1 $maxval $lutlist" | convert - -scale 256x1\! $Clutimage

  for Image in $Masklist; do
    $Magickbin $Image $Clutimage -clut $Image
    showimage $Image
  done
}

# core focus stack routines

focus_generate_masks() {
  local Maskgenerator Maskgenerator_all= Basenamelist= Maskready= Maskmax Showimage= Mode Line Imagename Command= Maskmd5=
  local Startzeit Dauer Restzeit Count
    
  Maskmethodlist="$(grep "\S" <<< "$Maskmethodlist")"
  [ -n "$Maskmethodlist" ] && while read Line; do
    [ "$Error" ] && break
    
    maskarg_parse "$Line"    
    Maskgenerator="$(focus_maskmethod "$Argmethod")"
        
    [ "$Argdiff" ] && Maskgenerator="$Maskgenerator
  mpr:sourcegray
    -compose Difference -composite"
    
    [ "$Argnegate" ] && Maskgenerator="$Maskgenerator
    -negate"
    
    [ "${Argclose1}" ] && Maskgenerator="$Maskgenerator
    -morphology Close:${Argclose2:-1} Octagon:${Argclose1:-3}"

    [ "$Argmethod" = "enfuse" ] && Enfuse_needlist="$Enfuse_needlist enfuse"
    [ "$Argsoft" ]              && Enfuse_needlist="$Enfuse_needlist enfuse"
      
    Maskmd5="$(md5cut "$Sourcemd5 $Maskgenerator")"
    Argbasename="$Argmethod.$Maskmd5"
    maskarg_store
      
    ## avoid [double] creating of existing masks
    Maskready=""
    grep -q -x "$Argbasename" <<< "$Basenamelist" && Maskready="yes"
    Basenamelist="$Basenamelist
$Argbasename"
    maskexist "$Argbasename" && Maskready="yes" || rm -f $(masklist "$Argbasename")
    
    [ -z "$Maskready" ] && {
      Maskgenerator_all="$Maskgenerator_all
$Maskgenerator
    -write $Cachedir/$Argbasename.NUMBER.tif"
      [ -z "$Showimage" ] && {
        Showimage="$Cachedir/$Argbasename.NUMBER.tif"
#        [ "$Showimageprocessing" ] && Maskgenerator_all="$Maskgenerator_all
#    -auto-level -write $Showimage"
      }
      Maskgenerator_all="$Maskgenerator_all
    -delete 0"
    }
  done <<< "$Maskmethodlist"
  #done < <(tac <<< "$Maskmethodlist")
  
  #Maskgenerator_all="$(sed "1,/SHOWIMAGE/{s%SHOWIMAGE%$Showimage%}" <<< "$Maskgenerator_all")"
  #Maskgenerator_all="$(sed "/SHOWIMAGE/d" <<< "$Maskgenerator_all")"
  
  grep -v Close <<< "$Maskgenerator_all" | grep -q morphology && {
    verbose "Mask generator kernels:
$($Magickbin xc: -write mpr:sourceimage -define morphology:showkernel=1 $Maskgenerator_all xc:white null: 2>&1)
"
    rm $Cachedir/*NUMBER* 2>/dev/null
  }

  # --evaluate, --compose, M,m
  generate_composite
  
  # --enfuse, --bg=enfuse, soft
  [ "$Enfuse_needlist" ] && [ ! -e "$Enfusebaseimage" ] && {
    note "Generating enfuse base image"
    nice enfuse --contrast-weight=1 --saturation-weight=0 --exposure-weight=0 --hard-mask -o "$Enfusebaseimage" $Sourceimagelist 2>&1 | { grep -v -E 'loading next image|alpha channel|assuming all pixels' ; :; } || error "Failed to generate enfuse base image"
    showimage "$Enfusebaseimage"
  }
  
  [ -z "$Maskmethodlist" ] && return 0
  
  # Generate masks
  Startzeit="$(date +%s)"
  Count=0
  note "Generating masks"
  grep -q "NUMBER" <<< "$Maskgenerator_all" || note "Skipping mask generation"
  grep -q "NUMBER" <<< "$Maskgenerator_all" && for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    
    # Generate command to generate masks            
    Command="$Magickbin
  $Sourceimage
    -alpha off
    -depth 16
    -write mpr:sourceimage
    -delete 0
  mpr:sourceimage"
  
    # --grayscale
    [ "$Grayscaleconverter" ] && Command="$Command
    $Grayscaleconverter"
    Command="$Command
    -write mpr:sourcegray
    -delete 0"
    
    Command="$Command
${Maskgenerator_all//NUMBER/$Number}"
    
    Command="$Command
  xc:white null:"
          
    [ "$Count" = "1" ] && verbose "Generating masks with:
$(grep "\S" <<< "$Command")"

    multicore "$Command" "${Showimage//NUMBER/$Number}" || error "Failure in mask generation"
    
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Contrast mask $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done
  multicore_wait || error "Failure in mask generation"
  
  
  # less,soft
  while read Line; do
    [ "$Error" ] && break
    maskarg_parse "$Line"
    
    # get -level min/max values for contrast masks
    [ "$Arglevel" = "yes" ] && {
      level_check
      maskarg_store
      level_masks
      Arglevel=
      Arglevelmin=
      Arglevelmax=
      maskarg_store
    }
    
    [ "${Argless}" ] && [ "${Argsoft}" ] && {
      note "Generating soft&less image for mask $Argmethod"
      Imagename="$Cachedir/$Argbasename-prepare-less${Argless}-soft${Argsoft}-cb${Cutblur}.tif"
      level_masks
      focus_montage --soft "$Argsoft" --lessthanmax "$Argless" --maskstrength="${Argmaskstrength:-1}" --output "$Imagename" -- $(masklist "$Argbasename") || break
      #$Magickbin "$Enfusebaseimage" "$Imagename" -compose Over -composite "$Imagename" || error "Failed to compose soft result on enfuse background"
      Argbasename="$Argmethod-soft$Argsoft-less$Argless-cb$Cutblur.$(md5cut "$Argbasename $Argsoft $Argless $Cutblur" )"
      maskexist "$Argbasename" || {
        rm -f $(masklist "$Argbasename")
        note "Generating comparision masks from soft&less result of $Argmethod"
        maskfromimage $Imagename $Cachedir/$Argbasename || break  ### FIXME issue with --cache
      }
      Arglevel=""
      Argmaskstrength=""
      Argtype="image"
      maskarg_store      
    }
    
    [ "${Argless}" ] && [ -z "${Argsoft}" ] && {
      [ "$Arglevel" = "yes" ] && level_masks
      Arglevelmin=""
      Arglevelmax=""
      Arglevel=""
      maskarg_store
      Imagename="$Cachedir/$Argbasename-prepare-less$Argless-cb${Cutblur}.tif"
      Maskmax="$Cachedir/$Argbasename-less${Argless}-cb$Cutblur.mask.tif"
      [ -e "$Maskmax" ] || {
        note "Generating less mask for $Argmethod"
        focus_montage --lessthanmax "$Argless" --maskmax "$Maskmax" --maskstrength="${Argmaskstrength:-1}" --output "$Imagename" -- $(masklist "$Argbasename") || break   
      }
      Argdarkenmask="$Maskmax"
      maskarg_store
    }
  done <<< "$Maskmethodlist"

  return ${Error:-0}
}
focus_merge_masks() {
  # Merge different masks.
  
  local Mergemask
  local Count Number Weightmax
  local Command
  local Mergeneeded Methodmask Mergecode=
  local Startzeit Dauer Restzeit
  
  Mergeneeded="no"
  [ "$Maskmethodnumber" -gt "1" ] && Mergeneeded="yes"
  Mergeneeded=yes

  [ -z "$Maskmethodlist" ] && {
    note "Skipping mask merge, no mask options are specified."
    return 0
  }
  
  while read Line; do
    maskarg_parse "$Line"
    [ "${Argweight:-100}" -gt "${Weightmax:-0}" ] && Weightmax="${Argweight:-100}"
  done <<< "$Maskmethodlist"
      
  Mergemaskbasename="mergemask"
  
  # generate merge code
  Mergecode="
  -colorspace gray
  ( -size ${Imagewidth}x${Imageheight} xc:black )"
  while read Line; do
    maskarg_parse "$Line"
    Mergemaskbasename="$Mergemaskbasename-$Argmethod"
      
    Methodmask="$Cachedir/$Argbasename.NUMBER.tif"
      
    [ "$Arglevel" ]                                         && Mergeneeded="yes" 
    [ "$Argdenoise" ]                                       && Mergeneeded="yes" 
    [ "$Argdarkenmask" ]                                    && Mergeneeded="yes" 
    [ "$Argsoft" ]                                          && Mergeneeded="yes" 
    [ "$Argthreshold" ]                                     && Mergeneeded="yes" 
    [ "$Globalclose" ]                                      && Mergeneeded="yes"
    [ "$Globalsoft" ]                                       && Mergeneeded="yes"
    [ "$Globaldenoise" ]                                    && Mergeneeded="yes"
    [ "$Testsetup" ]                                        && Mergeneeded="yes"
    [ "$Mergeneeded" = "no" ] && break
      
    Mergecode="$Mergecode
  ( 
  $Methodmask
    -level ${Arglevelmin:-0}%,${Arglevelmax:-100}%"

    ### FIXME might affect level
    [ "$Argmaskblur" ] && {
      Mergecode="$Mergecode
    -blur 0x$Argmaskblur"
      Argmaskblur=""
      maskarg_store
    }
    
    
    # less
    [ "$Argdarkenmask" ] && Mergecode="$Mergecode
  $Argdarkenmask
    -compose Darken -composite"
    
    # denoise ###FIXME Maskstrength
    [ "$Argdenoise" ] && Mergecode="$Mergecode $(denoisecode "$Argdenoise")"
    
    # threshold ###FIXME Maskstrength
    [ "$Argthreshold" ] && Mergecode="$Mergecode
    -black-threshold $(calc "$Argthreshold /$Argmaskstrength")%"
    
    Mergecode="$Mergecode
    +level 0%,$(calc "(100 * ${Argweight:-100}) / (${Maskmethodnumber:-1} * $Weightmax)" )% 
  )
    -compose Screen -composite"
  done <<< "$Maskmethodlist"
  
  # denoise low contrast areas
  [ "$Globaldenoise" ] && { ###FIXME Maskstrength
    Mergecode="$Mergecode $(denoisecode "$Globaldenoise")"
    Mergemaskbasename="$Mergemaskbasename-denoise"
  }   
  
  # --close
  [ "${Globalclose}" ] && {
    Mergecode="$Mergecode
    -morphology Close:${Globalclose2:-1} Octagon:${Globalclose1:-4}"
    Mergemaskbasename="$Mergemaskbasename-close"
  }
  
  Mergecode="$Mergecode
    -write mpr:mergemask
    -delete 0"
    
  Mergemaskbasename="$Mergemaskbasename.$(md5cut "$Sourcemd5 $Mergecode" )"
  maskexist "$Mergemaskbasename" && {
    note "Skipping merge, masks already exist: $Mergemaskbasename"
    return 0
  }
    
  # merge images
  note "Merging masks"
  Startzeit="$(date +%s)"
  Count=0
  for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    Mergemask="$Cachedir/$Mergemaskbasename.${Number}.tif"
    Methodmask="$Cachedir/$Argbasename.${Number}.tif"
    
    Command="
$Magickbin
$(sed "s/NUMBER/$Number/g" <<< "$Mergecode" )
  mpr:mergemask
    $Tifstore 
  $Mergemask"
  
    case $Mergeneeded in
      yes)
        [ "$Count" = "1" ] && verbose "Merging masks with:
$(grep "\S" <<< "$Command")"
        multicore "$Command" "$Mergemask" || error "Error while merging masks"
      ;;
      no)
        [ "$Count" = "1" ] && verbose "Skipping merge, just copying $Methodmask to $Mergemask"
        multicore "cp $Methodmask $Mergemask" "$Mergemask" || error "Error while merging $Methodmask"
      ;;
    esac
    
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Merging $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done
  multicore_wait || error "Error while merging masks"

  return ${Error:-0}
}
focus_montage() {
  # Finally: focus stacking

  local Resultimage Resultfinalblur Outputimage Sourceimage Maskimagelist= Resultmd5
  local Lessthanmaxmask
  local Maskmax Maskmaxcopy= Maskmaxready= Maskstrength=
  local Count Number
  local Contrastmaxlevel Softfusion= Lessthanmax=
  local Command Skipmontage=
  local Startzeit Dauer Restzeit
  local Stepwise Sourcepartimage Sourcepartimagelist= Sourcemask
  local Longoptions Parsedoptions
  
  Longoptions="soft:,lessthanmax:,maskmax:,maskstrength:,output:"
  
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --output)       Outputimage="${2:-}" ; shift ;;
      --soft)         Softfusion="${2:-}"  ; shift ;;
      --lessthanmax)  Lessthanmax="${2:-}" ; shift ;;
      --maskmax)      Maskmaxcopy="${2:-}" ; shift ;;
      --maskstrength) Maskstrength="${2:-}" ; shift ;;
      --) ;;
      *)              Maskimagelist="$Maskimagelist ${1:-}" ;;
    esac
    shift
  done
  [ -z "$Maskimagelist" ] && Maskimagelist="$(masklist $Mergemaskbasename | tr '\n' ' ')"
  
  Resultmd5="$(md5cut "$Maskimagelist $Softfusion $Lessthanmax $Cutblur")"
#  Resultimage="$Cachedir/montage-$(cut -d- -f2- <<< "$Mergemaskbasename" | cut -d. -f1)-soft${Softfusion:-0}-less${Lessthanmax:-0}.$Resultmd5.tif"
  Resultimage="$(cut -d- -f2- <<< "$Mergemaskbasename" | cut -d. -f1)"
  [ -z "$Resultimage" ] && Resultimage="$(basename $(awk '{print $1}' <<< "$Maskimagelist") | cut -d. -f1)"
  [ "$Softfusion" ]     && Resultimage="$Resultimage-soft${Softfusion:-0}"
  [ "$Lessthanmax" ]    && Resultimage="$Resultimage-less${Lessthanmax:-0}"
  [ "$Cutblur" ]        && Resultimage="$Resultimage-cutblur${Cutblur:-0}"
  Resultimage="$Cachedir/montage-$Resultimage.$Resultmd5.tif"
  
  Maskmax="${Maskmax:-$Cachedir/montage.max.$Resultmd5.tif}"
  
  [ -e "$Resultimage" ] && {
    verbose "Skipping montage, already exists: $(basename $Resultimage)"
    showimage "$Resultimage"
    Skipmontage="yes"
  }
  
  [ -z "$Skipmontage" ] && {
    mkimg_transparent "$Resultimage"
    mkimg_black       $Maskmax
  
    #[ "$Softfusion" ] && level_masks $Maskimagelist
    [ "$Softfusion" ] && {
      Softfusion="$(calc "$Softfusion /${Maskstrength:-1}")"
    }
  
    [ "$Lessthanmax" ] && {
      evaluate max $Maskmax $Maskimagelist || return 1
      Maskmaxready="yes"
      Contrastmaxlevel="$($Magickbin $Maskmax -format '%[fx:maxima*100]' info:)"
      Lessthanmax="$(calc "$Lessthanmax*$Contrastmaxlevel/100")"
      Lessthanmax="$(calc "$Lessthanmax/${Maskstrength:-1}")"
      Lessthanmaxmask="$Cachedir/lessthanmax.tif"
      mkimg_black "$Lessthanmaxmask"
    }
  
    Stepwise="no"
    [ "$Lessthanmax" ] && Stepwise="yes"
  
    case $Stepwise in
      yes) mkimg_black $Maskmax || return 1 ;;
      no)  [ "$Maskmaxready" = "yes" ] || evaluate max $Maskmax $Maskimagelist || return 1 ;;
    esac 
  }
  
  note "Focus montage"
  Startzeit="$(date +%s)"
  Count=0    
  [ -z "$Skipmontage" ] && for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    #Sourcemask="$(cut -d' ' -f$Number <<< "$Maskimagelist")"
    Sourcemask="$(awk "{print \$$Number}" <<< "$Maskimagelist")"
    Sourcepartimage="$Cachedir/sourcepart$Number.png"
    Sourcepartimagelist="$Sourcepartimagelist $Sourcepartimage"
    
    # Load images
    Command="
$Magickbin
  $Sourceimage
    -alpha off
    -write mpr:sourceimage
    -delete 0
  $Sourcemask
    -alpha off
    -write mpr:sourcemask
    -delete 0
  $Maskmax
    -alpha off
    -write mpr:maskmax
    -delete 0"
    [ "$Stepwise" = "yes" ] && Command="$Command
  $Resultimage
    -write mpr:resultimage
    -delete 0"
    
    # stepwise increase maskmax
    [ "$Stepwise" = "yes" ] && Command="$Command
  mpr:sourcemask 
  mpr:maskmax 
    -compose Lighten -composite
    -write mpr:maskmax
    -write $Maskmax
    -delete 0"
    
    # get area of source mask equal or sharper than current max
    Command="$Command
  mpr:maskmax
  mpr:sourcemask
    -compose MinusSrc -composite -fill white +opaque black
    -alpha off
    -negate
    -write mpr:cutmask
    -delete 0"
    
    # drop areas with contrast=0
    [ "$Background" ] && Command="$Command   
  mpr:cutmask
  ( mpr:sourcemask -threshold 0% )
    -compose Darken -composite
    -write mpr:cutmask
    -delete 0"
    
    ## --lessthanmax,less
    [ "$Lessthanmax" ] && { 
      Command="$Command
  $Lessthanmaxmask
    -write mpr:lessthanmax
    -delete 0
  mpr:cutmask
    -write mpr:cutmask_max
    -delete 0"
      
      # get part of actual maskmax
      Command="$Command
  mpr:maskmax
  mpr:cutmask_max
    -alpha Off -compose CopyOpacity -composite
    -write mpr:maskmax_part
    -delete 0"
    
      # paint actual maskmax part into lessmask
      Command="$Command
  mpr:lessthanmax
  mpr:maskmax_part
    -compose Over -composite
    -write mpr:lessthanmax
    -write $Lessthanmaxmask
    -delete 0"
    
      # get area of source mask that is stronger (+offset) than lessmask)
      Command="$Command
  mpr:sourcemask 
  ( mpr:lessthanmax -evaluate Add ${Lessthanmax:-0}% )
    -compose MinusSrc -composite
    -fill white +opaque black 
    -write mpr:cutmask_less
    -delete 0"
      
      # reduce max in maskmax where --lessthanmax takes over
      Command="$Command
  mpr:sourcemask
  mpr:cutmask_less
    -compose CopyOpacity -composite
    -write mpr:sourcemask_part
    -delete 0
  mpr:maskmax
  mpr:sourcemask_part
    -compose Over -composite
    -write mpr:maskmax
    -write $Maskmax
    -delete 0"
    
      # darken lessmask with current source mask to get a mask with decreasing sharpness after a max peak
      Command="$Command
  mpr:lessthanmax
  mpr:sourcemask
    -compose Darken -composite
    -write mpr:lessthanmax
    -delete 0"
      
      # store lessmask
      Command="$Command
  mpr:lessthanmax
    -write $Lessthanmaxmask
    -delete 0" 
    
      # get area of source mask equal or sharper than current max (same code as above, but now with less-adjusted maskmax.
      Command="$Command
  mpr:sourcemask
  mpr:maskmax
    -compose MinusDst -composite -fill white +opaque black
    -alpha off
    -negate
    -write mpr:cutmask
    -delete 0"
    } #/--lessthanmax
    
    [ "$Cutblur" ] && Command="$Command
  mpr:cutmask
    -alpha off
    -blur 0x${Cutblur:-1}
  mpr:cutmask
    -compose Lighten -composite
    -write mpr:cutmask
    -delete 0"
    
    case $Softfusion in
      "") # hard (default)
        Command="$Command
  mpr:sourceimage
  mpr:cutmask
    -alpha off -compose CopyOpacity -composite
    -write mpr:sourcepart
    -delete 0"
      ;;
      *) # --soft
        # get part of source mask
        Command="$Command
  mpr:sourcemask 
  mpr:cutmask
    -compose Darken -composite
    -write mpr:sourcemask_part
    -delete 0"
        # get part of source image (with semi transparency)
        Command="$Command
  mpr:sourceimage 
  mpr:sourcemask_part
    -alpha off -compose CopyOpacity -composite
    -channel alpha -level 0,${Softfusion}% +channel
    -write mpr:sourcepart
    -delete 0"
      ;;
    esac
    
    case $Stepwise in
      yes)
        Command="$Command
  mpr:resultimage
  mpr:sourcepart
    -compose Over -composite
    $Tifstorealpha
    -write $Resultimage
    -delete 0"
      ;;
      no)
        Command="$Command
  mpr:sourcepart
    $Tifstorealpha
    -write $Sourcepartimage 
    -delete 0"
      ;;
    esac
    
    Command="$Command
  xc:white null:"
          
    [ "$Count" = "1" ] && verbose "Focus montage with:
$(grep "\S" <<< "$Command")"

    case $Stepwise in
      yes)
        $Command || error "Error while cutting images"
        showimage $Resultimage
      ;;
      no)
        #multicore "$Command" "$Testimage" || error "Error in result montage"
        multicore "$Command" || error "Error in result montage"
        [ "$Multicore_processcount" = "$Multicore_maxprocesses" ] && {
          multicore_wait || error "Error in result montage"
          flatten "$Resultimage" $Sourcepartimagelist  || error "Error while flattening images"
          showimage "$Resultimage"
          Sourcepartimagelist=""
        }
      ;;
    esac
    #showimage $Testimage
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Montage $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done
  multicore_wait || error "Error in result montage"
  
  [ -z "$Skipmontage" ] && case $Stepwise in
    no)
      # possible leftovers from multicore
      verbose "Montage $Resultimage"
      [ "$Sourcepartimagelist" ] && {
        flatten "$Resultimage" $Sourcepartimagelist || error "Error while flattening images"
      }
    ;;
  esac

  # --finalblur
  Resultfinalblur="$Resultimage"
  [ "$Finalblur" ] && {
    Resultfinalblur="$Resultimage.finalblur.tif"
    Command="$Magickbin
  $Resultimage
    -write mpr:resultimage
    -delete 0
  $Maskmax
    -write mpr:maskmax
    -delete 0
  mpr:maskmax
    -threshold $(calc "${Finalblurpercent:-10} /${Maskstrength:-1}")%
    -negate
    -write mpr:cutmask
    -delete 0
  mpr:resultimage
    -blur 0x${Finalblursigma:-1}
  mpr:cutmask
    -alpha off
    -compose CopyOpacity -composite
    -write mpr:partsource_blurred
    -delete 0"
    [ "$Softfusion" ] && {
      Command="$Command
  mpr:partsource_blurred
    -channel alpha
  mpr:maskmax
    -compose Multiply -composite
    +channel
    -delete 0
      "
    }
    Command="$Command
  mpr:partsource_blurred
  mpr:resultimage
    -compose DstOver -composite
  $Resultfinalblur"
  
    verbose "Final blur command:
$Command"

    $Command || error "Error with --finalblur"
  }
  
  [ "$Maskmaxcopy" ] && cp "$Maskmax" "$Maskmaxcopy"
  $Magickbin "$Resultfinalblur" "$Outputimage" || error "Error converting '$Outputimage' to '$Resultimage'"
  
  return "${Error:-0}"
}
focus_maskmethod() {
  # Mask generating ImageMagick options
  # Most of them are based on edge detection: http://www.imagemagick.org/Usage/convolve/#edgedet
  local Method Sourceimage
  local Maskgenerator
    
  Method="${1:-none}"
    
  case $Method in
    blur)
      # Concept and result is similar to Difference of Gaussian (DoG). Using -gaussian-blur gives same as DoG.
      # Code based on https://im.snibgo.com/simpalign.htm#twoBlrDiff.bat
      Maskgenerator="
  mpr:sourcegray
    -blur ${Argradius1:-0}x${Argsigma1:-0.75}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    channel|saturation|chroma|lightness|darkness)
      Maskgenerator="
  mpr:sourceimage
    -colorspace ${Argword1:-HSB} 
    -channel ${Argword2:-1} -separate
    +channel"
    ;;
    comet) ### FIXME saturate drops some angles
      Maskgenerator="
  mpr:sourcegray 
    -define morphology:compose=${Argword1:-Lighten}
    -morphology Convolve Comet:${Argradius1:-0}x${Argsigma1:-5}:>
  mpr:sourcegray
    -compose difference -composite"
    ;;
    compass)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=50%!
    -define morphology:compose=Lighten
    -define convolve:bias=50%
    -morphology Convolve Compass:>"
#-compose Difference -composite" # sort of interesting.
    ;;
    compose)
      case $Argswap in
        "")
          Maskgenerator="
  ( mpr:sourcegray -alpha off )
  ( $Cachedir/compose.$Argword1.$Sourcemd5.tif $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
        ;;
        *)
          Maskgenerator="
  ( mpr:sourcegray -alpha off )
  ( $Cachedir/compose.$Argword1.swap.$Sourcemd5.tif $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
        ;;
      esac
    ;;
    diffstat)
      Maskgenerator=""
      [ "$Argword1" = "source" ] && Maskgenerator="$Maskgenerator mpr:sourcegray" || Maskgenerator="$Maskgenerator
  ( mpr:sourcegray -statistic ${Argword1:-median} ${Argradius1:-5} )"
      [ "$Argword2" = "source" ] && Maskgenerator="$Maskgenerator mpr:sourcegray" || Maskgenerator="$Maskgenerator
  ( mpr:sourcegray -statistic ${Argword2:-mean} ${Argradius1:-5} )"
Maskgenerator="$Maskgenerator
    -compose Difference -composite"
    ;;
    dog) # DoG: Difference of Gaussian
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100,100%
    -morphology Convolve DoG:${Argradius1:-0},${Argsigma1:-0.75},${Argsigma2:-1.2}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    enfuse)
      Maskgenerator="
  ( mpr:sourcegray -alpha off )
  ( $Cachedir/enfuse.$Sourcemd5.tif $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    evaluate)
      Maskgenerator="
  ( mpr:sourcegray -alpha off )
  ( $Cachedir/evaluate.$Argword1.$Sourcemd5.tif $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    GAUSSexperimental) 
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=-100,200%
    -morphology Convolve Gaussian:${Argradius1:-0}x${Argsigma1:-0.75}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    CROSSMORPHexperimental)
      Maskgenerator="
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1:-3}x1+1+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1:-3}x1+${Argradius1:-3}+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:1x${Argradius1:-3}+0+1 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:1x${Argradius1:-3}+0+${Argradius1:-3} )
    -evaluate-sequence min"
    ;;
    CROSSMORPH2experimental)
      Maskgenerator="
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1}x$((Argradius1/2))+0+$((Argradius1/4)) )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1}x$((Argradius1/2))+$((Argradius1-1))+$((Argradius1/4)) )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:$((Argradius1/2))x$((Argradius1))+$((Argradius1/4))+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:$((Argradius1/2))x$((Argradius1))+$((Argradius1/4))+$((Argradius1-1)) )
    -evaluate-sequence min"
    ;;
    experimental)
      Maskgenerator="
  mpr:sourcegray
    -threshold 80%
    -blur 0x5
    -auto-level
    -negate"
    ;;
    free)
      Maskgenerator="
  mpr:sourcegray 
    $Argword1"
    ;;
    freediff)
      Maskgenerator="
  mpr:sourcegray 
    $Argword1
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    freichen)
      case $Argword1 in
        "")
          Maskgenerator="
  (
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:1>
  )
  (
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:2>
  )
    -compose Screen
    -composite"
        ;;
        *)
          Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=10%
    -morphology Convolve FreiChen:${Argword1:-0}>"
        ;;
      esac
    ;;
    gaussian)
      Maskgenerator="
  ( mpr:sourcegray -gaussian-blur ${Argradius1:-0}x${Argsigma1:-0.75} )
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    XXXhalo)
      Maskgenerator="
  mpr:sourcegray
    -threshold $(calc "100-${Argpercent1:-50}")%
    -write mpr:halomask
    -delete 0
  mpr:sourcegray
    -brightness-contrast -23,-100
  mpr:halomask
    -compose CopyOpacity -composite
  mpr:sourcegray
    -compose DstOver -composite    
    "
    ;;
    halo)
      Maskgenerator="
  mpr:sourcegray
    -threshold $(calc "100-${Argpercent1:-50}")%
    -morphology Dilate Octagon:${Argradius1:-2}
    -blur 0x${Argsigma1:-5}
    -auto-level
    -negate"
    ;;
    image)
      Maskgenerator="
  ( mpr:sourcegray -alpha off )
  ( $Argword1 $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    kirsch)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=screen
    -define convolve:bias=15%
    -morphology Convolve Kirsch:>"
    ;;
    laplacian)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:bias=5%
    -define convolve:scale=100%!
    -morphology Convolve Laplacian:${Argword1:-0}>"
    ;;
    log)  # LoG: Laplacian of Gaussian
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100,100%
    -morphology Convolve LoG:${Argradius1:-0}x${Argsigma1:-0.75}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    morphology)
      Maskgenerator="
  mpr:sourcegray
    -morphology ${Argword1:-edge}:${Argradius2:-1} Octagon:${Argradius1:-2}"
    ;;
    none)
      Maskgenerator="mpr:sourcegray"
    ;;
    prewitt)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=screen
    -define convolve:bias=10%
    -morphology Convolve Prewitt:>"
    ;;
    roberts)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100%
    -define morphology:compose=screen
    -define convolve:bias=10%
    -morphology Convolve Roberts:@"
    ;;
    sobel)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100%!
    -define convolve:bias=10%
    -define morphology:compose=screen
    -morphology Convolve Sobel:>"
    ;;
    statistic)
      Maskgenerator="
  mpr:sourcegray
    -statistic ${Argword1:-standarddeviation} ${Argradius1:-2}x${Argradius1:-2}"
    ;;
    unsharp)
      Maskgenerator="
  mpr:sourcegray -unsharp ${Argradius1:-0}x${Argsigma1:-5}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    wavelet)
      Maskgenerator="
  mpr:sourcegray 
    -wavelet-denoise ${Argpercent1:-10}%
  mpr:sourcegray
    -compose Difference -composite"
    ;;
  esac
    
  grep . <<< "$Maskgenerator"
}

### mask args

maskarg_parse() {
  local Key Line Value
  
  Argbasename=""
  Argclose1=""
  Argclose2=""
  Argdarkenmask=""
  Argdenoise=""
  Argdiff=""
  Argless=""
  Arglevel=""
  Arglevelmin=""
  Arglevelmax=""
  Argmaskstrength=""
  #Argmethod=""
  Argnegate=""
  Argpercent1=""
  Argpercent2=""
  Argradius1=""
  Argradius2=""
  Argsigma1=""
  Argsigma2=""
  Argsoft=""
  Argtype=""
  Argswap=""
  Argthreshold=""
  Argweight=""
  Argword1=""
  Argword2=""
    
  while read -d, Line; do
    grep -q "=" <<< "$Line" && {
      Key="$(cut   -d= -f1    <<< "$Line")"
      Value="$(cut -d= -f2 -s <<< "$Line")"
      :
    } || {
      Key="$(digitrm "$Line")"
      Value="$(sed "s/${Key:-NOKEY}//"  <<< "$Line")"
    }
    case $Key in
      "w"|"w%")       Argweight="${Value:-$(maskarg_defaultvalue    "$Firstmaskmethod" noise)}" ;;
      "r")                Argradius1="$Value" ;;
      "R")                Argradius2="${Value}" ;;
      "s")                Argsigma1="$Value" ;;
      "S")                Argsigma2="${Value}" ;;
      "p"|"%")            Argpercent1="$(percentrm "$Value")" ;;
      "P")                Argpercent2="$(percentrm "$Value")" ;;
      "swap")             Argswap="swap" ;;
      "soft")             Argsoft="${Value:-$(maskarg_defaultvalue      "$Argmethod" soft)}" ;;
      "denoise")          Argdenoise="${Value:-$(maskarg_defaultvalue   "$Argmethod" noise)}" ;;
      "d"|"diff")         Argdiff="s" ;;
      "less")             Argless="${Value:-$(maskarg_defaultvalue      "$Argmethod" less)}" ;;
      "blur"|"maskblur")  Argmaskblur="${Value:-$(maskarg_defaultvalue  "$Argmethod" maskblur)}" ;;
      "n"|"neg"|"negate") Argnegate="neg" ;;
      "t"|"threshold")    Argthreshold="${Value:-$(maskarg_defaultvalue "$Argmethod" noise)}" ;;
      "c"|"close"|"cx"|"closex")
        Value="$(tr -d "close" <<< "$Line")"
        Value="${Value:-$(maskarg_defaultvalue                          "$Argmethod" close)}"
        Argclose1=$(cut -dx    -f1 <<< "$Value")
        Argclose2=$(cut -dx -s -f2 <<< "$Value")
        Argclose1="$(digitonly "$Argclose1")"
        Argclose2="$(digitonly "$Argclose2")"
        Argclose2="${Argclose2:-1}"
      ;;
      "CLOSE1")           Argclose1="$Value" ;;
      "CLOSE2")           Argclose2="$Value" ;;
      "LEVEL")            Arglevel="yes" ;;
      "LEVELMIN")         Arglevelmin="$Value" ;;
      "LEVELMAX")         Arglevelmax="$Value" ;;
      "DARKENMASK")       Argdarkenmask="$Value" ;;
      "NUM")              Maskmethodcount="$Value" ;;
      "STRENGTH")         Argmaskstrength="$Value" ;;
      "METHOD")           Argmethod="$Value" ;;
      "TYPE")             Argtype="$Value" ;;
      "BASENAME")         Argbasename="$Value" ;;
      *|WORD1|WORD2) ### FIXME
        [ -z "$Argword1" ] && Argword1="$Line" || Argword2="$Line" 
        Argword1="${Argword1#WORD1=}"
        Argword2="${Argword2#WORD2=}"
      ;;
    esac
  done <<< "${1:-},"
}
maskarg_store() {
  Maskmethodcount="${1:-$Maskmethodcount}"
  Newoption="NUM=$Maskmethodcount"
  Newoption="$Newoption,METHOD=$Argmethod"
  [ "$Argweight" ]             && Newoption="$Newoption,w=$Argweight"
  [ "$Argradius1" ]            && Newoption="$Newoption,r=$Argradius1"
  [ "$Argradius2" ]            && Newoption="$Newoption,R=$Argradius2"
  [ "$Argsigma1" ]             && Newoption="$Newoption,s=$Argsigma1"
  [ "$Argsigma2" ]             && Newoption="$Newoption,S=$Argsigma2"
  [ "$Argpercent1" ]           && Newoption="$Newoption,p=$Argpercent1"
  [ "$Argpercent2" ]           && Newoption="$Newoption,P=$Argpercent2"
  [ "$Argless" ]               && Newoption="$Newoption,less=$Argless"
  [ "$Argclose1" ]             && Newoption="$Newoption,CLOSE1=$Argclose1"
  [ "$Argclose2" ]             && Newoption="$Newoption,CLOSE2=$Argclose2"
  [ "$Argword1" ]              && Newoption="$Newoption,WORD1=$Argword1"
  [ "$Argword2" ]              && Newoption="$Newoption,WORD2=$Argword2"
  [ "$Argdenoise" ]            && Newoption="$Newoption,denoise=$Argdenoise"
  [ "$Argdiff" ]               && Newoption="$Newoption,diff"
  [ "$Argsoft" ]               && Newoption="$Newoption,soft=$Argsoft"
  [ "$Argmaskblur" ]           && Newoption="$Newoption,maskblur=$Argmaskblur"
  [ "$Argthreshold" ]          && Newoption="$Newoption,threshold=$Argthreshold"
  [ "$Argnegate" ]             && Newoption="$Newoption,negate"
  [ "$Argswap" ]               && Newoption="$Newoption,swap"
  [ "$Argdarkenmask" ]         && Newoption="$Newoption,DARKENMASK=$Argdarkenmask"
  [ "$Arglevel" ]              && Newoption="$Newoption,LEVEL"
  [ "$Arglevelmin" ]           && Newoption="$Newoption,LEVELMIN=$Arglevelmin"
  [ "$Arglevelmax" ]           && Newoption="$Newoption,LEVELMAX=$Arglevelmax"
  [ "$Argmaskstrength" ]       && Newoption="$Newoption,STRENGTH=$Argmaskstrength"
  [ "$Argtype" ]               && Newoption="$Newoption,TYPE=$Argtype"
  [ "$Argbasename" ]           && Newoption="$Newoption,BASENAME=$Argbasename"

  grep -q "NUM=$Maskmethodcount," <<< "$Maskmethodlist" \
    && Maskmethodlist="$(sed "s&^NUM=$Maskmethodcount,.*&$Newoption&" <<< "$Maskmethodlist")" \
    || Maskmethodlist="$Maskmethodlist
$Newoption"
  Maskmethodlist="$(grep "\S" <<< "$Maskmethodlist")"
}
maskarg_defaultvalue() {
  case "${2:-}" in
    close)
      echo "2x2"
    ;;
    maskblur)
      case "${1:-}" in
        blur|comet|compass|diffstat|dog|freichen|gaussian|kirsch|laplacian|log|morphology|prewitt|roberts|sobel|statistic|unsharp|wavelet)
          echo "1"
        ;;
        *)
          echo "0"
        ;;
      esac
    ;;
    less)
      case "${1:-}" in
        blur)       echo "8" ;;
        comet)      echo "6" ;;
        compass)    echo "4" ;;
        dog)        echo "6" ;;
        diffstat)   echo "5" ;;
        freichen)   echo "15" ;;
        gaussian)   echo "8" ;;
        #kirsch)     echo "2" ;;
        #laplacian
        log)        echo "8" ;;
        morphology) echo "10" ;;
        prewitt)    echo "4" ;;
        roberts)    echo "20" ;;
        sobel)      echo "4" ;;
        statistic)  echo "15" ;;
        #unsharp
        wavelet)    echo "35" ;;
        *)          echo "10" ;;
      esac
    ;;
    level)
      case "${1:-}" in
        blur)       echo "0%,7.68292%" ;;
        comet)      echo "0%,35.523%" ;;
        compass)    echo "45.0599%,80.0015%" ;;
        dog)        echo "0%,38.941%" ;;
        diffstat)
          case "$Argword1,$Argword2" in
            "median,mean") echo "0%,44.1398%" ;;
            "min,max")     echo "0%,100%" ;;
          esac
        ;;
        freichen)   echo "33.6584%,100%" ;;
        gaussian)   echo "0%,0.764477%" ;;
        #kirsch)     echo "" ;;
        laplacian)
          case $Argword1 in
            3)      echo "0%,18.6282%" ;;
          esac
        ;;
        log)        echo "0%,37.5494%" ;;
        morphology) echo "0%,100%" ;;
        prewitt)    echo "34.3893%,100%" ;;
        #roberts)    echo "7.64782%,100%" ;;
        sobel)      echo "34.3893%,100%" ;;
        statistic)
          case $Argword1 in
            standarddeviation) echo "0%,50.0008%" ;;
          esac
        ;;
        #unsharp
        wavelet)    echo "0%,12.8145%" ;;
        *)          echo "" ;;
      esac
    ;;
    levelmin)
      case "${1:-}" in
        blur)       echo "0" ;;
        comet)      echo "0" ;;
        compass)    echo "45" ;;
        dog)        echo "0" ;;
        diffstat)
          case "$Argword1,$Argword2" in
            "median,mean") echo "0" ;;
            "min,max")     echo "0" ;;
          esac
        ;;
        freichen)   echo "33.6584" ;;
        gaussian)   echo "0" ;;
        #kirsch)     echo "" ;;
        laplacian)
          case $Argword1 in
            3)      echo "0" ;;
          esac
        ;;
        log)        echo "0" ;;
        morphology) echo "0" ;;
        prewitt)    echo "34.3893" ;;
        #roberts)    echo "7.64782%,100%" ;;
        sobel)      echo "34.3893" ;;
        statistic)
          case $Argword1 in
            standarddeviation) echo "0" ;;
          esac
        ;;
        #unsharp
        wavelet)    echo "0" ;;
        *)          echo "" ;;
      esac
    ;;
    levelmax)
      case "${1:-}" in
        blur)       echo "7.68292" ;;
        comet)      echo "35.523" ;;
        compass)    echo "80" ;;
        dog)        echo "38.941" ;;
        diffstat)
          case "$Argword1,$Argword2" in
            "median,mean") echo "44.1398" ;;
            "min,max")     echo "100" ;;
          esac
        ;;
        freichen)   echo "100" ;;
        gaussian)   echo "0.764477" ;;
        #kirsch)     echo "" ;;
        laplacian)
          case $Argword1 in
            3)      echo "18.6282" ;;
          esac
        ;;
        log)        echo "37.5494" ;;
        morphology) echo "100" ;;
        prewitt)    echo "100" ;;
        #roberts)    echo "7.64782%,100%" ;;
        sobel)      echo "100" ;;
        statistic)
          case $Argword1 in
            standarddeviation) echo "50" ;;
          esac
        ;;
        #unsharp
        wavelet)    echo "12.8145" ;;
        *)          echo "" ;;
      esac
    ;;
    noise)
      case "${1:-}" in
        #blur)       echo "15" ;;
        #comet
        compass)    echo "25" ;;
        diffstat)   echo "15" ;;
        #dog
        freichen)   echo "15" ;;
        #gaussian)   echo "15" ;;
        image|evaluate|compose|enfuse)
                    echo "100" ;;
        #kirsch)     echo "2" ;;
        #laplacian
        log)        echo "10" ;;
        morphology) echo "10" ;;
        prewitt)    echo "15" ;;
        #roberts
        sobel)      echo "1" ;;
        statistic)  echo "10" ;;
        #unsharp
        wavelet)    echo "10" ;;
        *)          echo "15" ;;
      esac
    ;;
    percent1)
      case "${1:-}" in
        halo)       echo "25" ;;
        wavelet)    echo "10" ;;
        *)          echo "" ;;
      esac
    ;;
    percent2)
      case "${1:-}" in
        *)          echo "" ;;
      esac
    ;;
    radius1)
      case "${1:-}" in
        blur)       echo "" ;; # 0
        comet)      echo "" ;; # 0
        compass)    echo "" ;;
        diffstat)   echo "3" ;;
        dog)        echo "" ;; # 0
        freichen)   echo "" ;;
        gaussian)   echo "" ;; # 0
        kirsch)     echo "" ;;
        laplacian)  echo "" ;;
        log)        echo "" ;; # 0
        morphology) echo "1" ;;
        prewitt)    echo "" ;;
        roberts)    echo "" ;;
        sobel)      echo "" ;;
        statistic)  echo "2" ;;
        unsharp)    echo "" ;; # 0
        *)          echo "" ;;
      esac
    ;;
    radius2)
      case "${1:-}" in
        *)          echo "" ;;
      esac
    ;;
    sigma1)
      case "${1:-}" in
        blur)       echo "0.3" ;;
        comet)      echo "5" ;;
        compass)    echo "" ;;
        diffstat)   echo "" ;;
        dog)        echo "0.3" ;;
        finalblur)  echo "3" ;;
        freichen)   echo "" ;;
        gaussian)   echo "0.3" ;;
        halo)       echo "5" ;;
        kirsch)     echo "" ;;
        laplacian)  echo "" ;;
        log)        echo "0.2" ;;
        morphology) echo "" ;;
        prewitt)    echo "" ;;
        roberts)    echo "" ;;
        sobel)      echo "" ;;
        statistic)  echo "" ;;
        unsharp)    echo "2" ;;
        wavelet)    echo "" ;;
        *)          echo "" ;;
      esac
    ;;
    sigma2)
      case "${1:-}" in
        dog)       echo "$(calc "${Argsigma1:-0.75} * 1.6")" ;;
        *)         echo "" ;;
      esac
    ;;
    soft)
      case "${1:-}" in
        blur)       echo "25" ;;
        comet)      echo "30" ;;
        compass)    echo "35" ;;
        diffstat)   echo "25" ;;
        dog)        echo "25" ;;
        freichen)   echo "1" ;;
        gaussian)   echo "25" ;;
        #kirsch
        #laplacian)  echo "10" ;;
        log)        echo "25" ;;
        morphology) echo "25" ;;
        prewitt)    echo "2" ;;
        roberts)    echo "50" ;;
        sobel)      echo "2" ;;
        statistic)  echo "35" ;;
        #unsharp
        wavelet)    echo "75" ;;
        *)          echo "15" ;;
      esac
    ;;
    type)
      case "${1:-}" in
        blur|comet|compass|diffstat|dog|freichen|gaussian|kirsch|laplacian|log|morphology|prewitt|roberts|sobel|statistic|unsharp|wavelet)
          echo "mask"
        ;;
        *)
          echo "image"
        ;;
      esac
    ;;
    word1)
      case "${1:-}" in
        channel)    echo "HSL" ;;
        comet)      echo "lighten" ;;
        compose)    echo "overlay" ;;
        diffstat)   echo "median" ;;
        evaluate)   echo "max" ;;
        freichen)   echo "" ;;
        freediff)   echo "-sharpen 0x3" ;;
        laplacian)  echo "3" ;;
        morphology) echo "edge" ;;
        statistic)  echo "standarddeviation" ;;
        *)          echo "" ;;
      esac
    ;;
    word2)
      case "${1:-}" in
        channel)    echo "2" ;;
        diffstat)   echo "mean" ;;
        *)          echo "" ;;
      esac
    ;;
  esac
} 
maskarg_checkallowed() {
  local Method Option Arg
  Method="${1:-}"
  Option="${2:-}"
  Arg="${3:-}"
  case "$Option" in
    radius1)
      case "$Method" in
        blur|comet|dog|gaussian|halo|log|morphology|unsharp|wavelet) ;;
        diffstat|statistic)
          [ "$Arg" -lt "2" ] && error "--$Method needs a radius of at least 2"
        ;;
        *) error "$Method does not take argument radius" ;;
      esac
    ;;
    radius2)
      error "$Method does not take argument radius2"
    ;;
    sigma1)
      case "$Method" in
        blur|comet|dog|gaussian|halo|log|unsharp) ;;
        *) error "$Method does not take argument sigma" ;;
      esac
    ;;
    sigma2)
      case "$Method" in
        dog) ;;
        *) error "$Method does not take argument sigma2" ;;
      esac
    ;;
    percent1)
      case "$Method" in
        wavelet|halo) ;;
        *) error "$Method does not take argument percent1" ;;
      esac
    ;;
    percent2)
      case "$Method" in
        *) error "$Method does not take argument percent2" ;;
      esac
    ;;
    word1)
      case "$Method" in
        comet|channel|freichen|freediff|laplacian) ;;
        compose|evaluate|morphology)
          Arg="$(lowercase "${Arg}")"
          checkmagicklist "$Method" "$Arg" || {
            error "--$Method=$Arg: unknown argument.
  Please choose one out of '$Magicklist -list $Method'"
          }
        ;;
        diffstat)
          Arg="$(lowercase "${Arg}")"
          Arg="$(maskarg_checkstatistic "$Arg")"
        ;;
        statistic)
          Arg="$(lowercase "${Arg}")"
          Arg="$(maskarg_checkstatistic "$Arg")"
          [ "$Arg" = "source" ] && error "--$Method does not take argument $Arg
  Please choose one out of '$Magicklist -list $Method'"
        ;;
        *) error "$Method does not take argument word1 $Arg" ;;
      esac
    ;;
    word2)
      case "$Method" in
        diffstat)
          Arg="$(lowercase "${Arg}")"
          Arg="$(maskarg_checkstatistic "$Arg")"
        ;;
        *) error "$Method does not take argument word1 $Arg" ;;
      esac
    ;;
  esac
  [ "$Error" ] && return 1
  echo "$Arg"
  return 0
}
maskarg_checkstatistic() {
  local Mode

  Mode="${1:-}"
  case ${Mode,,} in
    0|source|none)          Mode="source" ;;
    1|gradient|grad)        Mode="gradient" ;;
    2|maximum|max)          Mode="maximum" ;;
    3|mean)                 Mode="mean" ;;
    4|median)               Mode="median" ;;
    5|minimum|min)          Mode="minimum" ;;
    6|mode)                 Mode="mode" ;;
    7|nonpeak)              Mode="nonpeak" ;;
    8|9|rms|rootmeansquare) Mode="rms" ;;
    10|standarddeviation|standard_deviation|standard-deviation|dev) 
                            Mode="standarddeviation" ;;
    *) error "Unknown statistic mode '$Mode'" ; return 1;;
  esac
  [ "$Error" ] && return 1
  echo "$Mode"
  return 0
}

#### run commands on all CPUs

multicore() {
  # Run multiple processes in parallel, but not more than $Multicore_maxprocesses
  # $1 Command
  # $2 Image to show if $1 is finished
  # Run multicore_wait afterwards to wait for the last processes to finish.
  
  local Process Command
  local Mem_needed Zram
  
  [ "$Multicore_processcount" = "$Multicore_maxprocesses" ] && {
    multicore_wait || return 1
  }
  [ "$Multicore_processcount" = "0" ] && Multicore_memorymax="$(freememory)"  
  Mem_needed=0
  for Process in $(seq $Multicore_maxprocesses); do
    Mem_needed="$(awk "BEGIN {print $Mem_needed + ${Multicore_memory[$Process]:-0} }" )"
  done
  Mem_needed="$((Mem_needed+${3:-0}))"
  [ "$Mem_needed" -gt "$Multicore_memorymax" ] && {
    note "multicore: Low memory. Waiting for $Multicore_processcount running processes to finish. Need: $((Mem_needed/1000)) MB, Available: $((Multicore_memorymax/1000)) MB"
    [ "$Mem_needed" -gt "$Multicore_memorymax" ] && [ "$Multicore_processcount" = "0" ] && note "multicore: Likely hard disk cache will be used and slow down the calculation."
    multicore_wait || return 1
  }
  
  ifcmdbreak && return 1

  Multicore_processcount=$((Multicore_processcount +1))

  Command="$(cut -d ' ' -f1 <<< "${1:-}")"
  case $(type -t "$Command") in
    file) Command="nice ${1:-}" ;;
    *)    Command="${1:-}" ;;
  esac
  
  #verbose "multicore: ${1:-}"
  Command="${Command//[$'\t\r\n']}"
  Command="$(sed 's/(/\\(/g ; s/)/\\)/g ; s/>/\\>/g' <<< "$Command")"
  eval "$Command &"
  
  Multicore_process[Multicore_processcount]=$!
  Multicore_image[Multicore_processcount]="${2:-}"
  Multicore_memory[Multicore_processcount]="${3:-0}"
  
  return 0
}
multicore_wait() {
  local Process= Error=
  for Process in $(seq $Multicore_maxprocesses); do
    [ "${Multicore_process[$Process]}" ] && {
      multicore_waitprocess "${Multicore_process[$Process]}" || {
        multicore_break
        Error=1
      }
      [ "$Error" ] && break
      [ "${Multicore_image[$Process]}" ] && showimage "${Multicore_image[$Process]}"
    }
    Multicore_process[$Process]=""
    Multicore_image[$Process]=""
    Multicore_memory[$Process]="0"
  done
  [ "$Error" ] && return 1
  Multicore_processcount=0
  return 0
}
multicore_waitprocess() {
  local Error=
  while sleep 0.2 ; do
    ps -p "${1:-}" >/dev/null || break
    ifcmdbreak && Error=1
    [ "$Error" ] && break
  done
  [ "$Error" ] && return 1
  wait "${1:-}"
  return $?
}
multicore_break() {
  local Process  
  for Process in $(seq $Multicore_maxprocesses); do
    [ "${Multicore_process[$Process]}" ] && {
      kill "${Multicore_process[$Process]}"
      wait "${Multicore_process[$Process]}"
      Multicore_process[$Process]=""
      Multicore_image[$Process]=""
      Multicore_memory[$Process]="0"
    }
  done
}
multicore_init() {
  # declare global variables
  local Process
  [ -z "${Multicore_maxprocesses:-}" ] && Multicore_maxprocesses="$(nproc)"
  Multicore_maxprocesses="${Multicore_maxprocesses:-1}"
  for Process in $(seq $Multicore_maxprocesses); do
    Multicore_process[$Process]=""
    Multicore_image[$Process]=""
    Multicore_memory[$Process]="0"
  done
  Multicore_processcount=0
  Multicore_minram=250000
  Multicore_maxprocesses=$Multicore_maxprocesses
}
ifcmdbreak() {
  return 1
}
### main

trap_sigint() {
  error "Received SIGINT"
  multicore_break
}
declare_variables() {
  Arglist='
  Argbasename=""
  Argclose1=""
  Argclose2=""
  Argdarkenmask=""
  Argdenoise=""
  Argdiff=""
  Argless=""
  Arglevel=""
  Arglevelmin=""
  Arglevelmax=""
  Argmaskblur=""
  Argmaskstrength=""
  Argmethod=""
  Argnegate=""
  Argpercent1=""
  Argpercent2=""
  Argradius1=""
  Argradius2=""
  Argsigma1=""
  Argsigma2=""
  Argsoft=""
  Argswap=""
  Argtype=""
  Argthreshold=""
  Argweight=""
  Argword1=""
  Argword2=""
  '
  eval $Arglist
  
  Background=""
  Backgroundimage=""
  Basename=""
  Cachedir=""
  Caseeval=""
  Casecompose=""
  Composefactor="" ### FIXME
  Compose_needlist=""
  Cutblur=""
  Difference_needlist=""
  Enfuse_needlist=""
  Evaluate_needlist=""
  Error=""
  Exifsourceimage=""
  Fakehdr=""
  Finalblur=""
  Finalblurpercent=""
  Finalblursigma=""
  Firstimage=""
  Firstmaskmethod=""
  Forceoverwrite=""
  Freemem=""
  Globalclose=""
  Globalclose1=""
  Globalclose2=""
  Globaldenoise=""
  Globalmaskblur=""
  Globalless=""
  Globalsoft=""
  Grayscale=""
  Grayscaleconverter=""
  Grayscalenumber=""
  Image=""
  Imageformat="tif"
  Imageheight=""
  Imagelistmemsize=""
  Imagememsize=""
  Imagenumber=""
  Imagewidth=""
  Layers=""
  Line=""
  Magickbin=""
  Magicklist=""
  Magickpixelmemory=""
  Magickversion=""
  Maskmethodcount=""
  Maskmethodlist=""
  Maskmethodnumber=""
  Mergemaskbasename=""
  Outputimage=""
  Parsedoptions=""
  Preservecache=""
  Revertimagelist=""
  Resultimage=""
  Showimageprocessing=""
  Showname=""
  Sourceimage=""
  Sourceimagelist=""
  Sourcemd5=""
  Startzeit="$(date +%s)"
  Testarg=""
  Testimage=""
  Testsetup=""
  Tifstore="+repage -quality 100% -compress lzw"
  Tifstorealpha="$Tifstore -type TrueColorAlpha"
  Verbose=""
  
  return 0
}
parse_options() {
  local Shortoptions Longoptions Parsererror Parsererrorfile Maskgeneratorargument
  #local Parsedoptions
  
  Shortoptions="ho:vV"
  Longoptions="basename:,cache::,exif::,force,help,output:,showimage,showname,test::,threads:,verbose,version"
  Longoptions="$Longoptions,bg:,background:,close::,cutblur::,denoise::,fakehdr::,finalblur::,grayscale:,layers::,less::,maskblur::,revert,soft::"
  Longoptions="$Longoptions,channel::,chroma::,compose::,darkness::,enfuse::,evaluate::,halo::,image::,lightness::,saturation::"
  Longoptions="$Longoptions,blur::,comet::,compass::,diffstat::,dog::,enfuse::,gaussian::,freichen::,kirsch::,laplacian::,log::,morphology::,none::,prewitt::,roberts::,sobel::,statistic::,unsharp::,wavelet::"  
  Longoptions="$Longoptions,experimental::,free::,freediff::"
  
  Parsererrorfile="/tmp/imfuse.parserserror.$RANDOM"
  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@" 2>"$Parsererrorfile")"
  [ -e $Parsererrorfile ] && Parsererror="$(cat "$Parsererrorfile")" && rm "$Parsererrorfile"
  [ "$Parsererror" ] && error "$Parsererror"
  eval set -- "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    [ "$Error" ] && break
    case "${1:-}" in
         --bg|--background)   Background="${2:-}"         ; shift ;;
         --basename)          Basename="${2:-auto}"       ; shift ;;
         --cache)             Preservecache="yes"         ; Cachedir="${2:-auto}" ; shift ;;
         --close)             Globalclose="${2:-auto}"    ; shift ;;
         --cutblur)           Cutblur="${2:-auto}"        ; shift ;;      
         --denoise)           Globaldenoise="${2:-auto}"  ; shift ;;
         --exif)              Exifsourceimage="${2:-auto}"        ; shift ;;
         --fakehdr)           Fakehdr="${2:-auto}"        ; shift ;;
         --finalblur)         Finalblur="${2:-auto}"      ; shift ;;
         --force)             Forceoverwrite="yes"        ;;
         --grayscale)         Grayscale="${2:-auto}"      ; shift ;;
      -h|--help)              usage                       ; exit 0 ;;
         --layers)            Layers="${2:-auto}"         ; shift ;;
         --less)              Globalless="${2:-auto}"     ; shift ;;
         --maskblur)          Globalmaskblur="${2:-auto}" ; shift ;;      
      -o|--output)            Outputimage="${2:-}"        ; shift ;;
         --revert)            Revertimagelist="yes"       ;;
      -V|--showimage)         Showimageprocessing="yes"   ;;
         --showname)          Showname="yes"              ;;
         --soft)              Globalsoft="${2:-auto}"     ; shift ;;
         --test)              Testsetup="test" Testarg="${2:-}"    ; shift ;;
         --threads)           Multicore_maxprocesses="${2:-}" ; shift ;;
      -v|--verbose)           Verbose="yes"               ;;
         --version)           echo "imfuse v$Version"     ; exit 0 ;;
      
--blur|--channel|--chroma|--comet|--compass|--compose|--darkness|--diffstat|--dog|--enfuse|--evaluate|\
--experimental|--free|--freediff|\
--freichen|--gaussian|--halo|--image|--kirsch|--laplacian|--lightness|--log|--morphology|--none|\
--prewitt|--roberts|--saturation|--sobel|--statistic|--unsharp|--wavelet)
        Argmethod="${1#--}"
        Maskgeneratorargument="${2:-}" && shift
        Maskmethodnumber="$((Maskmethodnumber+1))"
        Maskmethodcount="$Maskmethodnumber"
        maskarg_parse "$Maskgeneratorargument"
        maskarg_store "$Maskmethodcount"
      ;;
      
      --) ;;
      *)
        Sourceimagelist="$Sourceimagelist
$(realpath "${1:-}")" 
        [ -f "${1:-}" ] || error "File not found: ${1:-}"
      ;;
    esac
    shift
  done
  return ${Error:-0}
}  
check_options() {
  local Arg

  # --maskblur
  case $Globalmaskblur in
    0)    Globalmaskblur="" ;;
    auto) Globalmaskblur="1" ;;
  esac
  
  Maskmethodlist="$(grep "\S" <<< "$Maskmethodlist")"
  [ -n "$Maskmethodlist" ] && while read Line; do
    maskarg_parse "$Line"
    [ -z "$Argradius1" ]  && Argradius1="$(maskarg_defaultvalue            "$Argmethod" radius1)"
    [ -z "$Argradius2" ]  && Argradius2="$(maskarg_defaultvalue            "$Argmethod" radius2)"
    [ -z "$Argsigma1" ]   && Argsigma1="$(maskarg_defaultvalue             "$Argmethod" sigma1)"
    [ -z "$Argsigma2" ]   && Argsigma2="$(maskarg_defaultvalue             "$Argmethod" sigma2)"
    [ -z "$Argpercent1" ] && Argpercent1="$(maskarg_defaultvalue           "$Argmethod" percent1)"
    [ -z "$Argpercent2" ] && Argpercent2="$(maskarg_defaultvalue           "$Argmethod" percent2)"
    [ -z "$Argword1" ]    && Argword1="$(maskarg_defaultvalue              "$Argmethod" word1)"
    [ -z "$Argword2" ]    && Argword2="$(maskarg_defaultvalue              "$Argmethod" word2)"
    [ -n "$Argradius1" ]  && { Argradius1="$(maskarg_checkallowed  "$Argmethod" radius1  "$Argradius1")"  || Error=1 ; }
    [ -n "$Argradius2" ]  && { Argradius2="$(maskarg_checkallowed  "$Argmethod" radius2  "$Argradius2")"  || Error=1 ; }
    [ -n "$Argpercent1" ] && { Argpercent1="$(maskarg_checkallowed "$Argmethod" percent1 "$Argpercent1")" || Error=1 ; }
    [ -n "$Argpercent2" ] && { Argpercent2="$(maskarg_checkallowed "$Argmethod" percent2 "$Argpercent2")" || Error=1 ; }
    [ -n "$Argsigma1" ]   && { Argsigma1="$(maskarg_checkallowed   "$Argmethod" sigma1   "$Argsigma1")"   || Error=1 ; }
    [ -n "$Argsigma2" ]   && { Argsigma2="$(maskarg_checkallowed   "$Argmethod" sigma2   "$Argsigma2")"   || Error=1 ; }
    [ -n "$Argword1" ]    && { Argword1="$(maskarg_checkallowed    "$Argmethod" word1    "$Argword1")"    || Error=1 ; }
    [ -n "$Argword2" ]    && { Argword2="$(maskarg_checkallowed    "$Argmethod" word2    "$Argword2")"    || Error=1 ; }
    case $Argmethod in
      blur|comet|compass|diffstat|dog|free|freediff|freichen|gaussian|kirsch|laplacian|log|morphology|prewitt|roberts|sobel|statistic|unsharp|wavelet)
        Arglevel="yes"
      ;;
    esac
    Argtype="$(maskarg_defaultvalue "$Argmethod" type)"
    
#    [ "${Argless}" ] && [ "${Argsoft}" ] && Background="${Background:-enfuse}"
    [ "${Argsoft}" ] && Background="${Background:-enfuse}"
    
    [ "$Maskmethodcount" = "1" ] && Firstmaskmethod="$Argmethod"
  
    case $Argmethod in
      chroma)
        #Argmethod="channel"
        Argword1="HCL"
        Argword2="1"
      ;;
      compose)
        Evaluate_needlist="$Evaluate_needlist max min"
        Compose_needlist="$Compose_needlist $Argword1"
      ;;
      darkness)
        #Argmethod="channel"
        Argword1="HSL"
        Argword2="2"
        Argnegate="yes"
      ;;
      evaluate)
        Evaluate_needlist="$Evaluate_needlist $Argword1"
      ;;
      freichen)
        case $Argword1 in
          10|12|19) Argdiff=yes ;;
        esac
      ;;
      lightness)
        #Argmethod="channel"
        Argword1="HSL"
        Argword2="2"
      ;;
      image)
        [ -e "$Argword1" ] || error "--image needs an image file name as argument. Not found: '$Argword1'"
      ;;
      morphology)
        case $Argword1 in
          edge|edgein|edgeout|tophat|bottomhat) ;;
          *) Argdiff="yes" ;;
        esac
      ;;
      saturation)
        #Argmethod="channel"
        Argword1="HSB"
        Argword2="1"
      ;;
      statistic)
        case $Argword1 in
          gradient|standarddeviation|"") Argdiff="" ;;
          *)                             Argdiff="yes" ;;
        esac
      ;;
    esac
    
    [ "$Globalmaskblur" ] && [ "$Argtype" = "mask" ] && {
      Argmaskblur="$(calc "${Argmaskblur:-0} + $Globalmaskblur")"
    }
    
    maskarg_store "$Maskmethodcount"
  done <<< "$Maskmethodlist"

  [ "$Error" ] && return 1

  # --factor ### FIXME
  [ "$Composefactor" = "auto" ] && {
    case $Argmethod in
      compose)
        case $Maskgeneratorargument in
          blend|colordodge|lighten*|lineardodge|plus|screen) 
            Composefactor="0.5" ;;
          bumpmap|colorburn|colordodge|darken*|linearburn|multiply) 
            Composefactor="2" ;;
          overlay|pegtoplight|pinlight|softburn|softlight)
            Composefactor="1" ;;
          difference|hardlight|linearlight|freeze|reflect|stamp|vividlight)
            Composefactor="1" ;;
          colorize|displace|distort|divide*|exclusion|hardmix|interpolate|minus*|modul*|negate|saturate|softdodge) 
            Composefactor="1" ;;
          atop|blur|changemask|clear|copy*|darken|darkenintensity|dissolve|dst*|hue|in|intensity|mathematics|none|out|over|replace|src*|stereo|xor)
            Composefactor="1" ;;
          *) 
            Composefactor="1" ;;
        esac
      ;;
      *) Composefactor=1 ;;
    esac
    note "Setting --factor=$Composefactor"
  }
  
  # --cutblur
  [ "$Cutblur" = "auto" ] && Cutblur="1"
  
  # --fakehdr
  [ "$Fakehdr" = "auto" ] && Fakehdr="50"
  
  [ "$Finalblur" ] && {
    Argmethod="finalblur"
    [ "$Finalblur" = "auto" ] && Finalblur="w,s"
    maskarg_parse "$Finalblur"
    Finalblurpercent="${Argweight:-$(maskarg_defaultvalue $Firstmaskmethod noise)}"
    Finalblursigma="${Argsigma1:-$(maskarg_defaultvalue finalblur sigma1)}"
  }

  # --grayscale
  case ${Grayscale,,} in
    ""|auto)           Grayscale="RMS" ;;
  esac
  case ${Grayscale,,} in
    0|none)            Grayscalenumber=0 ; Grayscale="none" ;;
    1|rec601luma)      Grayscalenumber=1 ; Grayscale="Rec601Luma" ;;
    2|rec601luminance) Grayscalenumber=2 ; Grayscale="Rec601Luminance" ;;
    3|rec709luma)      Grayscalenumber=3 ; Grayscale="Rec709Luma" ;;
    4|rec709luminance) Grayscalenumber=4 ; Grayscale="Rec709Luminance" ;;
    5|brightness)      Grayscalenumber=5 ; Grayscale="Brightness" ;;
    6|lightness)       Grayscalenumber=6 ; Grayscale="Lightness" ;;
    7|average)         Grayscalenumber=7 ; Grayscale="Average" ;;
    8|ms)              Grayscalenumber=8 ; Grayscale="MS" ;;
    9|rms)             Grayscalenumber=9 ; Grayscale="RMS" ;;
    *)
      error "--grayscale: Unknown argument: $Grayscale"
    ;;
  esac
  case $Grayscale in
    ""|none) Grayscaleconverter="" ;;
    *)       Grayscaleconverter="-grayscale $Grayscale" ;;
  esac
  
  # --denoise
  case $Globaldenoise in
    auto) Globaldenoise="10" ;;
  esac
  
  # --softmode
  case $Globalsoft in
    "") ;;
    *)
      [ "$Globalsoft" = "auto" ] && Globalsoft="$(maskarg_defaultvalue "$Firstmaskmethod" soft )"
      Background="${Background:-enfuse}"
    ;;
  esac
  
  # --layers
  case $Layers in
    auto) Layers="24" ;;
  esac
  
  # --less
  case $Globalless in
    0)    Globalless="" ;;
    auto) Globalless="$(maskarg_defaultvalue "$Firstmaskmethod" less )" ;;
  esac
  
  # --close
  case $Globalclose in
    ""|"0") Globalclose="" ;;
    *)
      [ "$Globalclose" = "auto" ] && Globalclose="$(maskarg_defaultvalue "$Firstmaskmethod" close)"
      Globalclose1=$(cut -dx    -f1 <<< "$Globalclose")
      Globalclose2=$(cut -dx -s -f2 <<< "$Globalclose")
      Globalclose1="$(digitonly "$Globalclose1")"
      Globalclose2="$(digitonly "$Globalclose2")"
      Globalclose1="${Globalclose1:-1}"
      Globalclose2="${Globalclose2:-1}"
      Globalclose="${Globalclose1}x${Globalclose2}"
    ;;
  esac

  # --background
  [ "$Background" ] && {
    checkmagicklist compose  "$Background" && Background="compose,$Background"
    checkmagicklist evaluate "$Background" && Background="evaluate,$Background"
    checkmagicklist color    "$Background" && Background="color,$Background"
  }
  [ -z "$Maskmethodlist" ] && {
    Background="${Background:-enfuse}"
    note "No mask option specified, generating background only: $Background"
  }

  #### Files ####

  # --cachedir
  [ -z "$Cachedir" ]       && Cachedir="$(pwd)/cache.imfuse"
  [ "$Cachedir" = "auto" ] && Cachedir="$(pwd)/cache.imfuse"
  Cachedir="$(sed s%'~'%$HOME% <<< "$Cachedir")"
  Cachedir="$(realpath -m "$Cachedir")"
  
  [ -z "$Sourceimagelist" ] && error "No images specified"
  Sourceimagelist="$(grep .     <<< "$Sourceimagelist")"
  Sourceimagelist="$(sort -V -r <<< "$Sourceimagelist")"
  grep -q ' ' <<< "$Sourceimagelist" && error "imfuse does not accept whitespace in pathes or file names:
$(grep -m1 ' ' <<< "$Sourceimagelist")"
  
  Sourcemd5="$(md5cut "$(ls --full-time $Sourceimagelist)" )"
  
  # --revert
  [ "$Revertimagelist" = "yes" ] && Sourceimagelist="$(tac <<< "$Sourceimagelist")"
  
  # --basename
  case $Basename in
    #"")   Basename="imfuse" ;;
    auto) Basename="$(basename "$(pwd)")" ;;
  esac
  [ -d "$Basename" ] && {
    Outputdir="$Basename"
    Basename=""
  } || {
    Outputdir="$(dirname "$Basename")"
    Basename="$(basename "$Basename")"
  }
  #[ "$Basename" != "$(unspecialstring "$Basename")" ] && error "--basename: Name must not contain special chars or whitespace: '$Basename'"
  
  # --output
  Resultimage="imfuse."
        
  while read Line; do
    maskarg_parse "$Line"   
    Resultimage="${Resultimage}_${Argmethod}="
    [ "$Argweight" ]             && Resultimage="$Resultimage-w$Argweight"
    [ "$Argradius1" ]            && Resultimage="$Resultimage-r$Argradius1"
    [ "$Argsigma1" ]             && Resultimage="$Resultimage-s$Argsigma1"
    [ "$Argradius2" ]            && Resultimage="$Resultimage-R$Argradius2"
    [ "$Argsigma2" ]             && Resultimage="$Resultimage-s$Argsigma2"
    [ "$Argpercent1" ]           && Resultimage="$Resultimage-p$Argpercent1"
    [ "$Argpercent2" ]           && Resultimage="$Resultimage-P$Argpercent2"
    [ "$Argsoft" ]               && Resultimage="$Resultimage-soft$Argsoft"
    [ "$Argless" ]               && Resultimage="$Resultimage-less$Argless"
    [ "$Argclose1" ]             && Resultimage="$Resultimage-close$Argclose1"
    [ "$Argclose2" ]             && Resultimage="${Resultimage}x$Argclose2"
    [ "$Argmaskblur" ]           && Resultimage="$Resultimage-maskblur$Argmaskblur"
    [ "$Argdenoise" ]            && Resultimage="$Resultimage-denoise$Argdenoise"
    [ "$Argswap" ]               && Resultimage="$Resultimage-swap"
    [ "$Argnegate" ]             && Resultimage="$Resultimage-neg"
    [ "$Argthreshold" ]          && Resultimage="$Resultimage-t$Argthreshold"
    case $Argmethod in
      image) ;;
      saturation|chroma|darkness|lightness) ;;
      *) [ "$Argword1" ]         && Resultimage="$Resultimage-$(unspecialstring "$Argword1")" ;;
    esac
    case $Argmethod in
      saturation|chroma|darkness|lightness) ;;
      *) [ "$Argword2" ]         && Resultimage="$Resultimage-$(unspecialstring "$Argword2")" ;;
    esac
  done <<< "$Maskmethodlist"
  case $Fakehdr in
    "") ;;
    *) Resultimage="${Resultimage}_hdr$Fakehdr" ;;
  esac
  case $Globalsoft in
    "") ;;
    *) Resultimage="${Resultimage}_soft$Globalsoft" ;;
  esac
  case $Globalless in
    ""|0) ;;
    *) Resultimage="${Resultimage}_less$Globalless" ;;
  esac
  case $Globalclose in
    "") ;;
    *) Resultimage="${Resultimage}_close$Globalclose" ;;
  esac
  [ "$Cutblur" ] && {
    Resultimage="${Resultimage}_cutblur$Cutblur"
  }
  [ "$Finalblur" ] && {
    Resultimage="${Resultimage}_finalblur=w${Finalblurpercent}-s${Finalblursigma}"
  }
  case $Globaldenoise in
    "") ;;
    *) Resultimage="${Resultimage}_denoise$Globaldenoise" ;;
  esac
  case $Revertimagelist in
    "yes") Resultimage="${Resultimage}_rev" ;;
  esac
  case $Grayscalenumber in
    9) ;;
    *) Resultimage="${Resultimage}_gray$Grayscalenumber" ;;
  esac
  [ "$Background" ] && [ ! -f "$Background" ] && Resultimage="${Resultimage}_bg=$(cut -d, -f2 <<< "$Background")"
  [ "$Background" ] && [   -f "$Background" ] && Resultimage="${Resultimage}_bg=image"
  case $Testsetup in
    "") ;;
    *) Resultimage="${Resultimage}_test$Testarg" ;;
  esac
  Resultimage="$(sed "s/=-/=/g ; s/=_/_/g  ; s/\.\./\./g ; s/\._/\./g ; s/\._/\./g ; s/=$//g ; s/=\./=/g" <<< "$Resultimage")"
  #Resultimage="$(sed "s/=-/=/g ; s/=\./=/g ; s/=$//g" <<< "$Resultimage")"
    
  Fusemd5sum="$(md5cut "$Sourcemd5 $Maskmethodlist $Background $Fakehdr $Globalclose $Globaldenoise $Globalless $Globalsoft $Cutblur $Finalblur $Grayscale $Revertimagelist $Testsetup" )"
  
  Resultimage="${Resultimage}.${Fusemd5sum}.${Imageformat}"
  [ -z "$Outputdir" ] && Outputdir="$(pwd)"
  case $Outputimage in
    "") Outputimage="$Outputdir/$Basename$Resultimage" ;;
    *) [ "$(basename "$Outputimage")" = "$Outputimage" ] && Outputimage="$Outputdir/$Outputimage" ;;
  esac
  Outputimage="$(realpath "$Outputimage")"
  Resultimage="$Cachedir/${Basename:-}$Resultimage"
  
  return ${Error:-0}
}
main() {
  trap trap_sigint SIGINT
  set -u -o pipefail
  
  declare_variables
  multicore_init
  
  command -v convert >/dev/null && Magickbin="convert"
  command -v magick  >/dev/null && Magickbin="magick"
  [ -z "$Magickbin" ] && error "Neither command convert nor magick found. Please install ImageMagick."
  Magickversion="$($Magickbin -version)"
  grep -q " Q8 "   <<< "$Magickversion" && Magickpixelmemory="4"
  grep -q " Q16 "  <<< "$Magickversion" && Magickpixelmemory="8"
  grep -q " HDRI " <<< "$Magickversion" && Magickpixelmemory="16"
  Magicklist="$Magickbin"
  Magickbin="nice $Magickbin -quiet"
  
  Freemem="$(freememory)"
  [ -z "$Freemem" ] && {
    note "WARNING: failed to estimate free memory.
  Blindly guessing 1000 MB."
    Freemem="1000000"
  }
  
  parse_options "$@"
  check_options
  
  # --showname
  [ "$Showname" = "yes" ] && {
    echo $Outputimage
    return "${Error:-0}"
  }
  note "Setting --output=$Outputimage"
  
  # --force
  [ -f "$Outputimage" ] && [ -z "$Forceoverwrite" ] && { 
    note "Skipping all, output image already exists with matching md5sum."
    echo "$Outputimage"
    showimage "$Outputimage"
    return "${Error:-0}"
  }
  
  verbose "Mask options:
$Maskmethodlist
"
  [ "$Error" ] && return 1
  
  Sourceimagelist="$(grep -v -x "" <<< "$Sourceimagelist")"
  Imagenumber="$(grep -c "." <<< "$Sourceimagelist")"
  Imagenumberlength="${#Imagenumber}"
  
  Image="$(head -n1 <<< "$Sourceimagelist")"
  Imagewidth="$($Magickbin  -format '%w' "$Image" info:)"
  Imageheight="$($Magickbin -format '%h' "$Image" info:)"
  Imagememsize="$((Imagewidth*Imageheight*Magickpixelmemory/1000))"
  Imagememsize="$((Imagememsize*125/100))" # by observation. Alpha channel?
  Imagelistmemsize="$((Imagenumber*Imagememsize))"
  Image=""
  
  note "
  Image number:           $Imagenumber
  Image width:            $Imagewidth px
  Image height:           $Imageheight px
  Image memory size:      $Imagememsize kb
  Image list memory size: $Imagelistmemsize kb
  Free Memory:            $Freemem kb"
   
  mkdir -p $Cachedir   || error "Error creating cache folder $Cachedir"
  [ "$Preservecache" ] || rm -f $Cachedir/*
  
  #Firstimage="$(head -n1 <<< "$Sourceimagelist")" 
  [ "$(cat "$Cachedir/md5" 2>/dev/null)" != "$Sourcemd5" ] && rm -r $Cachedir/* 2>/dev/null
  echo "$Sourcemd5" > "$Cachedir/md5"
  [ "$Error" ] && return 1
  
  Enfusebaseimage="$Cachedir/enfuse.$Sourcemd5.tif"
  Testimage="$Cachedir/test.png"

  # --fakehdr
  [ "$Fakehdr" ] && {
    fakehdr "$Fakehdr"
    Imagelist=""
    for Image in $Sourceimagelist; do
      Imagelist="$Imagelist 
$Cachedir/fakehdr*.$(basename "$Image")"
    done
    Sourceimagelist="$(grep . <<< "$Imagelist")"
    Sourcemd5="$(md5cut "$(ls --full-time $Sourceimagelist)" )"
  }
  
  # --background
  Backgroundimage="$Cachedir/background.tif"
  case $Background in
    "") ;;
    *transparent) 
      mkimg_transparent "$Backgroundimage" 
    ;;
    saturation)
      Backgroundimage="$(imfuse --cache="$Cachedir" --basename="$Cachedir/" --saturation --showname $Sourceimagelist)"
      [ -e "$Backgroundimage" ] || {
        note "Generating saturation background image"
        imfuse --cache=$Cachedir --output="$Backgroundimage" --saturation $([ "$Showimageprocessing" = "yes" ] && echo -V) $Sourceimagelist || error "Failed to generate saturation background"
      }
    ;;
    evaluate*)    
      Background="$(lowercase $Background)"
      Background="$(cut -d, -f2 <<< "$Background")"
      Evaluate_needlist="$Evaluate_needlist $Background"
      generate_composite
      Backgroundimage="$Cachedir/evaluate.$Background.$Sourcemd5.tif"
    ;;
    compose*)
      Background="$(lowercase $Background)"
      Background="$(cut -d, -f2 <<< "$Background")"
      Evaluate_needlist="$Evaluate_needlist min max"
      Compose_needlist="$Compose_needlist $Background"
      generate_composite
      Backgroundimage="$Cachedir/compose.$Background.$Sourcemd5.tif"
    ;;
    color*)
      Background="$(cut -d, -f2 <<< "$Background")"
      mkimg_color "$Backgroundimage" "" "$(cut -d, -f2 <<< "$Background")"
    ;;
    enfuse)
      Enfuse_needlist="$Enfuse_needlist enfuse"
      Backgroundimage="$Enfusebaseimage"
    ;;
    *)
      [ -f "$Background" ] && identify "$Background" && $Magickbin "$Background" "$Backgroundimage" || error "Option --background: Failed to load image '$Background'.
  Either specify an image or a color name or a mode out of:
    saturation
    $Magicklist -list color
    $Magicklist -list evaluate
    $Magicklist -list compose"
    ;;
  esac
  [ "$Error" ] && return 1
  
  # Generating stackshot image
  mkimg_transparent "$Resultimage"
  focus_generate_masks                    || return 1
  [ -n "$Maskmethodlist" ] && {
    focus_merge_masks                     || return 1
    maskarg_parse "$(head -n1 <<< "$Maskmethodlist")"
    focus_montage --soft "$Globalsoft" --lessthanmax "$Globalless" --maskstrength="${Argmaskstrength:-1}" --output "$Resultimage"  || return 1
  }

  [ "$Background" ] && {
    $Magickbin "$Backgroundimage" "$Resultimage" -compose Over -composite "$Resultimage" || note "Failed to compose result over background"
  }
  [ "$Layers" ] && layered_sharpness
      
  [ "$Error" ] && return 1

  $Magickbin "$Resultimage" $Tifstorealpha "$Outputimage"  || error "Error storing result in $Outputimage"
  
  # Transfer EXIF metadata from first image to result
  [ "$Exifsourceimage" ] && {
    [ "$Exifsourceimage" = "auto" ] && Exifsourceimage="$(head -n1 <<< "$Sourceimagelist")"
    #exiftool -overwrite_original -tagsfromfile "$Exifsourceimage" -orientation="Horizontal" -rotation="Horizontal" -exifimagewidth=$Imagewidth -exifimageheight=$Imageheight -all:all  "$Outputimage" >/dev/null || note "Failed to transfer exif data"
    exiftransfer "$Exifsourceimage" "$Outputimage"
  }

  showimage "$Outputimage"
  note "Ready after $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")"
  echo "$Outputimage"
    
  return "${Error:-0}"
}
main "$@"
[ -z "$Preservecache" ] && [ -d "$Cachedir" ] && rm -R "$Cachedir"
exit "${Error:-0}"
