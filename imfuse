#! /bin/bash

# imfuse
Version="0.6.12-beta"

# ToDo:
#
# imfuse:
# --slab
# BUG: levelU kills data near 0% (--test pyramid)
# add w to each mask if n>1
# --level for --soft?
# redist() fails with b&w masks -> clut and result black
# --revert: broken
# ARG close: how to match --close ARG?
# whitespace in file names -> file names into array
# --maskblur altogether?
# --gamma?
# check --kirsch
# drop --unsharp?
# drop --denoise?
# --denoise after merge?
# drop --halo?
# find halo solution
# check exiftransfer / damaged one Beerenwanze or Spinne image
#
# stackfuser: 
# BUG fakehdr is missing
# BUG exiftransfer wrong after reverse-order or block-evaluate

usage() {
  echo "imfuse v$Version
Combines focus stackshot images to one overall sharp image.

Note that imfuse expects already aligned input images.
It assumes that the alphanumerical order of the input images goes from
top to bottom; for the other way around use option --revert.

Dependencies:
  imagemagick         Mandatory (command 'convert' or 'magick').
  enfuse              Recommended, needed for some options.
  geeqie              Optional, used by option -V, --showimage.
  exiftool            Optional, to transfer metadata from first image to result.

Usage:
  imfuse [OPTIONS] -- image1 image2 image3 ...

General options:
     --basename [=NAME]   Base name [+path] for output image. 
     --cache [=DIR]       Preserve cache files, can be partially reused.
                          Optionally specify a cache folder DIR.
     --exif [=IMAGE]      Transfer exif meta data from IMAGE or first image.
 -h, --help               Show this help and exit.
     --layers [=NUMBER]   Additonally store a layered TIFF image where
                          the layers contain different sharpness areas.
                          NUMBER is number of sharpness layers.  Default: 24
 -o, --output=FILE        Result image file name.
     --savemask [=FILE]   Store contrast mask in file FILE.
     --threads            Number of parallel threads to run at once.
                          Default: number of CPU's (nproc).
 -v, --verbose            Show verbose output.
     --version            Show imfuse version and exit.
 -V, --showimage          Show intermediate results with image viewer geeqie.
     --video              Generate a video of shown intermediate images.
 -W                       Show result with image viewer viewnior.

The mask generating options below can take additionally arguments [=ARG].
Multiple arguments are comma-separated. 
  Example: --morphology=r3,less20,close,maskblur --saturation=w50
Arguments taken by all mask options:
  w         Mask weight. Percent value from 0 to 100.
            Of interest if specifying more than one mask generation method.
            Example: --morphology --saturation=w25
            This will generate two masks. The saturation mask will only have
            noteable effect where the morphology mask strength is below 25%.
  less      Compare option --less, here applied for single mask only.
  alpha     Compare option --alpha, here applied for single mask only.
  maskblur  Compare option --maskblur, here applied for single mask only.
  denoise   Compare option --denoise, here applied for single mask only.
  negate    Negate/invert the mask. Rarely needed.
Arguments taken by few options only:
  r         Radius. Must be an integer value.
            Increased radius mostly causes less noise, less details and
            more contrast. Smaller radius causes more details and more noise.
  s         Sigma. Takes non-integer values like 0.75.
            Increased sigma mostly causes less noise, less details and
            more contrast. Smaller sigma causes more details and more noise.
  S         Second Sigma. Taken only optionally by --dog.
  p         Percent value.
  (words)   Some options take one or two word arguments.


Contrast mask options:
 --blur [=ARG]        Blur edge detection. 
                      Similar to --gaussian, but faster and less accurate.
                      ARG additionally takes argument: 
                        s       sigma                Default: 0.75
 --comet [=ARG]       Comet edge detection. Compares rotated mean areas.
                      ARG additionally takes arguments: 
                        s       sigma                Default: 5
                        (word)  MODE                 Default: Lighten
                      MODE can be one of '$(basename $Magicklist) -list compose'
                      Recommended: Lighten, Darken.
 --compass [=ARG]     Compass edge detection. 
 --dog [=ARG]         Difference of Gaussian. 
                      ARG additionally takes arguments: 
                        s       sigma                Default: 0.3
                        S       sigma2               Default: 1.6*sigma1
 --diffstat [=ARG]    Compares two local statistics of source images. 
                      Uses ImageMagick option -statistic. Compare --statistic.
                      ARG additionally takes arguments: 
                        r       radius               Default: 3
                        (word)  STAT1                Default: median
                        (word)  STAT2                Default: mean
                      Possible STAT1 and STAT2:
                        0|none|source
                        1|gradient|grad
                        2|maximum|max
                        3|mean
                        4|median
                        5|minimum|min
                        6|mode
                        7|nonpeak
                        8|9|rms|rootmeansquare
                        10|standarddeviation|dev
                      Most interesting alternative is a max,min difference.
 --free [=ARG]        Custom ImageMagick option for mask generation.
                      ARG is an arbitrary ImageMagick command, but must not
                      contain a comma.               Default: '-sharpen 0x3'
 --freediff [=ARG]    Custom ImageMagick option for mask generation.
                      The resulting mask  will be a '-compose Difference' 
                      comparision with the source image.
                      ARG is an arbitrary ImageMagick command, but must not
                      contain a comma.
 --freichen [=ARG]    Frei-Chen edge detection. 
                      ARG additionally takes arguments: 
                        (word)  MODENUMBER
                      Possible MODENUMBERs at:
                      http://www.imagemagick.org/Usage/convolve/#freichen
                      Default: A combination of modes 1 and 2.
 --gaussian [=ARG]    Gaussian blur edge detection. 
                      Similar to --blur, but slower and more accurate.
                      ARG additionally takes argument: 
                        s       sigma                Default: 0.3
 --kirsch [=ARG]      Kirsch edge detection. 
 --laplacian [=ARG]   Laplacian edge detection.
                      ARG additionally takes arguments: 
                        (word)  MODENUMBER           Default: 3
                      Possible MODENUMBERs at:
                      http://www.imagemagick.org/Usage/convolve/#laplacian
 --log [=ARG]         Laplacian of Gaussian.
                      ARG additionally takes argument: 
                        s       sigma                Default: 0.2
 --morphology [=ARG]  Morphology edge detection.
                      ARG additionally takes arguments: 
                        r       radius               Default: 2
                        (word)  MODE                 Default: edge
                      MODE can be one of '$(basename $Magicklist) -list morphology'
                      Some MODEs of interest:
                        edge, dilateintensity, smooth
 --prewitt [=ARG]     Prewitt edge detection. 
 --roberts [=ARG]     Roberts edge detection. 
 --sobel [=ARG]       Sobel edge detection. 
 --statistic [=ARG]   ImageMagick option -statistic.
                      ARG additionally takes arguments: 
                        r       radius               Default: 2
                        (word)  STAT                 Default: standarddeviation
                      Argument STAT is one of (number or name):
                        1|gradient|grad
                        2|maximum|max
                        3|mean
                        4|median
                        5|minimum|min
                        6|mode
                        7|nonpeak
                        8|9|rms|rootmeansquare
                        10|standarddeviation|dev
                      Get an impressive strong contrast with a high radius.
 --unsharp [=ARG]     Difference of -unsharp.
                      ARG additionally takes argument: 
                        s       sigma                Default: 2
 --wavelet [=ARG]     Based on ImageMagick option -wavelet-denoise.
                      ARG additionally takes arguments:
                        p       percent               Default: 10

Image comparision mask options: (Intended for artefact removal)
 --compose [=ARG]     Composes evaluated min,max of source images with MODE.
                      ARG additionally takes arguments:
                        (word)   MODE                Default: overlay
                      Adding a '2', e.g. '--compose=overlay2' swaps min,max
                      to max,min and can give a different result.
                      MODE can be one of '$(basename $Magicklist) -list compose'
                      Some MODEs of interest:
                        overlay interpolate colordodge hardlight reflect 
                        softburn softlight linearlight pegtoplight
 --enfuse [=ARG]      Image comparision with a basic enfuse result.
 --evaluate [=ARG]    Evaluates from all source images with mode MODE and
                      compares the result with each source image.
                      ARG additionally takes arguments:
                        (word)   MODE                Default: max
                      MODE can be one of '$(basename $Magicklist) -list evaluate'
                      Compare --max, --min, --mean, --median.
 --halo [=ARG]        Remove light halo of white background (overexposure).
                      ARG additionally takes arguments:
                        p        percent             Default: 25
                        r        radius              Default: 2
                        s        sigma               Default: 5
                      Greater percent removes more light.
                      sigma is a -blur sigma for a soft cut.
                      radius is a kernel radius.
                      Needs high 'weight' values even greater than 100.
                      Well to combine with --darkness.
                      Alternative option: --fakehdr
 --image [=ARG]       Loads an image and generates masks based on 
                      similarity with source images.
                      ARG additionally takes arguments:
                        (word)   An image file name
 --max [=ARG]         Same as --evaluate=max. Brightest pixels of stack.
                      Result is similar to --lightness.
 --mean [=ARG]        Same as --evaluate=mean. Average of pixels in stack.
 --median [=ARG]      Same as --evaluate=median. Median pixel of stack.
 --min [=ARG]         Same as --evaluate=min. Darkest pixels of stack.
                      Result is similar to --darkness.
                           
Colorspace channel mask options: (Intended for artefact removal)
(All are variations of --channel, most of interest is --saturation)
 --channel [=ARG]     Use a colorspace channel as mask.
                      ARG additionally takes arguments:
                        (word)   Colorspace           Default: HSL
                        (word)   Color channel        Default: 1
                      Colorspace can be one of '$(basename $Magicklist) -list colorspace'
                      The color channel is a number from 0..31.
 --chroma [=ARG]      Chroma channel from HCL colorspace.
 --darkness [=ARG]    Negated lightness channel from HSL colorspace.
                      Dark result, similar to --min.
 --lightness [=ARG]   Lightness channel from HSL colorspace. 
                      Bright result, -similar to --max.
 --saturation [=ARG]  Saturation channel from HSB colorspace.

Mask generation and fusion adjustments:
 --alpha [=LEVEL]     Generate transparent image using the contrast mask as 
                      alpha channel (=transparency channel).
                      Good method to reduce noise in low contrast areas.
                      The semitransparent result is composed over a background.
                      Default background is 'transparent'.
                      Can take an argument as one or two percent values.
                      Simplified usage: If only one value is given, 
                      positive values make the image more transparent and 
                      negative values make it less transparent.
                      Advanced usage: Two percent values A%xB% are applied
                      as '+level A%xB%' on the transparency alpha channel.
                      This allows to adjust transparency of low contrast areas 
                      with A% and of high contrast areas with B%. 
                      Negative values and higher than 100% are possible.
                      Try script 'demo-alphalevel' to understand the effects.
 --bg, --background BG    Specify a background to paint on. Default: enfuse
                      BG can be an image name or one out of:
                        enfuse
                        saturation
                        transparent
                        $Magicklist -list color
                        $Magicklist -list evaluate (compare --evaluate)
                        $Magicklist -list compose  (compare --compose)
                      Useful with options --alpha and --threshold.
                      Recommendations: enfuse saturation mean max min
                                       colorize colorize2 pinlight pinlight2
                      Interesting: interpolate overlay pegtoplight reflect
 --close [=ARG]       Closes gaps between nearby contrast lines to mark the 
                      area in between as strong contrast, too.
                      Can reduce artefacts in partial transparent objects.
                      Helps e.g. to strengthen thin shiny objects like hairs.
                      Takes arguments similar to contrast mask ARG:
                        r        kernel iteration    Default: 2
                        R        radius              Default: 2
                        p        threshold           Default: 25
                      Multiplying r and R results in the real radius applied.
                      A multiplied value like 3x4 (r3,R4) is faster than 
                      setting one of r oder R to 12.
                      Percent p is a threshold value; --close is only applied
                      to contrast areas stronger than percent p.
 --cutblur [=SIGMA]   Blur cut masks in final montage. Default SIGMA: 2
 --cutsoft [=SIGMA]   Similar to --cutblur, but composes default sharp cut mask
                      over blurred cut mask. Default SIGMA: 2
 --darkenmask=MASK    Use mask image MASK to darken the merged contrast masks.
                      (Special use cases, needed for script slab.)
 --denoise [=%]       Experimental option to remove noise in low contrast areas.
                      The percent value is a threshold. 
                      Rather use --alpha or --finalblur.
 --fakehdr [=%]       Balances over- and underexposed areas. Default %: 40
                      Remaining artefacts at borders of overexposured areas
                      might be fixed with --saturation. Alternative: --halo
 --finalblur [=p%,sSIGMA1,Ssigma2]   Soft blur of bokeh. Blurs low contrast 
                      areas with a contrast strenght up to % with SIGMA1.
                      Default %: 50, default SIGMA1: 3, default sigma2: 2
                      If sigma2 is given, the cut border between bokeh and 
                      foreground is blurred for a soft transition.
 --grayscale=MODE     Grayscale converting method before mask generation.
                      Compare ImageMagick option -grayscale. Default: RMS
                      MODE is one of: (number or name)
                0 none             No grayscale conversion. Barely tested.
                1 Rec601Luma       0.298839R' + 0.586811G' + 0.114350B'
                2 Rec601Luminance  0.298839R  + 0.586811G  + 0.114350B
                3 Rec709Luma       0.212656R' + 0.715158G' + 0.072186B'
                4 Rec709Luminance  0.212656R  + 0.715158G  + 0.072186B
                5 Brightness       max(R', G', B')
                6 Lightness        (min(R', G', B') + max(R', G', B')) / 2.0
                7 Average          (R' + G' + B') / 3.0
                8 MS               (R'^2 + G'^2 + B'^2) / 3.0
                9 RMS              sqrt( (R'^2 + G'^2 + B'^2) / 3.0 )
 --less [=%]          Strenghtens less contrasted objects in front of strong
                      contrasted background objects. 
                      Well to combine with --close and / or --cutblur.
                      Percent value % is the minimum intermediate contrast
                      difference between background and foreground object.
                      Default % depends on first mask, mostly 45% or 60%.
                      (If also using color channel or image comparision masks,
                      rather use 'less' as a mask argument than globally.)
 --maskblur [=SIGMA]  Blur masks with SIGMA (default 1). Enhances contrast.
                      Applied to contrast masks only.
 --merge [=COMPOSE]   Compose mode to merge multiple masks. Default: Plus
                      Of interest: Screen Interpolate Multiply Exclusion Blend
 --prefertop [=%]     Prefer top layer images up to %. Default %: 20
                      Similar to --less, but a rather brute-force attempt.
 --sigmoidalclut [=CONTRASTxMIDPOINT]   Change grayscale distribution of 
                      contrast masks along a sigmoidal curve. 
                      Helps to strenghten high contrast areas and to weaken
                      low contrast areas. Main use case is option --soft.
                      CONTRAST bends the curve; the higher, the stronger.
                      MIDPOINT is the inflection point of the curve in percent.
                      Compare IM option -sigmoidal-contrast.
                      Default CONTRAST: 10, default MIDPOINT: 50%
 --slab [=LAYERS]     Split stack into LAYERS different stacks and fuse them
                      separately. Fuse these results afterwards with increased
                      sigma and radius.
 --soft [=CONTRASTxMIDPOINT]   Enable soft fusion mode. Different concept than 
                      default maximum contrast montage. Images are multiplied 
                      with their contrast masks and added altogether as a whole.
                      For arguments compare --sigmoidalclut.
                      Does not support --less and --cutblur.
 --threshold [=%,sSIGMA] Make low contrast area transparent. Default %: 50
                      Set SIGMA to blur the cut mask border. Default SIGMA: 0
                           
Basics:                   
Fusing a focus stack aims to generate an overall sharp image of several single
captures that only show partial sharp areas.
Sharp areas show more contrast and detail than blurry unsharp areas.

So one important part is to find areas with a lot of contrast and detail.
This is done with the contrast mask options. From each source image the area
with more contrast than all other source images will be part of the result.

Artefacts / stack failures:
The attempt to get the strongest contrast areas out of the source images
has some weaknesses and can lead to artefacts.

 - Low contrast noise artefacts:
  All contrast mask methods give unsatisfying results in areas that have low 
  contrast on all source images of the stack.
  Possibilities:
   - Option --alpha gives a quite satisfying result for low contrast noise areas.
     Example: '--diffstat --alpha' or '--diffstat=alpha'
   - Another possibility to soften the noise is option --finalblur.
     Example: '--diffstat --finalblur=w25,s2'
   - Combining the contrast mask with a color saturation mask.
     Example: '--diffstat --saturation=w25'
     (Weight argument 'w25' causes the saturation mask to take effect only 
     in low contrast areas (<=25%) of the '--diffstat' mask.)
  
 - Objects in foreground with background artefacts:
  Sometimes objects in background result in a stronger contrast mask than
  objects in foreground. The foreground object will be incomplete.
  This can be fixed with option --less, additionally --cutblur or --close.
  
Examples:
Have a folder 'stackshot' containing all stack source images.
Go to the folder above 'stackshot'.
  Run imfuse with:
    imfuse -V --cache --diffstat stackshot/*
  You might be unsatisfied with low contrast areas. Try:
    imfuse -V --cache --diffstat --saturation=w50       stackshot/*
    imfuse -V --cache --diffstat --alpha                stackshot/*
  You might have incomplete foreground objects. Try:
    imfuse -V --cache --diffstat --alpha --less --close stackshot/*
"
}

### Messages

error() {
  [ -z "${Error:-}" ] && echo "imfuse ERROR: $*
" >&2
  Error=1
  #exit 1
}
note() {
  [ -z "${Error:-}" ] && echo "imfuse note: $*
" >&2
  return 0
}
verbose() {
  [ "$Verbose" = "yes" ] && echo "imfuse: $*" >&2
  return 0
}
showimage() {
  local Frame
  [ "$Showimageprocessing" = "yes" ] && geeqie -t -r --File:"${1:-}"
  #[ "$Showimageprocessing" ] && bash imgview "${1:-}"
  [ "$Video" ] && {
#    Videoframecount="$((Videoframecount+1))"
    Videoframecount="$(ls $Cachedir/videoframe????.* | sort -V | tail -n1)"
    Videoframecount="$(basename "$Videoframecount")"
    Videoframecount="${Videoframecount//[^0-9]/}"
    Videoframecount="$(sed "s/^0*//" <<< "$Videoframecount")"
    Videoframecount="$(calc "$Videoframecount+1")"
    Frame="$Cachedir/videoframe$(printnum "$Videoframecount" 4).tif"
    #ln -s "${1:-}" "$Frame"
    cp "${1:-}" "$Frame" ### FIXME ln -s where possible
  }
  return 0
}

### Misc

calc() {
  awk "BEGIN {print $* }"
}
comma2whitespace() {
  #sed "s/,/ /g" <<< "${1:-}"
  echo "${1//,/ /}"
}
digitonly() {
  #sed "s/[^0-9.]//g" <<< "${1:-}"
  echo "${1//[^0-9.]/}"
}
digitrm() {
  #sed "s/[0-9.]//g" <<< "${1:-}"
  echo "${1//[0-9.]/}"
}
freememory() {
  local Freemem Line Zram
  Freemem="$(LC_ALL=C free | grep "Mem:" | awk '{print $7}')"
  while read Line; do
    Zram="$(awk '{print ($3 - $4)}' <<< "$Line")"
    Zram="$((Zram/1000))"
    Freemem="$((Freemem + Zram))"
  done < <(/sbin/swapon --bytes | grep zram)
  Freemem="$((Freemem*100/80))"
  echo $Freemem
}
levelparse() {
  local String Part1 Part2
  String="${1:-}"
  String="$(tr -d '%' <<< "$String")"
  grep -q "x" <<< "$String" && {
    Part1="$(cut -dx    -f1 <<< "$String")"
    Part2="$(cut -dx -s -f2 <<< "$String")"
    :
  } || {
    Part1="$((0-String))"
    Part2="$((100-String))"
  }
  echo "${Part1}x${Part2}"
}
levelpercent() {
  local String Part1 Part2
  String="${1:-}"
  String="$(tr -d '%' <<< "$String")"
  Part1="$(cut -dx    -f1 <<< "$String")"
  Part2="$(cut -dx -s -f2 <<< "$String")"
  echo "${Part1}%x${Part2}%"
}
lowercase() {
    # Usage: lowercase "string"
    printf '%s\n' "${1,,}"
}
md5cut() {
  # print last 6 digits
  md5sum <<< "${1:-}" | cut -c27-32
}
parse_percent() {
  local Percent
  Percent="${1:-}"
  Percent="$(tr -d 'p%' <<< "$Percent")"
  [ "$Percent" = "$(digitonly "$Percent")" ] || {
    error "Invalid percent value: ${1:}"
    return 1
  }
  echo "$Percent"
}
percentrm() {
  # remove % from string
  #sed s/%//g <<< "${1:-}"
  echo "${1//%/}"
}
printnum(){
  # print number $1 with leading zeroes.
  # $1 number
  # $2 digits. Default: 3
  printf %0${2:-3}d "${1:-0}"
}
unspecialstring() {
  # Replace all characters except those described in "a-zA-Z0-9_" with a '-'. 
  # Replace newlines, too.
  # Remove leading and trailing '-'
  # Avoid double '--'
  # Return empty string if only special chars are given.
  printf %s "${1:-}" | LC_ALL=C tr -cs "a-zA-Z0-9._" "-" | sed -e 's/^-// ; s/-$//'
}

#### run commands on all CPUs

multicore() {
  # Run multiple processes in parallel, but not more than $Multicore_maxprocesses
  # $1 Command
  # $2 Image to show if $1 is finished
  # Run multicore_wait afterwards to wait for the last processes to finish.
  
  local Process Command= Commandargs=
  local Mem_needed Zram
  local Longoptions Parsedoptions
  local Showimage Memory
  
  Longoptions="showimage:,memory"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"  
  while [ "$#" -gt 0 ]; do
    case "${1:-}" in
      --showimage) Showimage="${2:-}" ; shift ;;
      --memory)    Memory="${2:-}" ; shift ;;
      --) ;;
      *)
        [ -z "$Command" ] && Command="${1:-}" || Commandargs="$Commandargs '${1:-}'"
      ;;
    esac
    shift
  done

  [ "$Multicore_processcount" = "$Multicore_maxprocesses" ] && {
    multicore_wait || return 1
  }
  [ "$Multicore_processcount" = "0" ] && Multicore_memorymax="$(freememory)"  
  Mem_needed=0
  for Process in $(seq $Multicore_maxprocesses); do
    Mem_needed="$(awk "BEGIN {print $Mem_needed + ${Multicore_memory[$Process]:-0} }" )"
  done
  Mem_needed="$((Mem_needed+${3:-0}))"
  [ "$Mem_needed" -gt "$Multicore_memorymax" ] && {
    note "multicore: Low memory. Waiting for $Multicore_processcount running processes to finish. Need: $((Mem_needed/1000)) MB, Available: $((Multicore_memorymax/1000)) MB"
    [ "$Mem_needed" -gt "$Multicore_memorymax" ] && [ "$Multicore_processcount" = "0" ] && note "multicore: Likely hard disk cache will be used and slow down the calculation."
    multicore_wait || return 1
  }
  
  ifcmdbreak && return 1

  Multicore_processcount=$((Multicore_processcount +1))

  case $(type -t "$(cut -d ' ' -f1 <<< "$Command")") in
    file) Command="nice $Command" ;;
    *)    ;;
  esac
  
  #verbose "multicore: ${1:-}"
  Command="${Command//[$'\t\r\n']}"
  Command="$(sed 's/(/\\(/g ; s/)/\\)/g ; s/>/\\>/g' <<< "$Command")"
  eval "$Command $Commandargs" &
  
  Multicore_process[Multicore_processcount]=$!
  Multicore_image[Multicore_processcount]="${Showimage:-}"
  Multicore_memory[Multicore_processcount]="${Memory:-0}"
  
  return 0
}
multicore_wait() {
  local Process= Error=
  for Process in $(seq $Multicore_maxprocesses); do
    [ "${Multicore_process[$Process]}" ] && {
      multicore_waitprocess "${Multicore_process[$Process]}" || {
        multicore_break
        Error=1
      }
      [ "$Error" ] && break
      [ "${Multicore_image[$Process]}" ] && showimage "${Multicore_image[$Process]}"
    }
    Multicore_process[$Process]=""
    Multicore_image[$Process]=""
    Multicore_memory[$Process]="0"
  done
  [ "$Error" ] && return 1
  Multicore_processcount=0
  return 0
}
multicore_waitprocess() {
  local Error=
  while sleep 0.2 ; do
    ps -p "${1:-}" >/dev/null || break
    ifcmdbreak && Error=1
    [ "$Error" ] && break
  done
  [ "$Error" ] && return 1
  wait "${1:-}"
  return $?
}
multicore_break() {
  local Process  
  for Process in $(seq $Multicore_maxprocesses); do
    [ "${Multicore_process[$Process]}" ] && {
      kill "${Multicore_process[$Process]}"
      wait "${Multicore_process[$Process]}"
      Multicore_process[$Process]=""
      Multicore_image[$Process]=""
      Multicore_memory[$Process]="0"
    }
  done
}
multicore_init() {
  # declare global variables
  local Process
  [ -z "${Multicore_maxprocesses:-}" ] && Multicore_maxprocesses="$(nproc)"
  Multicore_maxprocesses="${Multicore_maxprocesses:-1}"
  for Process in $(seq $Multicore_maxprocesses); do
    Multicore_process[$Process]=""
    Multicore_image[$Process]=""
    Multicore_memory[$Process]="0"
  done
  Multicore_processcount=0
  Multicore_minram=250000
  Multicore_maxprocesses=$Multicore_maxprocesses
}
ifcmdbreak() {
  return 1
}

### Files

checkmagicklist() {
  $Magicklist -list "${1:-}" | grep -q -w -i "^${2:-XXX}"
}
maskexist() {
  local Basename Masklist
  Basename="${1:-$Argbasename}"
  Masklist="$(masklist "$Basename")"
  Masknumber="$(grep -c . <<< "$Masklist")"
  [ "$Masknumber" = "$Imagenumber" ] && return 0 || return 1
}
masklist() {
  local Basename List
  Basename="${1:-$Argbasename}"
  ls $Cachedir/$Basename.* 2>/dev/null
  #List="$(find $Cachedir -regextype sed -regex "$Cachedir/${Basename}.[0-9]\{$Imagenumberlength\}.tif")"
  #echo "$List" >&2
  #echo "$List"
  #find $Cachedir -regextype sed -regex "$Cachedir/${Basename}.[0-9]\{$Imagenumberlength\}.tif"
}

### image processing helpers

alphalevel() {
  local Command Image Mask Level Clut= Clutimage
  local Longoptions Parsedoptions
  
  Longoptions="image:,mask:,level:,clut:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --image)        Image="${2:-}" ; shift ;;
      --mask)         Mask="${2:-}"  ; shift ;;
      --level)        Level="${2:-}" ; shift ;;
      --clut)         Clut="${2:-}"  ; shift ;;
    esac
    shift
  done
  
  [ -z "$Image" ] && return 1
  Level="${Level:-0x100}"
  Level="$(levelparse "$Level")"
  Level="$(levelpercent "$Level")"
  
  [ "$Clut" ] && {  
    Clutimage="$Cachedir/clutmask-$Clut.tif"
    [ -e "$Clutimage" ] || {
      $Magickbin -size 256x256 gradient: -rotate 90 -depth 16 -sigmoidal-contrast ${Clut}% "$Clutimage" || error "alphalevel(): Error in clut $Clut%"
      showimage "$Clutimage"
    }
  }
  
  Command="$Magickbin
  '$Image'
    -write mpr:image
    -delete 0"
  case "$Mask" in
    "")
      Command="$Command
  mpr:image
    -channel alpha
    -separate
    -write mpr:mask
    -delete 0"
    ;;
    *)
      Command="$Command
  $Mask
    -write mpr:mask
    -delete 0"
    ;;
  esac
  
  [ "$Clut" ] && Command="$Command
  mpr:mask
  $Clutimage
    -clut
    -write mpr:mask
    -delete 0"
    
  Command="$Command
  mpr:mask
    +level $Level
    -write mpr:mask
    -delete 0"
    
  case "$Mask" in
    "") ;;
    *)
      Command="$Command
  mpr:mask
    -write $Mask
    -delete 0"
    ;;
  esac
  
  Command="$Command
  mpr:image
  mpr:mask
    -alpha off
    -compose CopyOpacity -composite
    $Tifstorealpha
  $Image"
  
  multicore --showimage "$Image" -- $Command || error "Error in alphalevel(): $Parsedoptions"
  multicore_wait                             || error "Error in alphalevel(): $Parsedoptions"
  return ${Error:-0}
}
clut_gaussian() {
  local Clutimage Sigma
  Clutimage="${1:-}"
  Sigma="${2:-1}"
  $Magickbin -size 1x1 xc:white -bordercolor Black -border 2x0 -filter gaussian -define filter:sigma=$Sigma -resize 512x256! -crop 50%x100%+0+0 -auto-level "$Clutimage"
}
denoisecode() {
  echo "
    -write mpr:denoisemask
    -delete 0
  mpr:denoisemask
    -threshold ${1:-10}%
    -negate
    -transparent white
    -write mpr:cutmask
    -delete 0
  mpr:denoisemask
    -wavelet-denoise 50%
  mpr:cutmask
    -alpha off -compose CopyOpacity -composite
    -write mpr:blurlowcontrast
    -delete 0
  mpr:denoisemask
  mpr:blurlowcontrast
    -compose over -composite
"
}
evaluate() {
  local Sourceimagelist Resultimage Mode
  local Startzeit Dauer Restzeit
  local Split
  
  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  Sourceimagelist=""
  while [ $# -gt 0 ]; do
    Sourceimagelist="$Sourceimagelist
${1:-}"
    shift
  done
  Sourceimagelist="$(grep . <<< "$Sourceimagelist")"
  
  Split="$((Imagelistmemsize/Freemem +1))"
  
  note "evaluating $Mode: $Resultimage"
  Startzeit="$(date +%s)"
  case $Split in
    1)
      $Magickbin $Sourceimagelist -alpha off -evaluate-sequence "$Mode" $Tifstore "$Resultimage" || error "Error in evaluate(): $Mode"
    ;;
    *)
      case $Mode in
        min|max|mean)
          evaluate_stepwise "$Mode" "$Resultimage" $Sourceimagelist
        ;;
        *)
          evaluate_split "$Mode" "$Resultimage" $Sourceimagelist
        ;;
      esac
    ;;
  esac
  Dauer="$(( $(date +%s)-Startzeit))"
  verbose "evaluate() $Mode duration: $(date -u -d @$Dauer +"%T")"
  showimage "$Resultimage"
}
evaluate_split() {
  # -evaluate-sequence for images exceeding RAM
  # If needed, splits source images in smaller parts and puts them together after evaluating them
  # Slow, but reliable.
  # Needs global $Freemem

  local Sourceimagelist Resultimage Mode
  local Image Split Splitpercent Showsplit Part Partimage Partimagelist=
  local Startzeit Dauer Restzeit Count
  
  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  Sourceimagelist=""
  while [ $# -gt 0 ]; do
    Sourceimagelist="$Sourceimagelist
${1:-}"
    shift
  done
  Sourceimagelist="$(grep . <<< "$Sourceimagelist")"
  
  Split="$((Imagelistmemsize/Freemem +1))"

  note "Generating $Mode image $(basename "$Resultimage") in $Split parts."
  case $Split in
    1) 
      Startzeit="$(date +%s)"
      $Magickbin $Sourceimagelist -evaluate-sequence $Mode $Tifstore $Resultimage || error "Error in evaluate_split / $Mode"
      Dauer="$(( $(date +%s)-Startzeit))"
      verbose "Duration: $(date -u -d @$Dauer +"%T")"
    ;;
    *)
      Startzeit="$(date +%s)"
      Splitpercent="$((100/Split))"
      Showsplit="$(printnum $(( (Split+1)/2 )) 3)"
      Count="0"
      for Sourceimage in $Sourceimagelist; do
        [ "$Error" ] && break
        Count="$((Count+1))"
        verbose "Splitting image $Count / $Imagenumber into $Split pieces due to low memory: $(basename $Sourceimage)"
        $Magickbin $Sourceimage -crop 100%x${Splitpercent}% $Tifstore $Cachedir/split%03d.$(basename $Sourceimage).tif || error "Error in evaluate_split / crop"
        showimage $Cachedir/split${Showsplit}.$(basename $Sourceimage).tif
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
      done
      Startzeit="$(date +%s)"
      for Part in $(seq 0 $((Split-1))) ; do
        [ "$Error" ] && break
        verbose "Evaluating part $((Part+1)) / $Split"
        Partimage=$Cachedir/$Mode.part$Part.tif
        $Magickbin $Cachedir/split$(printnum $Part 3).*.tif -alpha off -evaluate-sequence $Mode $Tifstore $Partimage || error "Error in evaluate_split / evaluating parts"
        Partimagelist="$Partimagelist $Partimage"
        showimage $Partimage
        Dauer="$(( $(date +%s)-Startzeit))"
        Restzeit="$(( Dauer*(Split-Part+1) / (Part+1) ))"
        [ "$Restzeit" -lt "0" ] && Restzeit="$((Restzeit*-1))"
        verbose "Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
      done
      [ "$Error" ] && return 1
      $Magickbin $Partimagelist -append $Tifstore $Resultimage  || error "Error in evaluate_split / appending parts"
    ;;
  esac
  showimage $Resultimage
  return "${Error:-0}"
}
evaluate_stepwise() {
  # same as evaluate-sequence max or min,
  # but loads images one by one into ram instead of altogether.
  # $1 mode. Supported: max min 
  # $2 result image
  # $@ source images
  
  local Mode Composemode Resultimage Sourceimagelist Command Line Firstimage Count
  local Startzeit Dauer

  Mode="${1:-}" ; shift
  Resultimage="${1:-}" ; shift
  Firstimage="${1:-}" ; shift
  Sourceimagelist=""
  while [ $# -gt 0 ]; do
    Sourceimagelist="$Sourceimagelist
${1:-}"
    shift
  done
  Sourceimagelist="$(grep . <<< "$Sourceimagelist")"
  
  case $Mode in
    max) Composemode="Lighten" ;;
    min) Composemode="Darken" ;;
    mean) ;;
    *) 
      error "evaluate_stepwise(): Unsupported mode: $Mode"
      return 1
    ;;
  esac
  
  case $Mode in
    min|max)
      Command="$Magickbin
  $Firstimage"
      while read Line; do
        Command="$Command
  $Line
    -alpha off
    -compose $Composemode -composite"
      done <<< "$Sourceimagelist"
      Command="$Command 
  $Resultimage"
    ;;
    mean)
      Command="$Magickbin
  $Firstimage"
      Count=1
      while read Line; do
        Count="$((Count+1))"
        Command="$Command
  $Line
    -alpha off
    -compose blend
    -set option:compose:args $(calc 100/$Count)
    -composite"
      done <<< "$Sourceimagelist"
      Command="$Command
  $Resultimage"
    ;;
  esac

  Startzeit="$(date +%s)"
  verbose "evaluate_stepwise(): $Mode $Resultimage"
  $Command || {
    error "Error in evaluate_stepwise():
$Command"
  return 1
  }
  Dauer="$(( $(date +%s)-Startzeit))"
  verbose "Duration: $(date -u -d @$Dauer +"%T")"
  showimage "$Resultimage"
}
exiftransfer() {
  # Transfer exif data from image $1 to image $2
  # Does not transfer image size information.
  # Sets orientation tag to horizontal / no rotation.
  # Several warnings are supressed.
  local Sourceimage Destinationimage Exifargs
  
  Sourceimage="${1:-}"
  Destinationimage="${2:-}"
  Exifargs="$(exiftool -a -u -g1 -args "$Sourceimage")"
  Exifargs="$(LC_ALL=C grep -v -E -- \
    '-ExifTool|-System:|-File:|ImageWidth|ImageHeight|ImageSize|Compression|Orientation|Resolution' <<< "$Exifargs" \
    | sed "s/'/'\"'\"'/g ; s/=/='/ ; s/\$/'/" )"
  eval exiftool -ignoreMinorErrors -overwrite_original_in_place $Exifargs -Orientation=Horizontal "$Destinationimage" 2>&1 | grep -v -E 'Warning|files updated'
}
fakehdr() {
  # simulate a HDR image with multiple exposures combined to one image with balanced light.
  # To achieve this some brightened and darkened images are generated with IM and combined with enfuse.
  
  local Darkfactor Brightfactor Darkpercent Brightpercent
  local Error=
  local Method Percent
  local Imagecount Imagebasename Command Output Basename Brightimage Darkimage
  local Longoptions Parsedoptions
  
  Longoptions="percent:,method:,basename:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"  
  while [ "$#" -gt 0 ]; do
    case "${1:-}" in
      --percent)  Percent="${2:-}" ; shift ;;
      --method)   Method="${2:-}" ; shift ;;
      --basename) Basename="${2:-}" ; shift ;;
    esac
    shift
  done
  
  Percent="${Percent:-40}"
  Percent="${Percent%"%"}"
  Method="${Method:-level}"
  Basename="${Basename:-fakehdr${Percent}.$Method.$Sourcemd5}"
  maskexist "$Basename" && {
    verbose "Skipping fakehdr, already exists: $Basename"
    return 0
  }
  
  Darkpercent="$(awk   "BEGIN {print  100-$Percent}")"
  Brightpercent="$(awk "BEGIN {print  100+$Percent}")"
  Darkfactor="$(awk    "BEGIN {print (100-$Percent)/100}")"
  Brightfactor="$(awk  "BEGIN {print (100+$Percent)/100}")"
  #Brightfactor="$(awk  "BEGIN {print  1/$Darkfactor}")"

  Imagecount=0
  for Sourceimage in $Sourceimagelist; do
    Imagecount=$((Imagecount+1))
    Number="$(printnum $Imagecount $Imagenumberlength)"
    Imagebasename="$(basename $Sourceimage)"
    Brightimage="$Cachedir/$Imagebasename.exp.bright.tif"
    Darkimage="$Cachedir/$Imagebasename.exp.dark.tif"
    
    Command="$Magickbin '$Sourceimage' -write mpr:image -delete 0"  
    case $Method in
      brightness)    
        Command="$Command ( mpr:image -brightness-contrast  ${Percent}%         -write '$Brightimage'  )" 
        Command="$Command ( mpr:image -brightness-contrast -${Percent}%         -write '$Darkimage'   )" 
      ;;
      modulate)    
        Command="$Command ( mpr:image -modulate ${Brightpercent}%               -write '$Brightimage'  )" 
        Command="$Command ( mpr:image -modulate ${Darkpercent}%                 -write '$Darkimage'   )" 
      ;;
      multiply)    
        Command="$Command ( mpr:image -evaluate multiply ${Brightfactor}        -write '$Brightimage'  )" 
        Command="$Command ( mpr:image -evaluate multiply ${Darkfactor}          -write '$Darkimage'   )" 
      ;;
      levelgamma)    
        Command="$Command ( mpr:image -level 0%x${Darkpercent}%,${Brightfactor} -write '$Brightimage'  )" 
        Command="$Command ( mpr:image +level 0%x${Darkpercent}%,${Brightfactor} -write '$Darkimage'   )" 
      ;;
      level)    
        Command="$Command ( mpr:image -level 0%x${Darkpercent}%                 -write '$Brightimage'  )" 
        Command="$Command ( mpr:image +level 0%x${Darkpercent}%                 -write '$Darkimage'   )" 
      ;;
      gamma)
        Command="$Command ( mpr:image -gamma ${Brightfactor}                    -write '$Brightimage'  )" 
        Command="$Command ( mpr:image -gamma ${Darkfactor}                      -write '$Darkimage'   )" 
      ;;
    esac
    Command="$Command xc:white null:"

    multicore -- $Command || Error=1
    multicore_wait || Error=1
    [ "$Error" ] && break
    Output="$Cachedir/$Basename.$Number.tif"
    multicore --showimage "$Output" -- enfuse "$Sourceimage" "$Brightimage" "$Darkimage" -o "$Output" --saturation-weight=0 --gray-projector=average
#    multicore --showimage "$Output" "enfuse $Sourceimage $(find $Cachedir/${Imagebasename}.exp* | tr "\n" " ") -o $Output --saturation-weight=0 --gray-projector=average && \
#                                     exiftool -overwrite_original -tagsfromfile $Sourceimage -Orientation= -all:all $Output" || Error=1
    [ "$Error" ] && break
  done
  multicore_wait || return 1
  return ${Error:-0}
}
finalblur() {
  local Image Mask Percent Sigma1 Sigma2 Command Error
  local Longoptions Parsedoptions
  
  Longoptions="image:,mask:,percent:,sigma1:,sigma2:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --image)   Image="${2:-}" ;;
      --mask)    Mask="${2:-}" ;;
      --percent) Percent="${2:-}" ;;
      --sigma1)  Sigma1="${2:-}" ;;
      --sigma2)  Sigma2="${2:-}" ;;
    esac
    shift
    shift
  done
  Sigma1="${Sigma1:-1}"
  Sigma2="${Sigma2:-0}"
    
  Command="$Magickbin
  $Image
    -write mpr:resultimage
    -delete 0
  $Mask
    -write mpr:maskmax
    -delete 0
  mpr:maskmax
    -threshold ${Percent:-10}%
    -negate
    -write mpr:cutmask
    -delete 0"
    Command="$Command
  mpr:resultimage
    -alpha off
    -blur 0x$Sigma1
    -write mpr:bokeh
    -delete 0
  mpr:bokeh
  ( mpr:cutmask -blur 0x$Sigma2 )
    -alpha off
    -compose CopyOpacity -composite
    -write mpr:partsource_blurred
    -delete 0"
  false && [ "$Globalalpha" ] && {
    Command="$Command
  mpr:maskmax
  mpr:cutmask
    -compose Darken -composite
    -write mpr:partsource_blurred_alpha
    -delete 0
  mpr:partsource_blurred
  mpr:partsource_blurred_alpha
    -alpha off
    -compose CopyOpacity -composite
    -write mpr:partsource_blurred
    -delete 0
      "
  }
  Command="$Command
  mpr:resultimage
  mpr:partsource_blurred
    -compose Over -composite
  $Image"
  note "$Command"
  $Command || error "Error with --finalblur"
  showimage "$Image"
  return ${Error:-0}
}
flatten() {
  local Resultimage Image Command
  
  Resultimage="${1:-}"
  shift
  
  Command="$Magickbin
  $Resultimage
    -alpha set"
    
  for Image in "$@"; do
    Command="$Command
  $Image
    -compose Over -composite"
  done
  
  Command="$Command
    $Tifstorealpha
  $Resultimage"
    
  $Command
}
generate_image() {
  local Mode Imagename Swap Imagetype Showname=
  
  [ "${1:-}" = "--showname" ] && Showname="yes" && shift
  
  Mode="${1:-}"
  
  checkmagicklist color                     "$Mode"   && Imagetype="color"
  checkmagicklist evaluate                  "$Mode"   && Imagetype="evaluate"
  checkmagicklist compose  "$(tr -d "2" <<< "$Mode")" && Imagetype="compose"
  case "$Mode" in
    enfuse)                                              Imagetype="enfuse" ;;
    saturation)                                          Imagetype="saturation" ;;
  esac
  
  case "$Imagetype" in
    enfuse)     Imagename="$Cachedir/enfuse.$Sourcemd5.tif" ;;
    saturation) Imagename="$Cachedir/saturation.$Sourcemd5.tif" ;;
    evaluate)   Imagename="$Cachedir/evaluate.$Mode.$Sourcemd5.tif" ;;
    compose)    Imagename="$Cachedir/compose.$Mode.$Sourcemd5.tif" ;;
    color)      Imagename="$Cachedir/color.$Mode.${Imagewidth}x${Imageheight}.tif" ;;
  esac
  [ "$Showname" ] && {
    echo "$Imagename"
    return 0
  }
  
  [ -e "$Imagename" ] && return 0
  note "Generating image $Imagetype: $Mode"
  
  case "$Imagetype" in
    enfuse)
      nice enfuse --contrast-weight=1 --saturation-weight=0 --exposure-weight=0 --hard-mask -o "$Imagename" $Sourceimagelist 2>&1 || error "Failed to generate enfuse base image"
    ;;
    saturation)
      imfuse --cache="$Cachedir" --output="$Imagename" --saturation $([ "$Showimageprocessing" ] && echo -V) $Sourceimagelist || error "Failed to generate saturation image"
    ;;
    evaluate)
      evaluate "$Mode" "$Imagename" $Sourceimagelist || Error=1
    ;;
    compose)
      grep -q "2" <<< "$Mode" && Swap="-swap 0,1" || Swap=""
      Mode="$(tr -d "2" <<< "$Mode")"
      generate_image min || Error=1
      generate_image max || Error=1
      $Magickbin $(generate_image --showname min) $(generate_image --showname max) -alpha off $Swap -compose $Mode -composite "$Imagename" || error "Failed compositing $Mode: $Image"
    ;;
    color)
      case $Mode in
        transparent) mkimg_transparent      "$Imagename" || error "Failed to generate color image $Mode" ;;
        *)           mkimg_color "$Mode" "" "$Imagename" || error "Failed to generate color image $Mode" ;;
      esac
    ;;
  esac
  showimage "$Imagename"
  return "${Error:-0}"
}
layered_tif() {
  local Image Mask Layers Background 
  local Layer Layerlist= Factor Command Error
  Image="${1:-}"
  Mask="${2:-}"
  Layers="${3:-}"
  Background="${4:-}"
  Factor="$(calc "255 / $Layers")"
  
  note "Generating $Layers layers"
  
  Command="$Magickbin
  $Image
    -write mpr:image
    -delete 0
  $Mask
    -write mpr:mask
    -delete 0"
  for Layer in $(seq $Layers); do
    Command="$Command
  mpr:mask
    -color-threshold gray($(calc "($Layer-1)*$Factor"))-gray($(calc "$Layer*$Factor"))
    -write mpr:cutmask
    -delete 0
  mpr:image
  mpr:cutmask
    -alpha off
    -compose CopyOpacity -composite
    -write mpr:layer$Layer
    -delete 0"
    [ "$Globalalpha" ] && {
      Command="$Command
  mpr:mask
  mpr:cutmask
    -compose Darken -composite
    -write mpr:layermask
    -delete 0
  mpr:layer$Layer
  mpr:layermask
    -alpha off
    -compose CopyOpacity -composite
    -write mpr:layer$Layer
    -delete 0"
    }
    Layerlist="$Layerlist mpr:layer$Layer"
  done
  
  Command="$Command
  $Background
  $Layerlist
    $Tifstorealpha
  $Image"

  $Command || "Error in --layers"
  return ${Error:-0}
}
level_masks() {
  local Maskbasename Maskmax Maskmin Maskmd5 Clutimage Resultmask
  local Startzeit Dauer Restzeit
  local Count Mask Masklist Levelmin Levelmax
  
  Maskbasename="${1:-NO_MASK_SPECIFIED}"
  Masklist="$(masklist "$Maskbasename")"
  Maskmax="$Cachedir/$Maskbasename-max.tif"
  Maskmin="$Cachedir/$Maskbasename-min.tif"
  Clutimage="$Cachedir/$Maskbasename-clut.miff"
 
  note "Leveling with $Redistshape: $Maskbasename"
  case $Redistshape in
    ""|"none"|"off")  Prefix="level_" ; Redistshape="" ;;
    "uniform")  Prefix="levelU_" ;;
    "gaussian") Prefix="levelG${Redistpeak}_" ;;
  esac
  Maskbasename="${Prefix}${Maskbasename}"

  [ "$Forceoverwrite" = "level" ] && rm $Cachedir/$Maskbasename*
  maskexist "$Maskbasename" && {
    verbose "level_masks(): Already exists, skipping: $Maskbasename"
    echo "$Maskbasename"
    return 0
  }

  evaluate max $Maskmax $Masklist || return 1
  Levelmax="$($Magickbin "$Maskmax" -format '%[fx:maxima*100]' info:)"
  Levelmin="$(maskarg_defaultvalue $Argmethod levelmin)"
  [ -z "$Levelmin" ] && {
    evaluate min $Maskmin $Masklist || return 1
    Levelmin="$($Magickbin "$Maskmin" -format '%[fx:minima*100]' info:)"
  }
  verbose "level check: ${Levelmin}%,${Levelmax}% for $Maskbasename"
  
  $Magickbin $Maskmax -level ${Levelmin}%,${Levelmax}% $Maskmax

  [ "$Redistshape" ] && redist --image "$Maskmax" --clutimage "$Clutimage" --shape "$Redistshape" --peak "${Redistpeak:-50}"

  Startzeit="$(date +%s)"
  Count=0
  for Mask in $Masklist ; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    
    Resultmask="$(sed "s%.*/%&${Prefix}%" <<< "$Mask")"
    Command="
$Magickbin
  '$Mask'
    -level ${Levelmin}%,${Levelmax}%"
    [ "$Redistshape" ] && Command="$Command
  '$Clutimage'
    -clut"
    Command="$Command
  '$Resultmask'"
  
  [ "$Count" = "1" ] && verbose "Leveling masks with:
$(grep "\S" <<< "$Command")"
  
    #$Command || error "Failure in leveling $Argmethod masks"
    multicore --showimage "$Resultmask" -- $Command || error "Failure in leveling masks"
  
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Leveling $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done
  multicore_wait || error "Failure in leveling masks"

  echo "$Maskbasename"
  return "${Error:-0}"
}
maskfromimage() {
  # Generate masks based on comparision with a single image
  local Imagename Maskbasename
  local Startzeit Dauer Restzeit
  local Count Number Error=
  
  Imagename="${1:-}"
  Maskbasename="${2:-}"
  
  Startzeit="$(date +%s)"
  Count=0
  for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    Maskname="$Maskbasename.${Number}.tif"
    
  #( $Sourceimage $Grayscaleconverter -alpha off )
  #( $Imagename   $Grayscaleconverter -alpha off )
    Command="$Magickbin
  '$Imagename' 
    -write mpr:image
    -delete 0
  mpr:image
    -channel alpha
    -separate
    -write mpr:alpha
    -delete 0
  mpr:image
    $Grayscaleconverter
  ( '$Sourceimage' $Grayscaleconverter )
    -compose Difference -composite
    -alpha off 
    -negate
    -write mpr:diffmask
    -delete 0
  mpr:diffmask
  mpr:alpha
    -compose multiply -composite
    -write '$Maskname'
  -delete 0
    xc:white null:"
         
    #$Command || error "Failure in mask generation of comparision with $Imagename"
    multicore --showimage "$Maskname" -- $Command || error "Failure in mask generation of comparision with $Imagename"
  
    [ "$Count" = "1" ] && verbose "Generating masks with:
$(grep "\S" <<< "$Command")"

    #showimage $Maskname
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Image comparision mask $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done
  multicore_wait || error "Failure in mask generation of comparision with $Imagename"
  return ${Error:-0}
}
mkimg_black() {
  local Size
  Size="${2:-}"
  [ -z "$Size" ] && Size="${Imagewidth:-100}x${Imageheight:-100}"
  $Magickbin -size "$Size" xc:black                  -type Grayscale      $Tifstore "${1:-black.tif}"       || error "Failed to create black image."
}
mkimg_color() {
  local Size
  Size="${2:-}"
  [ -z "$Size" ] && Size="${Imagewidth:-100}x${Imageheight:-100}"
  $Magickbin -size "$Size" canvas:${1:-black} -type TrueColor       "${3:-color.tif}"       || error "Failed to create colored image."
}
mkimg_transparent() {
  # Generate transparent image $1 with size $2
  local Size
  Size="${2:-}"
  [ -z "$Size" ] && Size="${Imagewidth:-100}x${Imageheight:-100}"
  $Magickbin -size "$Size" canvas:transparent -type TrueColorAlpha "${1:-transparent.tif}"
}
redist() {
  local Referenceimage Clutimage Shape
  local histArr ccountArr totpix Lutlist
  local Peak Low High Expo Quantumrange
  local Factor LowArr HighArr PointArr
  local i x y 
  local intFunctionList integralArr
  local Longoptions Parsedoptions
  
  Longoptions="image:,clutimage:,shape:,peak:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --image)     Referenceimage="${2:-}" ;;
      --clutimage) Clutimage="${2:-}" ;;
      --shape)     Shape="${2:-}" ;;
      --peak)      Peak="${2:-}" ;;
    esac
    shift
    shift
  done
  
  Shape="${Shape:-uniform}"
  Peak=${Peak:-50}  # 0..100
  Low=50   # >0
  High=50  # >0

  Histogram="$Referenceimage.histogram-$Shape.tif"
      
  Quantumrange="$($Magickbin $Referenceimage -format "%[fx:quantumrange]" info:)" || return 1
  Expo="$($Magickbin xc: -format "%[fx:e]" info:)" 

  #Clutimage="$Cachedir/clut.$Maskmd5.miff"

  #cumHistogram 
  histArr=($($Magickbin $Referenceimage -colorspace gray -depth 8 -format "%c" histogram:info:- \
               | sed -n 's/[ ]*\([0-9]*\).*gray[(]\([0-9]*\).*$/\1 \2/p' \
               | awk '# AWK to generate a zero filled histogram
                      { bin[int($2)] += $1; } 
                      END { for (i=0;i<256;i++) {hist = bin[i]+0; print hist; }
                      } ' ))

  ccountArr=($(echo ${histArr[*]} \
               | awk '# AWK to generate a cumulative histogram
                      { split($0,count," ") }
                      END { for (i=0;i<256;i++) { cum += count[i]; print cum } }' ))
  totpix=${ccountArr[255]}
  
  case $Shape in
    uniform)
      # genUniformLutArr
      # special function to generate lut for Uniform Distribution which is just the cumulative histogram normalized to max value 
      # the uniform distribution has an integral which is f(x)=x
      # this Peaks that the cumulative distribution of the image is its own lut and only needs to be scaled
      
      # get raw cumulative histogram
      Factor="$($Magickbin xc: -format "%[fx:$Quantumrange/$totpix]" info:)"
      Lutlist="$(for ((i=0; i<256; i++)); do
        echo "${ccountArr[$i]}"
      done | awk -v Factor="$Factor" '{ print int(Factor*$1); }')"
    ;;
    gaussian)
      # function to generate gaussian array in two parts: 0 to Peak and Peak to 255
      Peak="$((256*Peak/100))"

      # create low part of gaussian distribution
      Factor="$($Magickbin xc: -format "%[fx:1/(2*($Low)^2)]" info:)"
      LowArr=($(awk -v Peak="$Peak" -v Factor="$Factor" -v Expo="$Expo" -v Quantumrange="$Quantumrange" '
	                BEGIN { for (i=0;i<=Peak;i++) print Quantumrange*Expo^(-((i-Peak)^2)*Factor); }'))

      # create high part of gaussian distribution
      Factor="$($Magickbin xc: -format "%[fx:1/(2*($High)^2)]" info:)"
      HighArr=($(awk -v Peak="$Peak" -v Factor="$Factor" -v Expo="$Expo" -v Quantumrange="$Quantumrange" '
                    BEGIN { for (i=Peak+1;i<256;i++) print Quantumrange*Expo^(-((i-Peak)^2)*Factor); }'))

      # combine low and high parts of gaussian distribution
      gausslist="${LowArr[*]} ${HighArr[*]}"
      functionArr=($gausslist)
      
      # integrate function distribution
      intFunctionList=$(for ((i=0; i<256; i++)); do
        echo "$i ${functionArr[$i]}"
      done | awk -v totpix="$totpix" '
                 # AWK to integrate a function
                 { cum += $2; rcum[$1] = cum; } 
                 END { for (i=0;i<256;i++) print int(totpix*rcum[i]/cum); }')
      integralArr=($intFunctionList)
    
      # for each possible bin graylevel (0 to 255) of cc2 starting at 0
      # get count from cumulate histogram cc2 at that bin, then
      # increment along bin graylevels of integrated function cc1 until that count exceeds that of cc2
      # find the bin graylevel in cc1 and use that as the output value of the lut transformation 
      # where the cc2 bin graylevel is the input value of the lut transformation
      # repeat for the next cc2 bin, but starting at graylevel where left off from previous.
      # as cumulative histograms never decrease, you don't have to start at graylevel 0 each time

      Lutlist=$(for ((i=0; i<256; i++)); do
        echo "$i ${integralArr[$i]} ${ccountArr[$i]}"
      done | awk -v Quantumrange="$Quantumrange" '# AWK to generate transformation lut
                 BEGIN { i=0; } { cc1[$1]=$2; cc2[$1]=$3; } 
                 END { for ( j=0;j<256;j++ ) 
                 { while ( i != 255 && cc1[i] <= cc2[j] ) 
                 { i++ } lut = Quantumrange*i/255; print lut; } }')
    ;;
  esac
  
  # now convert lutArr into lut image
  # Use NetPBM (PGM format implied intermediate image)

  echo "P2 256 1 $Quantumrange $Lutlist" | $Magickbin - -scale 256x1\! "$Clutimage"
  
  # draw histogram
  $Magickbin $Referenceimage $Clutimage -clut -define histogram:unique-colors=false histogram:- | $Magickbin - -filter point -resize 256x200! $Histogram
  case $Shape in
    "gaussian")
      # now overlay graph on histogram; scale graph to 128 wide (take every other point) and 100 tall and invert the y coordinates
      x=0
      while [ "$x" -lt 256 ] ; do
        y="$((200 - (200 * ${functionArr[$x]%.*} / $Quantumrange) ))"
        PointArr[$x]="$x,$y"
        x="$((x+1))"
      done
      $Magickbin $Histogram -stroke red -strokewidth 2 -fill none -draw "polyline ${PointArr[*]}" $Histogram
    ;;
  esac
#  verbose "histogram:
#$Histogram"
  showimage $Histogram
}
redistX() {
  local Referenceimage Clutimage Shape
  local histArr ccountArr totpix Lutlist
  local Peak Low High Expo Quantumrange
  local Factor LowArr HighArr PointArr
  local i x y 
  local intFunctionList integralArr
  local Longoptions Parsedoptions
  
  Longoptions="image:,clutimage:,shape:,peak:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --image)     Referenceimage="${2:-}" ;;
      --clutimage) Clutimage="${2:-}" ;;
      --shape)     Shape="${2:-}" ;;
      --peak)      Peak="${2:-}" ;;
    esac
    shift
    shift
  done
  
  Shape="${Shape:-uniform}"
  Peak=${Peak:-50}  # 0..100
  Low=50   # >0
  High=50  # >0

  Histogram="$Referenceimage.histogram-$Shape.tif"
      
  Quantumrange="$($Magickbin $Referenceimage -format "%[fx:quantumrange]" info:)" || return 1
  Expo="$($Magickbin xc: -format "%[fx:e]" info:)" 

  #Clutimage="$Cachedir/clut.$Maskmd5.miff"

  #cumHistogram 
  histArr=($($Magickbin $Referenceimage -colorspace gray -depth 8 -format "%c" histogram:info:- \
               | sed -n 's/[ ]*\([0-9]*\).*gray[(]\([0-9]*\).*$/\1 \2/p' \
               | awk '# AWK to generate a zero filled histogram
                      { bin[int($2)] += $1; } 
                      END { for (i=0;i<256;i++) {hist = bin[i]+0; print hist; }
                      } ' ))

  ccountArr=($(echo ${histArr[*]} \
               | awk '# AWK to generate a cumulative histogram
                      { split($0,count," ") }
                      END { for (i=0;i<256;i++) { cum += count[i]; print cum } }' ))
  totpix=${ccountArr[255]}
  
  case $Shape in
    uniform)
      # genUniformLutArr
      # special function to generate lut for Uniform Distribution which is just the cumulative histogram normalized to max value 
      # the uniform distribution has an integral which is f(x)=x
      # this Peaks that the cumulative distribution of the image is its own lut and only needs to be scaled
      
      # get raw cumulative histogram
      Factor="$($Magickbin xc: -format "%[fx:$Quantumrange/$totpix]" info:)"
      Lutlist="$(for ((i=0; i<256; i++)); do
        echo "${ccountArr[$i]}"
      done | awk -v Factor="$Factor" '{ print int(Factor*$1); }')"
    ;;
    gaussian)
      # function to generate gaussian array in two parts: 0 to Peak and Peak to 255
      Peak="$((256*Peak/100))"

      # create low part of gaussian distribution
      Factor="$($Magickbin xc: -format "%[fx:1/(2*($Low)^2)]" info:)"
      LowArr=($(awk -v Peak="$Peak" -v Factor="$Factor" -v Expo="$Expo" -v Quantumrange="$Quantumrange" '
	                BEGIN { for (i=0;i<=Peak;i++) print Quantumrange*Expo^(-((i-Peak)^2)*Factor); }'))

      # create high part of gaussian distribution
      Factor="$($Magickbin xc: -format "%[fx:1/(2*($High)^2)]" info:)"
      HighArr=($(awk -v Peak="$Peak" -v Factor="$Factor" -v Expo="$Expo" -v Quantumrange="$Quantumrange" '
                    BEGIN { for (i=Peak+1;i<256;i++) print Quantumrange*Expo^(-((i-Peak)^2)*Factor); }'))

      # combine low and high parts of gaussian distribution
      gausslist="${LowArr[*]} ${HighArr[*]}"
      functionArr=($gausslist)
      
      # integrate function distribution
      intFunctionList=$(for ((i=0; i<256; i++)); do
        echo "$i ${functionArr[$i]}"
      done | awk -v totpix="$totpix" '
                 # AWK to integrate a function
                 { cum += $2; rcum[$1] = cum; } 
                 END { for (i=0;i<256;i++) print int(totpix*rcum[i]/cum); }')
      integralArr=($intFunctionList)
    
      # for each possible bin graylevel (0 to 255) of cc2 starting at 0
      # get count from cumulate histogram cc2 at that bin, then
      # increment along bin graylevels of integrated function cc1 until that count exceeds that of cc2
      # find the bin graylevel in cc1 and use that as the output value of the lut transformation 
      # where the cc2 bin graylevel is the input value of the lut transformation
      # repeat for the next cc2 bin, but starting at graylevel where left off from previous.
      # as cumulative histograms never decrease, you don't have to start at graylevel 0 each time

      Lutlist=$(for ((i=0; i<256; i++)); do
        echo "$i ${integralArr[$i]} ${ccountArr[$i]}"
      done | awk -v Quantumrange="$Quantumrange" '# AWK to generate transformation lut
                 BEGIN { i=0; } { cc1[$1]=$2; cc2[$1]=$3; } 
                 END { for ( j=0;j<256;j++ ) 
                 { while ( i != 255 && cc1[i] <= cc2[j] ) 
                 { i++ } lut = Quantumrange*i/255; print lut; } }')
    ;;
  esac
  
  # now convert lutArr into lut image
  # Use NetPBM (PGM format implied intermediate image)

  echo "P2 256 1 $Quantumrange $Lutlist" | $Magickbin - -scale 256x1\! "$Clutimage"
  
  # draw histogram
  $Magickbin $Referenceimage $Clutimage -clut -define histogram:unique-colors=false histogram:- | $Magickbin - -filter point -resize 256x200! $Histogram
  case $Shape in
    "gaussian")
      # now overlay graph on histogram; scale graph to 128 wide (take every other point) and 100 tall and invert the y coordinates
      x=0
      while [ "$x" -lt 256 ] ; do
        y="$((200 - (200 * ${functionArr[$x]%.*} / $Quantumrange) ))"
        PointArr[$x]="$x,$y"
        x="$((x+1))"
      done
      $Magickbin $Histogram -stroke red -strokewidth 2 -fill none -draw "polyline ${PointArr[*]}" $Histogram
    ;;
  esac
  verbose "histogram:
$Histogram"
  showimage $Histogram
}
threshold() {
  local Image Mask Threshold Thresholdblur Command Error
  local Longoptions Parsedoptions
  
  Longoptions="image:,mask:,percent:,blur:"
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --blur)    Thresholdblur="${2:-}" ;;
      --image)   Image="${2:-}" ;;
      --mask)    Mask="${2:-}" ;;
      --percent) Threshold="${2:-}" ;;
    esac
    shift
    shift
  done
    
  Command="$Magickbin
  $Image
    -write mpr:image
    -delete 0
  $Mask
    -write mpr:mask
    -delete 0"
  case $Globalalpha in
    "")
      Command="$Command
  mpr:image
  ( mpr:mask -threshold ${Threshold}% -alpha off -blur 0x${Thresholdblur:-0} )
    -alpha off
    -compose CopyOpacity -composite
  $Image"
    ;;
    *)
      Command="$Command
  mpr:image
  ( mpr:mask -black-threshold ${Threshold}% -alpha off -blur 0x${Thresholdblur:-0} )
    -alpha off
    -compose CopyOpacity -composite
  $Image"
    ;;
  esac

  $Command || error "Error in --threshold=$Threshold"
  showimage "$Image"
  return ${Error:-0}
}
    
# core focus stack routines

focus_generate_masks() {
  local Maskgenerator Maskgenerator_all= Basenamelist= Maskready= Maskmax Showimage= Mode Line Imagename Command= Maskmd5
  local Startzeit Dauer Restzeit Count
    
  Maskmethodlist="$(grep "\S" <<< "$Maskmethodlist")"
  [ -n "$Maskmethodlist" ] && while read Line; do
    [ "$Error" ] && break
    
    maskarg_parse "$Line"
    
    Maskgenerator="$(focus_maskmethod "$Argmethod")"
    
    [ "$Testsetup" ] && [ "$Argtype" = "mask" ] && Maskgenerator="$Maskgenerator
    -write mpr:level0
    -delete 0
  mpr:sourcegray
    -write mpr:sourcegraybak
    -delete 0
  mpr:sourcegraybak
    -resize 80%
    -write mpr:sourcegray
    -delete 0
$(focus_maskmethod "$Argmethod")
    -write mpr:level1
    -auto-level
    -delete 0
  mpr:sourcegraybak
    -resize 50%
    -write mpr:sourcegray
    -delete 0
$(focus_maskmethod "$Argmethod")
    -write mpr:level2
    -delete 0
  mpr:sourcegraybak
    -resize 25%
    -write mpr:sourcegray
    -delete 0
$(focus_maskmethod "$Argmethod")
    -write mpr:level3
    -delete 0
  mpr:level3
    -resize ${Imagewidth}x${Imageheight}
    -write mpr:level3
    -delete 0
  mpr:level2
    -resize ${Imagewidth}x${Imageheight}
    -write mpr:level2
    -delete 0
  mpr:level1
    -resize ${Imagewidth}x${Imageheight}
    -write mpr:level1
    -delete 0
  mpr:level0 mpr:level1 mpr:level2 mpr:level3 
    -evaluate-sequence ${Testarg:-mean}"
  false && echo "mpr:level0 -evaluate Divide 2 -write mpr:level0 -delete 0
  mpr:level1 -evaluate Divide 2 -write mpr:level1 -delete 0
  mpr:level2 -evaluate Divide 2 -write mpr:level2 -delete 0
  mpr:level3 -evaluate Divide 2 -write mpr:level3 -delete 0
  mpr:level0 
  mpr:level1 
    -compose $Mergemethod -composite
  mpr:level2 
    -compose $Mergemethod -composite
  mpr:level3
    -compose $Mergemethod -composite
    "
        
    [ "$Argdiff" ] && Maskgenerator="$Maskgenerator
  mpr:sourcegray
    -compose Difference -composite"
    
    [ "$Argnegate" ] && Maskgenerator="$Maskgenerator
    -negate"
    
    [ "${Argclose1}" ] && Maskgenerator="$Maskgenerator
    -morphology Close:${Argclose2:-1} Octagon:${Argclose1:-3}"
    
    [ "$Argmaskblur" ] && {
      Maskgenerator="$Maskgenerator
    -blur 0x$Argmaskblur"
    }

#    [ "$Argmethod" = "enfuse" ] && Image_needlist="$Image_needlist enfuse"
      
    Maskmd5="$(md5cut "$Sourcemd5 $Maskgenerator")"
    Argbasename="$Argmethod.$Maskmd5"
    maskarg_store
    
    ## avoid [double] creating of existing masks
    Maskready=""
    grep -q -x "$Argbasename" <<< "$Basenamelist" && Maskready="yes"
    Basenamelist="$Basenamelist
$Argbasename"
    maskexist "$Argbasename" && Maskready="yes" || rm -f $(masklist "$Argbasename")
    
    [ -z "$Maskready" ] && {
      [ "$Argmethod" = "enfuse" ] && {
        enfuse --exposure-weight=0 --saturation-weight=0 --contrast-weight=1 --hard-mask --save-masks=$Cachedir/enfuse-soft.%n.tif:$Cachedir/enfuse-hard.%n.tif $Sourceimagelist || error "Error in --enfuse"
      }
      Maskgenerator_all="$Maskgenerator_all
$Maskgenerator
    -write '$Cachedir/$Argbasename.NUMBER.tif'"
      [ -z "$Showimage" ] && Showimage="$Cachedir/$Argbasename.NUMBER.tif"
      Maskgenerator_all="$Maskgenerator_all
    -delete 0"
    }
  done <<< "$Maskmethodlist"
  [ "$Error" ] && return 1
  
  verbose "mask generator kernels:
$(magick xc:white -define morphology:showkernel=1 $(grep -E -- '-define|-morphology' <<< "$Maskgenerator_all" | grep -v "Close") null: 2>&1)"

  # --evaluate, --compose, --enfuse
  for Mode in $Image_needlist; do
    generate_image "$Mode"
  done 
  
  [ -z "$Maskmethodlist" ] && return 0
  note "Generating masks"
  
  # Generate masks
  Startzeit="$(date +%s)"
  Count=0
  grep -q "NUMBER" <<< "$Maskgenerator_all" || note "Skipping mask generation"
  grep -q "NUMBER" <<< "$Maskgenerator_all" && for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    
    # Generate command to generate masks            
    Command="$Magickbin
  '$Sourceimage'
    -alpha off
    -depth 16
    -write mpr:sourceimage
    -delete 0
  mpr:sourceimage"
  
    # --grayscale
    [ "$Grayscaleconverter" ] && Command="$Command
    $Grayscaleconverter"
    Command="$Command
    -write mpr:sourcegray
    -delete 0"
    
    Command="$Command
${Maskgenerator_all//NUMBER/$Number}"
    
    Command="$Command
  xc:white null:"
          
    [ "$Count" = "1" ] && verbose "Generating masks with:
$(grep "\S" <<< "$Command")"

    multicore --showimage "${Showimage//NUMBER/$Number}" -- $Command || error "Failure in mask generation"
#    multicore --showimage "$Testimage" -- $Command || error "Failure in mask generation"
    
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Contrast mask $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done
  multicore_wait || error "Failure in mask generation"
  
  
  # level
  # less,alpha
  while read Line; do
    [ "$Error" ] && break
    maskarg_parse "$Line"
    
    # level and uniform masks
    [ "$Arglevel" = "yes" ] && {
      Argbasename="$(level_masks "$Argbasename")" || error "Error in level_masks()"
      maskarg_store
    }
    [ "$Error" ] && break
    
    # =alpha,less
    [ "${Argless}" ] && [ "${Argalpha}" ] && {
      note "Generating alpha&less image for mask $Argmethod"
      Imagename="$Cachedir/$Argbasename-prepare-less${Argless}-alpha${Argalpha}-cb${Cutblur}.tif"
      Maskmax="$Cachedir/$Argbasename-prepare-less${Argless}-alpha${Argalpha}-cb${Cutblur}.mask.tif"
      focus_montage --alpha "$Argalpha" --lessthanmax "$Argless" --cutsoft "$Cutsoft" -cutblur "$Cutblur" --maskmax="$Maskmax" --output "$Imagename" -- $(masklist "$Argbasename") || error "Error in focus_generate_masks->focus_montage for less+alpha"
      alphalevel --image "$Imagename" --mask "$Maskmax" --level "$Argalpha" || error "Error in focus_generate_masks->alphalevel"
      [ "$Error" ] && break
      #$Magickbin "$Enfusebaseimage" "$Imagename" -compose Over -composite "$Imagename" || error "Failed to compose alpha result on enfuse background"
      Argbasename="$Argmethod-alpha$Argalpha-less$Argless-cb$Cutblur.$(md5cut "$Argbasename $Argalpha $Argless $Cutblur" )"
      maskexist "$Argbasename" || {
        rm -f $(masklist "$Argbasename")
        note "Generating comparision masks from alpha&less result of $Argmethod"
        maskfromimage $Imagename $Cachedir/$Argbasename || error "Error in maskfromimage() for less+alpha"
        [ "$Error" ] && break
      }
      Arglevel=""
      Argtype="image"
      maskarg_store      
    }
    
    # =less
    [ "${Argless}" ] && [ -z "${Argalpha}" ] && {
      Imagename="$Cachedir/$Argbasename-prepare-less$Argless-cb${Cutblur}.tif"
      Maskmax="$Cachedir/$Argbasename-less${Argless}-cb$Cutblur.mask.tif"
      [ -e "$Maskmax" ] || {
        note "Generating less mask for $Argmethod"
        focus_montage --lessthanmax "$Argless" --maskmax "$Maskmax" --output "$Imagename" -- $(masklist "$Argbasename") || error "Error in focus_montage for less"
        [ "$Error" ] && break
      }
      Argdarkenmask="$Maskmax"
      maskarg_store
    }
  done <<< "$Maskmethodlist"
  
  
  return ${Error:-0}
}
focus_merge_masks() {
  # Merge different masks.
  
  local Mergemask
  local Count Number Weightmax Prefertopcode= Methodnumber=
  local Command
  local Skipmerge Methodmask Mergecode=
  local Startzeit Dauer Restzeit
  local Clutmaskimage
  
  note "Merging masks"
  
  #Skipmerge="yes"
  Skipmerge=no
  [ "$Maskmethodnumber" -gt "1" ] && Skipmerge="no"
  [ "$Darkenmask" ]               && Skipmerge="no"
  [ "$Prefertop" ]                && Skipmerge="no"
  [ "$Globalsigmoidal" ]          && Skipmerge="no"
  [ "$Forceoverwrite" = "merge" ] && Skipmerge="no"

  [ -z "$Maskmethodlist" ] && {
    note "Skipping merge, no mask options are specified."
    return 0
  }
    
  while read Line; do
    maskarg_parse "$Line"
    #[ "${Argweight:-100}" -gt "${Weightmax:-0}" ] && Weightmax="${Argweight:-100}"
    awk 'BEGIN {exit !('${Argweight:-100}' >= '${Weightmax:-0}')}' && Weightmax="${Argweight:-100}"
    Methodnumber="$((Methodnumber+1))"
  done <<< "$Maskmethodlist"
  Methodnumber=1 # overwritten for mean instead of Screen
  Weightmax=100
      
  Mergemaskbasename="mergemask"
  
  # --sigmoidalclut
  [ "$Globalsigmoidal" ] && {
    Clutmaskimage="$Cachedir/mergeclut.tif"
    $Magickbin -size 256x256 gradient: -rotate 90 -depth 16 -sigmoidal-contrast ${Globalsigmoidal}% "$Clutmaskimage" || error "Error generating clut '$Globalsigmoidal' for --sigmoidalclut."
    showimage "$Clutmaskimage"
  }
  
  # generate merge code
#  Mergecode="
#  -colorspace gray
#  ( -size ${Imagewidth}x${Imageheight} xc:black )"
  Mergemethod="${Mergemethod:-plus}"
  while read Line; do
    maskarg_parse "$Line"
    Mergemaskbasename="$Mergemaskbasename-$Argmethod"
      
    Methodmask="$Cachedir/$Argbasename.NUMBER.tif"
      
    [ "$Argdenoise" ]                                       && Skipmerge="no" 
    [ "$Argdarkenmask" ]                                    && Skipmerge="no"
    [ "$Globalclose" ]                                      && Skipmerge="no"
    [ "$Globaldenoise" ]                                    && Skipmerge="no"
    [ "$Globalmaskblur" ]                                   && Skipmerge="no"
      
    Mergecode="$Mergecode
  ( 
  '$Methodmask'"
    
    # less
    [ "$Argdarkenmask" ] && Mergecode="$Mergecode
  '$Argdarkenmask'
    -compose Darken -composite"
    
    # denoise
    [ "$Argdenoise" ] && Mergecode="$Mergecode $(denoisecode "$Argdenoise")"
    
    Mergecode="$Mergecode
    +level 0%,$(calc "(100 * ${Argweight:-100}) / ( $Weightmax * $Methodnumber )" )% 
  )
    -compose $Mergemethod -composite"
  done <<< "$Maskmethodlist"
#    -compose Screen -composite"
  Mergecode="$(sed "0,/-compose $Mergemethod -composite/{/-compose $Mergemethod -composite/d;}" <<< "$Mergecode")" # delete first -compose
#    Mergecode="$Mergecode
#    -colorspace gray
#    -evaluate-sequence mean"

  # denoise low contrast areas
  [ "$Globaldenoise" ] && {
    Mergecode="$Mergecode $(denoisecode "$Globaldenoise")"
    Mergemaskbasename="$Mergemaskbasename-denoise$Globaldenoise"
  }
    
  Mergecode="$Mergecode
    -write mpr:mergemask
    -delete 0"
  
  # --maskblur
  [ "$Globalmaskblur" ] && {
    Mergecode="$Mergecode
  mpr:mergemask
    -blur 0x$Globalmaskblur
    -write mpr:mergemask
    -delete 0"
    Mergemaskbasename="$Mergemaskbasename-maskblur$Globalmaskblur"
  }
    
  # --close    
  [ "$Globalclose" ] && {
    Mergecode="$Mergecode
  mpr:mergemask
    -threshold ${Globalclosethreshold:-50}%
    -write mpr:cutmask
    -delete 0
  mpr:mergemask
  mpr:cutmask
    -compose Darken -composite
    -morphology Close:${Globalclose1:-2} Octagon:${Globalclose2:-2}
  mpr:mergemask
    -compose Lighten -composite
    -write mpr:mergemask
    -delete 0"
    Mergemaskbasename="$Mergemaskbasename-close=r${Globalclose1}R${Globalclose2}p${Globalclosethreshold}"
  }
  
  # --sigmoidalclut
  [ "$Globalsigmoidal" ] && {
    Mergecode="$Mergecode
  mpr:mergemask
  $Clutmaskimage
    -clut
    -write mpr:mergemask
    -delete 0"
    Mergemaskbasename="$Mergemaskbasename-sigmoidal$Globalsigmoidal"
  }
    
  # --prefertop
  [ "$Prefertop" ] && Mergemaskbasename="$Mergemaskbasename-prefertop$Prefertop"
  
  # --darkenmask
  [ "$Darkenmask" ] && Mergecode="$Mergecode
  mpr:mergemask
  $Darkenmask
    -compose Darken -composite
    -write mpr:mergemask
    -delete 0"
  
  [ "$Forceoverwrite" != "merge" ] && case "$Skipmerge" in
    yes) 
      [ "$Maskmethodnumber" = "1" ] && Mergemaskbasename="$Argbasename" 
      note "Skipping merge, not needed."
      return 0
    ;;
  esac
  
  
  Mergemaskbasename="$Mergemaskbasename.$(md5cut "$Sourcemd5 $Mergecode $Prefertop" )"
  [ "$Forceoverwrite" != "merge" ] && maskexist "$Mergemaskbasename" && {
    note "Skipping merge, masks already exist: $Mergemaskbasename"
    return 0
  }
    
  # merge masks
  Startzeit="$(date +%s)"
  Count=0
  while read Sourceimage; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    Mergemask="$Cachedir/$Mergemaskbasename.${Number}.tif"
    Methodmask="$Cachedir/$Argbasename.${Number}.tif"
    
    # -downweight
    [ "${Prefertop:-0}" -lt "0" ] && Prefertopcode="+level 0,$(calc "100 - -1*$Prefertop * $Count / $Imagenumber")%"
    [ "${Prefertop:-0}" -gt "0" ] && Prefertopcode="+level 0,$(calc "100 -    $Prefertop *($Imagenumber - $Count) / $Imagenumber")%"
        
    Command="
$Magickbin
  $Sourceimage
    -alpha set 
    -alpha extract
    -write mpr:sourcealpha
    -delete 0
$(sed "s/NUMBER/$Number/g" <<< "$Mergecode" )
  mpr:mergemask
  mpr:sourcealpha
    -compose Darken -composite
    -write mpr:mergemask
    -delete 0
  mpr:mergemask
    $Prefertopcode
    $Tifstore 
  '$Mergemask'"
  
    [ "$Count" = "1" ] && verbose "Merging masks with:
$(grep "\S" <<< "$Command")"

    multicore --showimage "$Mergemask" -- $Command || error "Error while merging masks"
#    multicore --showimage "$Testimage" -- $Command || error "Error while merging masks"
    
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Merging $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done <<< $Sourceimagelist
  multicore_wait || error "Error while merging masks"
  
  #[ "$Maskmethodnumber" -gt 1 ] && {
  #  Mergemaskbasename="$(level_masks "$Mergemaskbasename")" || error "Error in level_masks after merge"
  #}

  return ${Error:-0}
}
focus_montage() {
  # Finally: focus stacking

  local Resultimage Resultimageready Resultfinalblur Outputimage Sourceimage Maskimagelist= Resultmd5 Cutblur= Cutsoft=
  local Lessthanmaxmask
  local Maskmax Maskmaxcopy= Maskmaxready= Levelmax
  local Count Number
  local Contrastmaxlevel Alphalevel= Lessthanmax=
  local Command Skipmontage=
  local Startzeit Dauer Restzeit
  local Stepwise Sourcepartimage Sourcepartimagelist= Sourcemask
  local Longoptions Parsedoptions
  
  Longoptions="alpha:,lessthanmax:,maskmax:,output:,cutblur:,cutsoft:"
  
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --output)       Outputimage="${2:-}" ; shift ;;
      --alpha)        Alphalevel="${2:-}" ; shift ;;
      --cutblur)      Cutblur="${2:-}" ; shift ;;
      --cutsoft)      Cutsoft="${2:-}" ; shift ;;
      --lessthanmax)  Lessthanmax="${2:-}" ; shift ;;
      --maskmax)      Maskmaxcopy="${2:-}" ; shift ;;
      --) ;;
      *)              Maskimagelist="$Maskimagelist ${1:-}" ;;
    esac
    shift
  done
  [ -z "$Maskimagelist" ] && Maskimagelist="$(masklist $Mergemaskbasename | tr '\n' ' ')"
  echo "$Maskimagelist"
  note "Focus montage"
  
  Resultmd5="$(md5cut "$(ls -l --full-time $Maskimagelist) $Lessthanmax $Cutblur $Cutsoft")"
  #Resultmd5="$(md5cut "$(find $Maskimagelist -ls) $Lessthanmax $Cutblur")"
  #Resultmd5="$(md5cut "$Maskimagelist $Lessthanmax $Cutblur")"
  Resultimage="$(cut -d- -f2- <<< "$Mergemaskbasename" | cut -d. -f1)"
  [ -z "$Resultimage" ] && Resultimage="$(basename $(awk '{print $1}' <<< "$Maskimagelist") | cut -d. -f1)"
  [ "$Lessthanmax" ]    && Resultimage="$Resultimage-less${Lessthanmax:-0}"
  [ "$Cutsoft" ]        && Resultimage="$Resultimage-cutsoft${Cutsoft:-0}"
  [ "$Cutblur" ]        && Resultimage="$Resultimage-cutblur${Cutblur:-0}"
  Resultimage="$Cachedir/montage-$Resultimage.$Resultmd5.tif"
  #Resultimage="$Cachedir/montage.${Resultmd5}.tif"
  Resultimageready="$Resultimage.ready"
  
  Maskmax="${Maskmax:-$Cachedir/montage.max.$Resultmd5.tif}" 
  
  [ "$Forceoverwrite" = "focus" ] && rm $Resultimageready
  [ -e "$Resultimage" ] && [ -e "$Resultimageready" ] && {
    verbose "Skipping focus montage, already exists: $(basename $Resultimage)"
    showimage "$Resultimage"
    Skipmontage="yes"
  }
  
  [ -z "$Skipmontage" ] && {
    mkimg_transparent "$Resultimage"
    
    Maskmax="${Maskmax:-$Cachedir/montage.max.$Resultmd5.tif}"
    evaluate max $Maskmax $Maskimagelist || return 1
    Levelmax="$($Magickbin "$Maskmax" -format '%[fx:maxima*100]' info:)"
  
    [ "$Lessthanmax" ] && {
      Lessthanmaxmask="$Cachedir/lessthanmax.tif"
      mkimg_black "$Lessthanmaxmask"
    }
  
    Stepwise="no"
    [ "$Lessthanmax" ] && Stepwise="yes"
  
    case $Stepwise in
      yes) mkimg_black "$Maskmax" || return 1 ;;
      no)  $Magickbin "$Maskmax" -level 0%,$Levelmax% "$Maskmax" || return 1 ;;
    esac 
  }
  
  Startzeit="$(date +%s)"
  Count=0    
  [ -z "$Skipmontage" ] && for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    #Sourcemask="$(cut -d' ' -f$Number <<< "$Maskimagelist")"
    Sourcemask="$(awk "{print \$$Number}" <<< "$Maskimagelist")"
    Sourcepartimage="$Cachedir/sourcepart$Number.png"
    Sourcepartimagelist="$Sourcepartimagelist $Sourcepartimage"
    
    # Load images
    Command="
$Magickbin
  $Sourceimage
    -alpha off
    -write mpr:sourceimage
    -delete 0
  $Sourcemask
    -alpha off
    -level 0%,$Levelmax%
    -write mpr:sourcemask
    -delete 0
  $Maskmax
    -alpha off
    -write mpr:maskmax
    -delete 0"
    [ "$Stepwise" = "yes" ] && Command="$Command
  $Resultimage
    -alpha Opaque
    -alpha off
    -write mpr:resultimage
    -delete 0"
    
    # stepwise increase maskmax
    [ "$Stepwise" = "yes" ] && Command="$Command
  mpr:sourcemask 
  mpr:maskmax 
    -compose Lighten -composite
    -write mpr:maskmax
    -write $Maskmax
    -delete 0"
    
    # get area of source mask equal or sharper than current max
    Command="$Command
  mpr:maskmax
  mpr:sourcemask
    -compose MinusSrc -composite -fill white +opaque black
    -alpha off
    -negate
    -write mpr:cutmask
    -delete 0"
    
    # drop areas with contrast=0
    false && [ "$Background" ] && Command="$Command   
  mpr:cutmask
  ( mpr:sourcemask -threshold 0% )
    -compose Darken -composite
    -write mpr:cutmask
    -delete 0"
    
    ## --lessthanmax,less
    [ "$Lessthanmax" ] && { 
      Command="$Command
  $Lessthanmaxmask
    -write mpr:lessthanmax
    -delete 0
  mpr:cutmask
    -write mpr:cutmask_max
    -delete 0"
      
      # get part of actual maskmax
      Command="$Command
  mpr:maskmax
  mpr:cutmask_max
    -alpha Off -compose CopyOpacity -composite
    -write mpr:maskmax_part
    -delete 0"
    
      # paint actual maskmax part into lessmask
      Command="$Command
  mpr:lessthanmax
  mpr:maskmax_part
    -compose Over -composite
    -write mpr:lessthanmax
    -write $Lessthanmaxmask
    -delete 0"
    
      # get area of source mask that is stronger (+offset) than lessmask)
      Command="$Command
  mpr:sourcemask 
  ( mpr:lessthanmax -evaluate Add ${Lessthanmax:-0}% )
    -compose MinusSrc -composite
    -fill white +opaque black 
    -write mpr:cutmask_less
    -delete 0"
      
      # reduce max in maskmax where --lessthanmax takes over
      Command="$Command
  mpr:sourcemask
  mpr:cutmask_less
    -compose CopyOpacity -composite
    -write mpr:sourcemask_part
    -delete 0
  mpr:maskmax
  mpr:sourcemask_part
    -compose Over -composite
    -write mpr:maskmax
    -write $Maskmax
    -delete 0"
    
      # darken lessmask with current source mask to get a mask with decreasing sharpness after a max peak
      Command="$Command
  mpr:lessthanmax
  mpr:sourcemask
    -compose Darken -composite
    -write mpr:lessthanmax
    -delete 0"
      
      # store lessmask
      Command="$Command
  mpr:lessthanmax
    -write $Lessthanmaxmask
    -delete 0" 
    
      # get area of source mask equal or sharper than current max (same code as above, but now with less-adjusted maskmax.
      Command="$Command
  mpr:sourcemask
  mpr:maskmax
    -compose MinusDst -composite -fill white +opaque black
    -alpha off
    -negate
    -write mpr:cutmask
    -delete 0"
    } #/--lessthanmax
    
    # --cutsoft: add a blur to cut mask
    [ "$Cutsoft" ] && Command="$Command
  mpr:cutmask
    -alpha off
    -blur 0x${Cutsoft:-1}
  mpr:cutmask
    -compose Lighten -composite
    -write mpr:cutmask
    -delete 0"
    
    # --cutblur: blur cut mask
    [ "$Cutblur" ] && Command="$Command
  mpr:cutmask
    -alpha off
    -blur 0x${Cutblur:-1}
    -write mpr:cutmask
    -delete 0"
    
    # get part of source image
    Command="$Command
  mpr:sourceimage
  mpr:cutmask
    -alpha off -compose CopyOpacity -composite
    -write mpr:sourcepart
    -write $Testimage
    -delete 0"
    
    case $Stepwise in
      yes)
        Command="$Command
  mpr:resultimage
  mpr:sourcepart
    -compose Over -composite
    -alpha off
    $Tifstore
    -write $Resultimage
    -delete 0"
      ;;
      no)
        Command="$Command
  mpr:sourcepart
    $Tifstorealpha
    -write $Sourcepartimage 
    -delete 0"
      ;;
    esac
    
    Command="$Command
  xc:white null:"
          
    [ "$Count" = "1" ] && verbose "Focus montage with:
$(grep "\S" <<< "$Command")"

    case $Stepwise in
      yes)
        $Command || error "Error while cutting images"
        #[ "$Alphalevel" ] && alphalevel --image "$Resultimage" --mask "$Maskmax" --level "$Alphalevel"
        showimage $Resultimage
        #showimage $Testimage
      ;;
      no)
        multicore "$Command" "$Testimage" || error "Error in result montage"
        #multicore "$Command" || error "Error in result montage"
        [ "$Multicore_processcount" = "$Multicore_maxprocesses" ] && {
          multicore_wait || error "Error in result montage"
          flatten "$Resultimage" $Sourcepartimagelist  || error "Error while flattening images"
          #[ "$Showimageprocessing" ] && [ "$Alphalevel" ] && alphalevel --image "$Resultimage" --mask "$Maskmax" --level "$Alphalevel"
          showimage "$Resultimage"
          Sourcepartimagelist=""
        }
      ;;
    esac
    #showimage $Testimage
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Focus montage $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done
  multicore_wait || error "Error in result montage"
  
  [ -z "$Skipmontage" ] && case $Stepwise in
    no)
      # possible leftovers from multicore
      verbose "Montage $Resultimage"
      [ "$Sourcepartimagelist" ] && {
        flatten "$Resultimage" $Sourcepartimagelist || error "Error while flattening images"
        #[ "$Showimageprocessing" ] && [ "$Alphalevel" ] && alphalevel --image "$Resultimage" --mask "$Maskmax" --level "$Alphalevel"
      }
    ;;
  esac
  [ "$Error" ] && return 1
  
  :> "$Resultimageready"
  
  [ "$Maskmaxcopy" ] && cp "$Maskmax" "$Maskmaxcopy"
  $Magickbin "$Resultimage" -alpha off $Tifstore "$Outputimage" || error "Error converting '$Outputimage' to '$Resultimage'"
  
  return "${Error:-0}"
}
focus_soft() {
  local Addsource Resultimageready Outputimage Alphalevel Maskmaxcopy Maskimagelist= Resultimage
  local Addmask
  local Count Number Skipmontage=
  local Startzeit Dauer Restzeit
  local Longoptions Parsedoptions
  local Clutmaximage Clutmaskimage Sigmoidal=
  
  Longoptions="alpha:,maskmax:,output:,sigmoidal:"
  
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --output)       Outputimage="${2:-}" ; shift ;;
      --alpha)        Alphalevel="${2:-}" ; shift ;;
      --sigmoidal)    Sigmoidal="${2:-}" ; shift ;;
      --maskmax)      Maskmaxcopy="${2:-}" ; shift ;;
      --) ;;
      *)              Maskimagelist="$Maskimagelist ${1:-}" ;;
    esac
    shift
  done
  [ -z "$Maskimagelist" ] && Maskimagelist="$(masklist $Mergemaskbasename | tr '\n' ' ')"

  Resultmd5="$(md5cut "$(ls -l --full-time $Maskimagelist) $Sigmoidal")"
  Resultimage="$(cut -d- -f2- <<< "$Mergemaskbasename" | cut -d. -f1)"
  [ -z "$Resultimage" ] && Resultimage="$(basename $(awk '{print $1}' <<< "$Maskimagelist") | cut -d. -f1)"
  Resultimage="$Cachedir/soft-$Resultimage.$Resultmd5"
  Resultimageready="$Resultimage.ready"
  Addmask="$Resultimage.addmask.tif"
  Resultimage="$Resultimage.tif"

  Addsource="$Cachedir/soft-addsource.tif"
  Clutmaximage="$Cachedir/soft-clutmax.tif"
  Clutmaskimage="$Cachedir/soft-clutmask$Sigmoidal.tif"
  
  [ "$Forceoverwrite" = "focus" ] && rm $Resultimageready
  [ -e "$Resultimage" ] && [ -e "$Resultimageready" ] && {
    verbose "Skipping focus soft, already exists: $(basename $Resultimage)"
    showimage "$Resultimage"
    Skipmontage="yes"
  }
  
  [ "$Skipmontage" ] || {
    mkimg_black $Addmask
    mkimg_black $Addsource
  }
  
  [ "$Sigmoidal" = "auto" ] && Sigmoidal=""
  [ "$Sigmoidal" ] && {
    $Magickbin -size 256x256 gradient: -rotate 90 -depth 16 -sigmoidal-contrast ${Sigmoidal}% "$Clutmaskimage" || error "Error generating clut '$Sigmoidal' for --soft."
    showimage "$Clutmaskimage"
  }
  
  Startzeit="$(date +%s)"
  Count=0
  [ "$Skipmontage" ] || for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    Sourcemask="$Cachedir/$Mergemaskbasename.$Number.tif"
    Command="$Magickbin
  $Sourceimage
    -depth 16
    -write mpr:sourceimage
    -delete 0
  $Sourcemask
    -depth 16
    -write mpr:mask
    -delete 0"
    
    [ "$Sigmoidal" ] && Command="$Command
  mpr:mask
  $Clutmaskimage
    -clut
    -write mpr:mask
    -delete 0"
    
    Command="$Command
  mpr:mask
    +level 2%,100%
    -evaluate Divide $Imagenumber
    -write mpr:mask
    -delete 0
  $Addmask
  mpr:mask
    -compose Plus -composite
    -write mpr:addmask
    $Tifstore
    -write $Addmask
    -delete 0
  $Addsource
  ( mpr:sourceimage mpr:mask -compose Multiply -composite )
    -evaluate-sequence Add
    -write mpr:sourceadd
    $Tifstore
    -write $Addsource
    -delete 0"
    [ "$Showimageprocessing" ] && {
      Command="$Command
  mpr:sourceadd
  mpr:addmask
    -compose DivideSrc -composite
    $Tifstorealpha
    -write $Resultimage"
    }
    Command="$Command
  xc: null:"
  
    [ "$Count" = "1" ] && verbose "Focus soft with:
$(grep "\S" <<< "$Command")"
  
    $Command || error "Error in focus_soft()"
    showimage $Resultimage
    Dauer="$(( $(date +%s)-Startzeit))"
    Restzeit="$(( Dauer*(Imagenumber-Count) / Count ))"
    verbose "Focus soft $Count/$Imagenumber. Duration: $(date -u -d @$Dauer +"%T"); ETA: $(date -u -d @$Restzeit +"%T")"
  done
  [ "$Error" ] && return 1
  
  $Magickbin $Addsource $Addmask -compose DivideSrc -composite $Tifstorealpha $Resultimage || error "Error in softfusion: failed to divide by mask"
  
  :> $Resultimageready

  [ "$Maskmaxcopy" ] && {
    redist --image "$Addmask" --clut "$Clutmaximage"  || error "Error generating clut for maskmax"
    $Magickbin "$Addmask" "$Clutmaximage" -clut "$Maskmaxcopy" || error "Error adjusting maskmax"
  }
  $Magickbin "$Resultimage" $Tifstore "$Outputimage" || error "Error storing result of softfusion"

  return ${Error:-0}
}
focus_softX() {
  local Addsource Resultimageready Outputimage Alphalevel Maskmaxcopy Maskimagelist= Power Resultimage
  local Addmask
  local Count Number Skipmontage=
  local Longoptions Parsedoptions
  
  Longoptions="alpha:,maskmax:,power:,output:"
  
  Parsedoptions="$(getopt --options="" --longoptions "$Longoptions" -- "$@")"
  eval set -- "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --output)       Outputimage="${2:-}" ; shift ;;
      --alpha)        Alphalevel="${2:-}" ; shift ;;
      --maskmax)      Maskmaxcopy="${2:-}" ; shift ;;
      --power)        Power="${2:-}" ; shift ;;
      --) ;;
      *)              Maskimagelist="$Maskimagelist ${1:-}" ;;
    esac
    shift
  done
  [ -z "$Maskimagelist" ] && Maskimagelist="$(masklist $Mergemaskbasename | tr '\n' ' ')"
  Power="${Power:-2}"

  Resultmd5="$(md5cut "$(ls -l --full-time $Maskimagelist) $Power")"
  Resultimage="$(cut -d- -f2- <<< "$Mergemaskbasename" | cut -d. -f1)"
  [ -z "$Resultimage" ] && Resultimage="$(basename $(awk '{print $1}' <<< "$Maskimagelist") | cut -d. -f1)"
  Resultimage="$Resultimage-power$Power"
  Resultimage="$Cachedir/soft-$Resultimage.$Resultmd5"
  Resultimageready="$Resultimage.ready"
  Addmask="$Resultimage.mask.tif"
  Resultimage="$Resultimage.tif"

  Addsource="$Cachedir/soft-addsource.tif"
  Clutimage="$Cachedir/soft-clut.tif"
  
  [ -e "$Resultimage" ] && [ -e "$Resultimageready" ] && {
    verbose "Skipping montage, already exists: $(basename $Resultimage)"
    showimage "$Resultimage"
    Skipmontage="yes"
  }
  
  [ "$Skipmontage" ] || {
    mkimg_black $Addmask
    mkimg_black $Addsource
  }
  
  Count=0
  [ "$Skipmontage" ] || for Sourceimage in $Sourceimagelist; do
    [ "$Error" ] && break
    Count="$((Count+1))"
    Number="$(printnum $Count $Imagenumberlength)"
    Sourcemask="$Cachedir/$Argbasename.$Number.tif"
    Command="$Magickbin
  $Sourceimage
    -depth 16
    -write mpr:sourceimage
    -delete 0
  $Sourcemask
    -write mpr:mask
    -depth 16
    -evaluate Pow ${Power:-2}
    -evaluate Divide $Imagenumber
    -write mpr:mask
    -delete 0
  $Addmask
  mpr:mask
    -compose Plus -composite
    -write mpr:addmask
    $Tifstore
    -write $Addmask
    -delete 0
  $Addsource
  ( mpr:sourceimage mpr:mask -compose Multiply -composite )
    -evaluate-sequence Add
    -write mpr:sourceadd
    $Tifstore
    -write $Addsource
    -delete 0"
    
    [ "$Showimageprocessing" ] && Command="$Command
  mpr:sourceadd
  mpr:addmask
    -compose DivideSrc -composite
    $Tifstorealpha
    -write $Resultimage"
    
    Command="$Command
  xc: null:"
  
    $Command || error "Error in focus_soft()"
    showimage $Resultimage
  done
  [ "$Error" ] && return 1
  
  :> $Resultimageready
  
#          -sigmoidal-contrast ${Testarg:-8},$Percent% # -treshold 15%
#          -function sinusoid 0.5,-90,0.5,0.5

  [ "$Maskmaxcopy" ] && {
    redist --image "$Addmask" --clut "$Clutimage"  
    $Magickbin "$Addmask" "$Clutimage" -clut "$Maskmaxcopy"
  }
  $Magickbin "$Resultimage" $Tifstore "$Outputimage"

  return ${Error:-0}
}
focus_maskmethod() {
  # Mask generating ImageMagick options
  # Most of them are based on edge detection: http://www.imagemagick.org/Usage/convolve/#edgedet
  local Method Sourceimage
  local Maskgenerator
    
  Method="${1:-none}"
    
  case $Method in
    blur)
      Maskgenerator="
  mpr:sourcegray
    -blur ${Argradius1:-0}x${Argsigma1:-0.75}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    channel|saturation|chroma|lightness|darkness)
      Maskgenerator="
  mpr:sourceimage
    -colorspace ${Argword1:-HSB} 
    -channel ${Argword2:-1} -separate
    +channel"
      [ "$Method" = "darkness" ] && Maskgenerator="$Maskgenerator
    -negate"
    ;;
    comet) ### FIXME saturate drops some angles
      Maskgenerator="
  mpr:sourcegray 
    -define morphology:compose=${Argword1:-Lighten}
    -morphology Convolve Comet:${Argradius1:-0}x${Argsigma1:-5}:>
  mpr:sourcegray
    -compose difference -composite"
    ;;
    compass)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=50%!
    -define morphology:compose=Lighten
    -define convolve:bias=50%
    -morphology Convolve Compass:>"
#-compose Difference -composite" # sort of interesting.
    ;;
    compose)
      Maskgenerator="
  ( mpr:sourcegray -alpha off )
  ( '$(generate_image --showname "$Argword1")' $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    diffstat)
      Maskgenerator=""
      [ "$Argword1" = "source" ] && Maskgenerator="$Maskgenerator mpr:sourcegray" || Maskgenerator="$Maskgenerator
  ( mpr:sourcegray -statistic ${Argword1:-median} ${Argradius1:-5} )"
      [ "$Argword2" = "source" ] && Maskgenerator="$Maskgenerator mpr:sourcegray" || Maskgenerator="$Maskgenerator
  ( mpr:sourcegray -statistic ${Argword2:-mean} ${Argradius1:-5} )"
Maskgenerator="$Maskgenerator
    -compose Difference -composite"
    ;;
    dog) # DoG: Difference of Gaussian
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100,100%
    -morphology Convolve DoG:${Argradius1:-0},${Argsigma1:-0.75},${Argsigma2:-1.2}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    enfuse)
#      case "${Argword1:-soft}" in
#        soft) Maskgenerator="
#  $Cachedir/enfuse-soft.NUMBER.tif
#    -depth 16" ;;
#        hard) Maskgenerator="
#  $Cachedir/enfuse-hard.NUMBER.tif
#    -depth 16" ;;
#      esac
      Maskgenerator="
  ( mpr:sourcegray -alpha off )
  ( '$(generate_image --showname enfuse)' $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    evaluate|min|max|mean|median)
      Maskgenerator="
  ( mpr:sourcegray -alpha off )
  ( '$(generate_image --showname "${Argword1:-$Method}")' $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    GAUSSexperimental) 
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=-100,200%
    -morphology Convolve Gaussian:${Argradius1:-0}x${Argsigma1:-0.75}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    CROSSMORPHexperimental)
      Maskgenerator="
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1:-3}x1+1+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1:-3}x1+${Argradius1:-3}+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:1x${Argradius1:-3}+0+1 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:1x${Argradius1:-3}+0+${Argradius1:-3} )
    -evaluate-sequence min"
    ;;
    CROSSMORPH2experimental)
      Maskgenerator="
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1}x$((Argradius1/2))+0+$((Argradius1/4)) )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:${Argradius1}x$((Argradius1/2))+$((Argradius1-1))+$((Argradius1/4)) )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:$((Argradius1/2))x$((Argradius1))+$((Argradius1/4))+0 )
  ( mpr:sourcegray -morphology ${Maskgeneratorargument:-edge}:${Argradius2:-1} Rectangle:$((Argradius1/2))x$((Argradius1))+$((Argradius1/4))+$((Argradius1-1)) )
    -evaluate-sequence min"
    ;;
    experimental)
      Maskgenerator="
  mpr:sourcegray
    -threshold 80%
    -blur 0x5
    -auto-level
    -negate"
    ;;
    free)
      Maskgenerator="
  mpr:sourcegray 
    $Argword1"
    ;;
    freediff)
      Maskgenerator="
  mpr:sourcegray 
    $Argword1
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    freichen)
      case $Argword1 in
        "")
          Maskgenerator="
  (
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:1>
  )
  (
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=5%
    -morphology Convolve FreiChen:2>
  )
    -compose Screen
    -composite"
        ;;
        *)
          Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=Screen
    -define convolve:bias=10%
    -morphology Convolve FreiChen:${Argword1:-0}>"
        ;;
      esac
    ;;
    gaussian)
      Maskgenerator="
  ( mpr:sourcegray -gaussian-blur ${Argradius1:-0}x${Argsigma1:-0.75} )
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    XXXhalo)
      Maskgenerator="
  mpr:sourcegray
    -threshold $(calc "100-${Argpercent1:-50}")%
    -write mpr:halomask
    -delete 0
  mpr:sourcegray
    -brightness-contrast -23,-100
  mpr:halomask
    -compose CopyOpacity -composite
  mpr:sourcegray
    -compose DstOver -composite    
    "
    ;;
    halo)
      Maskgenerator="
  mpr:sourcegray
    -threshold $(calc "100-${Argpercent1:-50}")%
    -morphology Dilate Octagon:${Argradius1:-2}
    -blur 0x${Argsigma1:-5}
    -auto-level
    -negate"
    ;;
    image)
      Maskgenerator="
  ( mpr:sourcegray -alpha off )
  ( '$Argword1' $Grayscaleconverter -alpha off )
    -compose Difference -composite
    -negate"
    ;;
    kirsch)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=screen
    -define convolve:bias=15%
    -morphology Convolve Kirsch:>"
    ;;
    laplacian)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:bias=5%
    -define convolve:scale=100%!
    -morphology Convolve Laplacian:${Argword1:-0}>"
    ;;
    log)  # LoG: Laplacian of Gaussian
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100,100%
    -morphology Convolve LoG:${Argradius1:-0}x${Argsigma1:-0.75}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    morphology)
      Maskgenerator="
  mpr:sourcegray
    -morphology ${Argword1:-edge}:${Argradius2:-1} Octagon:${Argradius1:-2}"
    ;;
    none)
      Maskgenerator="mpr:sourcegray"
    ;;
    prewitt)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100%!
    -define morphology:compose=screen
    -define convolve:bias=10%
    -morphology Convolve Prewitt:>"
    ;;
    roberts)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100%
    -define morphology:compose=screen
    -define convolve:bias=10%
    -morphology Convolve Roberts:@"
    ;;
    sobel)
      Maskgenerator="
  mpr:sourcegray
    -define convolve:scale=100%!
    -define convolve:bias=10%
    -define morphology:compose=screen
    -morphology Convolve Sobel:>"
    ;;
    statistic)
      Maskgenerator="
  mpr:sourcegray
    -statistic ${Argword1:-standarddeviation} ${Argradius1:-2}x${Argradius1:-2}"
    ;;
    unsharp)
      Maskgenerator="
  mpr:sourcegray -unsharp ${Argradius1:-0}x${Argsigma1:-5}
  mpr:sourcegray
    -compose Difference -composite"
    ;;
    wavelet)
      Maskgenerator="
  mpr:sourcegray 
    -wavelet-denoise ${Argpercent1:-10}%
  mpr:sourcegray
    -compose Difference -composite"
    ;;
  esac
    
  grep . <<< "$Maskgenerator"
}

### mask args

maskarg_parse() {
  local Key Line Value
  
  Argbasename=""
  Argclose1=""
  Argclose2=""
  Argdarkenmask=""
  Argdenoise=""
  Argdiff=""
  Argless=""
  Arglevel=""
  #Argmethod=""
  Argnegate=""
  Argpercent1=""
  Argpercent2=""
  Argradius1=""
  Argradius2=""
  Argsigma1=""
  Argsigma2=""
  Argalpha=""
  Argtype=""
  Argweight=""
  Argword1=""
  Argword2=""
    
  while read -d, Line; do
    grep -q "=" <<< "$Line" && {
      Key="$(cut   -d= -f1    <<< "$Line")"
      Value="$(cut -d= -f2 -s <<< "$Line")"
      :
    } || {
      Key="$(digitrm "$Line")"
      Value="$(sed "s/${Key:-NOKEY}//"  <<< "$Line")"
    }
    case $Key in
      #"w"|"w%")       Argweight="${Value:-$(maskarg_defaultvalue    "$Firstmaskmethod" noise)}" ;;
      "w"|"w%")           Argweight="${Value:-}" ;;
      "r")                Argradius1="$Value" ;;
      "R")                Argradius2="${Value}" ;;
      "s")                Argsigma1="$Value" ;;
      "S")                Argsigma2="${Value}" ;;
      "p"|"%")            Argpercent1="$(percentrm "$Value")" ;;
      "P")                Argpercent2="$(percentrm "$Value")" ;;
      "alpha"|"alphax")     
        Argalpha="$(tr -d "alpha=" <<< "$Line")"
        Argalpha="${Argalpha:-$(maskarg_defaultvalue      "$Argmethod" alpha)}"
        Argalpha="$(levelparse "$Argalpha")"
      ;;
      "denoise")          Argdenoise="${Value:-$(maskarg_defaultvalue   "$Argmethod" noise)}" ;;
      "d"|"diff")         Argdiff="s" ;;
      "less")             Argless="${Value:-$(maskarg_defaultvalue      "$Argmethod" less)}" ;;
      "blur"|"maskblur")  Argmaskblur="${Value:-$(maskarg_defaultvalue  "$Argmethod" maskblur)}" ;;
      "n"|"neg"|"negate") Argnegate="neg" ;;
      "c"|"close"|"cx"|"closex")
        Value="$(tr -d "close" <<< "$Line")"
        Value="${Value:-$(maskarg_defaultvalue                          "$Argmethod" close)}"
        Argclose1=$(cut -dx    -f1 <<< "$Value")
        Argclose2=$(cut -dx -s -f2 <<< "$Value")
        Argclose1="$(digitonly "$Argclose1")"
        Argclose2="$(digitonly "$Argclose2")"
        Argclose2="${Argclose2:-1}"
      ;;
      "CLOSE1")           Argclose1="$Value" ;;
      "CLOSE2")           Argclose2="$Value" ;;
      "LEVEL")            Arglevel="yes" ;;
      "DARKENMASK")       Argdarkenmask="$Value" ;;
      "NUM")              Maskmethodcount="$Value" ;;
      "METHOD")           Argmethod="$Value" ;;
      "TYPE")             Argtype="$Value" ;;
      "BASENAME")         Argbasename="$Value" ;;
      *|WORD1|WORD2) ### FIXME
        [ -z "$Argword1" ] && Argword1="$Line" || Argword2="$Line" 
        Argword1="${Argword1#WORD1=}"
        Argword2="${Argword2#WORD2=}"
      ;;
    esac
  done <<< "${1:-},"
}
maskarg_store() {
  Maskmethodcount="${1:-$Maskmethodcount}"
  Newoption="METHOD=$Argmethod"
  [ "$Argweight" ]             && Newoption="$Newoption,w=$Argweight"
  [ "$Argradius1" ]            && Newoption="$Newoption,r=$Argradius1"
  [ "$Argradius2" ]            && Newoption="$Newoption,R=$Argradius2"
  [ "$Argsigma1" ]             && Newoption="$Newoption,s=$Argsigma1"
  [ "$Argsigma2" ]             && Newoption="$Newoption,S=$Argsigma2"
  [ "$Argpercent1" ]           && Newoption="$Newoption,p=$Argpercent1"
  [ "$Argpercent2" ]           && Newoption="$Newoption,P=$Argpercent2"
  [ "$Argless" ]               && Newoption="$Newoption,less=$Argless"
  [ "$Argclose1" ]             && Newoption="$Newoption,CLOSE1=$Argclose1"
  [ "$Argclose2" ]             && Newoption="$Newoption,CLOSE2=$Argclose2"
  [ "$Argword1" ]              && Newoption="$Newoption,WORD1=$Argword1"
  [ "$Argword2" ]              && Newoption="$Newoption,WORD2=$Argword2"
  [ "$Argdenoise" ]            && Newoption="$Newoption,denoise=$Argdenoise"
  [ "$Argdiff" ]               && Newoption="$Newoption,diff"
  [ "$Argalpha" ]              && Newoption="$Newoption,alpha=$Argalpha"
  [ "$Argmaskblur" ]           && Newoption="$Newoption,maskblur=$Argmaskblur"
  [ "$Argnegate" ]             && Newoption="$Newoption,negate"
  [ "$Argdarkenmask" ]         && Newoption="$Newoption,DARKENMASK=$Argdarkenmask"
  [ "$Arglevel" ]              && Newoption="$Newoption,LEVEL"
  [ "$Argtype" ]               && Newoption="$Newoption,TYPE=$Argtype"
  [ "$Argbasename" ]           && Newoption="$Newoption,BASENAME=$Argbasename"
  Newoption="$Newoption,NUM=$Maskmethodcount"

  grep -q "NUM=$Maskmethodcount" <<< "$Maskmethodlist" \
    && Maskmethodlist="$(sed "s&.*NUM=$Maskmethodcount.*&$Newoption&" <<< "$Maskmethodlist")" \
    || Maskmethodlist="$Maskmethodlist
$Newoption"
  Maskmethodlist="$(grep "\S" <<< "$Maskmethodlist")"
}
maskarg_defaultvalue() {
  case "${2:-}" in
    close)
      echo "2x2"
    ;;
    maskblur)
      case "${1:-}" in
        blur|comet|compass|diffstat|dog|freichen|gaussian|kirsch|laplacian|log|morphology|prewitt|roberts|sobel|statistic|unsharp|wavelet)
          echo "1"
        ;;
        *)
          echo "0"
        ;;
      esac
    ;;
    less)
      case "${1:-}" in
        blur)       echo "60" ;;
        comet)      echo "45" ;;
        compass)    echo "45" ;;
        dog)        echo "35" ;;
        diffstat)
          case "$Argword1,$Argword2" in
            "median,mean") echo "45" ;;
            "min,max")     echo "45" ;;
            *)             echo "45" ;;
          esac
        ;;
        freichen)   
          case $Argword1 in
            "")     echo "45" ;;
            15)     echo "10" ;;
          esac
        ;;
        gaussian)   echo "60" ;;
        kirsch)     echo "60" ;;
        laplacian)
          case $Argword1 in
            3)      echo "60" ;;
          esac
        ;;
        log)        echo "60" ;;
        morphology) echo "45" ;;
        prewitt)    echo "45" ;;
        roberts)    echo "60" ;;
        sobel)      echo "45" ;;
        statistic)  echo "45" ;;
        #unsharp
        wavelet)    echo "60" ;;
        *)          echo "60" ;;
      esac
    ;;
    levelmin)
      case "${1:-}" in
        blur)       echo "0" ;;
        comet)      echo "0" ;;
        compass)    echo "45" ;;
        dog)        echo "0" ;;
        diffstat)
          case "$Argword1,$Argword2" in
            "median,mean") echo "0" ;;
            "min,max")     echo "0" ;;
          esac
        ;;
        freichen)   
          case $Argword1 in
            "") echo "33.6584" ;;
            15) echo "19" ;;
          esac
        ;;
        gaussian)   echo "0" ;;
        #kirsch)     echo "" ;;
        laplacian)
          case $Argword1 in
            3)      echo "0" ;;
          esac
        ;;
        log)        echo "0" ;;
        morphology) echo "0" ;;
        prewitt)    echo "34.3893" ;;
        #roberts)    echo "7.64782%,100%" ;;
        sobel)      echo "34.3893" ;;
        statistic)
          case $Argword1 in
            standarddeviation) echo "0" ;;
          esac
        ;;
        #unsharp
        wavelet)    echo "0" ;;
        *)          echo "" ;;
      esac
    ;;
    noise)
      echo "50"
      false && case "${1:-}" in
        #blur)       echo "15" ;;
        #comet
        compass)    echo "25" ;;
        diffstat)   echo "15" ;;
        #dog
        freichen)   echo "15" ;;
        #gaussian)   echo "15" ;;
        image|evaluate|compose|enfuse)
                    echo "100" ;;
        #kirsch)     echo "2" ;;
        #laplacian
        log)        echo "10" ;;
        morphology) echo "10" ;;
        prewitt)    echo "15" ;;
        #roberts
        sobel)      echo "1" ;;
        statistic)  echo "10" ;;
        #unsharp
        wavelet)    echo "10" ;;
        *)          echo "15" ;;
      esac
    ;;
    percent1)
      case "${1:-}" in
        halo)       echo "25" ;;
        wavelet)    echo "10" ;;
        *)          echo "" ;;
      esac
    ;;
    percent2)
      case "${1:-}" in
        *)          echo "" ;;
      esac
    ;;
    radius1)
      case "${1:-}" in
        #blur)       echo "" ;; # 0
        #comet)      echo "" ;; # 0
        compass)    echo "" ;;
        diffstat)   echo "3" ;;
        #dog)        echo "" ;; # 0
        freichen)   echo "" ;;
        #gaussian)   echo "" ;; # 0
        kirsch)     echo "" ;;
        laplacian)  echo "" ;;
        #log)        echo "" ;; # 0
        morphology) echo "1" ;;
        prewitt)    echo "" ;;
        roberts)    echo "" ;;
        sobel)      echo "" ;;
        statistic)  echo "2" ;;
        #unsharp)    echo "" ;; # 0
        *)          echo "" ;;
      esac
    ;;
    radius2)
      case "${1:-}" in
        *)          echo "" ;;
      esac
    ;;
    sigma1)
      case "${1:-}" in
        blur)       echo "0.3" ;;
        comet)      echo "5" ;;
        compass)    echo "" ;;
        diffstat)   echo "" ;;
        dog)        echo "0.3" ;;
        freichen)   echo "" ;;
        gaussian)   echo "0.3" ;;
        halo)       echo "5" ;;
        kirsch)     echo "" ;;
        laplacian)  echo "" ;;
        log)        echo "0.2" ;;
        morphology) echo "" ;;
        prewitt)    echo "" ;;
        roberts)    echo "" ;;
        sobel)      echo "" ;;
        statistic)  echo "" ;;
        unsharp)    echo "2" ;;
        wavelet)    echo "" ;;
        *)          echo "" ;;
      esac
    ;;
    sigma2)
      case "${1:-}" in
        dog)       echo "$(calc "${Argsigma1:-0.75} * 1.6")" ;;
        *)         echo "" ;;
      esac
    ;;
    alpha)
      echo "100"
    ;;
    type)
      case "${1:-}" in
        blur|comet|compass|diffstat|dog|freichen|gaussian|kirsch|laplacian|log|morphology|prewitt|roberts|sobel|statistic|unsharp|wavelet)
          echo "mask"
        ;;
        *)
          echo "image"
        ;;
      esac
    ;;
    word1)
      case "${1:-}" in
        channel)    echo "HSL" ;;
        comet)      echo "lighten" ;;
        compose)    echo "overlay" ;;
        diffstat)   echo "median" ;;
        evaluate)   echo "max" ;;
        freichen)   echo "" ;;
        freediff)   echo "-sharpen 0x3" ;;
        laplacian)  echo "3" ;;
        morphology) echo "edge" ;;
        statistic)  echo "standarddeviation" ;;
        *)          echo "" ;;
      esac
    ;;
    word2)
      case "${1:-}" in
        channel)    echo "2" ;;
        diffstat)   echo "mean" ;;
        *)          echo "" ;;
      esac
    ;;
  esac
} 
maskarg_checkallowed() {
  local Method Option Arg
  Method="${1:-}"
  Option="${2:-}"
  Arg="${3:-}"
  case "$Option" in
    radius1)
      case "$Method" in
        #blur|comet|dog|gaussian|halo|log|morphology|unsharp|wavelet) ;;
        halo|morphology) ;;
        diffstat|statistic)
          [ "$Arg" -lt "2" ] && error "--$Method needs a radius of at least 2"
        ;;
        *) error "$Method does not take argument radius" ;;
      esac
    ;;
    radius2)
      error "$Method does not take argument radius2"
    ;;
    sigma1)
      case "$Method" in
        blur|comet|dog|gaussian|halo|log|unsharp) ;;
        *) error "$Method does not take argument sigma" ;;
      esac
    ;;
    sigma2)
      case "$Method" in
        dog) ;;
        *) error "$Method does not take argument sigma2" ;;
      esac
    ;;
    percent1)
      case "$Method" in
        wavelet|halo) ;;
        *) error "$Method does not take argument percent1" ;;
      esac
    ;;
    percent2)
      case "$Method" in
        *) error "$Method does not take argument percent2" ;;
      esac
    ;;
    word1)
      case "$Method" in
        enfuse) ;;
        comet|channel|freichen|freediff|laplacian) ;;
        compose|evaluate|morphology)
          Arg="$(lowercase "${Arg}")"
          checkmagicklist "$Method" "$(tr -d '2' <<< "$Arg")" || {
            error "--$Method=$Arg: unknown argument.
  Please choose one out of '$Magicklist -list $Method'"
          }
        ;;
        diffstat)
          Arg="$(lowercase "${Arg}")"
          Arg="$(maskarg_checkstatistic "$Arg")"
        ;;
        statistic)
          Arg="$(lowercase "${Arg}")"
          Arg="$(maskarg_checkstatistic "$Arg")"
          [ "$Arg" = "source" ] && error "--$Method does not take argument $Arg
  Please choose one out of '$Magicklist -list $Method'"
        ;;
        *) error "$Method does not take argument word1 $Arg" ;;
      esac
    ;;
    word2)
      case "$Method" in
        diffstat)
          Arg="$(lowercase "${Arg}")"
          Arg="$(maskarg_checkstatistic "$Arg")"
        ;;
        channel) ;;
        *) error "$Method does not take argument word2 $Arg" ;;
      esac
    ;;
  esac
  [ "$Error" ] && return 1
  echo "$Arg"
  return 0
}
maskarg_checkstatistic() {
  local Mode

  Mode="${1:-}"
  case ${Mode,,} in
    0|source|none)          Mode="source" ;;
    1|gradient|grad)        Mode="gradient" ;;
    2|maximum|max)          Mode="maximum" ;;
    3|mean)                 Mode="mean" ;;
    4|median)               Mode="median" ;;
    5|minimum|min)          Mode="minimum" ;;
    6|mode)                 Mode="mode" ;;
    7|nonpeak)              Mode="nonpeak" ;;
    8|9|rms|rootmeansquare) Mode="rms" ;;
    10|standarddeviation|standard_deviation|standard-deviation|dev) 
                            Mode="standarddeviation" ;;
    *) error "Unknown statistic mode '$Mode'" ; return 1;;
  esac
  [ "$Error" ] && return 1
  echo "$Mode"
  return 0
}
maskarg_checkpercent() {
  # Allow percent values to be given without a leading 'p'. Few options only.
  [ -z "$Argpercent1" ] && [ -n "$Argword1" ] && {
    Argpercent1="$Argword1"
    Argword1=""
  }
  [ -n "$Argpercent1" ] && [ -n "$Argword1" ] && {
    error "Option does not take percent value along with a word argument"
    return 1
  }
  [ "$Argpercent1" = "$(digitonly "$Argpercent1")" ] || {
    error "Invalid sigma value: $Argpercent1"
    return 1
  }
}
maskarg_checksigma() {
  # Allow sigma values to be given without a leading 's'. Few options only.
  [ -z "$Argsigma1" ] && [ -n "$Argword1" ] && {
    Argsigma1="$Argword1"
    Argword1=""
  }
  [ -n "$Argsigma1" ] && [ -n "$Argword1" ] && {
    error "Option does not take sigma value along with a word argument"
    return 1
  }
  [ "$Argsigma1" = "$(digitonly "$Argsigma1")" ] || {
    error "Invalid sigma value: $Argsigma1"
    return 1
  }
}

### main

trap_sigint() {
  error "Received SIGINT"
  multicore_break
}
declare_variables() {
  Arglist='
  Argbasename=""
  Argclose1=""
  Argclose2=""
  Argdarkenmask=""
  Argdenoise=""
  Argdiff=""
  Argless=""
  Arglevel=""
  Argmaskblur=""
  Argmethod=""
  Argnegate=""
  Argpercent1=""
  Argpercent2=""
  Argradius1=""
  Argradius2=""
  Argsigma1=""
  Argsigma2=""
  Argalpha=""
  Argtype=""
  Argweight=""
  Argword1=""
  Argword2=""
  '
  eval $Arglist
  
  Background=""
  Backgroundimage=""
  Backgroundtype=""
  Basename=""
  Cachedir=""
  Caseeval=""
  Casecompose=""
  Composefactor="" ### FIXME
  Cutblur=""
  Cutsoft=""
  Darkenmask=""
  Difference_needlist=""
  Error=""
  Exifsourceimage=""
  Fakehdr=""
  Finalblur=""
  Finalblurpercent=""
  Finalblursigma1=""
  Finalblursigma2=""
  Firstimage=""
  Firstmaskmethod=""
  Forceoverwrite=""
  Freemem=""
  Globalalpha=""
  Globalclose=""
  Globalclose1=""
  Globalclose2=""
  Globalclosethreshold=""
  Globaldenoise=""
  Globalmaskblur=""
  Globalless=""
  Globalsigmoidal=""
  Globalthreshold=""
  Globalthresholdblur=""
  Grayscale=""
  Grayscaleconverter=""
  Grayscalenumber=""
  Image=""
  Imageformat="tif"
  Imageheight=""
  Imagelistmemsize=""
  Imagememsize=""
  Imagenumber=""
  Imagewidth=""
  Image_needlist=""
  Layers=""
  Line=""
  Magickbin=""
  Magicklist=""
  Magickpixelmemory=""
  Magickversion=""
  Maskmethodcount=""
  Maskmethodlist=""
  Maskmethodnumber=""
  Mergemaskbasename=""
  Mergemethod=""
  Outputimage=""
  Parsedoptions=""
  Preservecache=""
  Prefertop=""
  Redistdefault=""
  Redistpeak=""
  Redistshape=""
  Revertimagelist=""
  Resultimage=""
  Savemask=""
  Showimageprocessing=""
  Showname=""
  Slabkernelfactor=""
  Slabmasks=""
  Slaboptions=""
  Slaboverlap=""
  Slabs=""
  Slabsize=""
  Slabsourcelist=""
  Slabstep=""
  Softmode=""
  Sourceimage=""
  Sourceimagelist=""
  Sourcemd5=""
  Startzeit="$(date +%s)"
  Testarg=""
  Testimage=""
  Testsetup=""
  Tifstore="+repage -quality 100% -compress lzw"
  Tifstorealpha="$Tifstore -type TrueColorAlpha"
  Verbose=""
  Video=""
  Videoframecount=""
  Viewnior=""
  
  return 0
}
parse_options() {
  local Shortoptions Longoptions Parsererror Parsererrorfile Maskgeneratorargument
  #local Parsedoptions
  
  Shortoptions="ho:vVW"
  Longoptions="basename:,cache::,exif::,force::,help,output:,savemask::,showimage,showname,test::,threads:,verbose,version,video"
  Longoptions="$Longoptions,alpha::,background::,bg::,close::,cutblur::,cutsoft::,darkenmask:,denoise::,fakehdr::,finalblur::,grayscale:,layers::,less::,maskblur::,merge::,prefertop::,redist::,revert,sigmoidalclut::,slabs::,soft::,threshold::"
  Longoptions="$Longoptions,channel::,chroma::,compose::,darkness::,enfuse::,evaluate::,halo::,image::,lightness::,max::,mean::,median::,min::,saturation::"
  Longoptions="$Longoptions,blur::,comet::,compass::,diffstat::,dog::,enfuse::,gaussian::,freichen::,kirsch::,laplacian::,log::,morphology::,none::,prewitt::,roberts::,sobel::,statistic::,unsharp::,wavelet::"  
  Longoptions="$Longoptions,experimental::,free::,freediff::"
  
  Parsererrorfile="/tmp/imfuse.parserserror.$RANDOM"
  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@" 2>"$Parsererrorfile")"
  [ -e $Parsererrorfile ] && Parsererror="$(cat "$Parsererrorfile")" && rm "$Parsererrorfile"
  [ "$Parsererror" ] && error "$Parsererror"
  eval set -- "$Parsedoptions"
  
  while [ $# -gt 0 ]; do
    [ "$Error" ] && break
    case "${1:-}" in
         --alpha)             Globalalpha="${2:-auto}"        ; shift ;;
         --bg|--background)   Background="${2:-auto}"         ; shift ;;
         --basename)          Basename="${2:-auto}"           ; shift ;;
         --darkenmask)        Darkenmask="${2:-}"             ; shift ;;
         --cache)             Preservecache="yes"             ; Cachedir="${2:-auto}" ; shift ;;
         --close)             Globalclose="${2:-auto}"        ; shift ;;
         --cutblur)           Cutblur="${2:-auto}"            ; shift ;;      
         --cutsoft)           Cutsoft="${2:-auto}"            ; shift ;;      
         --denoise)           Globaldenoise="${2:-auto}"      ; shift ;;
         --exif)              Exifsourceimage="${2:-auto}"    ; shift ;;
         --fakehdr)           Fakehdr="${2:-auto}"            ; shift ;;
         --finalblur)         Finalblur="${2:-auto}"          ; shift ;;
         --force)             Forceoverwrite="${2:-yes}"      ; shift ;;
         --grayscale)         Grayscale="${2:-auto}"          ; shift ;;
      -h|--help)              usage                           ; exit 0 ;;
         --layers)            Layers="${2:-auto}"             ; shift ;;
         --less)              Globalless="${2:-auto}"         ; shift ;;
         --maskblur)          Globalmaskblur="${2:-auto}"     ; shift ;;      
         --merge)             Mergemethod="${2:-auto}"        ; shift ;;      
         --prefertop)         Prefertop="${2:-auto}"          ; shift ;;      
         --redist)            Redistshape="${2:-auto}"        ; shift ;;
      -o|--output)            Outputimage="${2:-}"            ; shift ;;
         --revert)            Revertimagelist="yes"           ;;
         --savemask)          Savemask="${2:-auto}"           ; shift ;;
      -V|--showimage)         Showimageprocessing="yes"       ;;
         --showname)          Showname="yes"                  ;;
         --sigmoidalclut)     Globalsigmoidal="${2:-auto}"    ; shift ;;
         --slabs)             Slabs="${2:-auto}"              ; shift ;;
         --soft)              Softmode="${2:-auto}"           ; shift ;;
         --test)              Testsetup="test"                ; Testarg="${2:-}" ; shift ;;
         --threads)           Multicore_maxprocesses="${2:-}" ; shift ;;
         --threshold)         Globalthreshold="${2:-auto}"    ; shift ;;
      -v|--verbose)           Verbose="yes"                   ;;
         --version)           echo "imfuse v$Version"         ; exit 0 ;;
         --video)             Video="auto"                    ;;
      -W)                     Viewnior="yes"                  ;;
      
--blur|--channel|--chroma|--comet|--compass|--compose|--darkness|--diffstat|--dog|--enfuse|--evaluate|\
--experimental|--free|--freediff|\
--freichen|--gaussian|--halo|--image|--kirsch|--laplacian|--lightness|--log|--morphology|\
--max|--mean|--median|--min|\
--none|--prewitt|--roberts|--saturation|--sobel|--statistic|--unsharp|--wavelet)
        Argmethod="${1#--}"
        Maskgeneratorargument="${2:-}" && shift
        Maskmethodnumber="$((Maskmethodnumber+1))"
        Maskmethodcount="$Maskmethodnumber"
        maskarg_parse "$Maskgeneratorargument"
        maskarg_store "$Maskmethodcount"
      ;;
      
      --) ;;
      *)
        Sourceimagelist="$Sourceimagelist
$(realpath "${1:-}")" 
        [ -f "${1:-}" ] || error "File not found: ${1:-}"
      ;;
    esac
    shift
  done
  return ${Error:-0}
}  
check_options() {
  local Arg Part1 Part2 Weightsum= Weightrest Masknoweightcount=
  
  # source images
  [ -z "$Sourceimagelist" ] && error "No images specified"
  Sourceimagelist="$(grep .     <<< "$Sourceimagelist")"
  Sourceimagelist="$(sort -V -r <<< "$Sourceimagelist")"
  grep -q ' ' <<< "$Sourceimagelist" && error "imfuse does not accept whitespace in pathes or file names:
$(grep -m1 ' ' <<< "$Sourceimagelist")"
  Sourceimagelist="$(grep -v -x "" <<< "$Sourceimagelist")"
  
  Imagenumber="$(grep -c "." <<< "$Sourceimagelist")"
  Imagenumberlength="${#Imagenumber}"
  Image="$(head -n1 <<< "$Sourceimagelist")"
  Imagewidth="$($Magickbin  -format '%w' "$Image" info:)"
  Imageheight="$($Magickbin -format '%h' "$Image" info:)"
  Imagememsize="$((Imagewidth*Imageheight*Magickpixelmemory/1000))"
  Imagememsize="$((Imagememsize*125/100))" # by observation. Alpha channel?
  Imagelistmemsize="$((Imagenumber*Imagememsize))"
  [ "$Error" ] && return 1
  
  #Maskmethodlist="$(sort -V   <<< "$Maskmethodlist")"
  Maskmethodlist="$(grep "\S" <<< "$Maskmethodlist")"
  [ -n "$Maskmethodlist" ] && while read Line; do
    maskarg_parse "$Line"
    [ -z "$Argradius1" ]  && Argradius1="$(maskarg_defaultvalue            "$Argmethod" radius1)"
    [ -z "$Argradius2" ]  && Argradius2="$(maskarg_defaultvalue            "$Argmethod" radius2)"
    [ -z "$Argsigma1" ]   && Argsigma1="$(maskarg_defaultvalue             "$Argmethod" sigma1)"
    [ -z "$Argsigma2" ]   && Argsigma2="$(maskarg_defaultvalue             "$Argmethod" sigma2)"
    [ -z "$Argpercent1" ] && Argpercent1="$(maskarg_defaultvalue           "$Argmethod" percent1)"
    [ -z "$Argpercent2" ] && Argpercent2="$(maskarg_defaultvalue           "$Argmethod" percent2)"
    [ -z "$Argword1" ]    && Argword1="$(maskarg_defaultvalue              "$Argmethod" word1)"
    [ -z "$Argword2" ]    && Argword2="$(maskarg_defaultvalue              "$Argmethod" word2)"
    [ -n "$Argradius1" ]  && { Argradius1="$(maskarg_checkallowed  "$Argmethod" radius1  "$Argradius1")"  || Error=1 ; }
    [ -n "$Argradius2" ]  && { Argradius2="$(maskarg_checkallowed  "$Argmethod" radius2  "$Argradius2")"  || Error=1 ; }
    [ -n "$Argpercent1" ] && { Argpercent1="$(maskarg_checkallowed "$Argmethod" percent1 "$Argpercent1")" || Error=1 ; }
    [ -n "$Argpercent2" ] && { Argpercent2="$(maskarg_checkallowed "$Argmethod" percent2 "$Argpercent2")" || Error=1 ; }
    [ -n "$Argsigma1" ]   && { Argsigma1="$(maskarg_checkallowed   "$Argmethod" sigma1   "$Argsigma1")"   || Error=1 ; }
    [ -n "$Argsigma2" ]   && { Argsigma2="$(maskarg_checkallowed   "$Argmethod" sigma2   "$Argsigma2")"   || Error=1 ; }
    [ -n "$Argword1" ]    && { Argword1="$(maskarg_checkallowed    "$Argmethod" word1    "$Argword1")"    || Error=1 ; }
    [ -n "$Argword2" ]    && { Argword2="$(maskarg_checkallowed    "$Argmethod" word2    "$Argword2")"    || Error=1 ; }
    #[ -z "$Argweight" ]   && Argweight="100"
    Weightsum="$((Weightsum + Argweight))"
    [ -z "$Argweight" ]   && Masknoweightcount="$((Masknoweightcount+1))"
    case $Argmethod in
      blur|comet|compass|diffstat|dog|enfuse|free|freediff|freichen|gaussian|kirsch|laplacian|log|morphology|prewitt|roberts|sobel|statistic|unsharp|wavelet)
        Arglevel="yes"
      ;;
    esac
    
    Argtype="$(maskarg_defaultvalue "$Argmethod" type)"
    [ "${Argalpha}" ] && Background="${Background:-enfuse}"
    [ "$Maskmethodcount" = "1" ] && Firstmaskmethod="$Argmethod"
    
    Slabmasks="$Slabmasks --$Argmethod=w$Argweight,r$Argradius1,R$Argradius2,s$Argsigma1,S$Argsigma2,p$Argpercent1,P$Argpercent2,$Argword1,$Argword2"
  
    case $Argmethod in
      chroma)
        #Argmethod="channel"
        Argword1="HCL"
        Argword2="1"
      ;;
      compose)
        Image_needlist="$Image_needlist max min"
        Image_needlist="$Image_needlist $Argword1"
      ;;
      darkness)
        #Argmethod="channel"
        Argword1="HSL"
        Argword2="2"
      ;;
      evaluate)
        Image_needlist="$Image_needlist $Argword1"
      ;;
      freichen)
        case $Argword1 in
          10|12|19) Argdiff=yes ;;
        esac
      ;;
      lightness)
        #Argmethod="channel"
        Argword1="HSL"
        Argword2="2"
      ;;
      image)
        [ -e "$Argword1" ] || error "--image needs an image file name as argument. Not found: '$Argword1'"
      ;;
      max|mean|median|min)
        Image_needlist="$Image_needlist $Argmethod"      
      ;;
      morphology)
        case $Argword1 in
          edge|edgein|edgeout|tophat|bottomhat) ;;
          *) Argdiff="yes" ;;
        esac
      ;;
      saturation)
        #Argmethod="channel"
        Argword1="HSB"
        Argword2="1"
      ;;
      statistic)
        case $Argword1 in
          gradient|standarddeviation|"") Argdiff="" ;;
          *)                             Argdiff="yes" ;;
        esac
      ;;
    esac
    
    maskarg_store "$Maskmethodcount"
  done <<< "$Maskmethodlist"
  [ "$Error" ] && return 1

  # w, weight
  Weightrest="$((100-Weightsum))"
  awk 'BEGIN {exit !('${Weightsum:-100}' > 100)}' && error "Sum of weight arguments exceed 100%."
  [ -n "$Maskmethodlist" ] && while read Line; do
    maskarg_parse "$Line"
    #Argweight="$(calc "$Argweight * 100 / $Weightsum")"
    [ -z "$Argweight" ] && {
      awk 'BEGIN {exit !('${Weightrest:-0}' <= 0)}' && error "Sum of weight arguments exceed 100%, nothing left for --$Argmethod."
      Argweight="$(calc "$Weightrest / $Masknoweightcount")"
    }
    maskarg_store
  done <<< "$Maskmethodlist"
  
  # --alpha
  case $Globalalpha in
    "") ;;
    *)
      [ "$Globalalpha" = "auto" ] && Globalalpha="0x100"
      Globalalpha="$(levelparse "$Globalalpha")"
      Background="${Background:-transparent}"
    ;;
  esac
  
  # --basename
  case $Basename in
    #"")   Basename="imfuse" ;;
    auto) Basename="$(basename "$(pwd)")" ;;
  esac
  [ -d "$Basename" ] && {
    Outputdir="$Basename"
    Basename=""
  } || {
    Outputdir="$(dirname "$Basename")"
    Basename="$(basename "$Basename")"
  }

  # --cachedir
  [ -z "$Cachedir" ]       && Cachedir="$(pwd)/cache.imfuse"
  [ "$Cachedir" = "auto" ] && Cachedir="$(pwd)/cache.imfuse"
  Cachedir="$(sed s%'~'%$HOME% <<< "$Cachedir")"
  Cachedir="$(realpath -m "$Cachedir")"
  
  # --close
  false && case $Globalclose in
    ""|"0") Globalclose="" ;;
    *)
      [ "$Globalclose" = "auto" ] && Globalclose="$(maskarg_defaultvalue "$Firstmaskmethod" close)"
      Globalclose1=$(cut -dx    -f1 <<< "$Globalclose")
      Globalclose2=$(cut -dx -s -f2 <<< "$Globalclose")
      Globalclose1="$(digitonly "$Globalclose1")"
      Globalclose2="$(digitonly "$Globalclose2")"
      Globalclose1="${Globalclose1:-1}"
      Globalclose2="${Globalclose2:-1}"
      Globalclose="${Globalclose1}x${Globalclose2}"
      false && [ "$Maskmethodnumber" = "1" ] && {
        maskarg_parse "$Maskmethodlist"
        Argclose1="$Globalclose1"
        Argclose2="$Globalclose2"
        maskarg_store
        Globalclose=""
        Globalclose1=""
        Globalclose2=""
      }
    ;;
  esac
  case $Globalclose in
    ""|"0") Globalclose="" ;;
    *)
      [ "$Globalclose" = "auto" ] && Globalclose="r,R,p"
      maskarg_parse "$Globalclose"
      Globalclose1="${Argradius1:-2}"
      Globalclose2="${Argradius2:-2}"
      Globalclosethreshold="${Argpercent1:-0}"
      Globalclose="r${Globalclose1},R${Globalclose2},p${Globalclosethreshold}"
    ;;
  esac
  
  # --cutblur
  case "$Cutblur" in
    "") ;;
    auto) Cutblur="2" ;;
    *)
      maskarg_parse "$Cutblur"
      maskarg_checksigma "$Cutblur"
      Cutblur="$Argsigma1"
    ;;
  esac
  
  # --cutsoft
  case "$Cutsoft" in
    "") ;;
    auto) Cutsoft="2" ;;
    *)
      maskarg_parse "$Cutsoft"
      maskarg_checksigma "$Cutsoft"
      Cutsoft="$Argsigma1"
    ;;
  esac
  
  # --denoise
  case $Globaldenoise in
    auto) Globaldenoise="10" ;;
  esac
  
  # --fakehdr
  [ "$Fakehdr" = "auto" ] && Fakehdr="40"
  case "$Fakehdr" in
    "") ;;
    auto) Fakehdr="40" ;;
    *)
      maskarg_parse "$Fakehdr"
      maskarg_checkpercent "$Fakehdr"
      Fakehdr="$Argpercent1"
    ;;
  esac

  # --finalblur
  [ "$Finalblur" ] && {
    Argmethod="finalblur"
    maskarg_parse "$Finalblur"
    maskarg_checkpercent "$Finalblur"
    Finalblurpercent="${Argpercent1:-50}"
    Finalblursigma1="${Argsigma1:-3}"
    Finalblursigma2="${Argsigma2:-2}"
  }

  # --grayscale
  case ${Grayscale,,} in
    ""|auto)           Grayscale="RMS" ;;
  esac
  case ${Grayscale,,} in
    0|none)            Grayscalenumber=0 ; Grayscale="none" ;;
    1|rec601luma)      Grayscalenumber=1 ; Grayscale="Rec601Luma" ;;
    2|rec601luminance) Grayscalenumber=2 ; Grayscale="Rec601Luminance" ;;
    3|rec709luma)      Grayscalenumber=3 ; Grayscale="Rec709Luma" ;;
    4|rec709luminance) Grayscalenumber=4 ; Grayscale="Rec709Luminance" ;;
    5|brightness)      Grayscalenumber=5 ; Grayscale="Brightness" ;;
    6|lightness)       Grayscalenumber=6 ; Grayscale="Lightness" ;;
    7|average)         Grayscalenumber=7 ; Grayscale="Average" ;;
    8|ms)              Grayscalenumber=8 ; Grayscale="MS" ;;
    9|rms)             Grayscalenumber=9 ; Grayscale="RMS" ;;
    *)
      error "--grayscale: Unknown argument: $Grayscale"
    ;;
  esac
  case $Grayscale in
    ""|none) Grayscaleconverter="" ;;
    *)       Grayscaleconverter="-grayscale $Grayscale" ;;
  esac
  
  # --layers
  case $Layers in
    auto) Layers="5" ;;
  esac

  # --less
  case $Globalless in
    0)    Globalless="" ;;
    auto) Globalless="$(maskarg_defaultvalue "$Firstmaskmethod" less )" ;;
    *)    
      maskarg_parse "$Globalless"
      maskarg_checkpercent "$Globalless"
      Globalless="$Argpercent1"
  esac

  # --maskblur
  case $Globalmaskblur in
    0)    Globalmaskblur="" ;;
    auto) Globalmaskblur="2" ;;
    *)
      maskarg_parse "$Globalmaskblur"
      maskarg_checksigma "$Globalmaskblur"
      Globalmaskblur="$Argsigma1"
    ;;
  esac
  
  # --merge
  Mergemethod="${Mergemethod:-Plus}"
  Mergemethod="${Mergemethod,,}"
  
  # --prefertop
  case $Prefertop in
    "") ;;
    auto) Prefertop="20" ;;
    *)
      maskarg_parse "$Prefertop"
      maskarg_checkpercent "$Prefertop"
      Prefertop="$Argpercent1"
  esac
  
  # --redist
  Redistdefault="uniform"
  case $Redistshape in
    "") Redistshape="uniform" ;;
    uniform|gaussian) ;;
    auto) Redistshape="$Redistdefault" ;;
    off|none) Redistshape="off" ;;
  esac
  
  # --revert
  [ "$Revertimagelist" = "yes" ] && Sourceimagelist="$(tac <<< "$Sourceimagelist")"
    
  # --showimage
  [ "$Showimageprocessing" ] && {
    command -v imgview >/dev/null || {
      note "-V, --showimage: imgview not found.
  Please install imgview."
      Showimageprocessing=""
    }
  }
  
  # --sigmoidalclut
  [ "$Globalsigmoidal" ] && {
    [ "$Globalsigmoidal" = "auto" ] && Globalsigmoidal="10x50%"
    Globalsigmoidal="$(percentrm "$Globalsigmoidal")"
    Part1="$(cut -dx -f1 <<< "$Globalsigmoidal")"
    Part2="$(cut -dx -f2 -s <<< "$Globalsigmoidal")"
    Part1="${Part1:-10}"
    Part2="${Part2:-50}"
    Globalsigmoidal="${Part1}x${Part2}"
  }
  
  # --slabs
  [ "$Slabs" ] && {
    [ "$Slabs" = "auto" ] && Slabs="10"
    Slabsize="$((Imagenumber / Slabs))"
    Slaboverlap=3
    Slabkernelfactor=3
    [ "$Verbose" ]             && Slaboptions="$Slaboptions -v"
    [ "$Showimageprocessing" ] && Slaboptions="$Slaboptions -V"
    for Slabstep in $(seq $Slabs); do
      Slabsourcelist[$Slabstep]="$(sed -n $((Slabsize*(Slabstep-1) +1)),$((Slabsize*Slabstep+Slaboverlap))p <<< "$(tac <<< "$Sourceimagelist")")"
    done
  }
  
  # --soft
  [ "$Softmode" ] && {
    [ "$Cutblur" ]    && error "Option --soft does not support option --cutblur."
    [ "$Cutsoft" ]    && error "Option --soft does not support option --cutsoft."
    [ "$Globalless" ] && error "Option --soft does not support option --less. You can specify 'less' as a mask argument instead."
  }
  [ "$Softmode" ] && [ "$Softmode" != "auto" ] && {
    Softmode="$(percentrm "$Softmode")"
    Part1="$(cut -dx -f1 <<< "$Softmode")"
    Part2="$(cut -dx -f2 -s <<< "$Softmode")"
    Part1="${Part1:-10}"
    Part2="${Part2:-50}"
    Softmode="${Part1}x${Part2}"
  }
  
  # --threshold
  case $Globalthreshold in
    "") ;;
    auto) Globalthreshold="50" ;;
    *)
      maskarg_parse "$Globalthreshold"
      maskarg_checkpercent "$Globalthreshold"
      Globalthreshold="$Argpercent1"
      Globalthresholdblur="$Argsigma1"
    ;;
  esac
  [ "$Globalthreshold" ] && Background="${Background:-transparent}"
  
  # --background
  [ "$Background" = "auto" ] && Background="enfuse"
  [ -z "$Maskmethodlist" ] && {
    Background="${Background:-enfuse}"
    note "No mask option specified, generating background only: $Background"
  }
  [ "$Background" ] && {
    checkmagicklist color                     "$Background"   && Backgroundtype="color"
    checkmagicklist evaluate                  "$Background"   && Backgroundtype="evaluate"
    checkmagicklist compose  "$(tr -d "2" <<< "$Background")" && Backgroundtype="compose"
    [ -f "$Background" ]                                      && Backgroundtype="image"
    case $Background in
      enfuse|saturation)                                         Backgroundtype="$Background" ;;
      none)                   Background="" ;                    Backgroundtype="none" ;;
    esac
    [ "$Backgroundtype" ] || error "--background: Unknown background: '$Background'"
  }
  
  return ${Error:-0}
}
check_background() {
  # --background
  
  case $Backgroundtype in
    none)
      Background=""
      Backgroundimage=""
    ;;
    compose)
      Background="$(lowercase $Background)"
      Image_needlist="$Image_needlist min max $Background"
      Backgroundimage="$(generate_image --showname "$Background")"
    ;;
    evaluate)    
      Background="$(lowercase $Background)"
      Image_needlist="$Image_needlist $Background"
      Backgroundimage="$(generate_image --showname "$Background")"
    ;;
    color)
      Image_needlist="$Image_needlist $Background"
      Backgroundimage="$(generate_image --showname "$Background")"
    ;;
    image)
      Backgroundimage="$Background"
    ;;
    saturation)
      Image_needlist="$Image_needlist saturation"
      Backgroundimage="$(generate_image --showname "$Background")"
    ;;
    enfuse)
      Image_needlist="$Image_needlist enfuse"
      Backgroundimage="$(generate_image --showname "$Background")"
    ;;
  esac
}
check_outputname() {
  # --output
  Resultimage="imfuse."
  [ "$Softmode" ] && {
    Resultimage="${Resultimage}soft"
    [ "$Softmode" != "auto" ] && Resultimage="${Resultimage}$Softmode"
  }
  [ "$Slabs" ] && {
    Resultimage="${Resultimage}slabs$Slabs"
  }
        
  while read Line; do
    [ -z "$Line" ] && break
    maskarg_parse "$Line"   
    Resultimage="${Resultimage}_${Argmethod}="
    [ "$Argweight" != "100" ]    && Resultimage="$Resultimage-w$(awk 'BEGIN {printf "%0.0f",'$Argweight'}')"
    [ "$Argradius1" ]            && Resultimage="$Resultimage-r$Argradius1"
    [ "$Argsigma1" ]             && Resultimage="$Resultimage-s$Argsigma1"
    [ "$Argradius2" ]            && Resultimage="$Resultimage-R$Argradius2"
    [ "$Argsigma2" ]             && Resultimage="$Resultimage-S$Argsigma2"
    [ "$Argpercent1" ]           && Resultimage="$Resultimage-p$Argpercent1"
    [ "$Argpercent2" ]           && Resultimage="$Resultimage-P$Argpercent2"
    [ "$Argalpha" ]              && Resultimage="$Resultimage-alpha$Argalpha"
    [ "$Argless" ]               && Resultimage="$Resultimage-less$Argless"
    [ "$Argclose1" ]             && Resultimage="$Resultimage-close$Argclose1"
    [ "$Argclose2" ]             && Resultimage="${Resultimage}x$Argclose2"
    [ "$Argmaskblur" ]           && Resultimage="$Resultimage-maskblur$Argmaskblur"
    [ "$Argdenoise" ]            && Resultimage="$Resultimage-denoise$Argdenoise"
    [ "$Argnegate" ]             && Resultimage="$Resultimage-neg"
    case $Argmethod in
      image) ;;
      saturation|chroma|darkness|lightness) ;;
      *) [ "$Argword1" ]         && Resultimage="$Resultimage-$(unspecialstring "$Argword1")" ;;
    esac
    case $Argmethod in
      saturation|chroma|darkness|lightness) ;;
      *) [ "$Argword2" ]         && Resultimage="$Resultimage-$(unspecialstring "$Argword2")" ;;
    esac
  done <<< "$Maskmethodlist"
  case $Fakehdr in
    "") ;;
    *) Resultimage="${Resultimage}_hdr=p$Fakehdr" ;;
  esac
  case $Globalless in
    ""|0) ;;
    *) Resultimage="${Resultimage}_less=p$Globalless" ;;
  esac
  case $Globalclose in
    "") ;;
    *) Resultimage="${Resultimage}_close=$Globalclose" ;;
  esac
  [ "$Globalmaskblur" ] && {
    Resultimage="${Resultimage}_maskblur=s$Globalmaskblur"
  }
  [ "$Prefertop" ] && {
    Resultimage="${Resultimage}_prefertop=p$Prefertop"
  }
  [ "$Globalsigmoidal" ] && {
    Resultimage="${Resultimage}_sigmoidal=$Globalsigmoidal"
  }
  [ "$Cutsoft" ] && {
    Resultimage="${Resultimage}_cutsoft=s$Cutsoft"
  }
  [ "$Cutblur" ] && {
    Resultimage="${Resultimage}_cutblur=s$Cutblur"
  }
  [ "$Finalblur" ] && {
    Resultimage="${Resultimage}_finalblur=p${Finalblurpercent}-s${Finalblursigma1}-S${Finalblursigma2}"
  }
  case $Globalalpha in
    "") ;;
    *) Resultimage="${Resultimage}_alpha=$Globalalpha" ;;
  esac
  [ "$Globalthreshold" ] && {
    Resultimage="${Resultimage}_threshold=p$Globalthreshold"
    [ "$Globalthresholdblur" ] && Resultimage="${Resultimage},s$Globalthresholdblur"
  }
  case $Globaldenoise in
    "") ;;
    *) Resultimage="${Resultimage}_denoise=$Globaldenoise" ;;
  esac
  case $Redistshape in
    $Redistdefault) ;;
    *) Resultimage="${Resultimage}_redist=${Redistshape:-off}${Redistpeak}" ;;
  esac
  case $Mergemethod in
    plus) ;;
    *) Resultimage="${Resultimage}_merge=$Mergemethod" ;;
  esac
  case $Revertimagelist in
    "yes") Resultimage="${Resultimage}_rev" ;;
  esac
  case $Grayscalenumber in
    9) ;;
    *) Resultimage="${Resultimage}_gray=$Grayscalenumber" ;;
  esac
  [ "$Background" ] && case $Backgroundtype in
    "") ;;
    image) Resultimage="${Resultimage}_bg=image$(md5cut "$(ls -l "$Background")")" ;;
    *)     Resultimage="${Resultimage}_bg=$Background" ;;
  esac
  [ "$Layers" ] && {
    Resultimage="${Resultimage}_layers=$Layers"
  }
  [ "$Darkenmask" ] && {
    Resultimage="${Resultimage}_darkenmask"
  }
  case $Testsetup in
    "") ;;
    *) Resultimage="${Resultimage}_test$Testarg" ;;
  esac
  Resultimage="$(sed "s/=-/=/g ; s/=_/_/g  ; s/\.\./\./g ; s/\._/\./g ; s/\._/\./g ; s/=$//g ; s/=\./=/g" <<< "$Resultimage")"
  #Resultimage="$(sed "s/=-/=/g ; s/=\./=/g ; s/=$//g" <<< "$Resultimage")"
    
  Fusemd5sum="$(md5cut "$Sourcemd5 $Maskmethodlist \
$Background $([ "$Darkenmask" ] && md5sum "$Darkenmask") $Cutblur $Cutsoft $Fakehdr $Finalblur \
$Globalalpha $Globalclose $Globaldenoise $Globalless $Globalmaskblur $Globalthreshold $Globalthresholdblur \
$Grayscale $Mergemethod $Prefertop $Redistpeak $Redistshape $Revertimagelist $Softmode $Testsetup" )"
  
  Resultimage="${Resultimage}_md${Fusemd5sum}"
  [ -z "$Outputdir" ] && Outputdir="$(pwd)"
  case $Outputimage in
    "") Outputimage="$Outputdir/$Basename$Resultimage.${Imageformat}" ;;
    *) [ "$(basename "$Outputimage")" = "$Outputimage" ] && Outputimage="$Outputdir/$Outputimage" ;;
  esac
  Outputimage="$(realpath -m "$Outputimage")"
  [ "$Video" ] && Video="$Outputimage.webm"
  Resultimage="$Cachedir/${Basename:-}$Resultimage.${Imageformat}"
  
  # --savemask
  [ "$Savemask" = "auto" ] && Savemask="$Outputimage.mask.tif"
  
  return ${Error:-0}
}
main() {
  trap trap_sigint SIGINT
  set -u
  local Slabopt
  
  declare_variables
  multicore_init
  
  # check magick version
  command -v convert >/dev/null && Magickbin="convert"
  command -v magick  >/dev/null && Magickbin="magick"
  [ -z "$Magickbin" ] && error "Neither command convert nor magick found. Please install ImageMagick."
  Magickversion="$($Magickbin -version)"
  grep -q " Q8 "   <<< "$Magickversion" && Magickpixelmemory="4"
  grep -q " Q16 "  <<< "$Magickversion" && Magickpixelmemory="8"
  grep -q " HDRI " <<< "$Magickversion" && Magickpixelmemory="16"
  Magicklist="$Magickbin"
  Magickbin="nice $Magickbin -quiet"
  
  # check RAM
  Freemem="$(freememory)"
  [ -z "$Freemem" ] && {
    note "WARNING: failed to estimate free memory.
  Blindly guessing 1000 MB."
    Freemem="1000000"
  }
  
  parse_options "$@"
  check_options
  [ "$Error" ] && return 1
  
  # --cache
  mkdir -p $Cachedir   || error "Error creating cache folder $Cachedir"
  [ "$Preservecache" ] || rm -rf $Cachedir/*
  rm -f $Cachedir/videoframe????.*
  Testimage="$Cachedir/test.png"
  Resultmask="$Cachedir/result.max.tif"
  
  Sourcemd5="$(md5cut "$(ls --full-time $Sourceimagelist)" )"
  echo "$Sourcemd5" > "$Cachedir/md5"
  
  # --output, --basename
  check_outputname
  # --showname
  [ "$Showname" = "yes" ] && {
    echo $Outputimage
    return "${Error:-0}"
  }
  note "Setting --output=$Outputimage"
  
  note "
  Image number:           $Imagenumber
  Image width:            $Imagewidth px
  Image height:           $Imageheight px
  Image memory size:      $Imagememsize kb
  Image list memory size: $Imagelistmemsize kb
  Free Memory:            $Freemem kb"
  
  # --force
  [ -f "$Outputimage" ] && [ -z "$Forceoverwrite" ] && { 
    note "Skipping all, output image already exists with matching md5sum."
    echo "$Outputimage"
    showimage "$Outputimage"
    [ "$Viewnior" ] && viewnior "$Outputimage" &
    return "${Error:-0}"
  }

  # --fakehdr
  [ "$Fakehdr" ] && {
    fakehdr --percent "$Fakehdr" --method level --basename "fakehdr$Fakehdr.$Sourcemd5" || error "Error in --fakehdr"
    Sourceimagelist="$(masklist "fakehdr$Fakehdr.$Sourcemd5")"
    Sourcemd5="$(md5cut "$(ls --full-time $Sourceimagelist)" )"
    [ "$Error" ] && return 1
  }
  
  # --background
  check_background
  for Mode in $Image_needlist; do
    [ "$Error" ] && break
    generate_image "$Mode"
  done 
  [ "$Error" ] && return 1
  
  
  # --slabs
  [ "$Slabs" ] && {
    Sourceimagelist=""
    for Slabstep in $(seq $Slabs); do
      [ "$Error" ] && break
      note "--slabs: Creating slab $Slabstep / $Slabs"
      Slabopt="$Slaboptions $Slabmasks --cache=$Cachedir/slab$Slabstep ${Slabsourcelist[$Slabstep]}"
      Image="$(imfuse --showname --basename=$Cachedir/slab$Slabs.$(printnum $Slabstep)_ $Slabopt)" || error "--slabs: Failed to retrieve image name in step $Slabstep"
      Sourceimagelist="$Image
$Sourceimagelist"
      [ -e "$Image" ] || {
        imfuse -o $Image $Slabopt || error "Error in slab step $Slabstep"
      }
    done
    Imagenumber=$Slabs
    Sourceimagelist="$(grep . <<< "$Sourceimagelist")"
    
    [ -n "$Maskmethodlist" ] && while read Line; do
      maskarg_parse "$Line"
      [ -n "$Argradius1" ]  && Argradius1="$(calc "$Argradius1 * $Slabkernelfactor")"
      [ -n "$Argradius2" ]  && Argradius2="$(calc "$Argradius2 * $Slabkernelfactor")"
      [ -n "$Argsigma1" ]   && Argsigma1="$(calc  "$Argsigma1  * $Slabkernelfactor")"
      [ -n "$Argsigma2" ]   && Argsigma2="$(calc  "$Argsigma2  * $Slabkernelfactor")"
#      [ -n "$Argpercent1" ] && { Argpercent1="$(maskarg_checkallowed "$Argmethod" percent1 "$Argpercent1")" || Error=1 ; }
#      [ -n "$Argpercent2" ] && { Argpercent2="$(maskarg_checkallowed "$Argmethod" percent2 "$Argpercent2")" || Error=1 ; }
      maskarg_store
    done <<< "$Maskmethodlist"
  }
  [ "$Error" ] && return 1
  
  # Generating stackshot image
  mkimg_transparent "$Resultimage"
  [ -n "$Maskmethodlist" ] && {
    focus_generate_masks                  || error "Error in mask generation"
    [ "$Error" ] && return 1
    focus_merge_masks                     || error "Error in mask merge"
    [ "$Error" ] && return 1
    case $Softmode in
      "") focus_montage --maskmax "$Resultmask" --output "$Resultimage" --alpha "$Globalalpha" --lessthanmax "$Globalless" --cutsoft "$Cutsoft" --cutblur "$Cutblur" || error "Error in focus_montage" ;;
      *)  focus_soft    --maskmax "$Resultmask" --output "$Resultimage" --alpha "$Globalalpha" --sigmoidal "$Softmode"     || error "Error in focus_soft" ;;
    esac
    [ "$Error" ] && return 1
    # --finalblur
    [ "$Finalblur" ] && {
      note "Applying --finalblur=p${Finalblurpercent},s${Finalblursigma1},S${Finalblursigma2}"
      finalblur --image "$Resultimage" --mask "$Resultmask" --percent "$Finalblurpercent" --sigma1 "$Finalblursigma1" --sigma2 "$Finalblursigma2" || error "Error in --finalblur"
      [ "$Error" ] && return 1
    }
    # --alpha=ARG
    [ "$Globalalpha" ] && {
      note "Applying --alpha=$Globalalpha"
      alphalevel --image "$Resultimage" --mask "$Resultmask" --level "$Globalalpha" || error "Error in leveling --alpha='$Globalalpha'"
      [ "$Error" ] && return 1
    }
    # --threshold
    [ "$Globalthreshold" ] && {
      note "Applying --threshold=$Globalthreshold"
      threshold --image "$Resultimage" --mask "$Resultmask" --percent "$Globalthreshold" --blur "$Globalthresholdblur" || error "Error -in --threshold"
      [ "$Error" ] && return 1
    }
    # --savemask
    [ "$Savemask" ] && {
      verbose "Saving mask to $Savemask"
      cp "$Resultmask" "$Savemask"
      showimage "$Savemask"
      
    }
  }
  # --background
  [ "$Background" ] && [ -z "$Layers" ] && {
    note "Applying --background=$Background"
    $Magickbin "$Backgroundimage" "$Resultimage" -compose Over -composite "$Resultimage" || note "Failed to compose result over background"
  }
  # --layered
  [ "$Layers" ] && {
    note "Applying --layers=$Layers"
    layered_tif "$Resultimage" "$Resultmask" "$Layers" "$Backgroundimage" || error "Error in --layers"
  }
      
  [ "$Error" ] && return 1

  $Magickbin "$Resultimage" $Tifstorealpha "$Outputimage"  || error "Error storing result in $Outputimage"
  
  # Transfer EXIF metadata from first image to result
  [ "$Exifsourceimage" ] && {
    [ "$Exifsourceimage" = "auto" ] && Exifsourceimage="$(head -n1 <<< "$Sourceimagelist")"
    #exiftool -overwrite_original -tagsfromfile "$Exifsourceimage" -orientation="Horizontal" -rotation="Horizontal" -exifimagewidth=$Imagewidth -exifimageheight=$Imageheight -all:all  "$Outputimage" >/dev/null || note "Failed to transfer exif data"
    exiftransfer "$Exifsourceimage" "$Outputimage"
  }

  showimage "$Outputimage"
  note "Ready after $(date -u -d @$(($(date +%s)-Startzeit)) +"%T")"
  echo "$Outputimage"
  
  [ "$Viewnior" ] && viewnior "$Outputimage" &
  
  [ "$Video" ] && {
    note "Generating video $Video"
    Videoframerate=5
    #nice ffmpeg -y -hide_banner -nostdin  -r $Videoframerate -f image2 -start_number 1 -i $Framedir/frame%04d.$Imageformat $Destinationfile || note "ERROR in video generation"
    [ -f "$Video" ] && rm "$Video"
    nice ffmpeg -y -hide_banner -nostdin  -r $Videoframerate -f image2 -start_number 1 -i "$Cachedir/videoframe%04d.$Imageformat" "$Video" || note "ERROR in video generation"
    rm $Cachedir/videoframe*
    ffplay "$Video"
  }
    
  return "${Error:-0}"
}
main "$@" || Error=1
[ -z "$Preservecache" ] && [ -d "$Cachedir" ] && rm -R "$Cachedir"
exit "${Error:-0}"
