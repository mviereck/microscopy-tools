#!/bin/bash
#
# stackshooter - Generate stackshots with arduino + steppermotor + camera
#
# License: MIT
#
# Dependencies:
#  - align_image_stack (hugin tools)
#  - ffmpeg
#  - geeqie
#  - gphoto2
#  - kaptain  https://github.com/mviereck/kaptain

#### Messages

note() {
  echo "${Colgreen}stackshooter:${Colnorm} $*" >&2
}
failure() {
  echo "${Colred}stackshooter FAILURE:${Colnorm} $*" >&2
  statusmessage "$*"
  setvar "error=yes"
  showpercent error
}
statusmessage() {
  sendkaptain "status='$(cut -c1-37 <<< "$*")'"
}

#### Misc

isnum() {
  [ "1" = "$(awk -v a="${1:-}" 'BEGIN {print (a == a + 0)}')" ]
}
milisleep() {
  local Time 
  Time="$(awk "BEGIN { print ${1:-1000} / 1000 }")"
  sleep $Time
}

#### File operations

get_latest_file() {
  ## Funktion: Neueste erstellte Datei ermitteln
  # $1 kann Suche auf Dateien DATEI* begrenzen
  ls -p -t $1* 2> /dev/null | grep -v "/" | head -n 1
}
get_last_file() {
  # Find alphanumerically last file beginning with $1 in pwd.
  local Filelist
  Filelist="$(find -mindepth 1 -maxdepth 1 | xargs realpath --relative-base $(pwd) | grep "^${1:-}")"
  Filelist="$(sort -V <<< "$Filelist")"
  tail -n1 <<< "$Filelist"
}
get_free_filenumber(){
  # Provide next free file number to file base name $1. 
  # Provide $1 without _00N.
  # $1 must not contain _
  local Number
  Number="$(get_last_file ${1:-} | rev | cut -d_ -f1 | rev | cut -d. -f1)"
  Number="${Number:-0}"
  Number="$(awk "BEGIN {print \"$Number\" + 1}" )"
  printf "%04d" "$Number"
}
setup_projectdir() {
  local Projecthome Projectname Projectdate
  
  Projecthome="$(getvar storagebasedir)"
  Projecthome="${Projecthome:-$HOME/stackshooter}"
  Projectbasename="$(getvar projectbasename)"
  Projectbasename="${Projectbasename:-project}"
  Projectdate="$(date +%Y-%m-%d)"

  [ "${1:-}" ] && Projectname="${1:-}.${Projectdate}"
  Projectname="${Projectname:-${Projectbasename}.${Projectdate}}"
  setvar "projectname=$Projectname"

  cd "$Projecthome"
  mkdir -p "$Projectname"
  cd "$Projectname"
}
showimage() {
  [ -f "${1:-}" ] || {
    failure "Image not found: ${1:-}"
    return 1
  }
  geeqie -t -r File:"${1:-}"
}

#### Device communication

device_init() {
  # Init Device and start watching background process
  
  local Device Watchdevicepid i Return

  Device="$(getvar device)"
  
  # Stop a running watching instance
  Watchdevicepid="$(getvar pidwatchdevice)"
  ps -p "$Watchdevicepid" >/dev/null 2>&1 && {
    kill $Watchdevicepid
    wait $Watchdevicepid 2>/dev/null
    exec 6>&-
  }

  # Device auf Gültigkeit prüfen
  [ -e "$Device" ] || {
    failure "Device not found: $Device"
    Device="$Devicefallback"
    failure "Fallback device: $Device"
    setvar "device=$Device"
  }

  # Daten von Device auf fifo umleiten
  note "Beginning to watch device: $Device"
  exec 6<>$Device
  cat <&6 >>$Devicemessagefifo & Watchdevicepid=$!
  storepid $Watchdevicepid
  setvar "pidwatchdevice=$Watchdevicepid"
    
  # Seriellen Port initialisieren
  stty -F $Device raw ispeed 9600 ospeed 9600 cs8 -hupcl -ignpar -cstopb -echo || {
    failure "Failed to initialize device $Device"
    return 1
  }
  
  sleep $Devicetimeout
  for ((i=1;i<=10;i++)); do
    device_check && break || Return=1
  done
  
  [ "$Return" = "1" ] && failure "Device init failed: $Device"
  
  return ${Return:-0}
}
device_send() {
  ## Funktion: Daten an Arduino senden  
  # Alle übergebenen Optionen werden an $Deviceadresse gesendet
  note "Send to device: $*"
  echo "$*" >&6
}
device_wait() {
  ## Funktion: Auf ein beliebiges Signal vom Arduino warten
  local Answer=
  
  read -t ${1:-$Devicetimeout} -r Answer <&6
  
  [ "$Answer" ] || {
    failure "Device does not respond: $(getvar device) "
    echo "TIMEOUT"
    return 1
  }
  
  note "Device responses: $Answer"
  echo "$Answer"
  return 0
}
device_check() {
  # Prüfen, ob Arduino auf Kontrollsignal "c" antwortet
  device_send "$(getvar signalcheck)"
  [ "$(device_wait)" = "TIMEOUT" ] && return 1 && failure "Device check failed: $(getvar device)" || return 0
}

#### Device navigation

position_store() {
  setvar "poscurrent=$Poscurrent"
  setvar "pos1=$Pos1"
  setvar "pos2=$Pos2"
  setvar "stepwidth=$Stepwidth"
  
  sendkaptain "poscurrent='$Poscurrent'"
  sendkaptain "pos1='$Pos1'"
  sendkaptain "pos2='$Pos2'"
  sendkaptain "difference='$(awk "BEGIN {print $Pos2 - $Pos1 }" )'"
  sendkaptain "distance='$(awk   "BEGIN {print $Stepdistance * ($Pos2 - $Pos1) }") $Stepunit'"
  sendkaptain "steps='$(awk      "BEGIN {print ($Pos2 - $Pos1)/$Stepwidth }" )'"
  sendkaptain "stepmy='$(awk     "BEGIN {print $Stepdistance * $Stepwidth}") $Stepunit'"
}
position_read() {
  local Newstepwidth
  Poscurrent="$(getvar poscurrent)"
  Pos1="$(getvar pos1)"
  Pos2="$(getvar pos2)"
  Stepwidth="$(getvar stepwidth)"
  Stepdistance="$(getvar stepdistance)"
  Stepunit="$(getvar stepunit)"
}
stepcmd() {
  local Return Answer
  position_read
  case ${1:-} in
    go) 
      steplauf "${2:-$Poscurrent}"
    ;;
    stepin)  
      steplauf "$(awk "BEGIN {print $Poscurrent + $Stepwidth }" )" 
    ;;
    stepout) 
      steplauf "$(awk "BEGIN {print $Poscurrent - $Stepwidth }" )" 
    ;;
    setpos0)
      Poscurrent=0
      #device_send "$(getvar signalsetpos0)"
      #Answer="$(device_wait)"
    ;;
    setpos1)
      Pos1="$Poscurrent"
    ;;
    setpos2)
      Pos2="$Poscurrent"
    ;;
    gopos0)
      steplauf "0" 
    ;;
    gopos1)
      steplauf "$Pos1" 
    ;;
    gopos2)
      steplauf "$Pos2" 
    ;;
    stepwidth)
      Stepwidth="${2:-25}"
      device_send "$(getvar signalstepwidth),$Stepwidth"
      Answer="$(device_wait)"
    ;;
  esac
  note "stepcmd $*: current:$Poscurrent pos1:$Pos1 pos2:$Pos2 stepwidth:$Stepwidth"
  Return=$?
  [ "$Answer" = "TIMEOUT" ] && Return=1
  position_store
  return "${Return:-0}"
}
steplauf() {
  # Go to position $1
  
  local Direction Distance Timetowait Stepwith_store
  
  device_check || return 1
  
  Stepwidth_store="$Stepwidth"
  # Use Distance from Poscurrent to $1 as temporary Stepwidth
  Distance="$(awk "BEGIN {print ${1:-} - $Poscurrent }" )"
  [ "$Distance" = "0" ] && return 0
  [ "$Distance" -gt "0" ] && {
    Direction="$(getvar signalstepin)"
  } || { 
    Direction="$(getvar signalstepout)"
    Distance="$(awk "BEGIN {print -1 * $Distance }" )"
  }

  [ "$Distance" = "$Stepwidth" ] || {
    device_send "$(getvar signalstepwidth),$Distance"
    [ "$(device_wait)" = "TIMEOUT" ] && return 1
  }

  Timetowait="$(awk "BEGIN {print 18 * $Distance / 10000 + $Devicetimeout }" )" ### FIXME needs more general solution

  device_send "$Direction"
  Answer="$(device_wait "$Timetowait")"
  [ "$Answer" = "TIMEOUT" ] && return 1
  case $Direction in
    "$(getvar signalstepin)")  Poscurrent="$(awk "BEGIN {print $Poscurrent + $Distance }" )" ;;
    "$(getvar signalstepout)") Poscurrent="$(awk "BEGIN {print $Poscurrent - $Distance }" )" ;;
  esac
  [ "$Distance" = "$Stepwidth_store" ] || {
    device_send "$(getvar signalstepwidth),$Stepwidth"
    device_wait >/dev/null
  }
}
stackshot() {
  ## Funktion: Fotoserie schießen, dabei Motor weiterdrehen. Geht von $Pos1 zu $Pos2.
  # -p   Default: Serie aus Preview-Bildern.
  # -c   Serie aus richtigen Fotos / Captures.
  
  local Posmem=
  local Stackshotdelay Anzahl Count= Loopcount=0 Warten
  local Fotomodus Ordnername= Glob
  local Mediannumber Medianmode Mediancount
  local Stackshotdir Stackshotbasename Stackshotname Projectname Storagebase
  
  gphoto2_cmd check || {
    dropvar stackshot
    return 1
  }
  device_check      || {
    dropvar stackshot
    return 1
  }
  
  [ "$1" = "-c" ] && Fotomodus="capture" && shift
  [ "$1" = "-p" ] && Fotomodus="preview" && shift
  Fotomodus="${Fotomodus:-preview}"
  
  Mediannumber="$(getvar mediannumber)"
  Mediannumber="${Mediannumber:-1}"
  [ "$Mediannumber" = "1" ] && Medianmode="no" || Medianmode="yes"
  
  Stackshotdelay="$(getvar stackshotdelay)"
  Stackshotdelay="${Stackshotdelay:-500}"
  
  Storagebasedir="$(getvar storagebasedir)"
  Storagebasedir="${Storagebasedir:-$HOME/stackshooter}"
  
  Projectname="$(getvar projectname)"
  Projectname="${Projectname:-project_unknown}"

  Stackshotbasename="$(getvar stackshotbasename)"
  Stackshotbasename="${Stackshotbasename:-st}" ### FIXME declare in GUI
  
  cd "$Storagebasedir/$Projectname"
  Stackshotname="${Stackshotbasename}_$(get_free_filenumber "$Stackshotbasename")"
  
  Stackshotdir="$Storagebasedir/$Projectname/$Stackshotname"
  setvar "lateststack=$Stackshotdir"
  mkdir -p "$Stackshotdir/stackshot"
  [ "$Medianmode" = "yes" ] && mkdir -p $Stackshotdir/median.source
  cd $Stackshotdir

  # ggf. Positionen für stepin +/- korrigieren
  position_read
  [ "$Pos1" -gt "$Pos2" ] && {
    note "stack: Switching Pos1:$Pos1 and Pos2:$Pos2"
    Posmem=$Pos1
    Pos1=$Pos2
    Pos2=$Posmem
    position_store
  }
    
  # Stackshot
  #Anzahl="$(bc <<< "($Pos2 - $Pos1) / $Stepwidth" | cut -d. -f1)"
  Anzahl="$(awk "BEGIN {print ($Pos2 - $Pos1) / $Stepwidth }" | cut -d. -f1)"
  note "Shooting stack $Stackshotdir with $Anzahl steps."
  sendkaptain "info='Shooting stack $(basename $Stackshotdir) with $Anzahl steps.'"
  
  # An Startposition gehen
  stepcmd go $Pos1
  position_read  
  [ "$Poscurrent" = "$Pos1" ] || { 
    failure "stack: Error: Missed position $Pos1: $Poscurrent." 
    dropvar stackshot
    return 1 
  }
  
  # Auf Start warten
  #sleep $(getvar startdelay)
  Warten="$(getvar startdelay)"
  Count=0
  while [ "$Count" -lt "$Warten" ] ; do
    statusmessage "Delay before start: Countdown $((Warten-Count))s"
    showpercent $Count $Warten
    testvar cmdbreak && break
    Count="$((Count+1))"
    sleep 1
  done
  showpercent busy
  
  statusmessage "mirror up"
  gphoto2_cmd mirrorup
  
  while [ "$Poscurrent" -lt "$Pos2" ] ; do
    Loopcount=$((Loopcount +1 ))
    testvar cmdbreak && break
    showpercent $Loopcount $Anzahl
    statusmessage "$Fotomodus $Loopcount / $Anzahl"
    
    for ((Mediancount=1 ; Mediancount<=$Mediannumber ; Mediancount++)); do
      # wait after step before capture
      Count=1
      while [ "$((Count*1000))" -lt "$Stackshotdelay" ] ; do
        statusmessage "Delay before next capture: Countdown $((Stackshotdelay/1000-Count))s"
        Count="$((Count+1))"
        sleep 1
      done
      Count="$((Count-1))"
      milisleep $((Stackshotdelay - Count*1000))

      # capture
      case $Fotomodus in
        capture) 
          Filename="$(LC_ALL=C gphoto2_wrap --capture-image-and-download --force-overwrite | grep 'Saving file as')"
          gphoto2_cmd mirrorup
          Filename="$(awk '{print $4}' <<< "$Filename")"
          Latestimage="$Stackshotdir/stackshot/capture_$(printf "%04d" $Loopcount).jpg"
          [ -e "$Filename" ] || {
            failure "Capture failed"
            dropvar stackshot
            return 1
          }
          mv "$Filename" "$Latestimage"
        ;;
        preview)
          gphoto2_wrap --capture-preview
          Latestimage="$Stackshotdir/stackshot/preview_$(printf "%04d" $Loopcount).jpg"
          mv -f capture_preview.jpg "$Latestimage"
          setvar "latestimage=$Latestimage"
        ;;
      esac
      
      case $Medianmode in
        yes)
          Mediangroup="$Stackshotdir/median.source/img_$(printf "%04d" $Loopcount)"
          Latestmedian="${Mediangroup}_m$(printf "%02d" $Mediancount).jpg"
          cp $Latestimage $Latestmedian
          note "stack: Image stored as $Latestmedian"
          setvar "latestimage=$Latestmedian"
        ;;
        no)
          note "stack: Image stored as $Latestimage"
        ;;
      esac
      
      showimage "$Latestimage"
    done
    
    [ "$Medianmode" = "yes" ] && {
      note "stack: Aligning captures of step $Loopcount."
      statusmessage "Aligning median captures of step $Loopcount."
      align_image_stack -l --use-given-order -a ${Mediangroup}_align $Mediangroup*.jpg 2>&1 | grep -v "Unable to read EXIF data"
      Latestimage="$Stackshotdir/stackshot/${Fotomodus}_$(printf "%04d" $Loopcount).jpg"
      $Convert ${Mediangroup}_align*.tif -evaluate-sequence median "$Latestimage"
      showimage "$Latestimage"
    }

    # step in
    statusmessage "next step"
    stepcmd stepin
    position_read
  done
  
  note "stack: Ready: Stackshot $Stackshotname with $((Loopcount * Mediannumber)) images in $Loopcount steps."
  note "stack: Location: $Stackshotdir"
  dropvar stackshot
  return 0
}

#### gphoto2 camera control

gphoto2_wrap() {
  local Cameraport
  Cameraport="$(getvar cameraport)"
  [ "$Cameraport" ] && Cameraport="--port=$Cameraport"
  note "gphoto2 $Cameraport $@"
  gphoto2 $Cameraport $@ || {
    failure "gphoto2 failed. Is the camera plugged in and turned on?"
    return 1
  }
  return 0
}
gphoto2_cmd () {
  ## Funktion: Sammlung und Koordination der gphoto2-Aufrufe
  #
  local Command Return=0 Workdir
 
  Command="${1:-}"
  shift
  case $Command in
    check)
      gphoto2_wrap --list-config >/dev/null 2>&1
      Return=$?
    ;;    
    set-config-value|scv)                     # Kameraeinstellung setzen (Wert)
      gphoto2_wrap --set-config-value $@
      Return=$? 
      ;;
    set-config-index|sci)                     # Kameraeinstellung setzen (Indexnummer)
      gphoto2_wrap --set-config-index $@
      Return=$? 
      ;;
    capture-image-and-download)               # Bild aufnehmen und herunterladen
      Workdir="$(pwd)/captures"
      mkdir -p "$Workdir"
      # %C als Suffix läßt gphoto2 Dateiende selbst richtig einsetzen (jpg oder cr2 oder ...)
      Latestimage="$Workdir/capture_$(get_free_filenumber capture).%C"
      gphoto2_wrap --capture-image-and-download --filename $Latestimage
      Return=$?
      # Dateiname mit tatsächlichem Suffix ermitteln. 
      Latestimage="$Workdir/$(get_latest_file "capture*.jpg")"
      [ "$Latestimage" ] || Latestimage="$Workdir/$(get_latest_file "capture*")"
      setvar "latestimage=$Latestimage"
      ;;
    capture-preview)                         # Einzelnes Videobild aufnehmen, ohne daß der Spiegel zuklappt
      ## Funktioniert ab gphoto2 Version >= 2.5.9 ##
      Workdir="$(pwd)/captures"
      mkdir -p "$Workdir"
      gphoto2_cmd mirrorup
      gphoto2_wrap --capture-preview
      Return=$?
      [ "$Return" = "0" ] && {
        Latestimage="$Workdir/preview_$(get_free_filenumber preview).jpg"
        mv capture_preview.jpg "$Latestimage"
        setvar "latestimage=$Latestimage"
      } 
      ;;
    mirrorup)                                 # Viewfinder einschalten = Spiegel hoch
      gphoto2_wrap --set-config-value viewfinder="1"
      Return=$? 
      ;;
    zoom)                                     # Viewfinder-Zoom setzen. Zulässige Werte sind 1, 5, und 10
      gphoto2_wrap --set-config-value eoszoom=$1
      Return=$? 
      ;;
    move-zoom)                                # Position von Viewfinder-Zoom ändern
      case $1 in
        x) ZOOM_XPOS="$[$ZOOM_XPOS+$2]" ;;
        y) ZOOM_YPOS="$[$ZOOM_YPOS+$2]" ;;
      esac
      [ "$ZOOM_XPOS" -lt "0" ] && ZOOM_XPOS="0" 
      [ "$ZOOM_YPOS" -lt "0" ] && ZOOM_YPOS="0" 
      gphoto2_wrap --set-config-value eoszoomposition="$ZOOM_XPOS,$ZOOM_YPOS"
      Return=$? 
      ;;
    reset)
      gphoto2_wrap --reset
      Return=$?
    ;;
    *)
      failure "gphoto2_cmd(): invalid command: $Command $@"
      Return=1
      ;;
  esac
  return $Return
}
video() {
  ## Funktion: Videoaufnahme starten oder stoppen, mit Speichern auf Festplatte oder ohne
  # $1  Aufnahmemodus
  local Videodauer Videomode Pidffplay
  local GPHOTO2 FFMPEG FFPLAY FFPLAY_LOCATION
  local Windowid Windowgeometry Ffplay_x Ffplay_y
  local Workdir

  Pidffplay="$(getvar pidffplay)"
  [ "$Pidffplay" ] && ps -p "$Pidffplay" >/dev/null 2>&1 && {
    # store window position
    Windowid=$(xdotool search --pid "$Pidffplay" | tail -n1)
    Windowgeometry="$(xdotool getwindowgeometry --shell $Windowid)"
    grep -q "X=" <<< "$Windowgeometry" && {
      Ffplay_x="$(grep "^X=" <<< "$Windowgeometry" | cut -d= -f2)"
      Ffplay_y="$(grep "^Y=" <<< "$Windowgeometry" | cut -d= -f2)"
      setvar "ffplay_x=$Ffplay_x"
      setvar "ffplay_y=$Ffplay_y"
    }
    # kill ffplay
    kill $Pidffplay
    dropvar pidffplay
    Pidffplay=""
  }

  # Restore ffplay position
  testvar ffplay_x && FFPLAY_LOCATION="-left $(getvar ffplay_x) -top $(getvar ffplay_y)"
  
  Videodauer="3600s"
  Videomode="${1:-preview}"
  
  GPHOTO2="gphoto2 --capture-movie=$Videodauer --stdout"
  FFMPEG="ffmpeg -loglevel error -i -  -c:v copy -f mpjpeg  - "
  FFPLAY="ffplay -loglevel error -sync ext -window_title stackshooter-Video $FFPLAY_LOCATION - "

  case $Videomode in
    preview)
      $GPHOTO2 | $FFPLAY & Pidffplay=$!
    ;;
    capture)
      Workdir="$(pwd)/video"
      mkdir -p "$Workdir"
      # Dateiname für neues Video
      Latestvideo="$Workdir/video_$(get_free_filenumber).mjpg"
      $GPHOTO2 | $FFMPEG | tee $Latestvideo | $FFPLAY & Pidffplay=$!
    ;;
    stop)
      # Videowiedergabe/aufnahme stoppen. 
      # Da das bereits am Anfang dieser Funktion geschieht, 
      # muß weiter nichts getan werden
    ;;
  esac
  
  [ "$Pidffplay" ] && ps -p "$Pidffplay" >/dev/null 2>&1 && setvar "pidffplay=$Pidffplay" && storepid $Pidffplay
 
}
cameralist() {
  local Camera Cameralist Cameralistkaptain
  Camera="$(getvar camera)"
  
  Cameralist="$(gphoto2 --auto-detect | tail -n+3)"
  while read Line; do
    Cameralist="$Cameralist
$(echo "$Line" | xargs)"
  done <<< "$Cameralist"
  Cameralist="$(tail -n+2 <<< "$Cameralist")"
  
  [ -z "$Cameralist" ] && failure "No camera detected."
  
  grep -q "$Camera" <<< "$Cameralist" || Camera=""
  [ -z "$Camera" ] && Camera="$(head -n1 <<< "$Cameralist")"
  [ -z "$Camera" ] && Camera="autodetect"
  Cameraport="$(rev <<< "$Camera" | cut -d' ' -f1 | rev)"
  
  Cameralistkaptain="'autodetect'"
  while read Line; do
    Cameralistkaptain="$Cameralistkaptain,'$Line'"
  done <<< "$Cameralist"
  
  sendkaptain "camera($Cameralistkaptain)='$Camera'"
  
  case $Camera in
    autodetect) 
      dropvar camera 
      dropvar cameraport  
    ;;
    *)
      setvar "camera=$Camera" 
      setvar "cameraport=$Cameraport"
    ;;
  esac
}
camerainit() {
  local Camera Cameraport
  local Configlist Kaptainlist Setting Value
  
  Camera="${1:-}"
  [ -z "$Camera" ] && Camera="$(getvar camera)"
  Cameraport="$(rev <<< "$Camera" | cut -d' ' -f1 | rev)"
  
  setvar "camera=$Camera"
  setvar "cameraport=$Cameraport"
  
  gphoto2_cmd reset
  gphoto2_cmd check || {
    
    return 1
  }
  gphoto2_cmd set-config-index autoexposuremode=3 # mode "Manuell"
  gphoto2_cmd set-config-index imageformat=0      # Large fine JPG. 6=Large fine JPG + RAW
  
  for Setting in iso shutterspeed; do
    note "Checking camera config options for $Setting"
    Configlist="$(gphoto2_wrap --get-config $Setting | grep Choice | awk '{print $3}')"
    Kaptainlist=""
    while read Line; do
      Kaptainlist="$Kaptainlist,'$Line'"
    done <<< "$Configlist"
    Kaptainlist="${Kaptainlist#,}"
    Value="$(getvar $Setting)"
    [ "$Value" ] && grep -q -x "$Value" <<< "$Configlist" || {
      grep -q -x "1/80" <<< "$Configlist" && Value="1/80"
      grep -q -x "800"  <<< "$Configlist" && Value="800"
      [ -z "$Value" ] && Value="$(head -n1 <<< "$Configlist")"
    }
    setvar "$Setting=$Value"
    gphoto2_cmd set-config-value $Setting=$Value
    sendkaptain "$Setting($Kaptainlist)='$Value'"
  done
}

#### Keyboard control

keyboard_stepin() {
  while :; do
    [ -e "$Keyboardstepinfile" ]  && stepcmd stepin  || sleep 0.2
  done
}
keyboard_stepout() {
  while :; do
    [ -e "$Keyboardstepoutfile" ] && stepcmd stepout || sleep 0.2
  done
}
keyboard_watch() {
  local Keyhub Keycode
  while read Line <$Keyboardfifo ; do
    Keyhub=$(awk '{print $2}' <<< "$Line")
    Keycode=$(awk '{print $3}' <<< "$Line")
    #note "Keycode: $Keycode ; Keyhub: $Keyhub"
    [ -e "$Keyboardwatchfile" ] && case $Keyhub in
      press)
        case $Keycode in
          # Durchgehender Lauf von Stepin/Stepout
          133) touch "$Keyboardstepinfile"  ;;  # win
          64)  touch "$Keyboardstepoutfile" ;; # L-alt
        esac
      ;;
      release)
        case $Keycode in
          133) rm -f "$Keyboardstepinfile" ;;        # win
          64)  rm -f "$Keyboardstepoutfile" ;;       # L-alt
        esac
      ;;
    esac
  done
}

#### Variable storage in parallel subshell

dropvar() {
  echo "unset  ${1:-}"   >$Storevarinfifo
  read Dummy             <$Storevaroutfifo
  echo "export ${1:-}"   >$Storevarinfifo
  read Dummy             <$Storevaroutfifo
}
dumpvar() {
  local Line Var
  echo "env"           >$Storevarinfifo
  while read -t1 Line; do
    Var="$(cut -d= -f1 <<< "$Line")"
    [ "$Var" = "${Var^^}" ] || echo "$Line"
  done                 <$Storevaroutfifo
}
getvar() {
  local Result
  echo "echo \$${1:-}"   >$Storevarinfifo
  read -t1 Result        <$Storevaroutfifo || failure "getvar(): No response for ${1:-}"
  #milisleep 10
  echo "$Result"
}
setvar() {
  echo "export '${1:-}'" >$Storevarinfifo
  read Dummy             <$Storevaroutfifo
}
storevar() {
  local Line
  #set -x
  while :; do
    read Line            <$Storevarinfifo
    eval "$Line"         >$Storevaroutfifo
  done                   
  failure "storevar(): terminated"
}
testvar() {
  local Value
  Value="$(getvar "${1:-}")"
  test -n "$Value"
}

#### GUI

gui_main() {
  local Kaptainpid Kaptaingrammar Kaptainstdinfile Kaptainstdoutfile Kaptainanswerfile Kaptainpipefile Kaptainsignal

  Kaptaingrammar="$Maincachedir/gui_main.grammar"
  Kaptainstdinfile="$Maincachedir/gui_main.stdin" 
  Kaptainstdoutfile="$Maincachedir/gui_main.stdout"
  Kaptainanswerfile="$Maincachedir/gui_main.reply"
  Kaptainpipefile="$Maincachedir/gui_main.pipe.sh"

  :>     "$Kaptainstdinfile"
  :>     "$Kaptainstdoutfile"
  
  gui_main_grammar > $Kaptaingrammar
  #nl -ba $Kaptaingrammar
  pipekaptain
  tail -F "$Kaptainstdoutfile" >> $Kaptainanswerfile & storepid $!

  kaptain --pipe $Kaptainpipefile $Kaptaingrammar & Kaptainpid=$!
  setvar "pidkaptain=$Kaptainpid"
  storepid $Kaptainpid
  
  gui_main_parser "camera:autodetect"
  gui_main_parser "devicecombo:autodetect"
  position_store
  
  while ps -p $Kaptainpid >/dev/null; do
    read -t1 Kaptainsignal
    [ "$Kaptainsignal" ] && {
      note "Signal from kaptain: $Kaptainsignal"
      Kaptainsignal="${Kaptainsignal%:pressed}"
    }
    [ "$Kaptainsignal" ] && gui_main_parser "$Kaptainsignal"
  done < <(tail -F "$Kaptainstdoutfile")
}
gui_main_grammar() {
  echo "#! /usr/bin/kaptain
start 'stackshooter'                                -> mainframe;
mainframe:framed                                   -> naviframe cameraframe stackshotframe statusframe;
  naviframe 'Device'                                 -> device stepline pos0line pos1line pos2line positionline poscalcline keyboardline;
    device:beside             'Device file'            -> devicecombo devicebutton ;
      devicecombo                                        -> @combo('autodetect')='autodetect' ;
      devicebutton                                       -> @button=' initialize' ;
    stepline:beside                                    -> stepin stepout stepwidth stepmy;
      stepin                                             -> @button='Step in';
      stepout                                            -> @button='Step out';
      stepwidth:beside        'Step width:'              -> @combo('1','2','5','10','15','20','25','30','40','50','60','75','100','150','200','250','300','400','500','750','1000','1500','2000','3000','5000','7500','10000')='50' ;
      stepmy                                             -> @text='' ;  
    pos0line:beside                                    -> setpos0 gopos0 ;
      setpos0                                            -> @button='Set current position as position zero' ;
      gopos0                                             -> @button='Go to pos0';
    pos1line:beside                                    -> setpos1 gopos1;
      setpos1                                            -> @button='Set current position as start point of stack' ;
      gopos1                                             -> @button='Go to pos1' ;
    pos2line:beside                                    -> setpos2 gopos2 ;
      setpos2                                            -> @button='Set current position as end point of stack' ;
      gopos2                                             -> @button='Go to pos2' ;
    positionline:beside                                -> poscurrent pos1 pos2;
      poscurrent:beside       'Current:'                 -> @text='' ;
      pos1:beside             'Pos1:'                    -> @text='' ;
      pos2:beside             'Pos2:'                    -> @text='' ;
    poscalcline:beside                                 -> difference distance steps;
      difference:beside       'Difference:'              -> @text='' ;
      distance:beside         'Distance:'                -> @text='' ;
      steps:beside            'Steps:'                   -> @text='' ;
    keyboardline:beside       'Watch Keyboard (Super=stepin, L-Alt=stepout)' -> "" | "" ;
  cameraframe                 'Camera'               -> cameraline settingline captureline videoline;
    settingline:beside                                 -> zoom iso shutterspeed ;
      zoom:beside 'Zoom:'                                -> @combo('1','10') ;
      iso:beside 'ISO:'                                  -> @combo('____') ;
      shutterspeed:beside     'Shutterspeed:'            -> @combo('________') ;
    cameraline:beside                                  -> camera ;
      camera:beside                                      -> @combo('autodetect')='autodetect' ;
    captureline:beside                                 -> capturepreview capturefullres ;
      capturepreview                                     -> @button='Capture preview' ;
      capturefullres                                     -> @button='Capture full resolution' ;
    videoline:beside                                   -> videostart videocapture videostop;
      videostart                                         -> @button='Start video' ;
      videocapture                                       -> @button='Capture video' ;
      videostop                                          -> @button='Stop video' ;
  stackshotframe              'Stackshot'            -> stackshotdelayline stackshotmedian stackshotline;
    stackshotline:beside                               -> stackshotpreview stackshotfullres ;
      stackshotpreview                                   -> @button='Run preview stackshot' ;
      stackshotfullres                                   -> @button='Run full resolution stackshot' ;
    stackshotmedian:beside    'Median captures to delete moved objects:' -> @combo('3','4','5','6','7','8','9','10')='5' | ! "";
    stackshotdelayline:beside                            -> stackshotdelay startdelay;
      stackshotdelay:beside   'Delay between captures (ms):'  -> @combo('100','200','300','400','500','750','1000','1500','2000','2500','3000','4000','5000')='500';
      startdelay:beside       'Delay before start:'      -> @combo('1','10','30','60','300','600')='1';
  statusframe 'Status'                               -> statusline ;
    statusline:beside                                  -> cmdpercent status config;
      cmdpercent                                         -> @icon ;
      status                                             -> @text ;
      config                                             -> @button='config' ;
"
}
gui_main_parser() {
  local Kaptainsignal Argument
  local Projecthome Projectname
  local Device
  
  Kaptainsignal="${1:-}"
  Argument="$(cut -s -d: -f2 <<< "$Kaptainsignal")"

  position_read
  
  statusmessage "$Kaptainsignal"
  showpercent busy
  dropvar cmdbreak

  # Provide project dir if needed, check settings in GUI
  case $Kaptainsignal in
    *capture*|stackshot*)
      testvar projectname || setup_projectdir
      Projecthome="$(getvar storagebasedir)"
      Projectname="$(getvar projectname)"
      cd "$Projecthome/$Projectname"
    ;;
  esac

  # Stop video if gphoto2 access
  case "$Kaptainsignal" in       # Laufende Videoaufnahme bei gphoto2 Aufruf unterbrechen, ggf. nach Kommando wieder starten
    iso*|shutter*|capture*|video*|zoom*|stackshot*)
      video stop
    ;;
  esac

  case $Kaptainsignal in
    devicecombo*)
      Device="$(cut -d: -f2 <<< "$Kaptainsignal")"
      case $Device in
        autodetect)
          Devicecombo=""
          Devicebasename="$(getvar devicebasename)"
          Devicelist="$(find ${Devicebasename}* 2>/dev/null)"
          for Device in $Devicelist; do
            Devicecombo="$Devicecombo,'$Device'"
          done
          Devicecombo="'autodetect'$Devicecombo,'/dev/null'"
          Device="$(head -n1 <<< "$Devicelist")"
          Device="${Device:-autodetect}"
          sendkaptain "devicecombo($Devicecombo)='$Device'"
        ;;
      esac
      setvar "device=$Device"
    ;;
    devicebutton*)
      Device="$(getvar device)"
      case $Device in
        autodetect) 
          gui_main_parser "devicecombo:autodetect"
          Device="$(getvar device)"
        ;;
      esac
      case $Device in
        autodetect) 
          Device="/dev/null"
          setvar "device=$Device"
        ;;
      esac
      device_init
      sendkaptain "devicecombo($Devicecombo)='$Device'"
      stepcmd setpos0
      stepcmd stepwidth $(getvar stepwidth)
    ;;
    
    camera:autodetect|camera:)
      cameralist
      camerainit
    ;;
    camera:*)
      camerainit "$Argument"
    ;;
    zoom*)
      gphoto2_cmd zoom $Argument
      setvar "zoom=$Argument"
    ;;
    iso*)
      gphoto2_cmd set-config-value iso="$Argument"
      setvar "iso=$Argument"
    ;;
    shutterspeed*)
      gphoto2_cmd set-config-value shutterspeed="$Argument"
      setvar "shutterspeed=$Argument"
    ;;
    
    capturepreview)
      gphoto2_cmd capture-preview
      showimage "$(getvar latestimage)"
    ;;
    capturefullres)
      gphoto2_cmd capture-image-and-download
      showimage "$(getvar latestimage)"
    ;;
    
    videostart)
      setvar "videomode=preview"
    ;;
    videocapture)
      setvar "videomode=capture"
    ;;
    videostop)
      dropvar videomode
    ;;
    
    setpos*|gopos*|stepin|stepout) 
      stepcmd $Kaptainsignal
    ;;
    stepwidth*)
      stepcmd stepwidth $Argument
    ;;
    keyboardline:on)
      keyboard_stepin  & setvar "pidkeyboardstepin=$!"  && storepid $(getvar pidkeyboardstepin)
      keyboard_stepout & setvar "pidkeyboardstepout=$!" && storepid $(getvar pidkeyboardstepout)
      touch "$Keyboardwatchfile"
    ;;
    keyboardline:off)
      testvar pidkeyboardstepin  && kill $(getvar pidkeyboardstepin)
      testvar pidkeyboardstepout && kill $(getvar pidkeyboardstepout)
      rm "$Keyboardwatchfile"
    ;;
    
    stackshotpreview|stackshotfullres)
      kill -s STOP $(getvar pidkeyboardwatch)
      setup_projectdir
      Argument="$(askkaptain stackshotmedian)"
      Argument="${Argument:-1}"
      setvar "mediannumber=$Argument"
      Argument="$(askkaptain stackshotdelay)"
      Argument="${Argument:-500}"
      setvar "stackshotdelay=$Argument"
      Argument="$(askkaptain startdelay)"
      setvar "startdelay=$Argument"
      Argument="${Argument:-100}"
      gui_stackshot $Kaptainsignal
      kill -s CONT $(getvar pidkeyboardwatch)
    ;;
    config)
      gui_config
      read_configfile "$Configfile"
      position_read
      position_store
    ;;
  esac

  # restart video
  testvar videomode && {
    ps -p "$(getvar pidffplay)" >/dev/null 2>&1 || video "$(getvar videomode)"
  }
  
  testvar error || {
    statusmessage ""
    showpercent idle
  }
  dropvar error
}
gui_config() {
  local Kaptainpid Kaptaingrammar Kaptainstdinfile Kaptainstdoutfile Kaptainanswerfile Kaptainpipefile Kaptainsignal
  local Setting
    
  Kaptaingrammar="$Maincachedir/gui_config.grammar"
  Kaptainstdinfile="$Maincachedir/gui_config.stdin"
  Kaptainstdoutfile="$Maincachedir/gui_config.stdout"
  Kaptainanswerfile="$Maincachedir/gui_config.reply"
  Kaptainpipefile="$Maincachedir/gui_config.pipe.sh"

  :>     "$Kaptainstdinfile"
  :>     "$Kaptainstdoutfile"
  
  echo '#! /usr/bin/kaptain
start "stackshooter configuration" -> frameset ;
  frameset:framed                                         -> fileframe signalframe unitframe saveframe;
    fileframe                 "Files"                       -> storagebasedir projectbasename stackshotbasename devicebasename;
      storagebasedir:beside     "Storage base dir:"           -> @directory="$HOME/Bilder/stackshooter" ;
      projectbasename:beside    "Project base name:"          -> @string="project" ;
      stackshotbasename:beside  "Stackshot base name:"        -> @string="st" ;
      devicebasename:beside     "Device base name to search:" -> @string="/dev/ttyACM" ;
    signalframe               "Device signals"              -> signaltext signalline1 signalline2;
      signaltext -> @text="Commands send to device by stackshooter. \n
  stackshooter expects an arbitray string as a response from device. \n
  signal stepin should cause n=stepwidth steps forwards. \n
  signal stepout should cause n=stepwidth steps backwards. \n
  signal stepwidth will be send as w,25 to transmit the value. \n
  signal check should cause no action but an answer only." ;
      signalline1:beside                                      -> signalstepin signalstepout;
        signalstepin:beside             "stepin"                -> @string="i" ;
        signalstepout:beside            "stepout"               -> @string="o" ;
      signalline2:beside                                      ->  signalstepwidth signalcheck;
        signalstepwidth:beside          "stepwidth"             -> @string="w" ;
        signalcheck:beside              "check"                 -> @string="c" ;
    unitframe                 "Step distance and unit"      -> unitline ;
      unitline:beside                                         -> stepdistance stepunit;
        stepdistance:beside         "Distance of stepwidth 1:"  -> @string="0.048" ;
        stepunit:beside             "Unit:"                     -> @string="my" ;
    saveframe:beside                                            -> savebutton closebutton;
      savebutton                                              -> @button="save settings" ;
      closebutton                                             -> @close="close" ;
' > "$Kaptaingrammar"
  #nl -ba < "$Kaptaingrammar"
  
  pipekaptain
  tail -F "$Kaptainstdoutfile" >> $Kaptainanswerfile & storepid $!
  
  kaptain --pipe $Kaptainpipefile $Kaptaingrammar & Kaptainpid=$!
  storepid $Kaptainpid
  
  for Setting in storagebasedir projectbasename stackshotbasename devicebasename signalstepin signalstepout signalstepwidth signalcheck stepdistance stepunit ; do
    sendkaptain "$Setting='$(getvar $Setting)'"
  done

  # watch signals of kaptain
  while ps -p $Kaptainpid >/dev/null; do
    read -t1 Kaptainsignal
    [ "$Kaptainsignal" ] && {
      note "Signal from kaptain: $Kaptainsignal"
      Kaptainsignal="${Kaptainsignal%:pressed}"
    }
    [ "$Kaptainsignal" ] && {
      case $Kaptainsignal in
        savebutton)
          :> $Configfile
          for Setting in storagebasedir projectbasename stackshotbasename devicebasename signalstepin signalstepout signalstepwidth signalcheck stepdistance stepunit ; do
            echo "${Setting}=$(askkaptain $Setting)" >> "$Configfile" 
          done
        ;;
      esac
    }
  done < <(tail -F "$Kaptainstdoutfile")
}
gui_stackshot() {
  local Kaptainpid Kaptaingrammar Kaptainstdinfile Kaptainstdoutfile Kaptainanswerfile Kaptainpipefile Kaptainsignal
  local Functionmode
  
  Functionmode="${1:-stackshotpreview}"
  
  Kaptaingrammar="$Maincachedir/gui_stackshot.grammar"
  Kaptainstdinfile="$Maincachedir/gui_stackshot.stdin"
  Kaptainstdoutfile="$Maincachedir/gui_stackshot.stdout"
  Kaptainanswerfile="$Maincachedir/gui_stackshot.reply"
  Kaptainpipefile="$Maincachedir/gui_stackshot.pipe.sh"

  :>     "$Kaptainstdinfile"
  :>     "$Kaptainstdoutfile"
  
  echo '#! /usr/bin/kaptain
start "Running stackshot"   -> frameset ;
  frameset  -> info cmdline status positionline poscalcline;
    info                -> @text="Running stackshot" ;
    cmdline:beside      -> cmdpercent cmdbreak;
      cmdpercent          -> @icon ;
      cmdbreak            -> @button="break";
    status              -> @text ;
    positionline:beside                                -> poscurrent pos1 pos2;
      poscurrent:beside       "Current:"                 -> @text="" ;
      pos1:beside             "Pos1:"                    -> @text="" ;
      pos2:beside             "Pos2:"                    -> @text="" ;
    poscalcline:beside                                 -> difference distance steps;
      difference:beside       "Difference:"              -> @text="" ;
      distance:beside         "Distance:"                -> @text="" ;
      steps:beside            "Steps:"                   -> @text="" ;
   
' > "$Kaptaingrammar"

  pipekaptain
  tail -F "$Kaptainstdoutfile" >> $Kaptainanswerfile & storepid $!
  
  kaptain --pipe $Kaptainpipefile $Kaptaingrammar & Kaptainpid=$!
  storepid $Kaptainpid
  
  showpercent busy
  setvar "stackshot=running"
  
  case $Functionmode in
    stackshotpreview) stackshot -p & Stackshotpid=$! ;;
    stackshotfullres) stackshot -c & Stackshotpid=$! ;;
  esac
  storepid $Stackshotpid
      
  # watch signals of kaptain
  while ps -p $Kaptainpid >/dev/null; do
    testvar stackshot || break
    read -t1 Kaptainsignal
    [ "$Kaptainsignal" ] && {
      note "Signal from kaptain: $Kaptainsignal"
      Kaptainsignal="${Kaptainsignal%:pressed}"
    }
    [ "$Kaptainsignal" ] && {
      case $Kaptainsignal in
        cmdbreak)
          setvar "cmdbreak=yes"
        ;;
      esac
    }
  done < <(tail -F "$Kaptainstdoutfile")
  
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
}
sendkaptain() {
  # send messages to kaptain over its stdin
#  note "Send to kaptain: $1"
  #testvar pidkaptain && echo "$1" >&${Kaptainstdin}
  testvar pidkaptain || return 1
  #echo "${1:-}" >>${Kaptainstdinfifo}
  echo "${1:-}" >>${Kaptainstdinfile}
}
askkaptain() {
  # ask kaptain for value of $1
  local Wait Answer
  
  testvar pidkaptain || return 1
  #gui_main_grammar | grep -q "${1:-}" || return 1
  
  :> $Kaptainanswerfile
  sendkaptain "${1:-}?"
  for Wait in $(seq 15); do
    milisleep $Wait
    Answer="$(cat "$Kaptainanswerfile")"
    [ -n "$Answer" ] && echo "$Answer" && break
  done
  return 0
}
pipekaptain() {
  # provide script for interactive kaptain option --pipe
  # Needs containing variables to be set beforehand.
  echo  "#! /bin/bash
$(declare -f storepid)
Storepidfile='$Storepidfile'
tail -F ${Kaptainstdinfile} & storepid \$!
cat >> ${Kaptainstdoutfile}
" >$Kaptainpipefile
  chmod +x $Kaptainpipefile
}
showpercent() {
  local Percent Part Full Percentimage
  
  Part="${1:-}"
  Full="${2:-1}"
  
  case "$Part" in
    idle)  Percentimage="p_idle.png" ;;
    error) Percentimage="p_error.png" ;;
    busy)  Percentimage="p_busy.png" ;;
    *)
      Percent="$(( 100 * Part / Full ))"
      Percentimage="p_$Percent.png" 
    ;;
  esac
  Percentimage="$Percentcachedir/$Percentimage"

  [ -e "$Percentimage" ] || case "$Part" in
    idle)  convert -size 100x20 xc:transparent -fill black  -pointsize 20 -gravity center -draw "text 0,0 'idle'"   "$Percentimage" ;;
    error) convert -size 100x20 xc:transparent -fill red    -pointsize 20 -gravity center -draw "text 0,0 'ERROR'"  "$Percentimage" ;;
    busy)  convert -size 100x20 xc:transparent -fill green1 -pointsize 20 -gravity center -draw "text 0,0 '* BUSY *'"   "$Percentimage" ;;
    *)     convert -size 100x20 xc:transparent -fill green1 -draw "rectangle 0,0,$((Percent * 1)),20" -fill black -pointsize 20 -gravity center -draw "text 0,0 '${Percent}%'" "$Percentimage" ;;
  esac
  sendkaptain "cmdpercent('$Percentimage')=''"
}

#### main

declare_variables() {
  Cachebasedir="$HOME/.cache/stackshots"
  Maincachedir="$Cachebasedir/stackshooter"
  Percentcachedir="$Cachebasedir/percent"
  Configdir="$HOME/.config/stackshots"
  Configfile="$Configdir/stackshooter.cfg"
  
  Storepidfile="$Maincachedir/store.pid"
  Storevarinfifo="$Maincachedir/storevar.in.fifo"
  Storevaroutfifo="$Maincachedir/storevar.out.fifo"
  
  Latestimage=""
  Latestvideo=""
  
  Device=""
  Devicecombo=""
  Devicetimeout=2
  Devicefallback="/dev/null"
  Devicemessagefifo="$Maincachedir/device.fifo"
  Devicebasename="/dev/ttyACM"
  
  Poscurrent=0
  Pos1=100
  Pos2=300
  Stepwidth=50
  
  Stepdistance="0.048"
  Stepunit="my"
  Stepdefaultwidth="50"
  
  Keyboardid=""
  Keyboardfifo="$Maincachedir/keyboard.fifo"
  Keyboardfd=""
  Keyboardstepinfile="$Maincachedir/keyboard.stepin"
  Keyboardstepoutfile="$Maincachedir/keyboard.stepout"
  Keyboardwatchfile="$Maincachedir/keyboard.watch"
    
  # Terminal colors used for messages
  Esc="$(printf '\033')"
  Colblue="${Esc}[35m"
  Colyellow="${Esc}[33m"
  Colgreen="${Esc}[32m"
  Colgreenbg="${Esc}[42m"
  Colred="${Esc}[31m"
  Colredbg="${Esc}[41m"
  Coluline="${Esc}[4m"
  Colnorm="${Esc}[0m"
}
read_configfile() {
  local Configfile Line
  Configfile="${1:-}"
  while read Line; do
    setvar "$Line"
  done < "$Configfile"
}
storepid() {
  echo "$(ps -p ${1:-} -h -o pid -o comm)" >> $Storepidfile
}
finish() {
  trap - EXIT
  local Line Pid Comm
  
  # kill stored pids
  while read Line; do
    Pid="$(awk  '{print $1}' <<< "$Line")"
    Comm="$(awk '{print $2}' <<< "$Line")"
    [ "$(ps -p $Pid -h -o comm)" = "$Comm" ] && kill $Pid
  done <$Storepidfile
  
  # close device
  exec 6>&-
  
  # remove cache
  rm -R $Maincachedir
  
  exit 0
}
main() {
  trap finish EXIT 
  
  declare_variables
  
  mkdir    "$Maincachedir"
  mkdir -p "$Percentcachedir"
  :> $Storepidfile
  mkfifo "$Devicemessagefifo"
  
  mkfifo "$Storevarinfifo"
  mkfifo "$Storevaroutfifo"
  storevar & storepid $!
  
  setvar "storagebasedir=$HOME/Bilder/stackshots"
  setvar "projectbasename=project"
  setvar "stackshotbasename=st"
  setvar "devicebasename=$Devicebasename"
      
  setvar "iso=800"
  setvar "shutterspeed=1/80"
  setvar "zoom=1"
  
  setvar "signalstepin=i"
  setvar "signalstepout=o"
  setvar "signalcheck=c"
  setvar "signalstepwidth=w"
  setvar "signalsetpos0=z"
  
  setvar "stepdistance=$Stepdistance"
  setvar "stepunit=$Stepunit"
  setvar "stepdefaultwidth=$Stepdefaultwidth"
  
  read_configfile "$Configfile"
  position_store
  
  mkfifo "$Keyboardfifo"
  Keyboardid=$(xinput | grep "AT Translated" | cut -d= -f2 | awk '{print $1}')
  [ "$Keyboardid" ] && {
    xinput test $Keyboardid >>$Keyboardfifo & storepid $!
    keyboard_watch                          & setvar "pidkeyboardwatch=$!"
    storepid $(getvar pidkeyboardwatch)
  } || failure "Cannot watch keyboard. xinput not installed? Invalid keyboard id '$Keyboardid'?"
  
  gui_main
}

main "$@"
finish
