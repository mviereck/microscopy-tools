#! /bin/bash

shopt -s extglob

#### Messages, Log

note() {
  echo "note: $*"    >> $Wizardmessagefifo
}

worknote() {
  echo "@work: $*"   >> $Wizardmessagefifo
}

warning() {
  echo "WARNING: $*" >> $Wizardmessagefifo
}

failure() {
  echo "FAILURE: $*" >> $Wizardmessagefifo
}

storeinfo() {
  # store and provide pieces of information
  # replace entry if codeword is already present
  # Store as codeword=string:
  #   $1 codeword=string
  # Dump stored string:
  #   $1 dump
  #   #2 codeword
  # Drop stored string:
  #   $1 drop
  #   #2 codeword
  # Test for codeword: (return 1 if not found)
  #   $1 test
  #   $2 codeword
  #
  # note: sed -i causes file permission issues if called in container in Cygwin, compare ticket #187
  #       chmod 666 for $Sharefolder could probably fix that. (FIXME)
  #
  [ -e "$Storeinfofile" ] || return 1
  case "${1:-}" in
    dump) grep     "^${2:-}="   $Storeinfofile | sed "s/^${2:-}=//" ;;      # dump entry
    drop) sed -i  "/^${2:-}=/d" $Storeinfofile ;;                           # drop entry
    test) grep -q  "^${2:-}="   $Storeinfofile ;;                           # test for entry
    *)                                                                      # store entry
      sed -i "/^$(echo "${1:-}" | cut -d= -f1)=/d"     $Storeinfofile       # drop possible old entry
      echo "${1:-}"                                 >> $Storeinfofile
    ;;
  esac
}

showlog() {
  local Line
  while read Line; do
    echo "$Line"
    echo "$Line" >> $Wizardlogfile
  done < $Wizardlogfifo
}

showmessages() {
  local Line
  while read Line; do
    echo "$Line"
    echo "$Line" >> $Wizardmessagefile
    sendkaptain 'ardulog=`tail '$Wizardmessagefile'`'
  done <&4
  echo ENDE
}

#### file operations

checkvar() {
  local Arg
  
  Arg="${1:-}"
  [ "$(cut -c1 <<< "$Arg")" = "-" ] && shift || Arg=""
  
  [ -z "${2:-}" ] && {
    failure "Variable ${1:-} is empty."
    return 1
  }
  
  case "$Arg" in
    -d) 
      [ -d "${2:-}" ] || {
        failure "${1:-} is not a directory: ${2:-}"
        return 1
      }
    ;;
    -e) 
      [ -e "${2:-}" ] || {
        failure "${1:-} does not exist: ${2:-}"
        return 1
      }
    ;;
  esac
  case "$Arg" in
    -D) 
      check_fileglob "${2:-}/*" || {
        failure "${1:-}: directory is empty: ${2:-}"
        return 1
      }
    ;;
    -E) 
      [ -s "${2:-}" ] || {
        failure "${1:-}: file is empty: ${2:-}"
        return 1
      }
    ;;
  esac
  return 0
}

myrm() {
  local Line
  for Line in "$@" ; do
    [ -e "$Line" ] && {
      worknote "rm: deleting $Line"
      rm -rf $Line
    }
  done
}

mymv() {
  check_fileglob "${1:-}" || {
    failure "mv: Source is empty: ${1:-}"
    return 1
  }
  [ -d "${2:-}" ] || {
    failure "mv: Target is not a directory: ${2:-}"
    return 1
  }
  worknote "mv: moving ${1:-} to ${2:-}"
  mv -f $(fileglob "${1:-}") "${2:-}"
}

mycp() {
  check_fileglob "${1:-}" || {
    failure "cp: Source is empty: ${1:-}"
    return 1
  }
  [ -d "${2:-}" ] || {
    failure "cp: Target is not a directory: ${2:-}"
    return 1
  }
  worknote "cp: copy ${1:-} to ${2:-}"
  cp $(fileglob "${1:-}") "${2:-}"
}

check_fileglob() {
  # check whether files exist for glob $1
  #[ -d "$1" ] && return 1
  [ -n "$(find ${1:-} -maxdepth 0 -type f -print -quit 2>/dev/null)" ]
}

check_dirglob() {
  # check whether directories exist for glob $1
  [ -f "${1:-}" ] && return 1
  [ -n "$(find ${1:-} -maxdepth 0 -type d -print -quit)" ]
}

fileglob() {
  # echos files only for glob $1
  local Path Glob Filelist
  
  [ -d "${1:-}" ] && {
    Path="${1:-}"
    Glob="*"
  } || {
    Path="$(dirname  "${1:-}")"
    Glob="$(basename "${1:-}")"
  }
  Path="$(realpath "$Path")"
  
  Filelist="$(find ${1:-} -maxdepth 0 -type f)"
  Filelist="$(sort -V <<< "$Filelist")"
  
  [ "$Filelist" ] && echo "$Filelist" || return 1
}

check_destinationfile() {
  local Destinationfile Function
  Destinationfile="${1:-}"
  Function="${2:-}"
  [ -e "$Destinationfile" ] && {
    #failure "$Function: Destination file already exists: $Destinationfile"
    failure "$Function: Destination file already exists: $(basename "$Destinationfile")"
    return 1
  }
  return 0
}

setup_workdir() {
  # Detect possible source directories in $2 for function $1
  # Set up variables that can be used to call function $1
  # Usage:
  #   setup_workdir Function Targetdir
  # Args:
  #   Function       One of align, sharpen, fuse, median, min, max, mean, set
  #   Targetdir      Target directory [+glob] to check.
  #                  Can already be in an arduterm-structure or an arbitrary one.
  #                  Location of $Destinationdir depends on detected directory structure.
  #   Functionoption   Mode of Function
  # Sets variables:
  #   Sourcedir                 Source directory within $Targetdir
  #   Sourcefileglob            Glob to get files. Mostly just "*"
  #   Destinationdir            Recommended directory to store resulting images.
  #                             Often serves as source dir for following functions.
  #   Destinationfile   Possible prefix of destination file(s). Can be "", though.
  #   Targetcachedir            Cache folder
  #
  # Run in a loop to check for next possible source dir in Targetdir.
  # Returns 0 on success and 1 if nothing more is to do.
  #
  # Stores already checked source dirs of $Targetdir in $Sourcedirchecklist. 
  # -> Set Sourcedirchecklist="" before running a loop with setup_workdir().
  # Use local in calling function:
  #   local Sourcedir Sourcefileglob Destinationdir Destinationfile Targetptofile Targetcachedir Sourcedirchecklist

  local Targetdir Singleshotdir Targetnewdir Targetprevdir 
  local Targetmagickdir Targetfusedir Targetcomposedir Targetcachedir
  
  Function="${1:-}"
  Targetdir="${2:-}"
  Functionoption="${3:-}"

  # Check if a glob like * is given
  check_fileglob "$Targetdir" && {
    Sourcefileglob="$(basename "$Targetdir")"
    Targetdir="$(dirname "$Targetdir")"
  }
  Sourcefileglob="${Sourcefileglob:-"*"}"
  Destinationdir=""
  Destinationfile=""

  Targetdir="$(realpath "$Targetdir")"
  [ -d "$Targetdir" ] || {
    failure "No target directory found. Please specify a target directory or make a stackshot.
  Wrong Target: $Targetdir"
    return 1
  }
  
  [ -d "$Targetdir/stackshot" ]          && Singleshotdir="$Targetdir/stackshot" || Singleshotdir="$Targetdir"
  [ -d "$Targetdir/stackshot-median" ]   && Singleshotdir="$Targetdir/stackshot-median"
  Targetmagickdir="$Targetdir/magick"
  Targetfusedir="$Targetdir/fuse"
  Targetcomposedir="$Targetdir/compose"
  
  Targetcachedir="$Targetdir/cache"
  myrm     "$Targetcachedir"
  mkdir -p "$Targetcachedir"
  Cachedir="$Targetcachedir"
  
  grep -q -- "fuse" <<< "$Function"      && Targetnewdir="$Targetfusedir"
  grep -q -- "compose" <<< "$Function"   && Targetnewdir="$Targetcomposedir"
  grep -q -- "evaluate" <<< "$Function"  && Targetnewdir="$Targetcomposedir" 
  grep -q -- "-evaluate" <<< "$Function" && Targetnewdir="$Targetcomposedir" && Sourcefileglob="*(*.median.*|*.min.*|*.max.*|*.mean.*)"
  
  [ "$Targetnewdir" ] || {
    Targetnewdir="$Targetmagickdir"
    mkdir -p $Targetnewdir
    check_fileglob "$Targetmagickdir/$Sourcefileglob" || mycp "$Singleshotdir/$Sourcefileglob" "$Targetmagickdir"
  }
  Targetprevdir="$Targetnewdir.bak"

  # backup for undo, serving also as source for batch operations
  case $Function in
    align*|brightness*|sharpen*|level*|contrast*|crop*|gamma*|stretch*|kuwahara*|prepare*|wizard*|whitebalance*)
      mkdir -p $Targetprevdir
      mycp "$Targetnewdir/*" "$Targetprevdir/"
      mymv "$Targetnewdir/$Sourcefileglob" "$Targetprevdir/"
    ;;
    evaluate)
      [ -e "$Targetnewdir" ] && {
        mkdir -p $Targetprevdir
        mycp "$Targetnewdir/*" "$Targetprevdir/"
        mymv "$Targetnewdir/*(*magick.median*|*magick.min*|*magick.max*|*magick.mean*)" "$Targetprevdir/"
      }
    ;;
    evaluate-fuse)
      [ -e "$Targetnewdir" ] && {
        mkdir -p $Targetprevdir
        mycp "$Targetnewdir/*" "$Targetprevdir/"
        mymv "$Targetnewdir/*(*fuse.median*|*fuse.min*|*fuse.max*|*fuse.mean*)" "$Targetprevdir/"
      }
    ;;
    compose)
      [ -e "$Targetnewdir" ] && {
        mkdir -p $Targetprevdir
        mycp "$Targetnewdir/*" "$Targetprevdir/"
        mymv "$Targetnewdir/!(*.median.*|*.min.*|*.max.*|*.mean.*|*.fuse.*)" "$Targetprevdir/"
      }
    ;;
    compose-fuse)
      [ -e "$Targetnewdir" ] && {
        mkdir -p $Targetprevdir
        mycp "$Targetnewdir/*" "$Targetprevdir/"
        mymv "$Targetnewdir/!(*.median.*|*.min.*|*.max.*|*.mean.*|*.magick.*)" "$Targetprevdir/"
      }
    ;;
    fuse)
      [ -e "$Targetnewdir" ] && {
        mkdir -p $Targetprevdir
        mymv "$Targetnewdir/*" "$Targetprevdir/"
      }
    ;;
  esac

  case $Function in
    fuse)
      Sourcedir="$Targetmagickdir"
      Destinationdir="$Targetfusedir"
      Destinationfile="$(basename "$Targetdir")"
    ;;
      
    evaluate|compose)
      Function=$(cut -d- -f1 <<<$Function)
      Sourcedir="$Targetmagickdir"
      Destinationdir="$Targetcomposedir"
      Destinationfile="$(basename "$Targetdir").$(basename "$Sourcedir")"
    ;;
    evaluate-fuse|compose-fuse)
      Sourcedir="$Targetfusedir"
      Destinationdir="$Targetcomposedir"
      Destinationfile="$(basename "$Targetdir").$(basename "$Sourcedir")"
    ;;
      
    align*|brightness*|sharpen*|level*|contrast*|crop*|gamma*|stretch*|kuwahara*|prepare*|wizard*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
      
    whitebalance*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
    
    undo*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
    
    *)
      failure "setup_workdir(): Function not defined: $Function"
      return 1
  esac
  
  [ "$Sourcedir" = "$Targetmagickdir" ] && {
    mkdir -p $Targetmagickdir
    check_fileglob "$Targetmagickdir/$Sourcefileglob" || mycp "$Singleshotdir/$Sourcefileglob" "$Targetmagickdir"
  }
  check_fileglob "$Sourcedir/$Sourcefileglob" || return 1
  
  [ "$Destinationdir" ] || return 1
  mkdir -p "$Destinationdir"
  
  return 0
}

#### show images

generate_doubleimage() {
  local Leftimage Rightimage Destinationfile Commentleft Commentright
  
  Leftimage="${1:-}"
  Rightimage="${2:-}"
  Destinationfile="${3:-}"
  Commentleft="${4:-previous}"
  Commentright="${5:-new}"
  
  montage -geometry +0+0 -label "$Commentleft" "$Leftimage" -label "$Commentright" -flop "$Rightimage" "$Destinationfile"
}

showimage() {
  local Imagelist
  Imagelist="$(fileglob "${1:-}")"
  case $(grep  -c .  <<< "$Imagelist") in
    0) failure "showimage: Not found: ${1:-}" ;;
    1) geeqie -t -r File:"$Imagelist" ;;
    *) viewnior           $Imagelist & ;;
  esac
}

showimagehalf() {
  local Sourceimage Destinationimage
  local Cacheimage
  Sourceimage="${1:-}"
  Destinationimage="${2:-}"
  Cacheimage=$Cachefolder/diff.jpg
  $Convert $Sourceimage -crop 50%x100%+0+0 $Cacheimage.half.jpg
  composite -geometry +0+0 $Cacheimage.half.jpg $Destinationimage $Cacheimage
  showimage $Cacheimage
}

showimagediff() {
  local Leftimage Rightimage Commentleft Commentright
  local Cacheimage
  
  Leftimage="${1:-}"
  Rightimage="${2:-}"
  Commentleft="${3:-previous}"
  Commentright="${4:-new}"
  
  Cacheimage="$Cachefolder/diff.jpg"
  
  generate_doubleimage "$Leftimage" "$Rightimage" "$Cacheimage" "$Commentleft" "$Commentright"
  showimage "$Cacheimage"
}

showimage_gui() {

  local Kaptaingrammar Kaptainpid Kaptainstdinfifo Kaptainstdoutfifo Kaptainsignal
  local Image
  
  Image="$Cachefolder/showimage.tif"
  
  Kaptaingrammar="$Cachedir/crop.kaptain.grammar"
  Kaptainstdinfifo="$Cachedir/crop.kaptain.stdin"
  Kaptainstdoutfifo="$Cachedir/crop.kaptain.stdout"
  mkfifo   $Kaptainstdinfifo
  mkfifo   $Kaptainstdoutfifo
  exec  8<>$Kaptainstdinfifo
  exec  9<>$Kaptainstdoutfifo
  
  echo "#! /usr/bin/kaptain
start 'View image stack' -> image directoryline resultline;
  image -> @icon('$Cropimage');
  directoryline -> stackshot magick;
    stackshot     -> @button='stackshot';
    magick        -> @button='magick';
  resultline    -> fusemedian fusemean fusemin fusemax;
    fusemedian    -> @button='fuse.median';
    fusemean      -> @button='fuse.median';
    fusemin       -> @button='fuse.median';
    fusemax       -> @button='fuse.median';
" >> "$Kaptaingrammar"
  kaptain --stdio "$Kaptaingrammar" <&8 >&9 & Kaptainpid=$!
  echo "$Kaptainpid" >> "$Storepidfile"

  while ps -p $Kaptainpid >/dev/null; do
    [ "$Refresh" = "yes" ] && {
      echo "image('$Image')='x'"  >&8
      Refresh="no"
    }

    read -t1 Kaptainsignal
    
    [ "$Kaptainsignal" ] && {
      Kaptainsignal="${Kaptainsignal%:pressed}"
      case $Kaptainsignal in
        ok)         Return=0; break ;;
      esac
      Refresh="yes"
    }
  done <&9
  
  exec 8>&- 9>&-
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
  return 0
}

#### image batch processing

parse_batchoptions() {
  # To be called by batch functions to parse options.
  # Include this local line in the calling function:
  #   local Targetdir Sourcedir Sourcefileglob Destinationdir Destinationfile Cachedir Function Functionmode Functionoption

  local Shortoptions Longoptions Parsedoptions
  Shortoptions="b:c:d:f:g:m:o:s:t:"
  Longoptions=""

  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@" )"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ] ; do
    case "${1:-}" in
      -t) Targetdir="${2:-}" ;;
      -s) Sourcedir="${2:-}" ;;
      -g) Sourcefileglob="${2:-}" ;;
      -d) Destinationdir="${2:-}" ;;
      -b) Destinationfile="${2:-}" ;;
      -c) Cachedir="${2:-}" ;;
      -f) Function="${2:-}" ;;
      -m) Functionmode="${2:-}" ;;
      -o) Functionoption="${2:-}" ;;
      --) ;;
      *) failure "Unbekannte Option ${1:-} ($Function)" ;;
    esac
    #[ "${1:-}" != "--" ] && [ -z "${2:-}" ] && failure "Option ${1:-} has no argument ($Function)" && return 1
    shift
    shift
  done

  [ "$Sourcefileglob" ] || Sourcefileglob="*"
  #[ ! -d "$Sourcedir" ]      && failure "$Function: source dir not found: $Sourcedir" && return 1
  #[ ! -d "$Destinationdir" ] && failure "$Function: destination dir not found: $Destinationdir"&& return 1
  #! check_fileglob "$Sourcedir/$Sourcefileglob" && failure "$Function: No source files found: $Sourcedir/$Sourcefileglob"  && return 1
  return 0
}

batch_function() {
  # Apply image processing function $1 on all possible source dirs in target directory $2, options in $3
  
  local $Batchlocal
  local Sourcedirchecklist Return=0
  
  parse_batchoptions "$@" || return 1
  
  [ -d "$Targetdir" ] || {
    failure "$Function: Target directory not found: $Targetdir"
    return 1
  }
  [ "$Function" ] || {
    failure "batch: No function defined for $Targetdir"
    return 1
  }
  
  [ -z "$Functionmode" ] && case "$Function" in
    compose|evaluate|fuse) Functionmode="all" ;;
  esac
  
  setup_workdir "$Function" "$Targetdir" "$Functionoption" || {
    failure "batch $Function: no source found in $Targetdir"
    #echo "$Sourcedir/$Sourcefileglob"
    return 1
  }

  note "$Function $Functionmode $Functionoption is running: $(basename "$Targetdir")/*/$(basename "$Sourcedir")"
  case "$Function" in
    brightness*|contrast*|gamma*|kuwahara*|level*|prepare*|sharpen*|stretch*|wizard*)
      Functionmode="${Function%magick}"
      Functionmode="${Function%compose}"
      Functionmode="${Function%fuse}"
      Functionmode="${Function%eval}"
      Function="wizard"
    ;;
    evaluate*|compose*)
      Function="${Function%-fuse}"
    ;;
  esac
  $Function -m "$Functionmode" -o "$Functionoption" -s "$Sourcedir" -g "$Sourcefileglob" -d "$Destinationdir" -b "$Destinationfile" -c "$Cachedir"
  Return=$?
  
  [ "$Return" = "0" ] && {
    note "$Function $Functionoption is ready: $(basename "$Targetdir")/$(basename "$Destinationdir")"
  } || {
    failure "ERROR in $Function $Functionmode $Functionoption"
    undo -s "$Sourcedir" -d "$Destinationdir" -c "$Cachedir"
  }
  
  [ "$(basename "$Destinationdir")" = "compose" ] && {
    [ -d "$Destinationdir/../stackshot" ] && {
      for Image in $(fileglob "$Destinationdir/+(*fuse.median*|*fuse.mean*|*fuse.min*|*fuse.max*|*magick.max*)"); do
        ln -f "$Image" "$Destinationdir/../"
      done
    }
    [ "$Destinationdir" != "${Destinationdir#$Wizardhome}" ] && check_fileglob "$Destinationdir/*fuse.median*" && {
      ln -f $(fileglob "$Destinationdir/*fuse.median*") "$Destinationdir/../../"
    }
  }
  
  return $Return
}

wizard() {
  # Wrapper for ImageMagick convert to work on folders
  # Args:
  #  mandatory:
  #   -f Function
  #   -s Sourcedir
  #   -d Destinationdir
  #  optional:
  #   -g Sourcefileglob
  #   -o Functionoption
  
  local $Batchlocal
  local Image Destinationfile
  local Return=0
  
  parse_batchoptions "$@" || return 1
  
  [ "$Functionoption" ] || case "$Function" in
    brightness) Functionoption="10x10" ;;
    contrast)   Functionoption="3x50%" ;;
    gamma)      Functionoption="auto" ;;
    kuwahara)   Functionoption="1" ;;
    level)      Functionoption="auto" ;;
    sharpen)    Functionoption="6x2" ;;
    stretch)    Functionoption="0%" ;;
  esac

  case "$Function" in
    gamma|level) 
      case "$Functionoption" in
        auto|"") Function="-auto-$Function" ; Functionoption="" ;;
        *)       Function="-$Function" ;;
      esac
    ;;
    brightness) Function="-brightness-contrast" ;;
    contrast) Function="-sigmoidal-contrast" ;;
    kuwahara) Function="-kuwahara" ;;
    sharpen)  Function="-adaptive-sharpen" ;;
    stretch)  Function="-contrast-stretch" ;;
#    prepare)  Function="-sigmoidal-contrast 3x50% -kuwahara 0.5 -adaptive-sharpen 6x2" ; Functionoption="" ;;
    prepare)  Function="-auto-gamma -auto-level -sigmoidal-contrast 3x50% -kuwahara 0.5 -adaptive-sharpen 6x2" ; Functionoption="" ;;
    wizard)   Function="$Functionoption" ; Functionoption="" ;;
  esac
  
  for Image in $(fileglob "$Sourcedir/$Sourcefileglob"); do
    Destinationfile="$Destinationdir/$(basename "$Image")"
    worknote "convert $Function $Functionoption $(basename "$Destinationfile")"
    check_destinationfile "$Destinationfile" "$Function" || break
    $Convert "$Image" $Function $Functionoption "$Destinationfile"
    Return=$?
    [ "$Return" != "0" ] && break
#    showimage "$Destinationfile"
#    showimagehalf "$Image" "$Destinationfile"
    showimagediff "$Image" "$Destinationfile" "$(basename "$Image")" "$Function $Functionoption"
  done

  return $Return
}

evaluate() {
  # Evaluate image stack. Mostly used to calculate a median to eliminate moving objects.
  # Usage:
  #   evaluate Functionoption Sourceglob Destinationfile [Fileformat]
  # Args:
  #   Functionoption         Evaluation mode, e.g. median, max, min. Get a list of possible modes with: convert -list evaluate
  #   Sourceglob       Path[+glob] to image stack. Default: ./*
  #   Destinationfile  Output file base name
  # setup_workdir() can help to set up Args.
  local $Batchlocal
  local Destinationfilebasename Fileformat
  
  parse_batchoptions "$@" || return 1

  Destinationfilebasename="${Destinationfile:-evaluate}"  
  Fileformat="${Functionoption:-jpg}"
  
  case "$Functionmode" in
    all)
      for Functionmode in min mean max median; do
        evaluate -s "$Sourcedir" -g "$Sourcefileglob" -d "$Destinationdir" -b "$Destinationfilebasename" -m "$Functionmode" -o "$Fileformat" 
      done
      return 0 ### FIXME
    ;;
    min|max|mean|median) ;;
    *) failure "evaluate: Unknown function mode $Functionmode" ; return 1 ;;
  esac
  
  Destinationfile="$Destinationdir/$Destinationfilebasename.$Functionmode.$Fileformat"
  $Convert $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence $Functionmode "$Destinationfile" || {
    failure "evaluate $Functionmode: ERROR in excuting convert. Please check policy restrictions of ImageMagick. Note that all input images have to be the same size."
    return 1
  }
  showimage "$Destinationfile"
  echo "$Destinationfile"
  return 0
}

compose() {

  local $Batchlocal
  local Minfile Maxfile Destinationfilebasename
  
  parse_batchoptions "$@" || return 1

  checkvar compose Sourcedir "$Sourcedir" || return 1
  checkvar compose Destinationdir "$Destinationdir" || return 1
  checkvar compose Cachedir "$Cachedir" || return 1
  
  Destinationfilebasename="${Destinationfile:-compose}"
  Functionmode="${Functionmode:-all}"
  Functionmode="$(tr '[:upper:]' '[:lower:]' <<< "$Functionmode")"
  
  Maxfile="$Cachedir/evaluate.max.jpg"
  Minfile="$Cachedir/evaluate.min.jpg"
  [ -e "$Maxfile" ] && [ -e "$Minfile" ] || {
    evaluate -s "$Sourcedir" -g "$Sourcefileglob" -d "$Cachedir" -m "max"
    evaluate -s "$Sourcedir" -g "$Sourcefileglob" -d "$Cachedir" -m "min"
  }

  [ -e "$Maxfile" ] && [ -e "$Minfile" ] || {
    failure "compose $Functionmode: Failed to create min and max files."
    return 1
  }
  
  [ "$Functionmode" = "all" ] && {
    for Functionmode in bumpmap colorburn difference linearburn linearlight modulate multiply overlay pegtoplight; do
      compose -s "$Sourcedir" -g "$Sourcefileglob" -d "$Destinationdir" -b "$Destinationfilebasename" -m "$Functionmode" -c "$Cachedir" || return 1
    done
    return 0
  }
  
  Destinationfile="$Destinationdir/$Destinationfilebasename.${Functionmode}1.jpg"
  $Convert "$Minfile" "$Maxfile" -compose "$Functionmode" -composite "$Destinationfile"
  echo "$Destinationfile"
  showimage "$Destinationfile"
  
  case $Functionmode in
    linearburn|multiply) ;;  # skip second compose for modes with identical result
    difference)
      $Convert "$Destinationfile" -negate "$Destinationdir/$Destinationfilebasename.${Functionmode}-negate.jpg"
    ;;
    *)
      Destinationfile="$Destinationdir/$Destinationfilebasename.${Functionmode}2.jpg"
      $Convert "$Maxfile" "$Minfile" -compose "$Functionmode" -composite "$Destinationfile"
      echo "$Destinationfile"
      showimage "$Destinationfile"
    ;;
  esac
}

fuse() {
  # fuse stackshot of images with enfuse
  # Usage:
  #   fuse [-m Fusemode] Sourceglob Destinationfile
  # Args:
  # -m Fusemode         Parameter set to use. Default: 1
  #    Sourceglob       Path[+glob] to image stack. Default: ./*
  #    Destinationfile  Output file. Default: fuse??.tif
  # setup_workdir() can help to set up Args.
  
  local $Batchlocal
  local Destinationfilebasename
  local Exposureweight Saturationweight Contrastweight
  local Contrastedgescale Contrastmincurvature Contrastwindowsize
  local Grayprojector
  
  parse_batchoptions "$@" || return 1
  
  Destinationfilebasename="${Destinationfile:-enfuse}"
  Functionmode="${Functionmode:-1}"
 
  # Predefined parameter sets
  Exposureweight=0.0
  Saturationweight=0.0
  Contrastweight=1.0
  Contrastedgescale=0
  Contrastmincurvature=""
  Contrastwindowsize="3"
  Grayprojector="luminance"
  
  case $Functionmode in
    all)
      fuse_all -s "$Sourcedir" -g "$Sourcefileglob" -d "$Destinationdir" -b "$Destinationfilebasename"
      return
    ;;
    1)
    ;;
    2)
      Saturationweight="0.1"
    ;;
    3) 
      Contrastwindowsize="7"
    ;;
    4) 
      Contrastwindowsize="7"
      Saturationweight="0.1"
    ;;
    5) 
      Contrastwindowsize="15"
    ;;
    6) 
      Contrastwindowsize="15"
      Saturationweight="0.1"
    ;;
    7) 
      Contrastwindowsize="23"
    ;;
    8) 
      Contrastwindowsize="23"
      Saturationweight="0.1"
    ;;
    9)
      Contrastedgescale="0.8:2000%:300%"
      #Contrastmincurvature="+8.0%"
    ;;
    10)
      Contrastedgescale="0.8:500%:500%"
      #Contrastmincurvature="+8.0%"
    ;;
    11)
      Contrastedgescale="1.2:16:4"
      #Contrastmincurvature="+5.0%"
    ;;
    12)
      Contrastedgescale="1.2:8:4"
      #Contrastmincurvature="+5.0%"
      #Saturationweight="0.1"
    ;;
    13)
      Contrastedgescale="1.6:16:4"
      #Contrastmincurvature="+3.0%"
    ;;
    14)
      Contrastedgescale="1.6:8:4"
      #Contrastmincurvature="+3.0%"
      #Saturationweight="0.1"
    ;;
    15)
      Contrastedgescale="1.6:16:10"
      #Contrastmincurvature="+6.0%"
    ;;
    16)
      Contrastedgescale="1.6:8:10"
      #Contrastmincurvature="+8.0%"
      #Saturationweight="0.1"
    ;;
    17)
      Contrastedgescale="2.0:500%:500%"
      #Contrastmincurvature="+2.0%"
    ;;
    18)
      Contrastwindowsize="15"
      Contrastedgescale="1.2:16:4"
      Contrastmincurvature="+8.01%"
    ;;
    19)
      Contrastwindowsize="23"
      Contrastedgescale="1.2:16:4"
      Contrastmincurvature="+8.01%"
    ;;
    20)
      Contrastedgescale="3.0:4:4"
    ;;
    
    
    ###############
    22x) #*
      Contrastwindowsize="23"
      Contrastedgescale="2.5:8:4"
      Contrastmincurvature="+8.01%"
    ;;
    
    23x) #*
      Contrastwindowsize="23"
      Contrastedgescale="2.5:4:2"
      Contrastmincurvature="+8.01%"
    ;;
    
    
    
    20x)
      Contrastwindowsize="23"
      Contrastedgescale="1.2:24:8"
    ;;
    21x)
      Contrastwindowsize="23"
      Contrastedgescale="0.5:36:24"
      Contrastmincurvature="+8.01%"
    ;;
    27x) #*
      Contrastwindowsize="15"
      Contrastedgescale="2.5:4:2"
      Contrastmincurvature="+8.01%"
    ;;
    
    
    xxx7)
      Contrastedgescale="0.3:1000%:300%"
      Contrastmincurvature="+0.3%"
    ;;
    xxx8)
      Contrastedgescale="0.3:1000%:300%"
      Contrastmincurvature="+0.3%"
      Saturationweight="0.1"
    ;;
    
    
    
    
    x11)
      Grayprojector="l-star"
    ;;
    x12) 
      Contrastwindowsize="7"
      Grayprojector="l-star"
    ;;
    x13)
      Grayprojector="l-star"
      Contrastedgescale="0.3:1000%:300%"
      Contrastmincurvature="+0.3%"
      Grayprojector="l-star"
    ;;
    x14)
      Contrastedgescale="0.8:2000%:300%"
      Grayprojector="l-star"
    ;;
    x15)
      Contrastedgescale="1.2:16:4"
      Contrastmincurvature="+8.0%"
      Grayprojector="l-star"
    ;;
    x16)
      Contrastedgescale="1.6:16:4"
      Contrastmincurvature="+4.0%"
      Grayprojector="l-star"
    ;;
    x17)
      Contrastedgescale="1.6:16:4"
      Saturationweight="0.1"
      Contrastmincurvature="+5.0%"
      Grayprojector="l-star"
    ;;
    x18)
      Contrastedgescale="1.6:16:10"
      Saturationweight="0.1"
      Contrastmincurvature="+10.0%"
      Grayprojector="l-star"
    ;;
    *) return 1 ;;
  esac

  Destinationfile="$Destinationdir/$Destinationfilebasename.fuse$(printf %02d $Fusemode).jpg"
  check_destinationfile "$Destinationfile" "fuse" || return 1
  worknote "fuse $Functionmode: Creating $(basename "$Destinationfile")"
  
  Enfuseoptions="
      --exposure-weight=$Exposureweight \
      --saturation-weight=$Saturationweight \
      --contrast-weight=$Contrastweight \
      --hard-mask \
      \
      --contrast-edge-scale=$Contrastedgescale \
      --contrast-window-size=$Contrastwindowsize \
      \
      --gray-projector=$Grayprojector"
  [ "$Contrastmincurvature" ] && Enfuseoptions="$Enfuseoptions \
      --contrast-min-curvature=$Contrastmincurvature"
  
  # Fusing here
  enfuse $Enfuseoptions \
         --output="$Destinationfile" \
         $(fileglob "$Sourcedir/$Sourcefileglob") \
         2>&1 | grep -v "does not have an alpha channel" | grep -v "assuming all pixels should contribute" | grep -v "loading next image" || {
    failure "fuse $Functionmode failed"
    return 1
  }
        
  # Write enfuse options into EXIF data of image
  exiv2 -M"set Exif.Photo.UserComment Comment charset=Ascii enfuse $(echo $Enfuseoptions)" "$Destinationfile" 

  note "fuse $Functionmode is ready: ${Destinationfile}"
  showimage "$Destinationfile"
}

fuse_all() {
  # Iterate through all fuse modes of fuse(). Run as much threads as CPU cores are given.
  # setup_workdir() can help to set up Args.
  # Usage:
  #  fuse_all Sourceglob Destinationdir Destinationfilebasename
  # Args:
  #  Sourceglob                Path[and glob] to stackshot images.
  #  Destinationdir            folder where to store results
  #  Destinationfilebasename   Prefix of created files. Default: "fuse". Suffix will be ??.tif
  
  
  local $Batchlocal 
  local Destinationfilebasename
  local Fusemode Fusepid Fusethreads Cpucount

  parse_batchoptions "$@" || return 1

  Destinationfilebasename="$Destinationfile"
  # number of CPUs to use
  Cpucount="$(nproc)"
  
  # fuse with enfuse
  # some hickhack to run multiple threads at once, but not more than number of CPUs.
  for Fusemode in $(seq 50); do
    Destinationfile="$Destinationdir/$Destinationfilebasename.fuse$(printf %02d $Fusemode).jpg"
    check_destinationfile "$Destinationfile" "fuse" && {
      fuse -s "$Sourcedir" -g "$Sourcefileglob" -d "$Destinationdir" -b "$Destinationfilebasename" -m "$Fusemode" & Fusepid[$Fusemode]=$! 
      #echo "${Fusepid[$Fusemode]} fuse" >>$Backgroundpidfile
      ps -p ${Fusepid[$Fusemode]} >/dev/null && while :; do
        sleep 2
        Fusethreads=0
        for ((i=1; i<=100; i++)); do
          [ "${Fusepid[$i]}" ] && ps -p "${Fusepid[$i]}" >/dev/null 2>&1 && Fusethreads=$((Fusethreads+1)) || Fusepid[$i]=""
        done
        [ "$Fusethreads" -lt $Cpucount ] && break
      done
    }
  done
  for ((i=1; i<=100; i++)); do
    [ "${Fusepid[$i]}" ] && ps -p "${Fusepid[$i]}" >/dev/null 2>&1 && wait ${Fusepid[$i]}
  done
  return 0
}

undo() {
  local $Batchlocal
  local Undocache
  
  parse_batchoptions "$@" || return 1

  Undocache="$Cachedir/undo"
  mkdir -p "$Undocache"
  
  mymv "$Sourcedir/*"      "$Undocache"      || return 1
  mymv "$Destinationdir/*" "$Sourcedir" 
  mymv "$Undocache/*"      "$Destinationdir"
  
  myrm "$Undocache"
}

## align

align_hugin() {
  # Align image stack with some panotools. Similar to align_image_stack
  # Advantage: pto file with aligned control points can be reused for multiple similar stacks
  # Usage:
  #  align Sourceglob Destinationdir [Cachedir]
  # Args:
  #  Sourcedir         Path[+glob] to source image stack
  #  Destinationdir    Path where to store aligned images
  #  Cachedir          Cache folder will contain align.pto file with control points. Can be reused to skip control point calculation.
  
  local Ptofile
  local Count Image Filearray Destinationfile
  local Logfile
  local Crop Cropx Cropy Cropsize
  
  
  local $Batchlocal
  local Imagewidth Imageheight

  parse_batchoptions "$@" || return 1
  
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Ptofile="$Cachedir/align_PTO.pto"
  
  worknote "align_hugin: Aligning $Sourcedir/$Sourcefileglob"
  
  # Get image size. Assuming same size for all images.
  Imagewidth=$($Convert  -format '%w'  "$(head -n1 <<< "$Imagelist")" info:)
  Imageheight=$($Convert -format '%h'  "$(head -n1 <<< "$Imagelist")" info:)
  
  echo "########## pto_gen ##########"
  worknote "align_hugin: Running pto_gen to create list of files"
  cd "$Sourcedir"
  pto_gen -o "$Ptofile.pto_gen.pto" -p 0 -f 40 --crop=0,${Imagewidth},0,${Imageheight} $Sourcefileglob || return 1
  
  sed -i '3 s/r:CROP//'                     "$Ptofile.pto_gen.pto"
  sed -i '3 s/\bf[0-9]*\b/f0/'              "$Ptofile.pto_gen.pto"
  sed -i "3 s/\bw[0-9]*\b/w${Imagewidth}/"  "$Ptofile.pto_gen.pto"
  sed -i "3 s/\bh[0-9]*\b/h${Imageheight}/" "$Ptofile.pto_gen.pto"
  sed -i "3 s/\bv[0-9]*\b/v40/"             "$Ptofile.pto_gen.pto"
    
#    pano_modify --projection=0 $Ptofile.pto_gen.pto
#    pano_modify --canvas=${Imagewidth}x${Imageheight} $Ptofile.pto_gen.pto
#    pano_modify --output-type=FUSEDSTACKS $Ptofile.pto_gen.pto

  # find control points
  echo "########## cpfind ##########"
  worknote "align_hugin: Running cpfind to find control points for alignment. That will take a while."
  cpfind -o "$Ptofile.cpfind.pto"  \
        --fullscale \
        --minmatches 4 \
        --linearmatch \
        --linearmatchlen 10 \
        --ransacmode rpyv \
        "$Ptofile.pto_gen.pto" || return 1
#        --linearmatchlen $Count \

  # clean up useless/wrong control points
  echo "########## cpclean ##########"
  worknote "align_hugin: Running cpclean to remove wrong control points"
  cpclean -s -o "$Ptofile.cpclean.pto" --pairwise-checking "$Ptofile.cpfind.pto" || return 1

#    pano_modify --crop=AUTO $Ptofile.cpclean.pto
    
  # calculate distortion of images to align control points
  echo "########## autooptimiser ##########"
  worknote "align_hugin: Running autooptimiser to transform control points into image distortion"
  autooptimiser -p -o "$Ptofile" "$Ptofile.cpclean.pto" || return 1
#    pano_modify --crop=AUTO $Ptofile
    
  # remove all pto files except the final one
  rm $Ptofile.*.pto

#  grep -q "Strange values may result!" < "$Logfile" && { ### FIXME
#    failure "align did not find enough control points!
#  Check out log file $Logfile
#  Probably source images are distorted too much."
#    return 1
#  }

  # distort images to align them
  echo "########## nona ##########"
  worknote "align_hugin: Running nona to transform images"
  nona -o "$Cachedir/PTO_ALIGN" "$Ptofile" || return 1
  
  cd "$Destinationdir"
  
  # Crop images
  worknote "align_hugin: Checking crop coordinates of common area of all aligned images"
  evaluate -s "$Cachedir" -g "PTO_ALIGN*" -b "$Cachedir/align_PTO" -m "min" -o "tif"
  Crop="$(trim_hard "$Cachedir/align_PTO.min.tif")"

  Count=0
  for Image in $(fileglob "$Cachedir/PTO_ALIGN*"); do
    Count=$((Count +1))
    Destinationfile="$(sed "${Count}q;d" <<< "$Imagelist")"
    Destinationfile="$Destinationdir/$(basename "$Destinationfile")"
    $Convert -crop "$Crop" "$Image" "$Destinationfile"
    showimage "$Destinationfile"
  done
}

align_ais() {
  local $Batchlocal
  local Count Image Destinationfile Alignarray Return

  parse_batchoptions "$@" || return 1

  # -z? -s0? -m?
  time align_image_stack -vv -l -s 1 -z -C --use-given-order -a "$Cachedir/align" $(fileglob "$Sourcedir/$Sourcefileglob") || return 1
  Count="-1"
  for Image in $(fileglob "$Cachedir/align*") ; do
    Count=$((Count+1))
    Alignarray[Count]="$Image"
  done
  Count="-1"
  for Image in $(fileglob "$Sourcedir/$Sourcefileglob") ; do
    Count=$((Count+1))
    Destinationfile="$Destinationdir/$(basename "$Image")"
    $Convert ${Alignarray[Count]} "$Destinationfile"
    showimage "$Destinationfile"
  done
}

align_ffmpeg() {
  local $Batchlocal
  local Sourcefilelist Destinationfile
  local Image Count=0 
  local Shakiness Blackborder
  local Cropevendir

  parse_batchoptions "$@" || return 1
  
  Functionmode="${Functionmode:-vidstab}"
  Shakiness="${Functionoption:-10}"
  Blackborder="crop=black:"
  
  Cropevendir="$Cachedir/cropeven"
  mkdir -p "$Cropevendir"
  crop -m even -s "$Sourcedir" -g "$Sourcefileglob" -d "$Cropevendir"

  Sourcefilelist=$Cachedir/align.source.list
  :> $Sourcefilelist
  
  for Image in $(fileglob "$Cropevendir/$Sourcefileglob"); do
    echo "file $Image" >>$Sourcefilelist
  done
  
  worknote "ffmpeg: generating video from images"
  ffmpeg -y -safe "0" -f "concat" -i "$Sourcefilelist" \
         -vcodec "libx264" -profile:v "high444" -refs "16" -crf "0" -preset "ultrafast" \
         "$Cachedir/align.source.mp4" || return 1
  
  case $Functionmode in
    vidstab)
      worknote "ffmpeg: Analyzing video with shakiness $Shakiness ($Function))"
      ffmpeg -y -i "$Cachedir/align.source.mp4" \
             -vf "vidstabdetect=shakiness=$Shakiness:accuracy=15:mincontrast=0.1:show=1:result=$Cachedir/transforms$Shakiness.trf" \
             "$Cachedir/align.vidstab-show.mp4" || return 1

      worknote "ffmpeg: Transforming image with shakiness $Shakiness ($Function)"
      ffmpeg -y -i "$Cachedir/align.source.mp4" \
             -vf "vidstabtransform=smoothing=0:optzoom=0:interpol=bicubic:relative=1:${Blackborder}debug=1:input=$Cachedir/transforms$Shakiness.trf,unsharp=5:5:0.8:3:3:0.4" \
             "$Cachedir/align.result.mp4" || return 1
    ;;
    deshake)
      worknote "ffmpeg: Aligning image ($Function)"
      ffmpeg -y -i "$Cachedir/align.source.mp4" \
             -vf "deshake=edge=blank:contrast=16:rx=64:ry=64:blocksize=32:filename=$Cachedir/align.ffmpeg.log" \
             "$Cachedir/align.result.mp4" || return 1
    ;;
  esac
  
  worknote "ffmpeg: Splitting aligned video into images"
  ffmpeg -y -i "$Cachedir/align.result.mp4" "$Cachedir/img%04d.tif" -hide_banner || return 1
  
  for Image in $(fileglob "$Cachedir/*.tif"); do
    Count="$((Count+1))"
    Destinationfile="$(sed "s/file // ; ${Count}q;d" $Sourcefilelist)"
    Destinationfile="$Destinationdir/$(basename $Destinationfile)"
    $Convert "$Image" "$Destinationfile"
  done
  
  #note "align: Checking crop coordinates of common area of all aligned images"
  #evaluate "$Destinationdir/*" "$Cachedir/align_crop" min tif
  #Crop="$(trim_hard "$Cachedir/align_crop.min.tif" "#000000")"
  
  #for Image in $(fileglob $Destinationdir/*); do
  #  $Convert $Image -crop "$Crop" $Image.crop.jpg
  #  mymv $Image.crop.jpg $Image
  #  showimage $Image
  #done
}

## crop and trim

cropcolorpermille() {
  # Function: Calculate permille part of pixels of color $2 in crop rectangle $3 of image $1
  # $1  $Image      image
  # $2  $Trimcolor  color to count
  # $3  $Cropgeometry       crop rectangle to search in
  # Output: Permille part of color in crop region
  
  local Image Trimcolor Cropgeometry
  local Colorcount Cropwidth Cropheight Permille
  
  Image="${1:-}"
  Trimcolor="${2:-}"
  Cropgeometry="${3:-}"
  
  Cropwidth=$(cut -dx -f1 <<< "$Cropgeometry")
  Cropheight=$(cut -dx -f2 <<< "$Cropgeometry" | cut -d+ -f1)

  Colorcount="$(convert "$Image" -crop "$Cropgeometry" txt: | grep -c "$Trimcolor")"
  # second way to count color, a bit slower.
#  Colorcount="$(convert "$Image" -crop "$Cropgeometry" -fill black +opaque "$Trimcolor"  -format %c histogram:info: | grep "$Trimcolor")"
#  Colorcount="$(awk '{print $1}' <<< "$Colorcount" | cut -d: -f1)"

  Permille=$((1000 * $Colorcount / ($Cropwidth*$Cropheight) ))
  echo "${Permille:-0}"
}

trim_hard() {
  # Function: Trim all border with color $2 from image $1
  # Results in a maximal inner rectangle without border color.
  # $1  $Image      image
  # $2  $Trimcolor  color to trim. Default: transparent
  # Output: crop geometry
  
  local Image Trimcolor
  local Imagewidth Imageheight
  local Left         Right         Top         Bottom
  local Skipleft     Skipright     Skiptop     Skipbottom
  local Permilleleft Permilleright Permilletop Permillebottom Permillemax
  local Return
  local Debugmode Loopcount
  
  Image="${1:-}"
  Trimcolor="${2:-"#00000000"}"
  
  Imagewidth=$(convert  -format '%w'  $Image info:)
  Imageheight=$(convert -format '%h'  $Image info:)
  
  Left=0
  Top=0
  Right=$((Imagewidth-1))
  Bottom=$((Imageheight-1))
  
  # First cut with regular trim to save some time.
  # Add a colored border so trim uses the desired color. Afterward remove border from canvas to get correct geometry values. 
  Line="$(convert "$Image" -bordercolor "$Trimcolor" -border 1x1  -trim -set page '%[fx:page.width-2]x%[fx:page.height-2]+%[fx:page.x-1]+%[fx:page.y-1]' info:)"
  Left="$(awk '{print $4}' <<< "$Line" | cut -d+ -f2)"
  Top="$(awk '{print $4}' <<< "$Line" | cut -d+ -f3)"
  Right="$(awk '{print $3}' <<< "$Line" | cut -dx -f1)"
  Right="$((Left+Right-1))"
  Bottom="$(awk '{print $3}' <<< "$Line" | cut -dx -f2)"
  Bottom="$((Top+Bottom-1))"
  
  # Workflow:
  # - Get permille amount of $Trimcolor from all sides.
  # - Remove side with greatest permille amount of $Trimcolor.
  # - Repeat check with new geometry
  while :; do
    # Get permille of $Trimcolor at each side
    [ "$Skipleft" ]   || Permilleleft=$(cropcolorpermille   $Image "$Trimcolor" 1x$((Bottom-Top+1))+$Left+$Top)
    [ "$Skipright" ]  || Permilleright=$(cropcolorpermille  $Image "$Trimcolor" 1x$((Bottom-Top+1))+$Right+$Top)
    [ "$Skiptop" ]    || Permilletop=$(cropcolorpermille    $Image "$Trimcolor" $((Right-Left+1))x1+$Left+$Top)
    [ "$Skipbottom" ] || Permillebottom=$(cropcolorpermille $Image "$Trimcolor" $((Right-Left+1))x1+$Left+$Bottom)
    
    # Determine maximal permille value
    Permillemax=$(echo "
$Permilleleft
$Permilleright
$Permilletop
$Permillebottom
" | sort -n | tail -n1)
    [ "$Permillemax" = "0" ] && break # Ready
    
    # Remove side with maximal permille of $Trimcolor.
    [ "$Permillemax" = "$Permilleleft" ]   && Left=$((Left+1))
    [ "$Permillemax" = "$Permilleright" ]  && Right=$((Right-1))
    [ "$Permillemax" = "$Permilletop" ]    && Top=$((Top+1))
    [ "$Permillemax" = "$Permillebottom" ] && Bottom=$((Bottom-1))
    
    # Skip check for sides without $Trimcolor in future to save some time
    [ "0" = "$Permilleleft" ]   && Skipleft=yes
    [ "0" = "$Permilleright" ]  && Skipright=yes
    [ "0" = "$Permilletop" ]    && Skiptop=yes
    [ "0" = "$Permillebottom" ] && Skipbottom=yes
    
    # Out-of-range error
    { [ "$Left" -gt "$Right" ] || [ "$Top" -gt "$Bottom" ] ; } && {
#      echo "Error: Failed to find an inner rectangle. Unuseable result: $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top" >&2
      failure "trim_hard(): Failed to find an inner rectangle. Unuseable result: $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top" 
      Return=1
      Left=0
      Top=0
      Right=$((Imagewidth-1))
      Bottom=$((Imageheight-1))
      break
    }
    
    # Debugging: show intermediate results
    Debugmode=yes
    [ "$Debugmode" ] && {
      Loopcount=$((Loopcount+1))
      [ "$Loopcount" = "1" ] && {
        Loopcount=0
        convert $Image -fill none -stroke red -strokewidth 1 -draw "rectangle $Left,$Top $Right,$Bottom" $Image.trim_hard.png
        showimage $Image.trim_hard.png
      }
    }
  done
  
  # Output of result
  #echo "$Left,$Top $Right,$Bottom"                     # "-draw rectangle" geometry
  echo $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top  # "-crop" geometry
  
  # Create image with red rectangle at crop coordinates and show it
  convert $Image -fill none -stroke red -strokewidth 1 -draw "rectangle $Left,$Top $Right,$Bottom" $Image.trim_hard.png
  showimage $Image.trim_hard.png
  
  return ${Return:-0}
}

cropgeometry_interactive() {
  # Interactive dialog to choose a crop geometry
  #   $1   Image to crop.
  #   $2   Cache folder to store files. Clean up yourself.
  #   $3   Preset crop geometry (optional). Default: entire image
  # Result:
  #   return 0 : echo crop geometry WxH+X+Y
  #   return 1 : no output
  # Dependencies:
  #   imagemagick
  #   kaptain (https://github.com/mviereck/kaptain)
  # Uses file descriptors <>&8 and <>&9

  local Kaptaingrammar Kaptainpid Kaptainstdinfifo Kaptainstdoutfifo Kaptainsignal
  local Image Imagewidth Imageheight
  local CropX CropY CropW CropH Cropgeometry
  local Refresh Stepsize Return
  local Cachedir Cropimage
  
  Image="${1:-}"
  Cachedir="${2:-}"
  Cropgeometry="${3:-}"
  
  checkvar -e Image "$Image" || return 1
  checkvar -d Cachedir "$Cachedir" || return 1
  
  Imagewidth=$(convert  -format '%w'  $Image info:)
  Imageheight=$(convert -format '%h'  $Image info:)
  
  Cropimage="$Cachedir/cropgeometry.gui.tif"
  convert "$Image" "$Cropimage"
  
  Stepsize=50
  Refresh="yes"

  grep -q "x" <<< "$Cropgeometry" && grep -q "+" <<< "$Cropgeometry" && {
    CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
    CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
    CropW=$(cut -dx -f1 <<< "$Cropgeometry")
    CropH=$(cut -dx -f2 <<< "$Cropgeometry")
    CropH=$(cut -d+ -f1 <<< "$CropH")
  } || {
    CropX=0
    CropY=0
    CropW=$((Imagewidth-1))
    CropH=$((Imageheight-1))
  }
  
  Kaptaingrammar="$Cachedir/crop.kaptain.grammar"
  Kaptainstdinfifo="$Cachedir/crop.kaptain.stdin"
  Kaptainstdoutfifo="$Cachedir/crop.kaptain.stdout"
  mkfifo   $Kaptainstdinfifo
  mkfifo   $Kaptainstdoutfifo
  exec  8<>$Kaptainstdinfifo
  exec  9<>$Kaptainstdoutfifo
  
  echo "#! /usr/bin/kaptain
start 'Choose crop geometry' -> image arrowline stepsizeline buttonline;
  image -> @icon('$Cropimage');
  arrowline:beside -> arrowposline arrowsizeline;
    arrowposline:beside 'Position:' -> posleft posright postop posbottom;
      posleft       -> @button=' < ';
      posright      -> @button=' > ';
      postop        -> @button=' ^ ';
      posbottom     -> @button=' v ';
    arrowsizeline:beside 'Size:' -> sizeleft sizeright sizetop sizebottom;
      sizeleft      -> @button=' < ';
      sizeright     -> @button=' > ';
      sizetop       -> @button=' ^ ';
      sizebottom    -> @button=' v ';
  stepsizeline:beside 'Step size' -> ss1 ss2 ss5 ss10 ss25 ss50 ss100 ss250;
    ss1           -> @button='1';
    ss2           -> @button='2';
    ss5           -> @button='5';
    ss10          -> @button='10';
    ss25          -> @button='25';
    ss50          -> @button='50';
    ss100         -> @button='100';
    ss250         -> @button='250';
  buttonline:beside -> imagesize geometry ok cancel ;
    imagesize:beside 'Source image size:'  -> @text='${Imagewidth}x${Imageheight}';
    geometry:beside  'Crop geometry:'      -> @string='$Cropgeometry';
    ok                                     -> @button=' OK' ;
    cancel                                 -> @close='Cancel';
" >> $Kaptaingrammar
  kaptain --stdio $Kaptaingrammar <&8 >&9 & Kaptainpid=$!

  while ps -p $Kaptainpid >/dev/null; do
    [ "$Refresh" = "yes" ] && {
      Cropgeometry="${CropW}x${CropH}+$CropX+$CropY"
      convert $Image -fill none -stroke red -strokewidth 1 -draw "rectangle $CropX,$CropY $((CropX+CropW-1)),$((CropY+CropH-1))" "$Cropimage"
      echo "image('$Cropimage')='x'"  >&8
      echo "geometry='$Cropgeometry'" >&8
      Refresh="no"
    }

    read -t1 Kaptainsignal
    
    [ "$Kaptainsignal" ] && {
      Kaptainsignal="${Kaptainsignal%:pressed}"
      case $Kaptainsignal in
        posleft)    CropX=$((CropX-$Stepsize)) ;;
        posright)   CropX=$((CropX+$Stepsize)) ;;
        postop)     CropY=$((CropY-$Stepsize)) ;;
        posbottom)  CropY=$((CropY+$Stepsize)) ;;
        sizeleft)   CropW=$((CropW-$Stepsize)) ;;
        sizeright)  CropW=$((CropW+$Stepsize)) ;;
        sizetop)    CropH=$((CropH-$Stepsize)) ;;
        sizebottom) CropH=$((CropH+$Stepsize)) ;;
        ss*)        Stepsize="$(cut -c3- <<< "$Kaptainsignal")" ;;
        ok)         Return=0; break ;;
      esac
      [ "$CropX" -lt "0" ] && CropX=0
      [ "$CropY" -lt "0" ] && CropY=0
      [ "$CropW" -lt "1" ] && CropW=1
      [ "$CropH" -lt "1" ] && CropH=1
      [ "$CropX" -gt "$Imagewidth" ]  && CropX=$Imagewidth
      [ "$CropY" -gt "$Imageheight" ] && CropY=$Imageheight
      [ "$((CropX+CropW-1))" -gt "$Imagewidth" ]  && CropW=$((Imagewidth-CropX))
      [ "$((CropY+CropH-1))" -gt "$Imageheight" ] && CropH=$((Imageheight-CropY))
      Refresh="yes"
    }
  done <&9
  
  exec 8>&- 9>&-
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
  [ "$Return" = "0" ] && {
    echo "$Cropgeometry"
    return 0
  }
  return 1
}

crop() {
  local $Batchlocal
  local Image Imagelist Cropgeometry Destinationfile
  local Imagewidth Imageheight Newwidth Newheight Shrink
  
  parse_batchoptions "$@" || return 1
  
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagewidth=$($Convert  -format '%w'  "$(head -n1 <<< "$Imagelist")" info:)
  Imageheight=$($Convert -format '%h'  "$(head -n1 <<< "$Imagelist")" info:)

  case $Functionmode in
    even)
      Newwidth=$((Imagewidth/2))
      Newwidth=$((Newwidth*2))
      Newheight=$((Imageheight/2))
      Newheight=$((Newheight*2))
      Cropgeometry="${Newwidth}x${Newheight}+0+0"
    ;;
    shrink) 
      Shrink="$Functionoption"
      Cropgeometry="$((Imagewidth - $((Shrink * 2))))x$((Imageheight - $((Shrink * 2))))+$Shrink+$Shrink"
    ;;
    geometry)
      Cropgeometry="$Functionoption"
    ;;
    interactive) 
      Image="$Cachedir/crop.min.jpg"
      $Convert $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence min "$Image"
      Cropgeometry="$(cropgeometry_interactive "$Image" "$Cachedir" "$Functionoption")"
    ;;
  esac
  
  [ "$Cropgeometry" ] || {
    failure "crop $Functionmode: crop geometry is empty"
    return 1
  }
  
  [ "$Cropgeometry" = "${Imagewidth}x${Imageheight}+0+0" ] && {
    worknote "crop $Functionmode: Images already have desired geometry: $Cropgeometry"
    cp $Imagelist "$Destinationdir" ### FIXME mycp()
    return
  }
  
  echo "# crop geometry: $Cropgeometry" >> "$Historyfile"

  @work "Crop geometry: $Cropgeometry"
  for Image in $Imagelist ; do
    Destinationfile="$Destinationdir/$(basename "$Image")"
    $Convert "$Image" -crop "$Cropgeometry" "$Destinationfile" || return 1
    showimagediff "$Image" "$Destinationfile" "$(basename "$Image")" "$Cropgeometry"
  done
}

whitebalance() {
  local $Batchlocal
  local Image Cropgeometry Imagewidth Imageheight
  local Referencecolor Meancolor Destinationfile Imagelist
  
  parse_batchoptions "$@" || return 1
  
  Functionmode="${Functionmode:-topleft}"
  Referencecolor="${Functionoption:-#AAAA99}"
  
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagewidth=$($Convert  -format '%w'  "$(head -n1 <<< "$Imagelist")" info:)
  Imageheight=$($Convert -format '%h'  "$(head -n1 <<< "$Imagelist")" info:)
  
  case $Functionmode in
    topleft)     Cropgeometry="10x10+5+5" ;;
    topright)    Cropgeometry="10x10+$((Imagewidth-15))+5" ;;
    bottomleft)  Cropgeometry="10x10+5+$((Imageheight-15))" ;;
    bottomright) Cropgeometry="10x10+$((Imagewidth-15))+$((Imageheight-15))" ;;
    interactive) 
      [ -x "$Whitebalance" ] || {
        failure "Need script 'whitebalance' in same folder as wizard"
        return 1
      }
      Image="$Cachedir/whitebalance.min.jpg"
      $Convert $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence min "$Image"
      Cropgeometry="$(cropgeometry_interactive "$Image" "$Cachedir" "50x50+10+10")"
      [ "$Cropgeometry" ] || {
        failure "whitebalance: Got no crop geometry"
        return 1
      }
    ;;
  esac
  
  echo "# whitebalance geometry: $Cropgeometry" >> "$Historyfile"
  for Image in $Imagelist; do
    Meancolor=$(convert $Image -crop $Cropgeometry -filter box -resize 1x1! -format "%[pixel:u]" info:)
    Destinationfile="$Destinationdir/$(basename "$Image")"
    worknote "whitebalance: $Meancolor: $(basename "$Destinationfile")"
    $Whitebalance -c "$Meancolor" -r "$Referencecolor" "$Image" "$Destinationfile" || return 1
    showimagediff "$Image" "$Destinationfile" "$(basename "$Image")" "whitebalance $Functionmode $Functionoption $Cropgeometry" 
  done
}

#### batch

getbatch1() {
  local Command= Line Argument
  for Line in gamma level contrast kuwahara sharpen brightness wizard; do
    Argument="$(askkaptain "$Line")"
    case $Line in
      brightness) Line="-brightness-contrast" ;;
      contrast)   Line="-sigmoidal-contrast" ;;
      sharpen)    Line="-adaptive-sharpen" ;;
      wizard)     Line="" 
                  Argument="$(askkaptain wizardline2)" ;;
      *)          Line="-$Line" ;;
    esac
    case $Argument in
      "") ;;
      auto) Command="$Command -auto$Line" ;;
      *)    Command="$Command $Line $Argument" ;;
    esac
  done
  echo "$Command"
}

runbatch1() {
  cmd -f wizard -o "$(getbatch1)" -t "$Stackdir"
}

runbatch2() {
  local Argument Functionmode Functionoption
  
  sendkaptain "whitebalance?"
  read Argument <&7
  [ "$Argument" ] && {
    sendkaptain "whitebalancemodecombo?"
    read Functionmode <&7
    sendkaptain "whitebalancecombo?"
    read Functionoption <&7
    cmd -f whitebalance -m "$Functionmode" -o "$Functionoption" -t "$Stackdir"
  }
  
  sendkaptain "crop?"
  read Argument <&7
  [ "$Argument" ] && cmd -f crop -o "$Argument" -t "$Stackdir"
  
  sendkaptain "align_ais?"
  read Argument <&7
  [ "$Argument" ] && cmd -f align_ais -t "$Stackdir"
  
  sendkaptain "align_hugin?"
  read Argument <&7
  [ "$Argument" ] && cmd -f align_hugin -t "$Stackdir"
  
  sendkaptain "align_deshake?"
  read Argument <&7
  [ "$Argument" ] && cmd -f align_ffmpeg -m deshake -t "$Stackdir"
  
  sendkaptain "align_vidstab?"
  read Argument <&7
  [ "$Argument" ] && cmd -f align_ffmpeg -m vidstab -o "$Argument" -t "$Stackdir"
}

runbatch3() {
  sendkaptain "compose_magick?"
  read Argument <&7
  [ "$Argument" ] && cmd -f compose-magick -m all -t "$Stackdir"
  
  cmd -f showimage -s "$Stackdir" -g "*magick.max.*"
  
  sendkaptain "fuse?"
  read Argument <&7
  [ "$Argument" ] && cmd -f fuse -m all -t "$Stackdir"
  
  sendkaptain "compose_fuse?"
  read Argument <&7
  [ "$Argument" ] && cmd -f compose-fuse -m all -t "$Stackdir"
  
  cmd -f showimage -s "$Stackdir" -g "*fuse.median.*"

  sendkaptain "sharpen_compose?"
  read Argument <&7
  [ "$Argument" ] && cmd -f sharpencompose -o 3x1 -t "$Stackdir"
  
  cmd -f showimage -s "$Stackdir" -g "*fuse.median.*"
  
  sendkaptain "kuwahara_compose?"
  read Argument <&7
  [ "$Argument" ] && cmd -f kuwaharacompose -o 2.0 -t "$Stackdir"
  
  cmd -f showimage -s "$Stackdir" -g "*fuse.median.*"
}

#### gui

kaptaingrammar() {
  echo '#! /usr/bin/kaptain
start "arduterm fuse" -> frameset;

  frameset -> topframe bottomframe;
    topframe:beside   -> topleftframe toprightframe ;
      topleftframe:framed   -> batchoptionframe ;
      toprightframe:framed  -> previewframe  showresultframe;
    bottomframe     ->  dirframe deleteframe statusframe;
  
  previewframe -> preview previewrefresh;
    preview             -> @icon("");
    previewrefresh      -> @button="Refresh preview";
  
  dirframe:beside -> choosedirbutton choosedir;
    choosedirbutton     -> @button="Choose stackshot directory:" ;
    choosedir           -> @string="'$Wizardhome/test'" ;
    
  deleteframe -> deletedir;
    deletedir:beside "Delete intermediate results" -> deletecache deletemagick deletefuse deletecompose deleteall;
      deletecache       -> @button="Delete cache + backup directories" ;
      deletemagick      -> @button="Delete magick directory" ;
      deletecompose     -> @button="Delete compose directory" ;
      deletefuse        -> @button="Delete fuse directory" ;
      deleteall         -> @button="Delete all";
    
  statusframe -> ardustatusline ardulog;
    ardustatusline:beside "Status of arduterm" -> ardustatus arducommandstatus arducommand;
      ardustatus        -> @text="" ;
      arducommandstatus -> @text="" ;
      arducommand       -> @text="" ;
    ardulog           -> @text="" ;
      
  batchoptionframe:beside            -> batchframeleft batchframeright;
    batchframeleft:framed              -> batchblock1 batchblock2 ;
    batchframeright:framed             -> batchblock3 runbatchframe undoframe;
    
      batchblock1 "batch block 1: prepare stackshot images in magick" -> gammaline levelline contrastline kuwaharaline sharpenline brightnessline wizardline applyallline;
        gammaline:beside                                      -> gamma gammamagick gammacompose gammafuse;
          gammacombo                                            -> @combow("auto","0.2","0.3","0.4","0.5","0.6","0.7","0.8","0.9","1.2","1.5","2.0","3.0","4.0")="auto" ;
          gammamagick                                           -> @button="magick" ;
          gammacompose                                          -> @button="compose" ;
          gammafuse                                             -> @button="fuse" ;
          gamma:beside                "gamma"                   -> gammacombo | "";
        levelline:beside                                      -> level levelmagick levelcompose levelfuse;
          levelcombo                                            -> @combow("auto")="auto" ;
          levelmagick                                           -> @button="magick" ;
          levelcompose                                          -> @button="compose" ;
          levelfuse                                             -> @button="fuse" ;
          level:beside                "level"                   -> levelcombo | "";
        contrastline:beside                                   -> contrast contrastmagick contrastcompose contrastfuse;
          contrastcombo                                         -> @combow("3x50%")="3x50%" ;
          contrastmagick                                        -> @button="magick" ;
          contrastcompose                                       -> @button="compose" ;
          contrastfuse                                          -> @button="fuse" ;
          contrast:beside             "sigmoidal-contrast"      -> contrastcombo | "";
        kuwaharaline:beside                                   -> kuwahara kuwaharamagick kuwaharacompose kuwaharafuse;
          kuwaharacombo                                         -> @combow("0.5","1.0","1.5","2.0","2.5","3.0","4.0","5.0")="0.5" ;
          kuwaharamagick                                        -> @button="magick" ;
          kuwaharacompose                                       -> @button="compose" ;
          kuwaharafuse                                          -> @button="fuse" ;
          kuwahara:beside             "kuwahara"                -> kuwaharacombo | "";
        sharpenline:beside                                    -> sharpen sharpenmagick sharpencompose sharpenfuse;
          sharpencombo                                          -> @combow("3x1","6x2","8x4")="6x2" ;
          sharpenmagick                                         -> @button="magick" ;
          sharpencompose                                        -> @button="compose" ;
          sharpenfuse                                           -> @button="fuse" ;
          sharpen:beside              "adaptive-sharpen"        -> sharpencombo | "";
        brightnessline:beside                                 -> brightness brightnessmagick brightnesscompose brightnessfuse;
          brightnesscombo                                       -> @combow("0x5","0x10","0x15","5x0","5x5","5x10","5x15","10x0","10x5","10x10","15x15","20x20")="10x10" ;
          brightnessmagick                                      -> @button="magick" ;
          brightnesscompose                                     -> @button="compose" ;
          brightnessfuse                                        -> @button="fuse" ;
          brightness:beside           "brightness-contrast"     -> brightnesscombo | ! "";
        wizardline                                           -> wizardline1 wizardline2;
          wizardline1:beside                                   -> wizard wizardmagick wizardcompose wizardfuse;
            wizardmagick                                         -> @button="magick" ;
            wizardcompose                                        -> @button="compose" ;
            wizardfuse                                           -> @button="fuse" ;
            wizard:beside         "convert (free option input):" -> "on" | ! "" ;
          wizardline2                                            -> @string="" ;
        applyallline:beside                                     -> applyall applyallmagick applyallcompose applyallfuse;
          applyallmagick                                          -> @button="magick" ;
          applyallcompose                                         -> @button="compose" ;
          applyallfuse                                            -> @button="fuse" ;
          applyall:beside             "Apply all"                 -> "" ;
          
      batchblock2 "batch block 2: post processing magick" -> whitebalanceline cropline align_aisline align_huginline align_deshakeline align_vidstabline ;
        whitebalanceline:beside                               -> whitebalance whitebalancemodecombo whitebalancecombo whitebalancemagick whitebalancecompose whitebalancefuse;
          whitebalancemodecombo                                 -> @combo("interactive","topleft","topright","bottomleft","bottomright")="topleft" ;
          whitebalancecombo                                     -> @combow("#777777","#888888","#999988","#999999","#AAAA99","#AAAAAA","#BBBBAA","#BBBBBB","#CCCCBB","#CCCCCC","#DDDDCC","#DDDDDD","#EEEEEE","#FFFFFF")="#AAAA99" ;
          whitebalancemagick                                    -> @button="magick" ;
          whitebalancecompose                                   -> @button="compose" ;
          whitebalancefuse                                      -> @button="fuse" ;
          whitebalance:beside         "whitebalance"            ->  "on" | ! "";
        cropline:beside                                       -> crop cropmodecombo cropcombo cropmagick cropcompose cropfuse;
          cropmodecombo                                         -> @combo("interactive","shrink","even","geometry")="interactive" ;
          cropcombo                                             -> @combow("","1","2","5","10","200x200+15+15")="" ;
          cropmagick                                            -> @button="magick" ;
          cropcompose                                           -> @button="compose" ;
          cropfuse                                              -> @button="fuse" ;
          crop:beside                 "crop"                    -> "on" | ! "";
        align_aisline:beside                                  -> align_ais align_aisbutton ;
          align_aisbutton                                       -> @button="magick" ;
          align_ais:beside            "align with ais"          -> "on" | ! "";
        align_huginline:beside                                -> align_hugin align_huginbutton ;
          align_huginbutton                                     -> @button="magick" ;
          align_hugin:beside          "align with hugin"        -> "on" | ! "";
        align_deshakeline:beside                              -> align_deshake align_deshakebutton ;
          align_deshakebutton                                   -> @button="magick" ;
          align_deshake:beside        "align ffmpeg-deshake "   -> "on" | ! "";
        align_vidstabline:beside                              -> align_vidstab align_vidstabcombo align_vidstabbutton ;
          align_vidstabcombo:beside     "Shakiness:"            -> @combo("1","2","3","4","5","6","7","8","9","10")="1" ;
          align_vidstabbutton                                   -> @button="magick" ;
          align_vidstab:beside        "align ffmpeg-vidstab:"   -> align_vidstabcombo | "";
        
      batchblock3 "batch block 3: combine stackshot images" -> compose_magick fuse compose_fuse sharpen_compose kuwahara_compose gammaminus_eval gammaplus_eval;
        compose_magick:beside         "compose magick"          -> @button="run" "on" | "";
        fuse:beside                   "fuse"                    -> @button="run" "on" | "";
        compose_fuse:beside           "compose fuse"            -> @button="run" "on" | "";
        sharpen_compose:beside        "sharpen compose 3x1"     -> @button="run" "on" | "";
        kuwahara_compose:beside       "kuwahara compose 1.0"    -> @button="run" "on" | ! "";
        gammaminus_eval:beside        "gamma eval 0.5"          -> @button="run" "on" | ! "";
        gammaplus_eval:beside         "gamma eval 2.0"          -> @button="run" "on" | ! "";

      runbatchframe "Batch processing" -> runbatch1 runbatch2 runbatch3 runbatchprocessing;
        runbatch1:beside              "batch block 1"           -> "batchblock1" | "" @button="run";
        runbatch2:beside              "batch block 2"           -> "batchblock2" | "" @button="run";
        runbatch3:beside              "batch block 3"           -> "batchblock3" | "" @button="run";
        runbatchprocessing                                      -> @button="Run batch";
        
      undoframe "undo last step" -> undoline ;
        undoline:beside                  -> undo undomagick undocompose undofuse;
          undomagick                       -> @button="magick" ;
          undocompose                      -> @button="compose" ;
          undofuse                         -> @button="fuse" ;
          undo ""                          -> "" ;
          
      showresultframe "Show results" -> showresultline @fill killviewnior;
        showresultline -> showstackshot showmagickline showcompose showfuse showevaluate;
          showstackshot                  -> @button="stackshot";
          showmagickline:beside          -> showmagick showmagickbackup;
            showmagick                     -> @button="magick";
            showmagickbackup               -> @button="backup + magick";
          showcompose                    -> @button="compose";
          showfuse                       -> @button="fuse";
          showevaluate                   -> @button="evaluate";
        killviewnior:beside            -> @fill @action("killall viewnior")="killall viewnior" @fill;
'
}

sendkaptain() {
  # send messages to kaptain over its stdin
  echo "$1" >&6
#  echo "sent to kaptain: $1"
}

askkaptain() {
  # ask kaptain for value of $1
  local Answer
  sendkaptain "${1:-}?"
  read Answer <&7
  echo "$Answer"
}

parse_kaptainsignal() {
  local Kaptainsignal
  local Command Argument Functionmode Functionoption

  Kaptainsignal="${1:-}"
  
  case $Kaptainsignal in
    choosedirbutton)
      Newstackdir="$(kdialog --getexistingdirectory "$Stackdir")"
      [ "$Newstackdir" ] && Stackdir="$Newstackdir" && update_dir
    ;;
    previewrefresh)
      update_dir
    ;;
    delete*) 
      cmd -f $Kaptainsignal -t "$Stackdir"
    ;;
    showstackshot)
      showimage "$Stackdir/stackshot/*"
    ;;
    showmagick)
      showimage "$Stackdir/magick/*"
    ;;
    showcompose)
      showimage "$Stackdir/compose/!(*.median.*|*.min.*|*.max.*|*.mean.*)"
    ;;
    showfuse)
      showimage "$Stackdir/fuse/*"
    ;;
    showevaluate)
      showimage "$Stackdir/compose/*(*.median.*|*.min.*|*.max.*|*.mean.*)"
    ;;
    showmagickbackup)
      cmd -f showcompare -m magick -t "$Stackdir"
    ;;
    
    compose*|fuse)
      cmd -f $(tr _ - <<< $Kaptainsignal) -t $Stackdir
    ;;
    sharpen_compose)
      cmd -f sharpen-compose -o 3x1 -t "$Stackdir"
    ;;
    kuwahara_compose)
      cmd -f kuwahara-compose -o 1.0 -t "$Stackdir"
    ;;
    
    *magick|*compose|*evaluate|*fuse)
      Command="$Kaptainsignal"
      Command="${Command%magick}"
      Command="${Command%compose}"
      Command="${Command%evaluate}"
      Command="${Command%fuse}"
      kaptaingrammar | grep -q "${Command}modecombo" && {
        sendkaptain "${Command}modecombo?"
        read Functionmode <&7
      }
      kaptaingrammar | grep -q "${Command}combo" && {
        sendkaptain "${Command}combo?"
        read Functionoption <&7
      }
      
      case "$Command" in
        applyall) 
          Functionoption="$(getbatch1)"
          Kaptainsignal="wizard${Kaptainsignal#applyall}"
        ;;
        wizard) Functionoption="$(askkaptain wizardline2)" ;;
      esac
      
      cmd -f "$Kaptainsignal" -m "$Functionmode" -o "$Functionoption" -t "$Stackdir"
    ;;
    
    align_aisbutton)
      cmd -f align_ais -t "$Stackdir"
    ;;
    align_huginbutton)
      cmd -f align_hugin -t "$Stackdir"
    ;;
    align_deshakebutton)
      cmd -f align_ffmpeg -m "deshake" -t "$Stackdir"
    ;;
    align_vidstabbutton)
      sendkaptain "align_vidstabcombo?"
      read Functionoption <&7
      cmd -f align_ffmpeg -m "vidstab" -o "$Functionoption" -t "$Stackdir"
    ;;
    
    runbatch1) 
      runbatch1 
      note "Batch 1 is ready."
    ;;
    runbatch2) 
      runbatch2 
      note "Batch 2 is ready."
    ;;
    runbatch3) 
      runbatch3 
      note "Batch 3 is ready."
    ;;
    runbatchprocessing)
      sendkaptain "runbatch1?"
      read Argument <&7
      [ "$Argument" ] && runbatch1
      sendkaptain "runbatch2?"
      read Argument <&7
      [ "$Argument" ] && runbatch2
      sendkaptain "runbatch3?"
      read Argument <&7
      [ "$Argument" ] && runbatch3
      note "Batch all is ready."
    ;;
    *)
      failure "Unknown signal: $Kaptainsignal"
    ;;
  esac
}

update_deletebuttons() {
  [ -d "$Stackdir/magick" ]  && sendkaptain "deletemagick='Delete magick'"   || sendkaptain "deletemagick='-'"
  [ -d "$Stackdir/compose" ] && sendkaptain "deletecompose='Delete compose'" || sendkaptain "deletecompose='-'"
  [ -d "$Stackdir/fuse" ]    && sendkaptain "deletefuse='Delete fuse'"       || sendkaptain "deletefuse='-'"
  { [ -d "$Stackdir/cache" ] || check_dirglob "$Stackdir/*.bak" ;}  && sendkaptain "deletecache='Delete cache + backups'" || sendkaptain "deletecache='-'"
  check_fileglob "$Stackdir/*(*.max.*|*.min.*|*.mean.*|*.median.*"  && sendkaptain "deleteresults='Delete results'"       || sendkaptain "deleteresults='-'"
}

update_preview() {
  local Sourcedir

  Sourcedir="$Stackdir/magick"
  check_fileglob $Sourcedir/* || Sourcedir=""
  
  [ -z "$Sourcedir" ] && {
    Sourcedir="$Stackdir/stackshot"
    check_fileglob $Sourcedir/* || Sourcedir=""
  }
  
  [ -z "$Sourcedir" ] && {
    sendkaptain "preview('')=x"
    return 1
  }  
  
  Previewlist="$(ls -l $Sourcedir/*)"
  [ "$Previewlist" = "$Previewlist_old" ] && return 0
  Previewlist_old="$Previewlist"
  
  sendkaptain "previewrefresh='* busy *'"
  
  convert $(fileglob $Sourcedir/*) -evaluate-sequence max "$Stackdirmaxpreview"
  convert "$Stackdirmaxpreview" -resize 256x256 "$Stackdirmaxpreview"
  
  sendkaptain "preview('$Stackdirmaxpreview')=x"
  sendkaptain "previewrefresh='Refresh preview'"
}

update_dir() {
  update_preview
  update_deletebuttons
  sendkaptain "choosedir='$Stackdir'"
}
#### main

cmd() {
  local $Batchlocal
  local Commandline Return=

  Commandline="$@"
  parse_batchoptions "$@" || return 1
  
  case "$Function" in
    deleteall)   myrm "$Targetdir"/*.bak "$Targetdir/cache" "$Targetdir/magick" "$Targetdir/compose" "$Targetdir/fuse" ; Return=0 ;;
    deletecache) myrm "$Targetdir/cache" "$Targetdir"/*.bak ; Return=0 ;;
    delete*)     myrm "$Targetdir/${Function#delete}" "$Targetdir/${Function#delete}.bak" ; Return=0 ;;
    
    align_hugin)
      batch_function -f align_hugin -t "$Targetdir"
      Return=$?
    ;;
    align_ais)
      batch_function -f align_ais -t "$Targetdir"
      Return=$?
    ;;
    align_ffmpeg)
      batch_function -f align_ffmpeg -m "$Functionmode" -o "$Functionoption" -t "$Targetdir"
      Return=$?
    ;;
    brightness*|contrast*|crop*|gamma*|kuwahara*|level*|prepare*|sharpen*|stretch*|undo*|whitebalance*|wizard*)
      Function="${Function%magick}"
      batch_function -f $Function -m "$Functionmode" -o "$Functionoption" -t "$Targetdir"
      Return=$?
    ;;
    compose-magick)
                             batch_function -f evaluate      -m "${Functionmode:-all}" -t "$Targetdir"
      Return=$?
      [ "$Return" = "0" ] && batch_function -f compose       -m "${Functionmode:-all}" -t "$Targetdir"
      Return=$?
    ;;
    compose-fuse)
                             batch_function -f evaluate-fuse -m "${Functionmode:-all}" -t "$Targetdir"
      Return=$?
      [ "$Return" = "0" ] && batch_function -f compose-fuse  -m "${Functionmode:-all}" -t "$Targetdir"
      Return=$?
    ;;
    compose)
                             batch_function -f evaluate      -m "${Functionmode:-all}" -t "$Targetdir"
      Return=$?
      [ "$Return" = "0" ] && batch_function -f compose       -m "${Functionmode:-all}" -t "$Targetdir"
      Return=$?
      [ "$Return" = "0" ] && batch_function -f evaluate-fuse -m "${Functionmode:-all}" -t "$Targetdir"
      Return=$?
      [ "$Return" = "0" ] && batch_function -f compose-fuse  -m "${Functionmode:-all}" -t "$Targetdir"
      Return=$?
    ;;
    fuse) 
      batch_function -f fuse -m "${Functionmode:-all}" -t "$Targetdir"
      Return=$?
    ;;
    showimage)
      showimage "$Sourcedir/$Sourcefileglob"
    ;;
  esac
  update_dir
  [ "$Return" = "0" ] && echo "$Commandline" >> "$Historyfile"  ### FIXME remove -t
}

declare_variables() {
  Wizardhome="/home/lauscher/Bilder/arduterm"

  Cachefolder=/tmp/fusegui$(mcookie)
  
  Batchlocal="Targetdir Sourcedir Sourcefileglob Destinationdir Destinationfile Cachedir Function Functionmode Functionoption"
  Convert="convert -quality 100%"

  Wizardlogfile=$Cachefolder/wizard.log
  Wizardlogfifo=$Cachefolder/wizard.log.fifo
  
  Wizardmessagefifo=$Cachefolder/wizard.message.fifo
  Wizardmessagefile=$Cachefolder/wizard.message.log
    
  Kaptaingrammar=$Cachefolder/kaptain.grammar
  Kaptainstdinfifo=$Cachefolder/kaptain.stdin 
  Kaptainstdoutfifo=$Cachefolder/kaptain.stdout
  
  Storeinfofile=$Cachefolder/store.info
  Storepidfile=$Cachefolder/store.pid
  
  Stackdirmaxpreview="$Cachefolder/preview.tif"
  
  Historyfile=""
  
  Xmeasure="$(dirname $0)/xmeasure"
  Whitebalance="$(dirname $0)/whitebalance"
}

create_cachefiles() {
  mkdir -p $Cachefolder
  
  mkfifo   $Kaptainstdinfifo
  exec  6<>$Kaptainstdinfifo
  mkfifo   $Kaptainstdoutfifo
  exec  7<>$Kaptainstdoutfifo

  mkfifo   $Wizardlogfifo
  
  mkfifo   $Wizardmessagefifo
  exec  4<>$Wizardmessagefifo
  :>       $Wizardmessagefile
  
  :>       $Storeinfofile
}

finish() {
  trap - EXIT
  while read Pid; do
    kill $Pid
  done <$Storepidfile
  rm -R $Cachefolder
}

main() {
  trap finish EXIT
  
  # init
  declare_variables
  create_cachefiles
  
  # start kaptain
  kaptaingrammar > $Kaptaingrammar
  #nl -ba $Kaptaingrammar
  kaptain --stdio $Kaptaingrammar <&6 >&7 & Kaptainpid=$!
  echo $Kaptainpid >> $Storepidfile
  
  showlog &
  echo $! >> $Storepidfile
  showmessages &
  echo $! >> $Storepidfile
  
  exec 3>&1
  exec 1>$Wizardlogfifo 2>&1

  # watch signals of kaptain
  while ps -p $Kaptainpid >/dev/null; do
    read -t1 Kaptainsignal
    [ "$Kaptainsignal" ] && {
      echo "Signal from kaptain: $Kaptainsignal"
      grep -q ":pressed" <<< "$Kaptainsignal" && {
        sendkaptain "choosedir?"
        read Stackdir <&7
        [ "$Stackdir" != "$Oldstackdir" ] && update_dir
        Oldstackdir="$Stackdir"
        Historyfile="$Stackdir/wizard.history"
        [ -d "$Stackdir/stackshot" ] || {
          echo "WARNING: Invalid Directory: $Stackdir
  Must contain a subfolder 'stackshot' that contains the source images."
          Stackdir=""
          Historyfile=""
        }
      }
      Kaptainsignal="${Kaptainsignal%:pressed}"
    }
    [ "$Kaptainsignal" ] && [ "$Stackdir" ] && parse_kaptainsignal "$Kaptainsignal"
  done <&7
}

main "$@"
finish

#########

cropgeometry_interactiveXXX() {
  local Image Imagewidth Imageheight
  local Geometry Windowid Xwininfo Displaypid
  local WinX  WinY  WinW  WinH
  local CropX CropY CropW CropH
  
  Image="${1:-}"
  Imagewidth=$(convert  -format '%w'  $Image info:)
  Imageheight=$(convert -format '%h'  $Image info:)

  [ -x "$Xmeasure" ] || {
    failure "cropgeometry_interactive(): Need program 'xmeasure' in same folder as wizard"
    return 1
  }
  
  display -title "Choose crop area of $(basename "$Image")" "$Image" & Displaypid=$!
  Geometry="$($Xmeasure)"
  
  Windowid=$(xdotool search "Choose crop area")
  Xwininfo="$(xwininfo -id "$Windowid" -stats)"
  WinX="$(( $(grep "Absolute upper-left X" <<< "$Xwininfo" | cut -d: -f2)  ))"
  WinY="$(( $(grep "Absolute upper-left Y" <<< "$Xwininfo" | cut -d: -f2)  ))"
  WinW="$(grep "geometry" <<< "$Xwininfo" | cut -dx -f1 | rev | cut -d' ' -f1 | rev)"
  WinH="$(grep "geometry" <<< "$Xwininfo" | cut -dx -f2 | cut -d+ -f1 | cut -d- -f1)"
  kill $Displaypid
    
  CropX="$(grep X <<< "$Geometry" | cut -d' ' -f2)"
  CropY="$(grep Y <<< "$Geometry" | cut -d' ' -f2)"
  CropW="$(grep W <<< "$Geometry" | cut -d' ' -f2)"
  CropH="$(grep H <<< "$Geometry" | cut -d' ' -f2)"
  CropX=$((CropX - WinX))
  CropY=$((CropY - WinY))
  
  { [ "$CropW" = "0" ] || [ "$CropH" = "0" ] || [ "$CropX" -lt "0" ] || [ "$CropY" -lt "0" ] ; } && return 1
  
  echo "${CropW}x${CropH}+$CropX+$CropY"
  return 0
}

### todo
# sharpen-compose fails
