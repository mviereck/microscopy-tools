#!/bin/bash

note() {
  echo "${Colgreen}Note:${Colnorm} $*" >&2
}
failure() {
  echo "${Colred}FAILURE:${Colnorm} $*" >&2
}

isnum() {                       # check if $1 is a number
  [ "1" = "$(awk -v a="${1:-}" 'BEGIN {print (a == a + 0)}')" ]
}
showimage() {
  note "Show image $@"
  geeqie -t -r file:"${1:-}"
}
milisleep() {
  local Time 
  Time="$(awk "BEGIN { print ${1:-1000} / 1000 }")"
  sleep $Time
}
storeinfo() {
  # store and provide pieces of information
  # replace entry if codeword is already present
  # Store as codeword=string:
  #   $1 codeword=string
  # Dump stored string:
  #   $1 dump
  #   #2 codeword
  # Drop stored string:
  #   $1 drop
  #   #2 codeword
  # Test for codeword: (return 1 if not found)
  #   $1 test
  #   $2 codeword
  #
  # note: sed -i causes file permission issues if called in container in Cygwin, compare ticket #187
  #       chmod 666 for $Sharefolder could probably fix that. (FIXME)
  #
  [ -e "$Storeinfofile" ] || return 1
  case "${1:-}" in
    dump) grep     "^${2:-}="   $Storeinfofile | sed "s/^${2:-}=//" ;;      # dump entry
    drop) sed -i  "/^${2:-}=/d" $Storeinfofile ;;                           # drop entry
    test) grep -q  "^${2:-}="   $Storeinfofile ;;                           # test for entry
    *)                                                                      # store entry
      sed -i "/^$(echo "${1:-}" | cut -d= -f1)=/d"     $Storeinfofile       # drop possible old entry
      echo "${1:-}"                                 >> $Storeinfofile
    ;;
  esac
}

get_latest_file() {
  ## Funktion: Neueste erstellte Datei ermitteln
  # $1 kann Suche auf Dateien DATEI* begrenzen
  ls -p -t $1* 2> /dev/null | grep -v "/" | head -n 1
}
get_last_file() {
  # Find alphanumerically last file beginning with $1 in pwd.
  local Filelist
  Filelist="$(find -mindepth 1 -maxdepth 1 | xargs realpath --relative-base $(pwd) | grep "^${1:-}")"
  Filelist="$(sort -V <<< "$Filelist")"
  tail -n1 <<< "$Filelist"
}
get_free_filenumber(){
  # Provide next free file number to file base name $1. 
  # Provide $1 without _00N.
  # $1 must not contain _
  local Number
  Number="$(get_last_file ${1:-} | rev | cut -d_ -f1 | rev | cut -d. -f1)"
  Number="${Number:-0}"
  Number="$(awk "BEGIN {print \"$Number\" + 1}" )"
  printf "%04d" "$Number"
}

setup_projectdir() {
  local Projecthome Projectname Projectdate
  
  Projecthome="$(storeinfo dump storagebasedir)"
  Projecthome="${Projecthome:-$HOME/ardustack}"
  Projectbasename="$(storeinfo dump projectbasename)"
  Projectbasename="${Projectbasename:-project}"
  Projectdate="$(date +%Y-%m-%d)"

  [ "${1:-}" ] && Projectname="${1:-}.${Projectdate}"
  Projectname="${Projectname:-${Projectbasename}.${Projectdate}}"
  storeinfo "projectname=$Projectname"

  cd "$Projecthome"
  mkdir -p "$Projectname"
  cd "$Projectname"
}

device_init() {
  local Watchdevicepid Device
  ## Funktion: Device initialisieren und Überwachung starten

  # Falls eine Instanz von watch_device() läuft, beenden
  Device="$(storeinfo dump device)"
  Watchdevicepid="$(storeinfo dump pidwatchdevice)"
  ps -p "$Watchdevicepid" >/dev/null 2>&1 && {
    kill $Watchdevicepid
    wait $Watchdevicepid 2>/dev/null
    exec 6<>-
  }

  # Device auf Gültigkeit prüfen
  [ -e "$Device" ] || {
    failure "Device not found: $Device"
    Device="/dev/null"
    failure "Fallback device: $Device"
  }

  # Daten von Device auf fifo umleiten
  note "Beginne Überwachung von $Device"
  exec 6<>$Device
  cat <&6 >>$Devicemessagefifo & Watchdevicepid=$!
  storeinfo "pidwatchdevice=$Watchdevicepid"
    
  # Seriellen Port initialisieren
  stty -F $Device raw ispeed 9600 ospeed 9600 cs8 -hupcl -ignpar -cstopb -echo || {
    failure "Fehler bei Initialisierung von Device $Device"
    return 1
  }
}
device_send() {
  ## Funktion: Daten an Arduino senden  
  # Alle übergebenen Optionen werden an $Deviceadresse gesendet
  note "Send to device: $*"
  echo "$*" >&6
}
device_wait() {
  ## Funktion: Auf ein beliebiges Signal vom Arduino warten
  local Antwort=
  
  read -t ${1:-$Devicetimeout} -r Antwort <&6
  
  [ "$Antwort" ] || {
    failure "Device: TIMEOUT"
    echo "TIMEOUT"
    return 1
  }
  
  note "Arduino meldet: $Antwort"
  echo "$Antwort"
  return 0
}
device_check() {
  # Prüfen, ob Arduino auf Kontrollsignal "c" antwortet
  device_send c
  [ "$(device_wait)" = "TIMEOUT" ] && return 1 && note "Device check failed" || return 0
}

position_store() {
  storeinfo "poscurrent=$Poscurrent"
  storeinfo "pos1=$Pos1"
  storeinfo "pos2=$Pos2"
  storeinfo "stepwidth=$Stepwidth"
  
  sendkaptain "poscurrent='$Poscurrent'"
  sendkaptain "pos1='$Pos1'"
  sendkaptain "pos2='$Pos2'"
  sendkaptain "difference='$((Pos2 - Pos1))'"
  sendkaptain "distance='$(awk 'BEGIN {print 0.048 * '$((Pos2 - Pos1))'}') my'"
  sendkaptain "steps='$(( (Pos2 - Pos1)/Stepwidth ))'"
  sendkaptain "stepmy='$(awk 'BEGIN {print 0.048 * '$Stepwidth'}') my'"
}
position_read() {
  local Newstepwidth
  
  Poscurrent="$(storeinfo dump poscurrent)"
  Pos1="$(storeinfo dump pos1)"
  Pos2="$(storeinfo dump pos2)"
  Stepwidth="$(storeinfo dump stepwidth)"
  
  storeinfo test pidkaptain && {
    Newstepwidth="$(askkaptain stepwidth)"
    isnum "$Newstepwidth" && [ "$Newstepwidth" != "$Stepwidth" ] && {
      Stepwidth="$Newstepwidth"
      storeinfo "stepwidth=$Stepwidth"
      stepcmd stepwidth $Stepwidth
    }
  }
}

stepcmd() {
  local Return Antwort
  position_read
  case ${1:-} in
    go) 
      steplauf "${2:-$Poscurrent}"
    ;;
    stepin)  
      steplauf "$(bc <<< "$Poscurrent + $Stepwidth")" 
    ;;
    stepout) 
      steplauf "$(bc <<< "$Poscurrent - $Stepwidth")" 
    ;;
    setpos0)
      Poscurrent=0
      device_send z
      Antwort="$(device_wait)"
    ;;
    setpos1)
      Pos1=$Poscurrent
    ;;
    setpos2)
      Pos2=$Poscurrent
    ;;
    gopos0)
      steplauf "0" 
    ;;
    gopos1)
      steplauf "$Pos1" 
    ;;
    gopos2)
      steplauf "$Pos2" 
    ;;
    stepwidth)
      Stepwidth="${2:-25}"
      device_send "w,$Stepwidth"
      Antwort="$(device_wait)"
    ;;
  esac
  note "stepcmd $*: current:$Poscurrent pos1:$Pos1 pos2:$Pos2 stepwidth:$Stepwidth"
  Return=$?
  [ "$Antwort" = "TIMEOUT" ] && Return=1
  position_store
  return "${Return:-0}"
}
steplauf() {
  # Zu Position $1 gehen
  # $1   Zielposition (gewolltes $Poscurrent)
  local Richtug= diff= Warten=
  
  diff="$(bc <<< "${1:-} - $Poscurrent")"
  [ "$diff" -eq "0" ] && return 1
  [ "$diff" -gt "0" ] && {
    Richtung="i"
  } || { 
    Richtung="o"
    diff="$(bc <<< "-1 * $diff")"
  }
  
  device_check || return 1

  [ "$diff" = "$Stepwidth" ] || {
    device_send "w,$diff"
    [ "$(device_wait)" = "TIMEOUT" ] && return 1
  }

  Warten="$(bc <<< "18 * $diff /10000 + $Devicetimeout")"

  device_send "$Richtung"
  Antwort="$(device_wait $Warten)"
  [ "$Antwort" = "TIMEOUT" ] && return 1
  
  case $Richtung in
    i)  Poscurrent="$(bc <<< "$Poscurrent + $diff")" ;;
    o)  Poscurrent="$(bc <<< "$Poscurrent - $diff")" ;;
  esac
  
  [ "$diff" = "$Stepwidth" ] || {
    device_send "w,$Stepwidth"
    device_wait >/dev/null
  }
}

stackshot() {
  ## Funktion: Fotoserie schießen, dabei Motor weiterdrehen. Geht von $Pos1 zu $Pos2.
  # -p   Default: Serie aus Preview-Bildern.
  # -c   Serie aus richtigen Fotos / Captures.
  
  local Posmem=
  local Stackshotdelay Anzahl Count= Loopcount=0
  local Fotomodus Ordnername= Glob
  local Mediannumber Medianmode Mediancount
  local Stackshotdir Stackshotbasename Stackshotname Projectname Storagebase
  
  gphoto2_cmd check || return 1
  device_check      || return 1
  
  [ "$1" = "-c" ] && Fotomodus="capture" && shift
  [ "$1" = "-p" ] && Fotomodus="preview" && shift
  Fotomodus="${Fotomodus:-preview}"
  
  Mediannumber="$(storeinfo dump mediannumber)"
  Mediannumber="${Mediannumber:-1}"
  [ "$Mediannumber" = "1" ] && Medianmode="no" || Medianmode="yes"
  
  Stackshotdelay="$(storeinfo dump stackshotdelay)"
  Stackshotdelay="${Stackshotdelay:-500}"
  
  Storagebasedir="$(storeinfo dump storagebasedir)"
  Storagebasedir="${Storagebasedir:-$HOME/ardustack}"
  
  Projectname="$(storeinfo dump projectname)"
  Projectname="${Projectname:-project_unknown}"
  
  Stackshotbasename="$(storeinfo dump stackshotbasename)"
  Stackshotbasename="${Stackshotname:-st}" ### FIXME declare in GUI
  
  cd "$Storagebasedir/$Projectname"
  Stackshotname="$Stackshotbasename__$(get_free_filenumber "$Stackshotbasename")"
  
  Stackshotdir="$Storagebasedir/$Projectname/$Stackshotname"
  storeinfo "lateststack=$Stackshotdir"
  mkdir -p "$Stackshotdir/stackshot"
  [ "$Medianmode" = "yes" ] && mkdir -p $Stackshotdir/median.source
  cd $Stackshotdir
  
  # ggf. Positionen für stepin +/- korrigieren
  position_read
  [ "$Pos1" -gt "$Pos2" ] && {
    note "stack: Switching Pos1:$Pos1 and Pos2:$Pos2"
    Posmem=$Pos1
    Pos1=$Pos2
    Pos2=$Posmem
    position_store
  }
    
  # Stackshot
  Anzahl="$(bc <<< "($Pos2 - $Pos1) / $Stepwidth" | cut -d. -f1)"
  note "Shooting stack $Stackshotdir with $Anzahl steps."
  
  # An Startposition gehen
  stepcmd go $Pos1
  position_read  
  [ "$Poscurrent" = "$Pos1" ] || { failure "stack: Error: Missed position $Pos1: $Poscurrent." ; return 1 ; }
  
  gphoto2_cmd mirrorup
  
  while [ "$Poscurrent" -lt "$Pos2" ] ; do
    Loopcount=$((Loopcount +1 ))
    
    for ((Mediancount=1 ; Mediancount<=$Mediannumber ; Mediancount++)); do
      milisleep "$Stackshotdelay"

      case $Fotomodus in
        capture) 
          gphoto2_wrap --capture-image-and-download
        ;;
        preview)
          gphoto2_wrap --capture-preview
          Latestimage="$Stackshotdir/stackshot/preview_$(printf "%04d" $Loopcount).jpg"
          mv -f capture_preview.jpg "$Latestimage"
          storeinfo "latestimage=$Latestimage"
        ;;
      esac
      case $Medianmode in
        yes)
          Mediangroup="$Stackshotdir/median.source/img_$(printf "%04d" $Loopcount)"
          Latestmedian="${Mediangroup}_m$(printf "%02d" $Mediancount).jpg"
          cp $Latestimage $Latestmedian
          note "stack: Image stored as $Latestmedian"
          storeinfo "latestimage=$Latestmedian"
        ;;
        no)
          note "stack: Image stored as $Latestimage"
        ;;
      esac
      showimage "$Latestimage"
    done
    
    [ "$Medianmode" = "yes" ] && {
      note "stack: Aligning captures of step $Loopcount."
      align_image_stack -m --use-given-order -a ${Mediangroup}_align $Mediangroup*.jpg 2>&1 | grep -v "Unable to read EXIF data"
      Latestimage="$Stackshotdir/stackshot/${Fotomodus}_$(printf "%04d" $Loopcount).jpg"
      $Convert ${Mediangroup}_align*.tif -evaluate-sequence median "$Latestimage"
      showimage "$Latestimage"
    }

    # step in
    stepcmd stepin
    position_read
        
    # Fortschrittsanzeige %
    #Count=$((Count + 1))
    #for ((i=1 ; i<=100 ; i++)); do
    #  Prozent="$((100 * $Count / $Anzahl))"
    #  [ "$Prozent" -lt "$i" ] && echo -n "." || echo -n "X" 
    #done
    #echo " $Prozent%"
  done
  
  # Create video from stackshot
  #note "stack: Creating video from stackshot"
  #[ -e "$Stackshotdir/stackshot" ]    && Glob="$Stackshotdir/stackshot/*"
  #[ -e "$Stackshotdir/median.source" ] && Glob="$Stackshotdir/median.source/*"
  #ffmpeg -framerate 5 -pattern_type glob -i "$Glob" -c:v libx264  -pix_fmt yuv420p "$Stackshotdir/stackshotvideo.mp4"
  
  note "stack: Ready: Stackshot $Stackshotname with $((Loopcount * Mediannumber)) images in $Loopcount steps."
  note "stack: Location: $Stackshotdir"
}

gphoto2_wrap() {
  note "gphoto2 $@"
  gphoto2 $@ || {
    failure "gphoto2 failed. Is the camera plugged in and turned on?"
    return 1
  }
  return 0
}
gphoto2_cmd () {
  ## Funktion: Sammlung und Koordination der gphoto2-Aufrufe
  #
  local Command Return=0
 
  Command="${1:-}"
  shift
  case $Command in
    check)
      gphoto2_wrap --list-config >/dev/null 2>&1 || failure "gphoto2 check failed. Is the camera connected and turned on?"
      Return=$?
    ;;    
    set-config-value|scv)                     # Kameraeinstellung setzen (Wert)
      gphoto2_wrap --set-config-value $@
      Return=$? 
      ;;
    set-config-index|sci)                     # Kameraeinstellung setzen (Indexnummer)
      gphoto2_wrap --set-config-index $@
      Return=$? 
      ;;
    capture-image-and-download)               # Bild aufnehmen und herunterladen
      # %C als Suffix läßt gphoto2 Dateiende selbst richtig einsetzen (jpg oder cr2 oder ...)
      Latestimage="$(pwd)/capture_$(get_free_filenumber capture).%C"
      gphoto2_wrap --capture-image-and-download --filename $Latestimage
      Return=$?
      # Dateiname mit tatsächlichem Suffix ermitteln. 
      Latestimage="$(pwd)/$(get_latest_file "capture*.jpg")"
      [ "$Latestimage" ] || Latestimage="$(pwd)/$(get_latest_file "capture*")"
      storeinfo "latestimage=$Latestimage"
      ;;
    capture-preview)                         # Einzelnes Videobild aufnehmen, ohne daß der Spiegel zuklappt
      ## Funktioniert ab gphoto2 Version >= 2.5.9 ##
      gphoto2_cmd mirrorup
      gphoto2_wrap --capture-preview
      Return=$?
      [ "$Return" = "0" ] && {
        Latestimage="$(pwd)/preview_$(get_free_filenumber preview).jpg"
        mv capture_preview.jpg "$Latestimage"
        storeinfo "latestimage=$Latestimage"
      } 
      ;;
    mirrorup)                                 # Viewfinder einschalten = Spiegel hoch
      gphoto2_wrap --set-config-value viewfinder="1"
      Return=$? 
      ;;
    zoom)                                     # Viewfinder-Zoom setzen. Zulässige Werte sind 1, 5, und 10
      gphoto2_wrap --set-config-value eoszoom=$1
      Return=$? 
      ;;
    move-zoom)                                # Position von Viewfinder-Zoom ändern
      case $1 in
        x) ZOOM_XPOS="$[$ZOOM_XPOS+$2]" ;;
        y) ZOOM_YPOS="$[$ZOOM_YPOS+$2]" ;;
      esac
      [ "$ZOOM_XPOS" -lt "0" ] && ZOOM_XPOS="0" 
      [ "$ZOOM_YPOS" -lt "0" ] && ZOOM_YPOS="0" 
      gphoto2_wrap --set-config-value eoszoomposition="$ZOOM_XPOS,$ZOOM_YPOS"
      Return=$? 
      ;;
    *)
      failure "gphoto2_cmd(): invalid command: $Command $@"
      Return=1
      ;;
  esac
  return $Return
}
video() {
  ## Funktion: Videoaufnahme starten oder stoppen, mit Speichern auf Festplatte oder ohne
  # $1  Aufnahmemodus
  local Videodauer Videomode Pidffplay
  local GPHOTO2 FFMPEG FFPLAY
  
  Pidffplay="$(storeinfo dump pidffplay)"
  [ "$Pidffplay" ] && ps -p "$Pidffplay" >/dev/null 2>&1 && {
    kill $Pidffplay
    storeinfo drop pidffplay
    Pidffplay=""
  }
  
  Videodauer="3600s"
  Videomode="${1:-preview}"
  
  GPHOTO2="gphoto2 --capture-movie=$Videodauer --stdout"
  FFMPEG="ffmpeg -loglevel error -i -  -c:v copy -f mpjpeg  - "
  FFPLAY="ffplay -loglevel error -sync ext -window_title ardustack-Video - "

  case $Videomode in
    preview)
      $GPHOTO2 | $FFPLAY & Pidffplay=$!
    ;;
    capture)
      # Dateiname für neues Video
      Latestvideo="$(pwd)/movie_$(get_free_filenumber).mjpg"
      $GPHOTO2 | $FFMPEG | tee $Latestvideo | $FFPLAY & Pidffplay=$!
    ;;
    stop)
      # Videowiedergabe/aufnahme stoppen. 
      # Da das bereits am Anfang dieser Funktion geschieht, 
      # muß weiter nichts getan werden
    ;;
  esac
  
  [ "$Pidffplay" ] && ps -p "$Pidffplay" >/dev/null 2>&1 && storeinfo "pidffplay=$Pidffplay"
 
}

kaptaingrammar() {
  echo "#! /usr/bin/kaptain
start 'ardustack'            -> mainframe;
mainframe:framed               -> fileframe naviframe camerasetframe captureframe videoframe stackshotframe;
  fileframe 'Files'              -> device storagebasedir projectbasename stackshotbasename;
    device:beside            'Device file'            -> @string='/dev/ttyACM1' @button='initialize' ;
    storagebasedir:beside    'Storage base dir:'      -> @string='$HOME/Bilder/ardustack' ;
    projectbasename:beside   'Project base name:'     -> @string='project' ;
    stackshotbasename:beside 'Stackshot base name:'   -> @string='st' ;
  naviframe 'Navigation'         -> stepline pos0line pos1line pos2line positionline poscalcline;
    stepline:beside                -> stepin stepout stepwidth stepmy;
      stepin                         -> @button='Step in';
      stepout                        -> @button='Step out';
      stepwidth:beside 'Step width:' -> @combow('1','5','10','25','50','100','250','500')='50' ;
      stepmy                         -> @text='' ;  
    pos0line:beside                -> setpos0 gopos0 ;
      setpos0                        -> @button='Set current position as position zero' ;
      gopos0                         -> @button='Go to pos0';
    pos1line:beside                -> setpos1 gopos1;
      setpos1                        -> @button='Set current position as start point of stack' ;
      gopos1                         -> @button='Go to pos1' ;
    pos2line:beside                -> setpos2 gopos2 ;
      setpos2                        -> @button='Set current position as end point of stack' ;
      gopos2                         -> @button='Go to pos2' ;
    positionline:beside            -> poscurrent pos1 pos2;
      poscurrent:beside 'Current:'   -> @text='' ;
      pos1:beside       'Pos1:'      -> @text='' ;
      pos2:beside       'Pos2:'      -> @text='' ;
    poscalcline:beside             -> difference distance steps;
      difference:beside 'Difference:'-> @text='' ;
      distance:beside   'Distance:'  -> @text='' ;
      steps:beside      'Steps:'     -> @text='' ;
  camerasetframe 'Camera settings' -> zoom lightline ;
    zoom:beside 'Zoom:'            -> zoom1 zoom5 zoom10 ;
      zoom1                          -> @button='1x' ;
      zoom5                          -> @button='5x' ;
      zoom10                         -> @button='10x' ;
    lightline:beside               -> iso shutter;
      iso:beside 'ISO:'              -> @combo('100','200','400','800','1600')='400' ;
      shutter:beside 'Shutterspeed:' -> @combo('1/10','1/20','1/40','1/80','1/125','1/200','1/320','1/400','1/800')='1/200' ;
  captureframe 'Captures'        -> captureline ;
    captureline:beside             -> capturepreview capturefullres ;
      capturepreview                 -> @button='Capture preview' ;
      capturefullres                 -> @button='Capture full resolution' ;
  videoframe 'Video'             -> videoline;
    videoline:beside               -> videostart videocapture videostop;
    videostart                       -> @button='Start video' ;
    videocapture                     -> @button='Capture video' ;
    videostop                        -> @button='Stop video' ;
  stackshotframe 'Stackshot'     -> stackshotline stackshotmedian stackshotdelay;
    stackshotline:beside           -> stackshotpreview stackshotfullres ;
      stackshotpreview               -> @button='Run preview stackshot' ;
      stackshotfullres               -> @button='Run full resolution stackshot' ;
    stackshotmedian:beside 'Median captures to delete moved objects:' -> @combo('3','4','5','6','7','8','9','10')='5' | ! "";
    stackshotdelay:beside 'Delay between captures (ms):' -> @combo('100','200','300','400','500','750','1000','1500','2000','2500','3000','4000','5000')='500';
"
}
sendkaptain() {
  # send messages to kaptain over its stdin
#  note "Send to kaptain: $1"
  storeinfo test pidkaptain && echo "$1" >&${Kaptainstdin}
}
askkaptain() {
  # ask kaptain for value of $1
  local Answer
  #kaptaingrammar | grep -q "${1:-}" || return 1
  sendkaptain "${1:-}?"
  storeinfo test pidkaptain && read Answer <&${Kaptainstdout}
  [ -z "$Answer" ] && return 1
  echo "$Answer"
  return 0
}
runkaptain() {

  
  kaptaingrammar > $Kaptaingrammar
  #nl -ba $Kaptaingrammar
  
  kaptain --stdio $Kaptaingrammar <&${Kaptainstdin} >&${Kaptainstdout} & Kaptainpid=$!
  storeinfo "pidkaptain=$Kaptainpid"
  parse_kaptainsignal

  # watch signals of kaptain
  while ps -p $Kaptainpid >/dev/null; do
    read -t1 Kaptainsignal <&${Kaptainstdout}
    [ "$Kaptainsignal" ] && {
      note "Signal from kaptain: $Kaptainsignal"
      grep -q ":on"      <<< "$Kaptainsignal" && Kaptainsignal=""
      grep -q ":off"     <<< "$Kaptainsignal" && Kaptainsignal=""
      Kaptainsignal="${Kaptainsignal%:pressed}"
    }
    [ "$Kaptainsignal" ] && parse_kaptainsignal "$Kaptainsignal"
  done
}
parse_kaptainsignal() {
  local Kaptainsignal Argument
  local Projecthome Projectname
  
  Kaptainsignal="${1:-}"
  Argument="$(cut -s -d: -f2 <<< "$Kaptainsignal")"

  position_read

  # Provide project dir if needed, check settings in GUI
  case $Kaptainsignal in
    *capture*|stackshot*)
      storeinfo "storagebasedir=$(askkaptain storagebasedir)"
      storeinfo "projectbasename=$(askkaptain projectbasename)"
      storeinfo "stackshotbasename=$(askkaptain stackshotbasename)"
      storeinfo test projectname || setup_projectdir
      Projecthome="$(storeinfo dump storagebasedir)"
      Projectname="$(storeinfo dump projectname)"
      cd "$Projecthome/$Projectname"
    ;;
  esac

  # Stop video if gphoto2 access
  case "$Kaptainsignal" in       # Laufende Videoaufnahme bei gphoto2 Aufruf unterbrechen, ggf. nach Kommando wieder starten
    iso*|shutter*|capture*|video*|zoom*|stackshot*)
      video stop
    ;;
  esac

  case $Kaptainsignal in
    device*)
      storeinfo "device=$(askkaptain device)"
      device_init
    ;;
    zoom*)
      Argument="${Kaptainsignal#zoom}"
      gphoto2_cmd zoom $Argument
      storeinfo "zoom=$Argument"
    ;;
    iso*)
      gphoto2_cmd set-config-value iso="$Argument"
      storeinfo "iso=$Argument"
    ;;
    shutter*)
      gphoto2_cmd set-config-value shutterspeed="$Argument"
      storeinfo "shutterspeed=$Argument"
    ;;
    
    capturepreview)
      gphoto2_cmd capture-preview
      showimage "$(storeinfo dump latestimage)"
    ;;
    capturefullres)
      gphoto2_cmd capture-image-and-download
      showimage "$(storeinfo dump latestimage)"
    ;;
    
    videostart)
      storeinfo "videomode=preview"
    ;;
    videocapture)
      storeinfo "videomode=capture"
    ;;
    videostop)
      storeinfo drop videomode
    ;;
    
    setpos*|gopos*|stepin|stepout) 
      stepcmd $Kaptainsignal
    ;;
    
    stackshot*)
      storeinfo drop videomode
      setup_projectdir
      Argument="$(askkaptain stackshotmedian)"
      Argument="${Argument:-1}"
      storeinfo "mediannumber=$Argument"
      Argument="$(askkaptain stackshotdelay)"
      storeinfo "stackshotdelay=$Argument"
      case $Kaptainsignal in
        stackshotpreview) stackshot -p ;;
        stackshotfullres) stackshot -c ;;
      esac
    ;;
  esac

  # restart video
  storeinfo test videomode && {
    ps -p "$(storeinfo dump pidffplay)" >/dev/null 2>&1 || video "$(storeinfo dump videomode)"
  }
}

declare_variables() {
  Cachefolder=/tmp/ardustack  
  
  Storeinfofile="$Cachefolder/store.info"
  
  Kaptainpid=""

  Kaptaingrammar=$Cachefolder/kaptain.grammar
  Kaptainstdinfifo=$Cachefolder/kaptain.stdin 
  Kaptainstdoutfifo=$Cachefolder/kaptain.stdout
  
  Latestimage=""
  Latestvideo=""
  
  Devicetimeout=10
  Devicemessagefifo="$Cachefolder/device.fifo"
  
  Poscurrent=0
  Pos1=1000
  Pos2=1100
  Stepwidth=50
  
  # Terminal colors used for messages
  Esc="$(printf '\033')"
  Colblue="${Esc}[35m"
  Colyellow="${Esc}[33m"
  Colgreen="${Esc}[32m"
  Colgreenbg="${Esc}[42m"
  Colred="${Esc}[31m"
  Colredbg="${Esc}[41m"
  Coluline="${Esc}[4m"
  Colnorm="${Esc}[0m"
}
setup_cache() {
  mkdir $Cachefolder
  :> $Storeinfofile
  mkfifo $Devicemessagefifo
  
  
  mkfifo   $Kaptainstdinfifo
  exec  {Kaptainstdin}<>$Kaptainstdinfifo
  mkfifo   $Kaptainstdoutfifo
  exec  {Kaptainstdout}<>$Kaptainstdoutfifo
}
finish() {
  local Line Pid
  
  # kill stored pids
  while read Line; do
    grep -q "^pid" <<< "$Line" && {
      Pid="$(cut -d= -f2 <<< "$Line")"
      ps -p "$Pid" >/dev/null 2>&1 && kill $Pid
      wait $Pid 2>/dev/null
    }
  done < "$Storeinfofile"
  
  # remove cache
  rm -R $Cachefolder
}
main() {
  trap finish EXIT 
  
  # Dependencies:
  # bc
  # gphoto2
  # ffmpeg
  
  declare_variables
  setup_cache
  
  storeinfo "storagebasedir=$HOME/Bilder/ardustack"
  sendkaptain "storagebasedir='$(storeinfo dump storagebasedir)'"
  
  storeinfo "device=/dev/ttyACM0"
  device_init
  position_store
  stepcmd setpos0
  
  storeinfo "iso=400"
  storeinfo "shutterspeed=1/200"
  storeinfo "zoom=1"
  
  runkaptain
}

main "$@"
