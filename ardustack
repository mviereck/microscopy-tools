#!/bin/bash
#
# ardustack - Generate stackshots with arduino + steppermotor + camera
#
# License: MIT
#
# Dependencies:
#  - ffmpeg
#  - geeqie
#  - gphoto2
#  - kaptain  https://github.com/mviereck/kaptain

note() {
  echo "${Colgreen}Note:${Colnorm} $*" >&2
}
failure() {
  echo "${Colred}FAILURE:${Colnorm} $*" >&2
  statusmessage "$*"
  storeinfo "error=yes"
  showpercent error
}
statusmessage() {
  sendkaptain "status='$(cut -c1-35 <<< "$*")'"
}

isnum() {                       # check if $1 is a number
  [ "1" = "$(awk -v a="${1:-}" 'BEGIN {print (a == a + 0)}')" ]
}
showimage() {
  [ -f "${1:-}" ] || {
    failure "Image not found: ${1:-}"
    return 1
  }
  geeqie -t -r File:"${1:-}"
}
milisleep() {
  local Time 
  Time="$(awk "BEGIN { print ${1:-1000} / 1000 }")"
  sleep $Time
}
storeinfo() {
  # store and provide pieces of information in file $Storeinfofile
  # replace entry if codeword is already present
  # Store as codeword=string:
  #   $1 codeword=string
  # Dump stored string:
  #   $1 dump
  #   #2 codeword
  # Drop stored string:
  #   $1 drop
  #   #2 codeword
  # Test for codeword: (return 1 if not found)
  #   $1 test
  #   $2 codeword
  #
  local Lockfile Return
  
  #note "$*"
  
  #[ -e "$Storeinfofile" ] || return 1
  
  Lockfile="$Storeinfofile.lock"
  [ -e "$Lockfile" ] && {
    while [ -e "$Lockfile" ] ; do
      sleep 0.1
    done
  }
  case "${1:-}" in
    dump|test) ;;
    *) touch "$Storeinfofile.lock" ;;
  esac
  
  case "${1:-}" in
    dump) grep     "^${2:-}="   $Storeinfofile | sed "s/^${2:-}=//" || Return=1 ;;  # dump entry
    drop) sed -i  "/^${2:-}=/d" $Storeinfofile ;;                                   # drop entry
    test) grep -q  "^${2:-}="   $Storeinfofile                      || Return=1 ;;  # test for entry
    *)                                                                              # store entry
      sed -i "/^$(echo "${1:-}" | cut -d= -f1 | head -n1)=/d"  $Storeinfofile       # drop possible old entry
      echo "${1:-}"                                         >> $Storeinfofile
    ;;
  esac
  
  case "${1:-}" in
    dump|test) ;;
    *) rm "$Storeinfofile.lock" ;;
  esac
  
  return ${Return:-0}
}

get_latest_file() {
  ## Funktion: Neueste erstellte Datei ermitteln
  # $1 kann Suche auf Dateien DATEI* begrenzen
  ls -p -t $1* 2> /dev/null | grep -v "/" | head -n 1
}
get_last_file() {
  # Find alphanumerically last file beginning with $1 in pwd.
  local Filelist
  Filelist="$(find -mindepth 1 -maxdepth 1 | xargs realpath --relative-base $(pwd) | grep "^${1:-}")"
  Filelist="$(sort -V <<< "$Filelist")"
  tail -n1 <<< "$Filelist"
}
get_free_filenumber(){
  # Provide next free file number to file base name $1. 
  # Provide $1 without _00N.
  # $1 must not contain _
  local Number
  Number="$(get_last_file ${1:-} | rev | cut -d_ -f1 | rev | cut -d. -f1)"
  Number="${Number:-0}"
  Number="$(awk "BEGIN {print \"$Number\" + 1}" )"
  printf "%04d" "$Number"
}

setup_projectdir() {
  local Projecthome Projectname Projectdate
  
  Projecthome="$(storeinfo dump storagebasedir)"
  Projecthome="${Projecthome:-$HOME/ardustack}"
  Projectbasename="$(storeinfo dump projectbasename)"
  Projectbasename="${Projectbasename:-project}"
  Projectdate="$(date +%Y-%m-%d)"

  [ "${1:-}" ] && Projectname="${1:-}.${Projectdate}"
  Projectname="${Projectname:-${Projectbasename}.${Projectdate}}"
  storeinfo "projectname=$Projectname"

  cd "$Projecthome"
  mkdir -p "$Projectname"
  cd "$Projectname"
}

device_init() {
  # Init Device and start watching background process
  
  local Device Watchdevicepid i Return

  Device="$(storeinfo dump device)"
  
  # Stop a running watching instance
  Watchdevicepid="$(storeinfo dump pidwatchdevice)"
  ps -p "$Watchdevicepid" >/dev/null 2>&1 && {
    kill $Watchdevicepid
    wait $Watchdevicepid 2>/dev/null
    exec 6<>-
  }

  # Device auf Gültigkeit prüfen
  [ -e "$Device" ] || {
    failure "Device not found: $Device"
    Device="$Devicefallback"
    failure "Fallback device: $Device"
  }

  # Daten von Device auf fifo umleiten
  note "Beginning to watch device: $Device"
  exec 6<>$Device
  cat <&6 >>$Devicemessagefifo & Watchdevicepid=$!
  storeinfo "pidwatchdevice=$Watchdevicepid"
    
  # Seriellen Port initialisieren
  stty -F $Device raw ispeed 9600 ospeed 9600 cs8 -hupcl -ignpar -cstopb -echo || {
    failure "Failed to initialize device $Device"
    return 1
  }
  
  sleep $Devicetimeout
  for ((i=1;i<=10;i++)); do
    device_check && break || Return=1
  done
  
  [ "$Return" = "1" ] && failure "Initialized device $Device does not respond to signal $Ardu_check"
  
  return ${Return:-0}
}
device_send() {
  ## Funktion: Daten an Arduino senden  
  # Alle übergebenen Optionen werden an $Deviceadresse gesendet
  note "Send to device: $*"
  echo "$*" >&6
}
device_wait() {
  ## Funktion: Auf ein beliebiges Signal vom Arduino warten
  local Answer=
  
  read -t ${1:-$Devicetimeout} -r Answer <&6
  
  [ "$Answer" ] || {
    failure "Device $(storeinfo dump device): TIMEOUT"
    echo "TIMEOUT"
    return 1
  }
  
  note "Device responses: $Answer"
  echo "$Answer"
  return 0
}
device_check() {
  # Prüfen, ob Arduino auf Kontrollsignal "c" antwortet
  device_send "$Ardu_check"
  [ "$(device_wait)" = "TIMEOUT" ] && return 1 && note "Device check failed" || return 0
}

position_store() {
  storeinfo "poscurrent=$Poscurrent"
  storeinfo "pos1=$Pos1"
  storeinfo "pos2=$Pos2"
  storeinfo "stepwidth=$Stepwidth"
  
  sendkaptain "poscurrent='$Poscurrent'"
  sendkaptain "pos1='$Pos1'"
  sendkaptain "pos2='$Pos2'"
  sendkaptain "difference='$(awk "BEGIN {print $Pos2 - $Pos1 }" )'"
  sendkaptain "distance='$(awk   "BEGIN {print $Stepdistance * ($Pos2 - $Pos1) }") $Stepunit'"
  sendkaptain "steps='$(awk      "BEGIN {print ($Pos2 - $Pos1)/$Stepwidth }" )'"
  sendkaptain "stepmy='$(awk     "BEGIN {print $Stepdistance * $Stepwidth}") $Stepunit'"
}
position_read() {
  local Newstepwidth
  
  Poscurrent="$(storeinfo dump poscurrent)"
  Pos1="$(storeinfo dump pos1)"
  Pos2="$(storeinfo dump pos2)"
  Stepwidth="$(storeinfo dump stepwidth)"
  Stepdistance="$(storeinfo dump stepdistance)"
  Stepunit="$(storeinfo dump stepunit)"
  
  #storeinfo test pidkaptain && {
  #  Newstepwidth="$(askkaptain stepwidth)"
  #  isnum "$Newstepwidth" && [ "$Newstepwidth" != "$Stepwidth" ] && {
  #    Stepwidth="$Newstepwidth"
  #    storeinfo "stepwidth=$Stepwidth"
  #    stepcmd stepwidth $Stepwidth
  #  }
  #}
}

stepcmd() {
  local Return Answer
  position_read
  case ${1:-} in
    go) 
      steplauf "${2:-$Poscurrent}"
    ;;
    stepin)  
      #steplauf "$(bc <<< "$Poscurrent + $Stepwidth")" 
      steplauf "$(awk "BEGIN {print $Poscurrent + $Stepwidth }" )" 
    ;;
    stepout) 
      #steplauf "$(bc <<< "$Poscurrent - $Stepwidth")" 
      echo " 1 $Poscurrent"
      steplauf "$(awk "BEGIN {print $Poscurrent - $Stepwidth }" )" 
      echo " 2 $Poscurrent"
    ;;
    setpos0)
      Poscurrent=0
      device_send "$Ardu_setpos0"
      Answer="$(device_wait)"
    ;;
    setpos1)
      Pos1="$Poscurrent"
    ;;
    setpos2)
      Pos2="$Poscurrent"
    ;;
    gopos0)
      steplauf "0" 
    ;;
    gopos1)
      echo " 1 $Poscurrent"
      steplauf "$Pos1" 
      echo " 2 $Poscurrent"
    ;;
    gopos2)
      steplauf "$Pos2" 
    ;;
    stepwidth)
      Stepwidth="${2:-25}"
      device_send "$Ardu_stepwidth,$Stepwidth"
      Answer="$(device_wait)"
    ;;
  esac
  note "stepcmd $*: current:$Poscurrent pos1:$Pos1 pos2:$Pos2 stepwidth:$Stepwidth"
  Return=$?
  [ "$Answer" = "TIMEOUT" ] && Return=1
  position_store
  return "${Return:-0}"
}
steplauf() {
  # Go to position $1
  
  local Direction Distance Timetowait Stepwith_store
  
  device_check || return 1
  
  Stepwidth_store="$Stepwidth"
  # Use Distance from Poscurrent to $1 as temporary Stepwidth
  Distance="$(awk "BEGIN {print ${1:-} - $Poscurrent }" )"
  [ "$Distance" = "0" ] && return 0
  [ "$Distance" -gt "0" ] && {
    Direction="$Ardu_stepin"
  } || { 
    Direction="$Ardu_stepout"
    Distance="$(awk "BEGIN {print -1 * $Distance }" )"
  }

  [ "$Distance" = "$Stepwidth" ] || {
    device_send "$Ardu_stepwidth,$Distance"
    [ "$(device_wait)" = "TIMEOUT" ] && return 1
  }

  #Timetowait="$(bc <<< "18 * $Distance /10000 + $Devicetimeout")"
  Timetowait="$(awk "BEGIN {print 18 * $Distance / 10000 + $Devicetimeout }" )" ### FIXME needs more general solution

  device_send "$Direction"
  Answer="$(device_wait "$Timetowait")"
  [ "$Answer" = "TIMEOUT" ] && return 1
  case $Direction in
    "$Ardu_stepin")  Poscurrent="$(awk "BEGIN {print $Poscurrent + $Distance }" )" ;;
    "$Ardu_stepout") Poscurrent="$(awk "BEGIN {print $Poscurrent - $Distance }" )" ;;
  esac
  [ "$Distance" = "$Stepwidth_store" ] || {
    device_send "$Ardu_stepwidth,$Stepwidth"
    device_wait >/dev/null
  }
}

stackshot() {
  ## Funktion: Fotoserie schießen, dabei Motor weiterdrehen. Geht von $Pos1 zu $Pos2.
  # -p   Default: Serie aus Preview-Bildern.
  # -c   Serie aus richtigen Fotos / Captures.
  
  local Posmem=
  local Stackshotdelay Anzahl Count= Loopcount=0
  local Fotomodus Ordnername= Glob
  local Mediannumber Medianmode Mediancount
  local Stackshotdir Stackshotbasename Stackshotname Projectname Storagebase
  
  gphoto2_cmd check || return 1
  device_check      || return 1
  
  [ "$1" = "-c" ] && Fotomodus="capture" && shift
  [ "$1" = "-p" ] && Fotomodus="preview" && shift
  Fotomodus="${Fotomodus:-preview}"
  
  Mediannumber="$(storeinfo dump mediannumber)"
  Mediannumber="${Mediannumber:-1}"
  [ "$Mediannumber" = "1" ] && Medianmode="no" || Medianmode="yes"
  
  Stackshotdelay="$(storeinfo dump stackshotdelay)"
  Stackshotdelay="${Stackshotdelay:-500}"
  
  Storagebasedir="$(storeinfo dump storagebasedir)"
  Storagebasedir="${Storagebasedir:-$HOME/ardustack}"
  
  Projectname="$(storeinfo dump projectname)"
  Projectname="${Projectname:-project_unknown}"

  Stackshotbasename="$(storeinfo dump stackshotbasename)"
  Stackshotbasename="${Stackshotbasename:-st}" ### FIXME declare in GUI
  
  cd "$Storagebasedir/$Projectname"
  Stackshotname="${Stackshotbasename}_$(get_free_filenumber "$Stackshotbasename")"
  
  Stackshotdir="$Storagebasedir/$Projectname/$Stackshotname"
  storeinfo "lateststack=$Stackshotdir"
  mkdir -p "$Stackshotdir/stackshot"
  [ "$Medianmode" = "yes" ] && mkdir -p $Stackshotdir/median.source
  cd $Stackshotdir

  # ggf. Positionen für stepin +/- korrigieren
  position_read
  [ "$Pos1" -gt "$Pos2" ] && {
    note "stack: Switching Pos1:$Pos1 and Pos2:$Pos2"
    Posmem=$Pos1
    Pos1=$Pos2
    Pos2=$Posmem
    position_store
  }
    
  # Stackshot
  #Anzahl="$(bc <<< "($Pos2 - $Pos1) / $Stepwidth" | cut -d. -f1)"
  Anzahl="$(awk "BEGIN {print ($Pos2 - $Pos1) / $Stepwidth }" | cut -d. -f1)"
  note "Shooting stack $Stackshotdir with $Anzahl steps."
  
  # An Startposition gehen
  stepcmd go $Pos1
  position_read  
  [ "$Poscurrent" = "$Pos1" ] || { failure "stack: Error: Missed position $Pos1: $Poscurrent." ; return 1 ; }
  
  # Auf Start warten
  sleep $(storeinfo dump startdelay)
  
  gphoto2_cmd mirrorup
  
  while [ "$Poscurrent" -lt "$Pos2" ] ; do
    Loopcount=$((Loopcount +1 ))
    storeinfo test cmdbreak && break
    showpercent $Loopcount $Anzahl
    
    for ((Mediancount=1 ; Mediancount<=$Mediannumber ; Mediancount++)); do
      milisleep "$Stackshotdelay"

      case $Fotomodus in
        capture) 
          Filename="$(LC_ALL=C gphoto2_wrap --capture-image-and-download --force-overwrite | grep 'Saving file as')"
          gphoto2_cmd mirrorup
          Filename="$(awk '{print $4}' <<< "$Filename")"
          Latestimage="$Stackshotdir/stackshot/capture_$(printf "%04d" $Loopcount).jpg"
          [ -e "$Filename" ] || {
            failure "Capture failed"
            return 1
          }
          mv "$Filename" "$Latestimage"
        ;;
        preview)
          gphoto2_wrap --capture-preview
          Latestimage="$Stackshotdir/stackshot/preview_$(printf "%04d" $Loopcount).jpg"
          mv -f capture_preview.jpg "$Latestimage"
          storeinfo "latestimage=$Latestimage"
        ;;
      esac
      case $Medianmode in
        yes)
          Mediangroup="$Stackshotdir/median.source/img_$(printf "%04d" $Loopcount)"
          Latestmedian="${Mediangroup}_m$(printf "%02d" $Mediancount).jpg"
          cp $Latestimage $Latestmedian
          note "stack: Image stored as $Latestmedian"
          storeinfo "latestimage=$Latestmedian"
        ;;
        no)
          note "stack: Image stored as $Latestimage"
        ;;
      esac
      showimage "$Latestimage"
    done
    
    [ "$Medianmode" = "yes" ] && {
      note "stack: Aligning captures of step $Loopcount."
      align_image_stack -m --use-given-order -a ${Mediangroup}_align $Mediangroup*.jpg 2>&1 | grep -v "Unable to read EXIF data"
      Latestimage="$Stackshotdir/stackshot/${Fotomodus}_$(printf "%04d" $Loopcount).jpg"
      $Convert ${Mediangroup}_align*.tif -evaluate-sequence median "$Latestimage"
      showimage "$Latestimage"
    }

    # step in
    stepcmd stepin
    position_read
        
    # Fortschrittsanzeige %
    #Count=$((Count + 1))
    #for ((i=1 ; i<=100 ; i++)); do
    #  Prozent="$((100 * $Count / $Anzahl))"
    #  [ "$Prozent" -lt "$i" ] && echo -n "." || echo -n "X" 
    #done
    #echo " $Prozent%"
  done
  
  # Create video from stackshot
  #note "stack: Creating video from stackshot"
  #[ -e "$Stackshotdir/stackshot" ]    && Glob="$Stackshotdir/stackshot/*"
  #[ -e "$Stackshotdir/median.source" ] && Glob="$Stackshotdir/median.source/*"
  #ffmpeg -framerate 5 -pattern_type glob -i "$Glob" -c:v libx264  -pix_fmt yuv420p "$Stackshotdir/stackshotvideo.mp4"
  
  note "stack: Ready: Stackshot $Stackshotname with $((Loopcount * Mediannumber)) images in $Loopcount steps."
  note "stack: Location: $Stackshotdir"
}

#### gphoto2 camera
gphoto2_wrap() {
  local Cameraport
  Cameraport="$(storeinfo dump cameraport)"
  [ "$Cameraport" ] && Cameraport="--port=$Cameraport"
  note "gphoto2 $Cameraport $@"
  gphoto2 $Cameraport $@ || {
    failure "gphoto2 failed with error code $?. Is the camera plugged in and turned on?"
    return 1
  }
  return 0
}
gphoto2_cmd () {
  ## Funktion: Sammlung und Koordination der gphoto2-Aufrufe
  #
  local Command Return=0
 
  Command="${1:-}"
  shift
  case $Command in
    check)
      gphoto2_wrap --list-config >/dev/null 2>&1 || failure "gphoto2 check failed. Is the camera connected and turned on?"
      Return=$?
    ;;    
    set-config-value|scv)                     # Kameraeinstellung setzen (Wert)
      gphoto2_wrap --set-config-value $@
      Return=$? 
      ;;
    set-config-index|sci)                     # Kameraeinstellung setzen (Indexnummer)
      gphoto2_wrap --set-config-index $@
      Return=$? 
      ;;
    capture-image-and-download)               # Bild aufnehmen und herunterladen
      # %C als Suffix läßt gphoto2 Dateiende selbst richtig einsetzen (jpg oder cr2 oder ...)
      Latestimage="$(pwd)/capture_$(get_free_filenumber capture).%C"
      gphoto2_wrap --capture-image-and-download --filename $Latestimage
      Return=$?
      # Dateiname mit tatsächlichem Suffix ermitteln. 
      Latestimage="$(pwd)/$(get_latest_file "capture*.jpg")"
      [ "$Latestimage" ] || Latestimage="$(pwd)/$(get_latest_file "capture*")"
      storeinfo "latestimage=$Latestimage"
      ;;
    capture-preview)                         # Einzelnes Videobild aufnehmen, ohne daß der Spiegel zuklappt
      ## Funktioniert ab gphoto2 Version >= 2.5.9 ##
      gphoto2_cmd mirrorup
      gphoto2_wrap --capture-preview
      Return=$?
      [ "$Return" = "0" ] && {
        Latestimage="$(pwd)/preview_$(get_free_filenumber preview).jpg"
        mv capture_preview.jpg "$Latestimage"
        storeinfo "latestimage=$Latestimage"
      } 
      ;;
    mirrorup)                                 # Viewfinder einschalten = Spiegel hoch
      gphoto2_wrap --set-config-value viewfinder="1"
      Return=$? 
      ;;
    zoom)                                     # Viewfinder-Zoom setzen. Zulässige Werte sind 1, 5, und 10
      gphoto2_wrap --set-config-value eoszoom=$1
      Return=$? 
      ;;
    move-zoom)                                # Position von Viewfinder-Zoom ändern
      case $1 in
        x) ZOOM_XPOS="$[$ZOOM_XPOS+$2]" ;;
        y) ZOOM_YPOS="$[$ZOOM_YPOS+$2]" ;;
      esac
      [ "$ZOOM_XPOS" -lt "0" ] && ZOOM_XPOS="0" 
      [ "$ZOOM_YPOS" -lt "0" ] && ZOOM_YPOS="0" 
      gphoto2_wrap --set-config-value eoszoomposition="$ZOOM_XPOS,$ZOOM_YPOS"
      Return=$? 
      ;;
    reset)
      gphoto2_wrap --reset
      Return=$?
    ;;
    *)
      failure "gphoto2_cmd(): invalid command: $Command $@"
      Return=1
      ;;
  esac
  return $Return
}
video() {
  ## Funktion: Videoaufnahme starten oder stoppen, mit Speichern auf Festplatte oder ohne
  # $1  Aufnahmemodus
  local Videodauer Videomode Pidffplay
  local GPHOTO2 FFMPEG FFPLAY FFPLAY_LOCATION
  local Windowid Windowgeometry Ffplay_x Ffplay_y

  Pidffplay="$(storeinfo dump pidffplay)"
  [ "$Pidffplay" ] && ps -p "$Pidffplay" >/dev/null 2>&1 && {
    # store window position
    Windowid=$(xdotool search --pid "$Pidffplay" | tail -n1)
    Windowgeometry="$(xdotool getwindowgeometry --shell $Windowid)"
    grep -q "X=" <<< "$Windowgeometry" && {
      Ffplay_x="$(grep "^X=" <<< "$Windowgeometry" | cut -d= -f2)"
      Ffplay_y="$(grep "^Y=" <<< "$Windowgeometry" | cut -d= -f2)"
      storeinfo "ffplay_x=$Ffplay_x"
      storeinfo "ffplay_y=$Ffplay_y"
    }
    # kill ffplay
    kill $Pidffplay
    storeinfo drop pidffplay
    Pidffplay=""
  }

  # Restore ffplay position
  storeinfo test ffplay_x && FFPLAY_LOCATION="-left $(storeinfo dump ffplay_x) -top $(storeinfo dump ffplay_y)"
  
  Videodauer="3600s"
  Videomode="${1:-preview}"
  
  GPHOTO2="gphoto2 --capture-movie=$Videodauer --stdout"
  FFMPEG="ffmpeg -loglevel error -i -  -c:v copy -f mpjpeg  - "
  FFPLAY="ffplay -loglevel error -sync ext -window_title ardustack-Video $FFPLAY_LOCATION - "

  case $Videomode in
    preview)
      $GPHOTO2 | $FFPLAY & Pidffplay=$!
    ;;
    capture)
      # Dateiname für neues Video
      Latestvideo="$(pwd)/movie_$(get_free_filenumber).mjpg"
      $GPHOTO2 | $FFMPEG | tee $Latestvideo | $FFPLAY & Pidffplay=$!
    ;;
    stop)
      # Videowiedergabe/aufnahme stoppen. 
      # Da das bereits am Anfang dieser Funktion geschieht, 
      # muß weiter nichts getan werden
    ;;
  esac
  
  [ "$Pidffplay" ] && ps -p "$Pidffplay" >/dev/null 2>&1 && storeinfo "pidffplay=$Pidffplay"
 
}
cameralist() {
  local Camera Cameralist Cameralistkaptain
  Camera="$(storeinfo dump camera)"
  
  Cameralist="$(gphoto2 --auto-detect | tail -n+3)"
  while read Line; do
    Cameralist="$Cameralist
$(echo "$Line" | xargs)"
  done <<< "$Cameralist"
  Cameralist="$(tail -n+2 <<< "$Cameralist")"
  
  [ -z "$Cameralist" ] && failure "No camera detected."
  
  grep -q "$Camera" <<< "$Cameralist" || Camera=""
  [ -z "$Camera" ] && Camera="$(head -n1 <<< "$Cameralist")"
  [ -z "$Camera" ] && Camera="autodetect"
  Cameraport="$(rev <<< "$Camera" | cut -d' ' -f1 | rev)"
  
  Cameralistkaptain="'autodetect'"
  while read Line; do
    Cameralistkaptain="$Cameralistkaptain,'$Line'"
  done <<< "$Cameralist"
  
  sendkaptain "camera($Cameralistkaptain)='$Camera'"
  
  case $Camera in
    autodetect) 
      storeinfo drop camera 
      storeinfo drop cameraport  
    ;;
    *)
      storeinfo "camera=$Camera" 
      storeinfo "cameraport=$Cameraport"
    ;;
  esac
}
camerainit() {
  local Camera Cameraport
  local Configlist Kaptainlist Setting Value
  
  Camera="${1:-}"
  [ -z "$Camera" ] && Camera="$(storeinfo dump camera)"
  Cameraport="$(rev <<< "$Camera" | cut -d' ' -f1 | rev)"
  
  storeinfo "camera=$Camera"
  storeinfo "cameraport=$Cameraport"
  
  gphoto2_cmd reset
  gphoto2_cmd check || return 1
  gphoto2_cmd set-config-index autoexposuremode=3 # mode "Manuell"
  gphoto2_cmd set-config-index imageformat=0      # Large fine JPG. 6=Large fine JPG + RAW
  
  for Setting in iso shutterspeed; do
    note "Checking camera config options for $Setting"
    Configlist="$(gphoto2_wrap --get-config $Setting | grep Choice | awk '{print $3}')"
    Kaptainlist=""
    while read Line; do
      Kaptainlist="$Kaptainlist,'$Line'"
    done <<< "$Configlist"
    Kaptainlist="${Kaptainlist#,}"
    Value="$(storeinfo dump $Setting)"
    [ "$Value" ] && grep -q -x "$Value" <<< "$Configlist" || {
      grep -q -x "1/80" <<< "$Configlist" && Value="1/80"
      grep -q -x "800"  <<< "$Configlist" && Value="800"
      [ -z "$Value" ] && Value="$(head -n1 <<< "$Configlist")"
    }
    storeinfo "$Setting=$Value"
    gphoto2_cmd set-config-value $Setting=$Value
    sendkaptain "$Setting($Kaptainlist)='$Value'"
  done
}

#### Keyboard control
keyboard_stepin() {
  while :; do
    [ -e "$Keyboardstepinfile" ]  && stepcmd stepin  || sleep 0.2
  done
}
keyboard_stepout() {
  while :; do
    [ -e "$Keyboardstepoutfile" ] && stepcmd stepout || sleep 0.2
  done
}
keyboard_watch() {
  local Keyhub Keycode
  while read Line <&${Keyboardfd} ; do
    Keyhub=$(awk '{print $2}' <<< $Line)
    Keycode=$(awk '{print $3}' <<< $Line)
    #note "Keycode: $Keycode ; Keyhub: $Keyhub"
    storeinfo test keyboard_watch && case $Keyhub in
      press)
        case $Keycode in
          # Durchgehender Lauf von Stepin/Stepout
          133) touch "$Keyboardstepinfile"  ;;  # win
          64)  touch "$Keyboardstepoutfile" ;; # L-alt
        esac
      ;;
      release)
        case $Keycode in
          133) rm -f "$Keyboardstepinfile" ;;        # win
          64)  rm -f "$Keyboardstepoutfile" ;;       # L-alt
        esac
      ;;
    esac
  done
}

#### GUI
kaptaingrammar() {
  echo "#! /usr/bin/kaptain
start 'ardustack'                                -> mainframe;
mainframe:framed                                   -> fileframe naviframe camerasetframe captureframe videoframe stackshotframe statusframe;
  fileframe 'Files'                                  -> device storagebasedir projectbasename stackshotbasename;
    device:beside             'Device file'            -> devicecombo devicebutton ;
      devicecombo                                        -> @combow('autodetect')='autodetect' ;
      devicebutton                                       -> @button='initialize' ;
    storagebasedir:beside     'Storage base dir:'      -> @directory='$HOME/Bilder/ardustack' ;
    projectbasename:beside    'Project base name:'     -> @string='project' ;
    stackshotbasename:beside  'Stackshot base name:'   -> @string='st' ;
  naviframe 'Navigation'                             -> stepline pos0line pos1line pos2line positionline poscalcline keyboardline;
    stepline:beside                                    -> stepin stepout stepwidth stepmy;
      stepin                                             -> @button='Step in';
      stepout                                            -> @button='Step out';
      stepwidth:beside        'Step width:'              -> @combo('1','2','5','10','15','20','25','30','40','50','60','75','100','150','200','250','300','400','500','750','1000','1500','2000','3000','5000','7500','10000')='50' ;
      stepmy                                             -> @text='' ;  
    pos0line:beside                                    -> setpos0 gopos0 ;
      setpos0                                            -> @button='Set current position as position zero' ;
      gopos0                                             -> @button='Go to pos0';
    pos1line:beside                                    -> setpos1 gopos1;
      setpos1                                            -> @button='Set current position as start point of stack' ;
      gopos1                                             -> @button='Go to pos1' ;
    pos2line:beside                                    -> setpos2 gopos2 ;
      setpos2                                            -> @button='Set current position as end point of stack' ;
      gopos2                                             -> @button='Go to pos2' ;
    positionline:beside                                -> poscurrent pos1 pos2;
      poscurrent:beside       'Current:'                 -> @text='' ;
      pos1:beside             'Pos1:'                    -> @text='' ;
      pos2:beside             'Pos2:'                    -> @text='' ;
    poscalcline:beside                                 -> difference distance steps;
      difference:beside       'Difference:'              -> @text='' ;
      distance:beside         'Distance:'                -> @text='' ;
      steps:beside            'Steps:'                   -> @text='' ;
    keyboardline:beside       'Watch Keyboard (Super=stepin, L-Alt=stepout)' -> "" | "" ;
  camerasetframe              'Camera settings'      -> cameraline settingline ;
    settingline:beside                                 -> zoom iso shutterspeed ;
      zoom:beside 'Zoom:'                                -> @combo('1','10') ;
      iso:beside 'ISO:'                                  -> @combo('____') ;
      shutterspeed:beside     'Shutterspeed:'            -> @combo('________') ;
    cameraline:beside                                  -> camera ;
      camera:beside                                      -> @combo('autodetect')='autodetect' ;
  captureframe                'Captures'             -> captureline ;
    captureline:beside                                 -> capturepreview capturefullres ;
      capturepreview                                   -> @button='Capture preview' ;
      capturefullres                                   -> @button='Capture full resolution' ;
  videoframe                  'Video'                -> videoline;
    videoline:beside                                   -> videostart videocapture videostop;
      videostart                                         -> @button='Start video' ;
      videocapture                                       -> @button='Capture video' ;
      videostop                                          -> @button='Stop video' ;
  stackshotframe              'Stackshot'            -> stackshotline stackshotmedian stackshotdelayline;
    stackshotline:beside                               -> stackshotpreview stackshotfullres ;
      stackshotpreview                                   -> @button='Run preview stackshot' ;
      stackshotfullres                                   -> @button='Run full resolution stackshot' ;
    stackshotmedian:beside    'Median captures to delete moved objects:' -> @combo('3','4','5','6','7','8','9','10')='5' | ! "";
    stackshotdelayline:beside                            -> stackshotdelay startdelay;
      stackshotdelay:beside   'Delay between captures (ms):'  -> @combo('100','200','300','400','500','750','1000','1500','2000','2500','3000','4000','5000')='500';
      startdelay:beside       'Delay before start:'      -> @combo('1s','10s','30s','1m','5m','10m')='1s';
  statusframe 'Status'                               -> statusline ;
    statusline:beside                                  -> cmdpercent status cmdbreak;
      cmdpercent                                         -> @icon ;
      status                                             -> @text ;
      cmdbreak                                           -> @button='break';
"
}
sendkaptain() {
  # send messages to kaptain over its stdin
#  note "Send to kaptain: $1"
  storeinfo test pidkaptain && echo "$1" >&${Kaptainstdin}
}
askkaptain() {
  # ask kaptain for value of $1
  local Answer
  #kaptaingrammar | grep -q "${1:-}" || return 1
  sendkaptain "${1:-}?"
  storeinfo test pidkaptain && read Answer <&${Kaptainstdout}
  [ -z "$Answer" ] && return 1
  echo "$Answer"
  return 0
}
showpercent() {
  local Percent Part Full Percentimage
  
  Part="${1:-}"
  Full="${2:-1}"
  
  case "$Part" in
    idle)  Percentimage="p_idle.png" ;;
    error) Percentimage="p_error.png" ;;
    busy)  Percentimage="p_busy.png" ;;
    *)
      Percent="$(( 100 * Part / Full ))"
      Percentimage="p_$Percent.png" 
    ;;
  esac
  Percentimage="$Percentcachedir/$Percentimage"

  [ -e "$Percentimage" ] || case "$Part" in
    idle)  convert -size 100x20 xc:transparent -fill black  -pointsize 20 -gravity center -draw "text 0,0 'idle'"   "$Percentimage" ;;
    error) convert -size 100x20 xc:transparent -fill red    -pointsize 20 -gravity center -draw "text 0,0 'ERROR'"  "$Percentimage" ;;
    busy)  convert -size 100x20 xc:transparent -fill green1 -pointsize 20 -gravity center -draw "text 0,0 '* BUSY *'"   "$Percentimage" ;;
    *)     convert -size 100x20 xc:transparent -fill green1 -draw "rectangle 0,0,$((Percent * 1)),20" -fill black -pointsize 20 -gravity center -draw "text 0,0 '${Percent}%'" "$Percentimage" ;;
  esac
  sendkaptain "cmdpercent('$Percentimage')=''"
}
runkaptain() {

  kaptaingrammar > $Kaptaingrammar
  #nl -ba $Kaptaingrammar
  
  kaptain --stdio $Kaptaingrammar <&${Kaptainstdin} >&${Kaptainstdout} & Kaptainpid=$!
  storeinfo "pidkaptain=$Kaptainpid"

  position_store
  sendkaptain "storagebasedir='$(storeinfo dump storagebasedir)'"
  parse_kaptainsignal "camera:autodetect"
  parse_kaptainsignal "device:autodetect"

  position_store
  stepcmd setpos0
  
  # watch signals of kaptain
  while ps -p $Kaptainpid >/dev/null; do
    read -t1 Kaptainsignal <&${Kaptainstdout}
    [ "$Kaptainsignal" ] && {
      note "Signal from kaptain: $Kaptainsignal"
      Kaptainsignal="${Kaptainsignal%:pressed}"
    }
    [ "$Kaptainsignal" ] && parse_kaptainsignal "$Kaptainsignal"
  done
}
parse_kaptainsignal() {
  local Kaptainsignal Argument
  local Projecthome Projectname
  local Device Devicecombo
  
  Kaptainsignal="${1:-}"
  Argument="$(cut -s -d: -f2 <<< "$Kaptainsignal")"

  position_read
  
  statusmessage "$Kaptainsignal"
  showpercent busy
  storeinfo drop cmdbreak

  # Provide project dir if needed, check settings in GUI
  case $Kaptainsignal in
    *capture*|stackshot*)
      storeinfo "storagebasedir=$(askkaptain storagebasedir)"
      storeinfo "projectbasename=$(askkaptain projectbasename)"
      storeinfo "stackshotbasename=$(askkaptain stackshotbasename)"
      storeinfo test projectname || setup_projectdir
      Projecthome="$(storeinfo dump storagebasedir)"
      Projectname="$(storeinfo dump projectname)"
      cd "$Projecthome/$Projectname"
    ;;
  esac

  # Stop video if gphoto2 access
  case "$Kaptainsignal" in       # Laufende Videoaufnahme bei gphoto2 Aufruf unterbrechen, ggf. nach Kommando wieder starten
    iso*|shutter*|capture*|video*|zoom*|stackshot*)
      video stop
    ;;
  esac

  case $Kaptainsignal in
    device*)
      Device="$(askkaptain devicecombo)"
      case $Device in
        autodetect)
          Devicecombo=""
          Devicelist="$(find /dev/ttyACM* 2>/dev/null)"
          for Device in $Devicelist; do
            Devicecombo="$Devicecombo,'$Device'"
          done
          Devicecombo="'autodetect'$Devicecombo"
          Device="$(head -n1 <<< "$Devicelist")"
          sendkaptain "devicecombo($Devicecombo)='${Device:-autodetect}'"
        ;;
      esac
      storeinfo "device=${Device:-NO_DEVICE_FOUND}"
      device_init
      stepcmd setpos0
      stepcmd stepwidth $(storeinfo dump stepwidth)
    ;;
    
    camera:autodetect|camera:)
      cameralist
      camerainit
    ;;
    camera:*)
      camerainit "$Argument"
    ;;
    zoom*)
      gphoto2_cmd zoom $Argument
      storeinfo "zoom=$Argument"
    ;;
    iso*)
      gphoto2_cmd set-config-value iso="$Argument"
      storeinfo "iso=$Argument"
    ;;
    shutterspeed*)
      gphoto2_cmd set-config-value shutterspeed="$Argument"
      storeinfo "shutterspeed=$Argument"
    ;;
    
    capturepreview)
      gphoto2_cmd capture-preview
      showimage "$(storeinfo dump latestimage)"
    ;;
    capturefullres)
      gphoto2_cmd capture-image-and-download
      showimage "$(storeinfo dump latestimage)"
    ;;
    
    videostart)
      storeinfo "videomode=preview"
    ;;
    videocapture)
      storeinfo "videomode=capture"
    ;;
    videostop)
      storeinfo drop videomode
    ;;
    
    setpos*|gopos*|stepin|stepout) 
      stepcmd $Kaptainsignal
    ;;
    stepwidth*)
      stepcmd stepwidth $Argument
    ;;
    keyboardline:on)
      keyboard_stepin  & storeinfo "pidkeyboardstepin=$!"
      keyboard_stepout & storeinfo "pidkeyboardstepout=$!"
      storeinfo "keyboard_watch=yes"
    ;;
    keyboardline:off)
      storeinfo test pidkeyboardstepin  && kill $(storeinfo dump pidkeyboardstepin)
      storeinfo test pidkeyboardstepout && kill $(storeinfo dump pidkeyboardstepout)
      storeinfo drop keyboard_watch
    ;;
    
    stackshot*)
      storeinfo drop videomode
      setup_projectdir
      Argument="$(askkaptain stackshotmedian)"
      Argument="${Argument:-1}"
      storeinfo "mediannumber=$Argument"
      Argument="$(askkaptain stackshotdelay)"
      storeinfo "stackshotdelay=$Argument"
      Argument="$(askkaptain startdelay)"
      storeinfo "startdelay=$Argument"
      case $Kaptainsignal in
        stackshotpreview) stackshot -p & ;;
        stackshotfullres) stackshot -c & ;;
      esac
    ;;
    cmdbreak*)
      storeinfo "cmdbreak=yes"
    ;;
  esac

  # restart video
  storeinfo test videomode && {
    ps -p "$(storeinfo dump pidffplay)" >/dev/null 2>&1 || video "$(storeinfo dump videomode)"
  }
  
  storeinfo test error || {
    statusmessage ""
    showpercent idle
  }
  storeinfo drop error
}

#### main
declare_variables() {
  Cachefolder=/tmp/ardustack
  Localsharefolder="$HOME/.local/share/ardustack"
  Percentcachedir="$Localsharefolder/percent"
  
  Storeinfofile="$Cachefolder/store.info"
  
  Kaptainpid=""
  Kaptaingrammar="$Cachefolder/kaptain.grammar"
  Kaptainstdinfifo="$Cachefolder/kaptain.stdin" 
  Kaptainstdoutfifo="$Cachefolder/kaptain.stdout"
  
  Latestimage=""
  Latestvideo=""
  
  Devicetimeout=2
  Devicefallback="/dev/null"
  Devicemessagefifo="$Cachefolder/device.fifo"
  
  Poscurrent=0
  Pos1=100
  Pos2=300
  Stepwidth=50
  
  Stepdistance="0.048"
  Stepunit="my"
  
  Keyboardid=""
  Keyboardfifo="$Cachefolder/keyboard.fifo"
  Keyboardfd=""
  Keyboardstepinfile="$Cachefolder/keyboard.stepin"
  Keyboardstepoutfile="$Cachefolder/keyboard.stepout"
  
  # Command codes send to Arduino. Each command expects an (arbitrary) answer string+newline from arduino.
  # Answers will be shown and can contain sense making messages.
  Ardu_check="c"
  Ardu_stepin="i"
  Ardu_stepout="o"
  Ardu_stepwidth="w"  # sent with comma+value in form: w,12
  Ardu_setpos0="z"
    
  # Terminal colors used for messages
  Esc="$(printf '\033')"
  Colblue="${Esc}[35m"
  Colyellow="${Esc}[33m"
  Colgreen="${Esc}[32m"
  Colgreenbg="${Esc}[42m"
  Colred="${Esc}[31m"
  Colredbg="${Esc}[41m"
  Coluline="${Esc}[4m"
  Colnorm="${Esc}[0m"
}
setup_cache() {
  mkdir    "$Cachefolder"
  mkdir -p "$Localsharefolder"
  mkdir -p "$Percentcachedir"
  
  
  :> $Storeinfofile
  mkfifo "$Devicemessagefifo"
  
  mkfifo "$Keyboardfifo"
  exec {Keyboardfd}<>"$Keyboardfifo"
  
  mkfifo   "$Kaptainstdinfifo"
  exec  {Kaptainstdin}<>"$Kaptainstdinfifo"
  mkfifo   "$Kaptainstdoutfifo"
  exec  {Kaptainstdout}<>"$Kaptainstdoutfifo"
}
finish() {
  trap - EXIT
  local Line Pid
  
  # kill stored pids
  while read Line; do
    grep -q "^pid" <<< "$Line" && {
      Pid="$(cut -d= -f2 <<< "$Line")"
      ps -p "$Pid" >/dev/null 2>&1 && kill $Pid
      wait $Pid 2>/dev/null
    }
  done < "$Storeinfofile"
  
  exec 6<>-
  
  # remove cache
  rm -R $Cachefolder
  
  exit 0
}
main() {
  trap finish EXIT 
  
  # Dependencies:
  # bc
  # gphoto2
  # ffmpeg
  
  declare_variables
  setup_cache
  
  storeinfo "storagebasedir=$HOME/Bilder/ardustack"
  
  storeinfo "iso=800"
  storeinfo "shutterspeed=1/80"
  storeinfo "zoom=1"
  
  storeinfo "stepdistance=$Stepdistance"
  storeinfo "stepunit=$Stepunit"
  position_store
  
  Keyboardid=$(xinput | grep "AT Translated" | cut -d= -f2 | awk '{print $1}')
  [ "$Keyboardid" ] && {
    xinput test $Keyboardid >>$Keyboardfifo & storeinfo "pidxinput=$!"
    keyboard_watch                          & storeinfo "pidkeyboardwatch=$!"
  } || failure "Cannot watch keyboard. xinput not installed? Invalid keyboard id '$Keyboardid'?"
  
  runkaptain
}
main "$@"
finish

# Todo:
# break button
# replace align_image_stack ?
# percent display
# config dialog
# - distance
# - folders
# - arduino commands
# - wait foranswer yes/no
# - check pos yes/no
