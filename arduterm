#! /bin/bash

#############################################################################
## arduterm
# Arduino Terminal: Skript, um PC und Arduino kommunizieren zu lassen.
#                   Fragt Kommandos von der Tastatur und vom Arduino ab und kann darauf reagieren.
#                   Kann Signale an den Arduino senden und vom Arduino empfangen.
#                   Auch andere Geräte/Devices sind grundsätzlich ansteuerbar.
#                   Signalbasis: Zeichenfolgen, abgeschlossen mit NL/Newline/0xA/Enter.
#                   arduterm kann einfache Skripte mit arduterm-Kommandos ausführen.
#                   Steuerung durch andere Skripte ist durch Eintrag von Kommandos
#                   in die Datei /tmp/arduterm/arduterm.commands.execute möglich.
# Primäres Ziel:    Fotostacking automatisieren mit einem an einen Arduino angeschlossenen 
#                   Schrittmotor/Stackingschlitten und einer per USB angeschlossenen Kamera.
#                   Dabei Aufnahme von Bildern und Videos mit gphoto2
#                   Live-Vorschau von bildern und Videos mit geeqie und ffmpeg
#
# Integration von gphoto2:
#  - Videoaufnahme aus Preview-Bildern
#  - Fotoaufnahme, speichern in Kamera oder auf Festplatte
#  - Preview-Fotoaufnahme ohne Bewegung von Shutter oder Spiegel
#  - Kamera konfigurieren
# Integration von ffmpeg und geeqie
#  - Videovorschau mit ffmpeg und ffplay
#  - Video mit ffmpeg in Einzelbilder zerlegen
#  - Fotovorschau mit Bildbetrachter geeqie
#
# Benötigt gphoto2 in Version 2.5.9 oder höher, um fehlerfrei die Kamera anzusteuern
# Benötigt die Pakete gphoto2, ffmpeg, geeqie und dialog
# Getestet mit Canon EOS 1000D
#
# Steuerung durch externe Programme möglich durch Eintrag von Kommandos
# in die Datei /tmp/arduterm/arduterm.command.execute
#############################################################################

VERSION="v0.4.0-beta"

########################################
#### Programmspezifische Funktionen ####

comment() {
  ## Funktion: Allgemeine Meldungen ausgeben
  local Line
  Line="$(sed "s%$Arduhome%-%g" <<< "$*")"
  echo -e "${GELB}${Line}${WEISS}" >&2
  return 0
}
fehler() {
  ## Funktion: Fehlermeldungen ausgeben
  local Line
  Line="$(sed "s%$Arduhome%-%g" <<< "$*")"
  echo -e "${ROT}${Line}${WEISS}" >&2
  return 0
}
mykill() {
  # Funktion: Prozeß $1 beenden
  local Pid=
  Pid="${1:-}"
  ps -p $Pid >/dev/null 2>&1 && {
    kill $Pid
    wait $Pid 2>/dev/null
  } || return 1
}
window_wait() {
  for ((i=1 ; i<=50 ; i++)); do
    xdotool search --name "${1:-}" >/dev/null && break
    #sleep 0.01
  done
}

###########################
#### Dateioperationen  ####

get_latest_file() {
  ## Funktion: Neueste erstellte Datei ermitteln
  # $1 kann Suche auf Dateien DATEI* begrenzen
  ls -p -t $1* 2> /dev/null | grep -v "/" | head -n 1
}
get_last_file() {
  ## Funktion: Die alphabetisch/numerisch letzte Datei, die mit $1 beginnt, ermitteln und Name ausgeben
  basename -a $(find "$(dirname "$(realpath ${1:-})" )" -mindepth 1 -maxdepth 1) | grep "$(basename ${1:-})" | sort | tail -n1
}
get_free_filenumber(){
  ## Funktion: Zu Dateiname $1 nächste freie Nummer ausgeben
  # $1  Dateiname ohne Nummer und _ohne_ suffix, nach dem Prinzip
  #     DATEINAME_000x.jpg nur DATEINAME übergeben. 
  #     DATEINAME darf keine Unterstriche _ oder Zahlen 0..9 oder Punkte enthalten
  local Nummer
  Nummer=$(get_last_file $1 | rev | cut -d_ -f1 | rev | cut -d. -f1)  
  printf "%04d" $(bc <<<"${Nummer:-"-1"} + 1")
}
check_fileglob() {
  # check whether files exist for glob $1
  local File
  for File in ${1:-}; do
    [ -f "$File" ] && return 0
  done
  return 1
}
check_dirglob() {
  # check whether directories exist for glob $1
  local File
  for File in ${1:-}; do
    [ -d "$File" ] && return 0
  done
  return 1
}
fileglob() {
  # echos files only for glob $1
  # (except those with .pto in their name)
  local File Filelist
  for File in ${1:-}; do
    [ -f "$File" ] && Filelist="$Filelist
$File"
  done
  Filelist=$(sed '/^$/d'    <<< "$Filelist" | sort)
  Filelist=$(grep -v '.pto' <<< "$Filelist")
  [ "$Filelist" ] && echo $Filelist || return 1
}
dirglob() {
  # echos directories only for glob $1
  # (except those with .pto in their name)
  local File Filelist
  for File in ${1:-}; do
    [ -d "$File" ] && Filelist="$Filelist
$File"
  done
  Filelist=$(sed '/^$/d'    <<< "$Filelist" | sort)
  Filelist=$(grep -v '.pto' <<< "$Filelist")
  [ "$Filelist" ] && echo $Filelist || return 1
}
setup_projectdir() {
  [ "${1:-}" ] && Projektname="${1:-}.$(date +%Y-%m-%d)"
  Projektname="${Projektname:-project.$(date +%Y-%m-%d)}"
  cd "$Arduhome"
  mkdir -p "$Projektname"
  cd "$Projektname"
  pwd > $Workdirfile
}
check_doubledir() {
  # splits directory name $1 at dots . and checks if a directory exists in sequence variations of the name

  local IFS Dir Basedir Line Count Combi
  
  Dir="${1:-}"
  Basedir="$(dirname "$Dir")"
  Dir="$(basename "$Dir")"
  
  IFS="."
  Count=-1
  for Line in $Dir; do
     Count=$((Count+1))
  done
  IFS=" "
  
  Dir="{$(tr '.' ',' <<< "$Dir")}"
  for ((i=0 ; i<=Count; i++));do
    Combi="$Combi.$Dir"
  done
  Combi="${Combi#'.'}"
  
  for Line in $(eval echo $Combi); do
    [ -d "$Basedir/$Line" ] && return 0
  done
  return 1
}
check_destinationfile() {
  local Destinationfile Function
  Destinationfile="${1:-}"
  Function="${2:-}"
  [ -e "$Destinationfile" ] && {
    #fehler "$Function: Destination file already exists: $Destinationfile"
    fehler "$Function: Destination file already exists: $(basename "$Destinationfile")"
    return 1
  }
  return 0
}

###########################################
#### Kommunikation mit Device/Arduino  ####

device_init() {
  ## Funktion: Device initialisieren und Überwachung starten

  # Falls eine Instanz von watch_device() läuft, beenden
  ps -p "$Watchdevicepid" >/dev/null 2>&1 && {
    comment "Überwachung von $Deviceadresse wird beendet ..."
    kill $Watchdevicepid
    wait $Watchdevicepid 2>/dev/null
    exec 6<>-
  }

  # Device auf Gültigkeit prüfen
  Deviceadresse="${1:-$Deviceadresse}"
  [ -e "$Deviceadresse" ] || {
    fehler "Fehler: Geräteadresse nicht gefunden: $Deviceadresse"
    Deviceadresse="/dev/null"
    fehler "Setze Geräteadresse auf $Deviceadresse"
  }
  
  # Daten von Device auf fifo umleiten
  comment "Beginne Überwachung von $Deviceadresse"
  exec 6<>$Deviceadresse
  cat <&6 >>$Devicemessagefifo & Watchdevicepid=$!
    
  # Seriellen Port initialisieren
  stty -F $Deviceadresse raw ispeed 9600 ospeed 9600 cs8 -hupcl -ignpar -cstopb -echo || {
    fehler "Fehler bei Initialisierung von Device $Deviceadresse"
    return 1
  }
  sleep 2
}
device_send() {

  ## Funktion: Daten an Arduino senden  
  # Alle übergebenen Optionen werden an $Deviceadresse gesendet
  echo "$*" >&6
}
device_wait() {
  ## Funktion: Auf ein beliebiges Signal vom Arduino warten
  local Antwort=
  
  read -t ${1:-$Devicetimeout} -r Antwort <&7
  
  [ "$Antwort" ] || {
    fehler "Device: TIMEOUT"
    echo "TIMEOUT"
    return 1
  }
  
  comment "Arduino meldet: $Antwort"
  echo "$Antwort"
  return 0
}
device_check() {
  # Prüfen, ob Arduino auf Kontrollsignal "c" antwortet
  device_send c
  [ "$(device_wait)" = "TIMEOUT" ] && return 1 || return 0
}
setpos0() {
  ## Funktion: Positionszähler von Arduino auf 0 setzen.
  local Antwort
  device_send z
  Antwort="$(device_wait)"
}

####################################
#### Video- und Bildfunktionen  ####

videoaufnahme() {
  ## Funktion: Videoaufnahme starten oder stoppen, mit Speichern auf Festplatte oder ohne
  # $1  Aufnahmemodus
  local Videodauer GPHOTO2 FFMPEG FFPLAY
  
  # Videoaufnahme pauschal stoppen
  mykill $Ffplaypid
  Ffplaypid=
  
  Videodauer="3600s"
  Videomode=$1
  
  GPHOTO2="mygphoto2 --capture-movie=$Videodauer --stdout"
  FFMPEG="ffmpeg -loglevel error -i -  -c:v copy -f mpjpeg  - "
  FFPLAY="ffplay -loglevel error -sync ext -window_title arduterm-Video - "

  case $1 in
    preview)
      $GPHOTO2 | $FFPLAY & Ffplaypid=$!
    ;;
    capture-movie)
      # Dateiname für neues Video
      Latestvideo="$(pwd)/movie_$(get_free_filenumber) movie).mjpg"
      $GPHOTO2 > $Latestvideo & Ffplaypid=$!
    ;;
    capture-movie-and-preview)
      # Dateiname für neues Video
      Latestvideo="$(pwd)/movie_$(get_free_filenumber) movie).mjpg"
      $GPHOTO2 | $FFMPEG | tee $Latestvideo | $FFPLAY & Ffplaypid=$!
    ;;
    stop-movie)
      # Videowiedergabe/aufnahme stoppen. 
      # Da das bereits am Anfang dieser Funktion geschieht, 
      # muß weiter nichts getan werden
      Videomode=""
    ;;
  esac
  
  # Fenster arrangieren
  ps -p $Ffplaypid >/dev/null 2>&1 && {
    [ "$Windowmode" = "fullimage" ]   && Windowmode="split"
    [ "$Imageviewerpid" ]             || Windowmode="fullpreview"
    window_wait arduterm-Video
    window_placement
  } &
}
showimage() {
  ## Funktion: Imageviewer starten
  # $1 = Bildname
  
  #mykill $Imageviewerpid
  #sxiv -sf $1 2>/dev/null & Imageviewerpid=$!
  geeqie -t -r file:"${1:-}"
  #display -remote "${1:-}"  & Imageviewerpid=$!
  #[ "${1:-}" ] && ln -f -s "$(realpath ${1:-})" $Latestimagelink
  #pgrep imvr >/dev/null || imvr "$Latestimagelink"  & Imageviewerpid=$!
  
  # Fenster arrangieren
  {  
    [ "$Windowmode" = "fullpreview" ] && Windowmode="split"
    [ "$Ffplaypid" ]                  || Windowmode="fullimage"
    window_wait Geeqie
#    window_wait imv
#    window_wait sxiv
 #
 #window_wait ImageMagick
    window_placement
  } &
}
window_placement() {
  ## Funktion: Fenster von Imageviewer und Videospieler nebeneinander oder maximiert anordnen.
  ## Zweiten Monitor bevorzugen. Guake Terminal oben halten.
  
  local Targetmonitor Screenpos ScreenX ScreenW
  
  # Versuche, zweiten Monitor zu finden.
  Targetmonitor=$(xrandr | grep " connected" | grep -v "+0+0" | cut -d' ' -f1 | head -n1)
  [ "$Targetmonitor" ] || Targetmonitor=$(xrandr | grep " connected" | cut -d' ' -f1 | head -n1)
  
  Screenpos=$(xrandr | grep $Targetmonitor | sed 's/primary//' | awk '{print $3}')
  ScreenX=$(cut -d+ -f2 <<< "$Screenpos")
  ScreenW=$(cut -dx -f1 <<< "$Screenpos")
  ScreenH=$(cut -dx -f2 <<< "$Screenpos" | cut -d+ -f1)

  
  case $Windowmode in
    split)
#      wmctrl -r sxiv -e 0,$ScreenX,0,$(bc <<< "$ScreenW / 2"),-1
#      wmctrl -r ImageMagick: -e 0,$ScreenX,0,$(bc <<< "$ScreenW / 2"),-1
#      wmctrl -r imv -e 0,$ScreenX,0,$(bc <<< "$ScreenW / 2"),-1
      wmctrl -r Geeqie -e 0,$ScreenX,0,$(bc <<< "$ScreenW / 2"),-1
      wmctrl -r arduterm-Video -e 0,$(bc <<< "$ScreenX + $ScreenW / 2"),0,$(bc <<< "$ScreenW / 2"),-1
#      wmctrl -r sxiv -b add,maximized_vert
#      wmctrl -r ImageMagick: -b add,maximized_vert
#      wmctrl -r imv -b add,maximized_vert
      wmctrl -r Geeqie -b add,maximized_vert
      wmctrl -r arduterm-Video -b add,maximized_vert
      wmctrl -a Guake
    ;;
    fullimage)
#      wmctrl -r sxiv -e 0,$ScreenX,0,$ScreenW,-1
#      wmctrl -r imv -e 0,$ScreenX,0,$ScreenW,-1
      wmctrl -r Geeqie -e 0,$ScreenX,0,$ScreenW,-1
      #wmctrl -r ImageMagick: -e 0,$ScreenX,0,$ScreenW,$ScreenH
#      wmctrl -r sxiv -b add,maximized_vert
#      wmctrl -r ImageMagick: -b add,maximized_vert,maximized_horz
#      wmctrl -r imv -b add,maximized_vert,maximized_horz
      wmctrl -r Geeqie -b add,maximized_vert,maximized_horz
#      wmctrl -a sxiv
      #wmctrl -a ImageMagick
      wmctrl -a Guake
    ;;
    fullpreview)
      wmctrl -r arduterm-Video -e 0,$ScreenX,0,$ScreenW,-1
      wmctrl -r arduterm-Video -b add,maximized_vert
      wmctrl -a arduterm-Video
      wmctrl -a Guake
    ;;
  esac
}

########################################
#### gphoto2-spezifische Funktionen ####

mygphoto2() {
  comment "Aufruf von: gphoto2 $@"
  gphoto2 "$@"
  return $?
}
ardu_gphoto2 () {
  ## Funktion: Sammlung und Koordination der gphoto2-Aufrufe
  #
  local Command Return=0
 
  Command=$1
  shift
  case $Command in
    set-config)                               # Konfigurationsdialog
      ardu_gphoto2_set_config_dialog $@
      Return=$?
      ;; 
    get-config)                               # Kameraeinstellung lesen
      gphoto2_get_config $@
      Return=$? 
      ;;
    set-config-value|scv)                     # Kameraeinstellung setzen (Wert)
      mygphoto2 --set-config-value $@
      Return=$? 
      ;;
    set-config-index|sci)                     # Kameraeinstellung setzen (Indexnummer)
      mygphoto2 --set-config-index $@
      Return=$? 
      ;;
    switch-config)                            # Kameraeinstellung: Im Index eines weiter (+) oder zurück (-)
      gphoto2_switch_config $@
      Return=$? 
      ;;
    capture-image)                            # Bild aufnehmen und auf Kamera speichern
      mygphoto2 --capture-image
      Return=$? 
      ;;
    capture-image-and-download)               # Bild aufnehmen und herunterladen
      # %C als Suffix läßt gphoto2 Dateiende selbst richtig einsetzen (jpg oder cr2 oder ...)
      Latestimage="$(pwd)/capture_$(get_free_filenumber capture).%C"
      mygphoto2 --capture-image-and-download --filename $Latestimage
      Return=$?
      # Dateiname mit tatsächlichem Suffix ermitteln. 
      Latestimage="$(pwd)/$(get_latest_file "capture*.jpg")"
      [ "$Latestimage" ] || Latestimage="$(pwd)/$(get_latest_file "capture*")"
      echo "$Latestimage" > $Latestimagefile
      ;;
    capture-preview)                         # Einzelnes Videobild aufnehmen, ohne daß der Spiegel zuklappt
      ## Funktioniert ab gphoto2 Version >= 2.5.9 ##
      mygphoto2 --set-config-value viewfinder="1"
      mygphoto2 --capture-preview
      Return=$?
      [ "$Return" = "0" ] && {
        Latestimage="$(pwd)/preview_$(get_free_filenumber preview).jpg"
        mv capture_preview.jpg $Latestimage
        echo "$Latestimage" > $Latestimagefile
      } 
      ;;
    mirrorup)                                 # Viewfinder einschalten = Spiegel hoch
      mygphoto2 --set-config-value viewfinder="1"
      Return=$? 
      ;;
    zoom)                                     # Viewfinder-Zoom setzen. Zulässige Werte sind 1, 5, und 10
      mygphoto2 --set-config-value eoszoom=$1
      Return=$? 
      ;;
    move-zoom)                                # Position von Viewfinder-Zoom ändern
      case $1 in
        x) ZOOM_XPOS="$[$ZOOM_XPOS+$2]" ;;
        y) ZOOM_YPOS="$[$ZOOM_YPOS+$2]" ;;
      esac
      [ "$ZOOM_XPOS" -lt "0" ] && ZOOM_XPOS="0" 
      [ "$ZOOM_YPOS" -lt "0" ] && ZOOM_YPOS="0" 
      mygphoto2 --set-config-value eoszoomposition="$ZOOM_XPOS,$ZOOM_YPOS"
      Return=$? 
      ;;
    gphoto2) # gphoto2 direkt aufrufen
      mygphoto2 $@
      return=$?
      ;;
    *)
      fehler "ardu_gphoto2() mit ungültigen Parametern aufgerufen: $Command $@"
      Return=1
      ;;
  esac
  return $Return
}
gphoto2_switch_config() {
  ## Funktion=Konfiguration vom Typ RADIO umschalten mit + oder -
  # $1  Zu verändernder Konfigurationswert, Name im Config-Baum
  # $2  + oder - für nächsten oder vorherigen Wert.
  #     +n oder -n für n-weiten Schritt im config-Index
  #     keine Angabe = +1
  #     n ohne '+' oder '-' => +n
  # Bei Überschreiten/Unterschreiten des Index wird auf Anfang/Ende vom Index gesetzt 

  local Choicecount Configlabel Configtype Configcurrent 
  local Dumpline Dumplineleft Dumplineright
  
  # Derzeitige Konfiguration auslesen und speichern
  mygphoto2 --get-config $1 > $Kameradumpfile || {
    fehler "Fehler: Konfiguration der Kamera für $1 konnte nicht gelesen werden"
    return 1
  }
  
  # Konfiguration parsen
  while read Dumpline ; do
    Dumplineleft="$(cut -d: -f1 <<< $Dumpline)"
    Dumplineright="$(cut -d' ' -f2- <<< $Dumpline)"
    case $Dumplineleft in
      Label)   Configlabel="$Dumplineright" ;;
      Type)    Configtype="$Dumplineright" ;;
      Current) Configcurrent="$Dumplineright" ;;
      Readonly) ;;
      END) ;;
      Choice) 
        [ "$(cut -d' ' -f2 <<<"$Dumplineright")" = "$Configcurrent" ] && Configcurrentindex="$(cut -d' ' -f1 <<<"$Dumplineright")" 
        Choicecount=$((Choicecount + 1))
      ;;
      "") ;;
    esac
  done <$Kameradumpfile
  
  case $Configtype in
    RADIO) ;;
    TEXT|DATE|TOGGLE)
      fehler "Fehler: Werte vom Typ $TYPE können nicht mit Kommando 'switch' geändert werden."
      fehler "        Bitte Kommando 'set-config-value $1=WERT' oder 'set-config $1' verwenden."
      return 1
    ;;
  esac
  
  # Indexänderung berechnen
  case $2 in
    "+"|"") Change="+1" ;;
    "-")    Change="-1" ;;
    *)
      case $(cut -c1 <<< $2) in
        "+"|"-") Change="$2" ;;
        *)       Change="+$2" ;;
      esac
    ;;
  esac
  Newindex=$(($Configcurrentindex $Change))
  # wrap index out of range
  [ "$Newindex" -ge "$Choicecount" ] && Newindex=0
  [ "$Newindex" -lt "0" ] && Newindex=$((Choicecount -1))
  
  # Neuen Wert ermitteln
  while read Dumpline; do
    [ "$(cut -d' ' -f2 <<<"$Dumpline")" = "$Newindex" ] && Newcurrent="$(cut -d' ' -f3- <<<"$Dumpline")" && break
  done < <(grep Choice <$Kameradumpfile)
 
  # Neuen Index setzen
  mygphoto2 --set-config-index $1=$Newindex || {
    fehler "Fehler: $1: $Configlabel $Configcurrent konnte nicht geändert werden"
    echo $Configcurrent
    return 1
  }
  echo "$Newcurrent"
  return 0
}
gphoto2_get_config() {
  ## Funktion: Kameraeinstellungen anzeigen
  # Usage: [-a | all] [ENTRY]
  # ohne Optionen      Tabelle aller RADIO/MENU Einstellungen ausgeben
  # ENTRY              Einstellung von ENTRY ausgeben
  # -a, all            Tabelle aller Einstellungen ausgeben
  #                    Mit ENTRY: Dump des ENTRY Eintrags ausgeben
  
  local Tabelle Configentry Configlabel Configtype Configcurrent Dumpline Showall
  
  case "${1:-}" in
    "-a"|"all") Showall="yes" && shift ;;
    *)          Showall="no" ;;
  esac

  case $1 in
    "") # Keine einzelne Einstellung angegeben: Alle RADIO und MENU Einstellungen anzeigen
      mygphoto2 --list-all-config > $Kameradumpfile || {
        fehler "Konnte Kamera nicht auslesen"
        return 1
      }
      
      while read Dumpline ; do
      
        Dumplineleft="$(cut -d: -f1 <<< "$Dumpline")"
        case $Dumplineleft in
          Label|Type|Current) Dumplineright="$(cut -d' ' -f2- <<< "$Dumpline")" ;;
        esac
        
        case $Dumplineleft in
          Label)    Configlabel="$Dumplineright" ;;
          Type)     Configtype="$Dumplineright" ;;
          Current)  Configcurrent="$Dumplineright" ;;
          Readonly) ;;
          Choice)   ;;
          END)
            echo -n "." >&2    # ...
            case $Configtype in
              RADIO|MENU)
                Tabelle="$Tabelle
${Configentry}§${Configlabel}§${Configcurrent}"
                ;;
              *|TOGGLE|TEXT|DATE)
                [ "$Showall" = "yes" ] && Tabelle="$Tabelle
${Configentry}§${Configlabel}§${Configcurrent}"
                ;;
            esac
            ;;
          *) [ "$(cut -c1 <<< "$Dumpline")" = "/" ] && Configentry="$(basename "$Dumpline")" ;;
        esac
        
      done <$Kameradumpfile
      echo ""
  
      # Ergebnis in eine übersichtliche Tabelle verwandeln
      Tabelle="$(sort <<< "$Tabelle")"
      column -t -s"§" <<< "$Tabelle"
      ;;
    
    *) # einzelnes Config als Option angegeben
      mygphoto2 --get-config $1 > $Kameradumpfile && {
        case $Showall in
          yes) cat $Kameradumpfile ;;
          no)  grep "Current" <$Kameradumpfile | cut -d' ' -f2- ;;
        esac
      } || fehler "Fehler: Konfiguration der Kamera konnte nicht gelesen werden"
      ;;
  esac
}
ardu_gphoto2_set_config_dialog() {
  ## Funktion: Dialogboxen zur Konfiguration der Kamera erzeugen
  # $1   ENTRY, der zu konfigurieren ist. Wenn leer, alle Configentrys zur Auswahl anbieten
  local Configentry= Count= Dialogoptions= Line=

  Configentry=$1
  
  # Auswahl aus allen Konfiguartionsmöglichkeiten anbieten
  [ -z "$Configentry" ] && {
    mygphoto2 --list-all-config > $Kameradumpfile || {
      fehler "Konnte Kamerakonfiguration nicht lesen."
      return 1
    }
    
    declare -i Count="0"
    while read -r Line ; do
      Configentry[$Count]="$(basename $Line)"
      Count=$Count+1
    done < <(look "/" $Kameradumpfile)

    declare -i Count="0"
    while read -r Line ; do
      LABEL[$Count]="$(cut -d ' ' -f2- <<<"$Line")"
      Count=$Count+1
    done < <(look "Label:" $Kameradumpfile)
  
    declare -i Count="0"
    while read -r Line ; do
      TYPE[$Count]="$(cut -d ' ' -f2- <<<"$Line")"
      Count=$Count+1
    done < <(look "Type:" $Kameradumpfile)
    
    declare -i Count="0"
    while read -r Line ; do
      CURRENT[$Count]="$(cut -d ' ' -f2- <<< "$Line")"
      Count=$Count+1
    done < <(look "Current:" $Kameradumpfile)
      
    # Optionen sortieren, Type RADIO zuerst
    :> $Kameradumpfile
    while [ "$Count" -ge "1" ] ; do
      Count=$Count-1
      case ${TYPE[$Count]} in
        RADIO|MENU) echo -n "AAAA " >> $Kameradumpfile ;;
        TOGGLE) echo -n "BBBB " >> $Kameradumpfile ;;
        TEXT) echo -n "DDDD " >> $Kameradumpfile ;;
        DATE) echo -n "EEEE " >> $Kameradumpfile ;;
        *) echo -n "CCCC " >> $Kameradumpfile ;;
      esac
      echo "'${Configentry[$Count]}' '${LABEL[$Count]}§${TYPE[$Count]}§${CURRENT[$Count]}'" >> $Kameradumpfile
    done
    while read -r Line ; do
      Dialogoptions="$Dialogoptions $(echo $Line | cut -d ' ' -f2-)"
    done < <(sort -V $Kameradumpfile)
      
    Configentry=$(eval dialog --column-separator '§' --menu '"Kamera Konfiguration auswählen"' 40 120 30 $Dialogoptions 3>&1 1>&2 2>&3 3>&-)
  }

  # Einzelne Konfiguration ändern
  [ -n "$Configentry" ] && {
    comment "Lese Konfiguration von $Configentry von der Kamera, bitte warten ..."
    mygphoto2 --get-config $Configentry > $Kameradumpfile || {
      fehler "Fehler: Konfiguration der Kamera konnte nicht gelesen werden"
      return 1
    }

      INDEX="0"
      Dialogoptions=""
      LABEL=`look "Label:" $Kameradumpfile | cut -d ' ' -f2-`
      TYPE=`look "Type:" $Kameradumpfile | cut -d ' ' -f2-`
      CURRENT=`look "Current:" $Kameradumpfile | cut -d ' ' -f2-`
      while read -r Line ; do
        CHOICE[$INDEX]=`echo -n $Line | cut -d ' ' -f3-`
        Dialogoptions="$Dialogoptions $INDEX '${CHOICE[$INDEX]}'"
        if [ "${CHOICE[$INDEX]}" = "$CURRENT" ] ; then Dialogoptions="$Dialogoptions on"
        else Dialogoptions="$Dialogoptions off" ; fi
        INDEX=$[$INDEX+1]
      done < <(look "Choice:" $Kameradumpfile)

      case $TYPE in
      RADIO|MENU)
        INDEX=$(eval dialog --radiolist '"Auswahl für $Configentry: $LABEL \nDerzeit: $CURRENT"' 40 120 30 $Dialogoptions 3>&1 1>&2 2>&3 3>&-)
        if test "$INDEX" ; then 
          comment "Setze $Configentry=$INDEX => $LABEL ${CHOICE[$INDEX]}"
          mygphoto2 --set-config-index $Configentry=$INDEX
        fi
        ;;
      TEXT)
        CHOICE=$(eval dialog --inputbox '"Neuer Wert für $Configentry: $LABEL \nDerzeit: $CURRENT"' 12 78 '"$CURRENT"' 3>&1 1>&2 2>&3 3>&-)
        if test "$CHOICE" ; then
          comment "Ändere $Configentry: $LABEL von $CURRENT auf $CHOICE"
          mygphoto2 --set-config-value "$Configentry=$CHOICE"
        fi
        ;;
      TOGGLE)
        Dialogoptions="1 Ein off 0 Aus off"
        #eval echo  --radiolist '"Schalter: $Configentry: $LABEL' 15 70 2 $Dialogoptions
        CHOICE=$(eval dialog --radiolist '"Schalter: $Configentry: $LABEL"' 15 70 2 $Dialogoptions 3>&1 1>&2 2>&3 3>&-)
        if test "$CHOICE" ; then 
          comment "Stelle Schalter $Configentry auf $CHOICE"
          mygphoto2 --set-config-value $Configentry=$CHOICE 
        fi
        ;;
      *)
        DIALOGTEXT="Unbekannter Konfigurationstyp $TYPE. Ausgabe von get-config $Configentry:\n"
        while read -r LINE ; do
          DIALOGTEXT=$DIALOGTEXT$LINE"\n"
        done < $Kameradumpfile
        CHOICE=$(eval dialog --inputbox '"$DIALOGTEXT"' 12 78 '"$CURRENT"' 3>&1 1>&2 2>&3 3>&-)
        if test -n "$CHOICE" ; then 
          comment "Setze $Configentry auf $CHOICE"
          mygphoto2 --set-config-value $Configentry=$CHOICE
        fi
        ;;
      esac
  }
}

#########################
#### Stackfunktionen ####

steplauf() {
  # Zu Position $1 gehen
  # $1   Zielposition (gewolltes $Poscurrent)
  local Richtug= diff= Warten=
  
  diff="$(bc <<< "$1 - $Poscurrent")"
  [ "$diff" -eq "0" ] && return 1
  [ "$diff" -gt "0" ] && {
    Richtung="i"
  } || { 
    Richtung="o"
    diff="$(bc <<< "-1 * $diff")"
  }
  
  device_check || return 1

  [ "$diff" = "$Schrittweite" ] || {
    device_send "w,$diff"
    [ "$(device_wait)" = "TIMEOUT" ] && return 1
  }

  Warten="$(bc <<< "18 * $diff /10000 + $Devicetimeout")"

  device_send "$Richtung"
  Antwort="$(device_wait $Warten)"
  [ "$Antwort" = "TIMEOUT" ] && return 1
  
  case $Richtung in
    i)  Poscurrent="$(bc <<< "$Poscurrent + $diff")" ;;
    o)  Poscurrent="$(bc <<< "$Poscurrent - $diff")" ;;
  esac
  
  [ "$diff" = "$Schrittweite" ] || {
    device_send "w,$Schrittweite"
    device_wait >/dev/null
  }
  savepos
}
stackshot() {
  ## Funktion: Fotoserie schießen, dabei Motor weiterdrehen. Geht von $Pos1 zu $Pos2.
  # -p   Default: Serie aus Preview-Bildern.
  # -c   Serie aus richtigen Fotos / Captures.
  
  local Posmem=
  local Stepwait Evalmode Anzahl= Count= Loopcount=0 Evalcount
  local Fotomodus= Ordnername= Glob
  local Shortoptions Longoptions
  
  Shortoptions="cpm::"
  Longoptions=""
  Parsedoptions="$(getopt --options $Shortoptions --longoptions $Longoptions --name "$0" -- "$@")"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    case "${1:-}" in
      -c) Fotomodus="capture" ;;
      -p) Fotomodus="preview" ;;
      -m) 
        Evalstack="yes"
        Evalnumber="${2:-5}"
        shift
      ;;
    esac
    shift
  done
    
  [ "$1" = "-c" ] && Fotomodus="capture" && shift
  [ "$1" = "-p" ] && Fotomodus="preview" && shift
  Fotomodus="${Fotomodus:-preview}"
  
  Stepwait="0.4"
  Windowmode=fullimage
  
  # Markierung für loop, daß es weiterlaufen soll
  echo "stack $Pos1 to $Pos2" >$Stackshotfile
  
  # ggf. Positionen für stepin korrigieren
  readpos
  [ "$Pos1" -gt "$Pos2" ] && {
    comment "stack: Switching Pos1:$Pos1 and Pos2:$Pos2"
    Posmem=$Pos1
    Pos1=$Pos2
    Pos2=$Posmem
    savepos
  }
  
  Anzahl="$(bc <<< "($Pos2 - $Pos1) / $Schrittweite" | cut -d. -f1)"
  comment "stack: Number of steps: $Anzahl"
  
  # An Startposition gehen
  cmd -w go1   ### FIXME somehow does not wait
  readpos
  [ "$Poscurrent" = "$Pos1" ] || { fehler "stack: Error: Missed position $Pos1: $Poscurrent." ; return 1 ; }

  # Unterordner anlegen
  Stackshotname="${Stackshotname:-stackshot}"
  Lateststack="$Arduhome/$Projektname/${Stackshotname}_$(get_free_filenumber "$Arduhome/$Projektname/$Stackshotname")"
  mkdir -p "$Lateststack/stackshot"
  echo "$Lateststack" >"$Lateststackfile"
  [ "$Evalstack" = "yes" ] && {
    mkdir -p $Lateststack/median.source
    for Line in median min max; do
      mkdir -p $Lateststack/$Line
    done
  }

  # Stackshot
  comment "stack: Shooting stack $Lateststack"
  sleep 1

  mygphoto2 --set-config-value viewfinder="1"
  while [ "$Poscurrent" -lt "$Pos2" ] ; do
    Loopcount=$((Loopcount +1 ))
    
    for ((Evalcount=1 ; Evalcount<=$Evalnumber ; Evalcount++)); do
      [ -s $Stackshotfile ] || { fehler "stack: interrupted" ; break ; }
      [ "$Evalstack" = "yes" ] && sleep $Evalwait

      case $Fotomodus in
        capture) 
          #cmd -w "capture-image-and-download"
          mygphoto2 "capture-image-and-download"
        ;;
        preview)
          # cmd -w "capture-preview"
          mygphoto2 --capture-preview
          Latestimage="$Lateststack/stackshot/preview_$(printf "%04d" $Loopcount).jpg"
          mv -f capture_preview.jpg $Latestimage
        ;;
      esac
      case $Evalstack in
        yes)
          Evalgroup="$Lateststack/median.source/img_$(printf "%04d" $Loopcount)"
          Latestmedian="${Evalgroup}_m$(printf "%02d" $Evalcount).jpg"
          cp $Latestimage $Latestmedian
          comment "stack: Image stored as $Latestmedian"
          showimage "$Latestmedian"
        ;;
        no)
          comment "stack: Image stored as $Latestimage"
          showimage "$Latestimage"
        ;;
      esac
      echo "$Latestimage" > $Latestimagefile
    done
    
    [ "$Evalstack" = "yes" ] && {
      comment "stack: Aligning captures of step $Loopcount."
      align_image_stack -m --use-given-order -a ${Evalgroup}_align $Evalgroup*.jpg 2>&1 | grep -v "Unable to read EXIF data"
      Latestimage="$Lateststack/stackshot-median/${Fotomodus}_$(printf "%04d" $Loopcount).jpg"
      $Convert ${Evalgroup}_align*.tif -evaluate-sequence median "$Latestimage"
      showimage "$Latestimage"
    }

    # step in
    cmd -w stepin
    [ "$Evalstack" = "no" ] && sleep $Stepwait
    readpos
    
    [ -s $Stackshotfile ] || { fehler "stack: interrupted" ; break ; }
    
    # Fortschrittsanzeige %
    Count=$((Count + 1))
    for ((i=1 ; i<=100 ; i++)); do
      Prozent="$((100 * $Count / $Anzahl))"
      [ "$Prozent" -lt "$i" ] && echo -n "." || echo -n "X" 
    done
    echo " $Prozent%"
  done
  
  # Create video from stackshot
  comment "stack: Creating video from stackshot"
  [ -e "$Lateststack/stackshot" ]    && Glob="$Lateststack/stackshot/*"
  [ -e "$Lateststack/median.source" ] && Glob="$Lateststack/median.source/*"
  ffmpeg -framerate 5 -pattern_type glob -i "$Glob" -c:v libx264  -pix_fmt yuv420p "$Lateststack/stackshotvideo.mp4"
  
  comment "stack: Ready: Stackshot $Stackshotname with $((Count * Evalnumber)) images in $Count steps."
  comment "stack: Location: $Lateststack"
  :> $Stackshotfile
}

##########################
#### Image processing ####

detect_sourcedir() {
  # Detect possible source directories in $2 for function $1
  # Set up variables that can be used to call function $1
  # Usage:
  #   detect_sourcedir Function Targetdir
  # Args:
  #   Function       One of align, sharpen, fuse, median, min, max, mean, set
  #   Targetdir      Target directory [+glob] to check.
  #                  Can already be in an arduterm-structure or an arbitrary one.
  #                  Location of $Destinationdir depends on detected directory structure.
  #   Functionmode   Mode of Function
  # Sets variables:
  #   Sourcedir                 Source directory within $Targetdir
  #   Sourcefileglob            Glob to get files. Mostly just "*"
  #   Destinationdir            Recommended directory to store resulting images.
  #                             Often serves as source dir for following functions.
  #   Destinationfilebasename   Possible prefix of destination file(s). Can be "", though.
  #   Targetcachedir            Cache folder
  #
  # Run in a loop to check for next possible source dir in Targetdir.
  # Returns 0 on success and 1 if nothing more is to do.
  #
  # Stores already checked source dirs of $Targetdir in $Sourcedirchecklist. 
  # -> Set Sourcedirchecklist="" before running a loop with detect_sourcedir().
  # Use local in calling function:
  #   local Sourcedir Sourcefileglob Destinationdir Destinationfilebasename Targetptofile Targetcachedir Sourcedirchecklist

  local Function Targetdir Singleshotdir Stackdir Checkline Skip
  
  Function="${1:-}"
  Targetdir="${2:-}"
  Functionmode="${3:-}"
  
  # Check if a glob like * is given
  check_fileglob "$Targetdir" && {
    Sourcefileglob="$(basename "$Targetdir")"
    Targetdir="$(dirname "$Targetdir")"
  }
  Sourcefileglob="${Sourcefileglob:-"*"}"
  Targetdir="$(realpath "$Targetdir")"
  Targetfusedir="$Targetdir/fuse"
  Targetcomposedir="$Targetdir/compose"
  
  # check if it is an arduterm directory structure, or an arbitrary image directory
  [ -d "$Targetdir/stackshot" ] && {
    Singleshotdir="stackshot"
  } || {
    Singleshotdir="$(basename "$Targetdir")"
  }
  [ -d "$Targetdir/stackshot-median" ] && Singleshotdir="$Singleshotdir stackshot-median"
  Targetcachedir="$Targetdir/cache"
  [ -d "$Targetcachedir/crop" ] && Singleshotdir="crop"
  
  [ -d "$Targetdir" ] || {
    fehler "No target directory found. Please specify a target directory or make a stackshot.
  Wrong Target: $Targetdir"
    return 1
  }
  
  for Stackdir in $Singleshotdir $(dirglob "$Targetcachedir/*") $Targetfusedir $Targetcomposedir; do
    Stackdir="$(basename $Stackdir)"
    grep -q -E 'sharpen|align|level|contrast|crop' <<< "$Stackdir" && Sourcedir="$Targetcachedir/$Stackdir" || Sourcedir="$Targetdir/$Stackdir"
    grep -q -E 'stackshot|crop' <<< "$Singleshotdir" || {
      [ "$Stackdir" = "$Singleshotdir" ] && Sourcedir="$Targetdir"
    }
    Destinationdir=""
    Destinationfilebasename=""
    Skip="no"
      
    case $Function in
      fuse)
        Destinationdir="$Targetfusedir"
        Destinationfilebasename="$Stackdir"
        case $Stackdir in
          fuse|compose) Skip="yes" ;;
        esac
        # exclude some less interesting dirs to save computing time
        grep -q align    <<< "$Stackdir" || Skip="yes"  # only fuse aligned stacks
        grep -q level    <<< "$Stackdir" || Skip="yes"  # only fuse leveled stacks
        grep -q sharpen  <<< "$Stackdir" || Skip="yes"  # only fuse sharpened stacks
        grep -q contrast <<< "$Stackdir" || Skip="yes"  # only fuse contrasted stacks
      ;;
      
      evaluate|compose)
        Destinationfilebasename="$(basename "$Targetdir").$Stackdir"
        case $Stackdir in
          fuse) Destinationdir="$Targetcomposedir" ;;
          compose) Skip="yes" ;;
          *)    
            Destinationdir="$Targetcomposedir" 
            grep -q align    <<< "$Stackdir" || Skip="yes"  # only compose aligned stacks
            grep -q level    <<< "$Stackdir" || Skip="yes"  # only compose leveled stacks
            grep -q sharpen  <<< "$Stackdir" || Skip="yes"  # only compose sharpened stacks
            grep -q contrast <<< "$Stackdir" || Skip="yes"  # only compose contrasted stacks
          ;;
        esac
      ;;
      
      align|sharpen|level|contrast)
        Destinationdir="$Targetcachedir/$Stackdir.$Function$Functionmode"
        grep -q "$Function" <<< "$Stackdir" && Skip="yes"
        check_doubledir "$Destinationdir"   && Skip="yes"
        #[ "$Function" != "level" ] && ! grep -q level <<<"$Destinationdir" && check_dirglob "$Targetcachedir/*level*" && Skip="yes"
        case $Stackdir in
          fuse|compose) Skip="yes" ;;
        esac
        case $Function in
          sharpen)
            check_doubledir "$Targetcachedir/$Stackdir.align" && Skip="yes"
            check_doubledir "$Targetcachedir/$Stackdir.level" && Skip="yes"
            check_doubledir "$Targetcachedir/$Stackdir.contrast*" && Skip="yes"
            check_doubledir "$Targetcachedir/$Stackdir.wb" && Skip="yes"
          ;;
          align)
            check_doubledir "$Targetcachedir/$Stackdir.level" && Skip="yes"
            #echo "Source: $Sourcedir"
            #ls -l $Sourcedir
            #echo "look for level:"
            #ls -l $Sourcedir.level
            #echo ---
          ;;
          contrast)
            check_doubledir "$Targetcachedir/$Stackdir.align" && Skip="yes"
            check_doubledir "$Targetcachedir/$Stackdir.level" && Skip="yes"
            check_doubledir "$Targetcachedir/$Stackdir.sharpen*" && Skip="yes"
            check_doubledir "$Targetcachedir/$Stackdir.wb" && Skip="yes"
          ;;
        esac
      ;;
      
      crop)
        [ "$Stackdir" != "$Singleshotdir" ] && Skip="yes"
        [ "$Stackdir"  = "crop" ]           && Skip="yes"
        Destinationdir="$Targetcachedir/crop"
      ;;
      
      whitebalance-choose)
        case $Stackdir in
          compose)
            Sourcefileglob="*.fuse.median.*"
            Sourcefileglob="$(find "$Targetcomposedir" -name "$Sourcefileglob")"
            [ -f "$Sourcefileglob" ] && {
              Sourcefileglob="$(basename "$Sourcefileglob")"
              Destinationdir="$Targetcachedir"
              Destinationfilebasename="whitebalance.geometry"
            } || Skip="yes"
          ;;
          *) Skip="yes" ;;
        esac
      ;;
      
      whitebalance)
        case $Stackdir in
          fuse)    Destinationdir="$Targetfusedir.wb" ;;
          compose) Destinationdir="$Targetcomposedir.wb" ;;
          *) 
            Destinationdir="$Targetcachedir/$Stackdir.wb" 
            [ -d "$Targetcomposedir" ] && Skip="yes"
          ;;
        esac
        grep -q "wb" <<< "$Stackdir"        && Skip="yes"
        check_doubledir "$Destinationdir"   && Skip="yes"
        [ -e "$Targetcachedir/whitebalance.geometry" ] || Skip="yes"
      ;;
    esac

    check_fileglob "$Sourcedir/$Sourcefileglob" || Skip="yes"
    [ "$Destinationdir" ] || Skip="yes"
    
    [ "$Skip" = "no" ] && {
#      Checkline="$Function$Option$Sourcedir$Destinationdir"
      Checkline="$Sourcedir$Destinationdir"
      grep -q "$Checkline" <<< "$Sourcedirchecklist" || {
        mkdir -p "$Destinationdir"
        #check_fileglob "$Destinationdir/$Destinationfilebasename*" && fehler "detect_sourcedir: ${1:-}: Destination file(s) already exists: $Destinationdir/$Destinationfilebasename*"
        Sourcedirchecklist="$Sourcedirchecklist
$Checkline"
        return 0
      }
    }
  done
  return 1
}
batch_all() {
  # Apply all image processing functions on target directory $1
  
  local Targetdir

  Targetdir="${1:-$Lateststack}"
  [ -d "$Targetdir" ] || check_fileglob "$Targetdir" || {
    fehler "batch_all: Target directory not found: $Targetdir"
    return 1
  }
  
  batch_function align    "$Targetdir"
  batch_function level    "$Targetdir"
  batch_function contrast "$Targetdir" "3x50%"
  batch_function sharpen  "$Targetdir" "6x2"
  batch_function evaluate "$Targetdir" all
  batch_function compose  "$Targetdir" all
  batch_function fuse     "$Targetdir" all
  batch_function compose  "$Targetdir" all
  batch_function evaluate "$Targetdir" all
  
  comment "batch_all is ready: $Targetdir"
}
batch_function() {
  # Apply image processing function $1 on all possible source dirs in target directory $2
  
  local Function Targetdir Option
  local Sourcedir Sourcefileglob Destinationdir Destinationfilebasename Targetcachedir Sourcedirchecklist # vars of detect_sourcedir()

  Function="${1:-}"
  Targetdir="${2:-$Lateststack}"
  Option="${3:-}"
  
  [ -d "$Targetdir" ] || check_fileglob "$Targetdir" || {
    fehler "$Function: Target directory not found: $Targetdir"
    return 1
  }
  [ "$Function" ] || {
    fehler "batch: No function defined for $Targetdir"
    return 1
  }
  
  [ -z "$Option" ] && case "$Function" in
    compose)  Option="bumpmap" ;;
    evaluate) Option="max" ;;
    fuse)     Option="all" ;;
    sharpen)  Option="6x2" ;;
    contrast) Option="6x50%" ;;
  esac
  
  while detect_sourcedir "$Function" "$Targetdir" "$Option"; do
    comment "$Function $Option is running: $(basename "$Targetdir")/*/$(basename "$Sourcedir")"
    case "$Function" in
      "fuse")                            fuse          "$Sourcedir/$Sourcefileglob" "$Destinationdir/$Destinationfilebasename" "$Option" ;;
      "level")                           level         "$Sourcedir/$Sourcefileglob" "$Destinationdir" ;;
      "contrast")                        contrast      "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Option" ;;
      "sharpen")                         sharpen       "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Option" ;;
      "align")                           align         "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Targetcachedir/align.pto.dir" ;;
      "align2")                          align         "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Targetcachedir/align2.pto.dir" ;;
      "evaluate")                        evaluate      "$Sourcedir/$Sourcefileglob" "$Destinationdir/$Destinationfilebasename" "$Option" ;;
      "compose")                         compose       "$Sourcedir/$Sourcefileglob" "$Destinationdir/$Destinationfilebasename" "$Option" ;;
      "crop")                            mycrop        "$Sourcedir/$Sourcefileglob" "$Destinationdir" ;;
      "whitebalance-choose")       choose_whitebalance "$Sourcedir/$Sourcefileglob" "$Destinationdir/$Destinationfilebasename" ;;
      "whitebalance")                    whitebalance  "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Targetcachedir" ;;
    esac
    comment "$Function $Option is ready: $(basename "$Targetdir")/*/$(basename "$Sourcedir")"
  done
}
sharpen() {
  # Sharpen images
  # Usage:
  #   sharpen Sharpmode Sourceglob Destinationdir
  # Args:
  #   Sourceglob       Path[+glob] to source files
  #   Destinationdir   Path where to store sharpened images
  #   Sharpmode        radius x sigma, auto-radius if 0. sigma is more important.
  # detect_sourcedir() can help to set up Args.
  
  local Sharpmode Sourceglob Destinationdir
  local Destinationfile
  
  Sourceglob="${1:-"*"}"
  Destinationdir="${2:-}"
  check_fileglob "$Sourceglob" || Sourceglob="$Sourceglob/*"
  check_fileglob "$Sourceglob" || {
    fehler "sharpen: No source files found: $Sourceglob"
    return 1
  }
  Sharpmode="${3:-"6x2"}"
  
  for Image in $(fileglob "$Sourcedir/$Sourcefileglob"); do
    Destinationfile="$(basename "$Image")"
    check_destinationfile "$Destinationdir/$Destinationfile" "sharpen $Sharpmode" || break
#    $Convert "$Image" -contrast -adaptive-sharpen $Sharpmode "$Destinationdir/$Destinationfile"
    $Convert "$Image" -adaptive-sharpen $Sharpmode "$Destinationdir/$Destinationfile"
    showimage "$Destinationdir/$Destinationfile"
  done
}
level() {

  # Normalize images (white balance, contrast)
  # Usage:
  #   level Sourceglob Destinationdir
  # Args:
  #   Sourceglob       Path[+glob] to source files
  #   Destinationdir   Path where to store sharpened images
  # detect_sourcedir() can help to set up Args.
  
  local Sourceglob Destinationdir
  local Destinationfile
  
  Sourceglob="${1:-"*"}"
  Destinationdir="${2:-}"
  check_fileglob "$Sourceglob" || Sourceglob="$Sourceglob/*"
  check_fileglob "$Sourceglob" || {
    fehler "level: No source files found: $Sourceglob"
    return 1
  }
  
  for Image in $(fileglob "$Sourcedir/$Sourcefileglob"); do
    Destinationfile="$(basename "$Image")"
    check_destinationfile "$Destinationdir/$Destinationfile" "level" || break
#    $Convert "$Image" -auto-level "$Destinationdir/$Destinationfile"
#    $Convert "$Image" -auto-level -auto-gamma -contrast-stretch 0% "$Destinationdir/$Destinationfile"
#    $Convert "$Image" -auto-level "$Destinationdir/$Destinationfile"
#    $Convert "$Image" -contrast-stretch 0 -kuwahara 0.5 "$Destinationdir/$Destinationfile"
    $Convert "$Image" -auto-gamma -auto-level "$Destinationdir/$Destinationfile"
    showimage "$Destinationdir/$Destinationfile"
  done
}
contrast() {

  # Enhance contrast
  # Usage:
  #   level Sourceglob Destinationdir
  # Args:
  #   Sourceglob       Path[+glob] to source files
  #   Destinationdir   Path where to store contrasted images
  # detect_sourcedir() can help to set up Args.
  
  local Sourceglob Destinationdir
  local Destinationfile
  
  Sourceglob="${1:-"*"}"
  Destinationdir="${2:-}"
  Functionmode="${3:-3x50%}"
  check_fileglob "$Sourceglob" || Sourceglob="$Sourceglob/*"
  check_fileglob "$Sourceglob" || {
    fehler "contrast: No source files found: $Sourceglob"
    return 1
  }
  
  for Image in $(fileglob "$Sourcedir/$Sourcefileglob"); do
    Destinationfile="$(basename "$Image")"
    check_destinationfile "$Destinationdir/$Destinationfile" "contrast" || break
#    $Convert "$Image" -auto-level "$Destinationdir/$Destinationfile"
#    $Convert "$Image" -auto-level -auto-gamma -contrast-stretch 0% "$Destinationdir/$Destinationfile"
    $Convert "$Image" -sigmoidal-contrast "$Functionmode" -kuwahara 0.5 "$Destinationdir/$Destinationfile"
    showimage "$Destinationdir/$Destinationfile"
  done
}
align() {
  # Align image stack with some panotools. Similar to align_image_stack
  # Advantage: pto file with aligned control points can be reused for multiple similar stacks
  # Usage:
  #  align Sourceglob Destinationdir [Cachedir]
  # Args:
  #  Sourcedir         Path[+glob] to source image stack
  #  Destinationdir    Path where to store aligned images
  #  Cachedir          Cache folder will contain align.pto file with control points. Can be reused to skip control point calculation.
  
  local Sourcedir Destinationdir Ptofile
  local Sourcefileglob Prevdir
  local Imagewidth Imageheight
  local Count Line Filearray Destinationfile
  local Logfile Cachedir
  local Crop Cropx Cropy Cropsize
  
  
  Sourcedir="${1:-"*"}"
  Destinationdir="${2:-}"
  Cachedir="${3:-"/tmp/align$(mcookie)"}"
  mkdir -p "$Cachedir"
  
  [ -d "$Sourcedir" ] && {
    Sourcefileglob="*"
  }
  check_fileglob "$Sourcedir" && {
    Sourcefileglob="$(basename "$Sourcedir")"
    Sourcedir="$(dirname "$Sourcedir")"
  }
  check_fileglob "$Sourcedir/$Sourcefileglob" || {
    fehler "align: No source files found: $Sourcedir/$Sourcefileglob"
    cd "$Prevdir"
    return 1
  }
  
  #echo "AS $Sourcedir/$Sourcefileglob"
  #echo "AD $Destinationdir"
  #echo "AC $Cachedir"
  #echo ""
  
  # cd to source dir to collect base file names only. Allows multiple use of aligned $Ptofile
  Prevdir="$(pwd)"
  cd "$Sourcedir"
  
  # read source file names in array
  Count=-1
  for Line in $(fileglob "$Sourcefileglob"); do
    Count=$((Count +1))
    Filearray[$Count]="$Line"
  done
  
  # Use existing pto file if possible
  Ptofile="align.pto"
  [ -f "$Cachedir/$Ptofile" ] && cp "$Cachedir/$Ptofile" "$Sourcedir/$Ptofile"
  Logfile="$Cachedir/$Ptofile.log"
  #tail -f "$Logfile" &
  
  comment "align: Aligning $Sourcedir/$Sourcefileglob"
  check_destinationfile "$Destinationdir/${Filearray[0]}" align || {
    cd "$Prevdir"
    return 1
  }
  
  # Get image size. Assuming same size for all images.
  Imagewidth=$($Convert  -format '%w'  ${Filearray[0]} info:)
  Imageheight=$($Convert -format '%h'  ${Filearray[0]} info:)
  
  [ -e "$Ptofile" ] && {
    comment "align: Using control points of given pto file $Ptofile"
  } || {
    echo "########## pto_gen ##########" >> "$Logfile"
    comment "align: Running pto_gen to create list of files"
    pto_gen -o "$Ptofile.pto_gen.pto" -p 0 -f 40 --crop=0,${Imagewidth},0,${Imageheight} $(fileglob "$Sourcefileglob") >> "$Logfile" 2>&1 || {
      fehler "Error in pto_gen
$(tail $Logfile)"
      cd "$Prevdir"
      return 1
    }
    sed -i '3 s/r:CROP//'                     "$Ptofile.pto_gen.pto"
    sed -i '3 s/\bf[0-9]*\b/f0/'              "$Ptofile.pto_gen.pto"
    sed -i "3 s/\bw[0-9]*\b/w${Imagewidth}/"  "$Ptofile.pto_gen.pto"
    sed -i "3 s/\bh[0-9]*\b/h${Imageheight}/" "$Ptofile.pto_gen.pto"
    sed -i "3 s/\bv[0-9]*\b/v40/"             "$Ptofile.pto_gen.pto"
    
#    pano_modify --projection=0 $Ptofile.pto_gen.pto
#    pano_modify --canvas=${Imagewidth}x${Imageheight} $Ptofile.pto_gen.pto
#    pano_modify --output-type=FUSEDSTACKS $Ptofile.pto_gen.pto

    # find control points
    echo "########## cpfind ##########" >> "$Logfile"
    comment "align: Running cpfind to find control points for alignment. That will take a while."
    cpfind -o "$Ptofile.cpfind.pto"  \
        --fullscale \
        --minmatches 4 \
        --linearmatch \
        --linearmatchlen 3 \
        --ransacmode hom \
        "$Ptofile.pto_gen.pto" 2>&1 >> "$Logfile" || {
      fehler "Error in cpfind
$(tail $Logfile)"
      cd "$Prevdir"
      return 1
    }

    # clean up useless/wrong control points
    echo "########## cpclean ##########" >> "$Logfile"
    comment "align: Running cpclean to remove wrong control points"
    cpclean -s -o "$Ptofile.cpclean.pto" --pairwise-checking "$Ptofile.cpfind.pto" >> "$Logfile" || {
      fehler "Error in cpclean
$(tail $Logfile)"
      cd "$Prevdir"
      return 1
    }

    #pano_modify --crop=AUTO $Ptofile.cpclean.pto
    
    # calculate distortion of images to align control points
    echo "########## autooptimiser ##########" >> "$Logfile"
    comment "align: Running autooptimiser to transform control points into image distortion"
    autooptimiser -p -o "$Ptofile" "$Ptofile.cpclean.pto" >> "$Logfile" || {
      fehler "Error in autooptimiser
$(tail $Logfile)"
      cd "$Prevdir"
      return 1
    }
    #pano_modify --crop=AUTO $Ptofile
    
    # remove all pto files except the final one
    rm $Ptofile.*.pto
  }

  grep -q "Strange values may result!" < "$Logfile" && fehler "WARNING: You may get strange align results due to missing control points!
  Check out log file $Logfile
  Probably source images are distorted too much."

  # distort images to align them
  echo "########## nona ##########" >> "$Logfile"
  comment "align: Running nona to transform images"
  nona -o "$Destinationdir/PTO_ALIGN" "$Ptofile" >> "$Logfile" || {
    fehler "Error in nona
$(tail $Logfile)"
    cd "$Prevdir"
    return 1
  }
  mv "$Sourcedir/$Ptofile" "$Cachedir/$Ptofile"

  
  cd "$Destinationdir"
  
  # Crop images
  Crop="$(grep "arducrop" < "$Cachedir/$Ptofile" | tail -n1 | cut -d: -f2)"
  [ "$Crop" ] && {
    comment "align: Found crop values in $Cachedir/$Ptofile: $Crop"
  } || {
    comment "align: Checking crop coordinates of common area of all aligned images"
    evaluate "$Destinationdir/PTO_ALIGN*" "$Cachedir/align_PTO" min tif
    Crop="$(trim_hard "$Cachedir/align_PTO.min.tif")"
    [ "$Crop" = "${Imagewidth}x${Imageheight}+0+0" ] || echo "# arducrop:$Crop" >> "$Cachedir/$Ptofile"
#    Crop="$(~/git/microscopy-tools/innercrop -o none -t "5,5,5,5" -m box "$Cachedir/align_PTO.min.tif" "$Cachedir/align_PTO_MINBOX.tif")"
#    #comment "align: innercrop check result: $Crop"
#    Cropx="$(grep "Left" <<< "$Crop" | cut -d: -f2 | cut -d, -f1)"
#    Cropx="${Cropx#" "}"
#    Cropy="$(grep "Upper" <<< "$Crop" | cut -d, -f2)"
#    Cropsize="$(grep "Width" <<< "$Crop" | cut -d: -f2 | cut -d" " -f2)"
#    Crop="${Cropsize}+${Cropx}+${Cropy}"
#    [ "$Crop" = "++" ] && [ "$Crop" = "" ] || echo "# arducrop:$Crop" >> "$Cachedir/$Ptofile"
  }
  [ "$Crop" ] && comment "align: Crop at $Crop" || {
    fehler "align: Crop failed. Continuing image processing with possibly damaged edges."
    Crop="${Imagewidth}x${Imageheight}+0+0"
  }

  Count=-1
  for Line in $(fileglob "PTO_ALIGN*"); do
    Count=$((Count +1))
    $Convert -crop "$Crop" "$Destinationdir/$Line" "$Destinationdir/${Filearray[$Count]}"
    #$Convert "$Destinationdir/$Line" "$Cachedir/${Line%.tif}.jpg" 
    rm "$Line"
  done
  
  [ "$(dirname "$Cachedir")" = "/tmp" ] && rm -R "$Cachedir"
  cd "$Prevdir"
}
align_ais() {

  Sourcedir="${1:-"*"}"
  Destinationdir="${2:-}"
  Cachedir="${3:-"/tmp/align$(mcookie)"}/align.pto.dir"
  mkdir -p "$Cachedir"
  time align_image_stack -l -s 0 -C --use-given-order -a $Destinationdir/align $Sourcedir 2>&1 | grep -v "Unable to read EXIF data"

}
evaluate() {
  # Evaluate image stack. Mostly used to calculate a median to eliminate moving objects.
  # Usage:
  #   evaluate Functionmode Sourceglob Destinationfile [Fileformat]
  # Args:
  #   Functionmode         Evaluation mode, e.g. median, max, min. Get a list of possible modes with: convert -list evaluate
  #   Sourceglob       Path[+glob] to image stack. Default: ./*
  #   Destinationfilebasename  Output file base name
  # detect_sourcedir() can help to set up Args.
  
  local Functionmode Sourceglob Destinationfile Destinationfilebasename Fileformat
  local Sourcedir
  Sourceglob="${1:-"*"}"
  Destinationfilebasename="${2:-evaluate}"
  Functionmode="${3:-}"
  Fileformat="${4:-jpg}"
  
  #echo "ES $Sourceglob"
  #echo "ED $Destinationfile"
  #echo "EM $Functionmode"
  
  check_fileglob "$Sourceglob" || Sourceglob="$Sourceglob/*"
  check_fileglob "$Sourceglob" || {
    fehler "evaluate $Functionmode: No source files found: $Sourceglob"
    return 1
  }
  Sourcedir="$(dirname "$Sourceglob")"
  
  [ "$Functionmode" = "all" ] && {
    for Functionmode in min mean set max median; do
      evaluate "$Sourceglob" "$Destinationfilebasename" "$Functionmode" "$Fileformat"
    done
    return 0
  }
  
  Destinationfile="$Destinationfilebasename.$Functionmode.$Fileformat"
  [ "$(basename "$Sourcedir")" = "fuse" ] || check_destinationfile "$Destinationfile" "evaluate $Functionmode" || return 1
  $Convert $(fileglob "$Sourceglob") -evaluate-sequence $Functionmode "$Destinationfile" || {
    fehler "evaluate $Functionmode: ERROR in excuting convert. Please check policy restrictions of ImageMagick. Note that all input images have to be the same size."
    return 1
  }
  showimage "$Destinationfile"
  
  [ "$(basename "$Sourcedir")" = "fuse" ] && {
    [ -d "$Sourcedir/../stackshot" ] && ln -f "$Destinationfile" "$Sourcedir/../"
    [ "$Sourcedir" != "${Sourcedir#$Arduhome}" ] && [ "$Functionmode" = "median" ] && ln -f "$Destinationfile" "$Sourcedir/../../"
  }
}
compose() {

  local Mode Sourceglob Destinationfilebasename
  local Minfile Maxfile Destinationdir
  Sourceglob="${1:-"*"}"
  Destinationfilebasename="${2:-compose}"
  Mode="${3:-linearburn}"
  Mode="$(tr '[:upper:]' '[:lower:]' <<< "$Mode")"
  Destinationdir="$(dirname "$Destinationfilebasename")"
  
  check_fileglob "$Sourceglob" || Sourceglob="$Sourceglob/*"
  check_fileglob "$Sourceglob" || {
    fehler "compose $Mode: No source files found: $Sourceglob"
    return 1
  }
  
  Maxfile="$Destinationfilebasename.max.jpg"
  Minfile="$Destinationfilebasename.min.jpg"
  [ -e "$Maxfile" ] || evaluate "$Sourceglob" "$Destinationfilebasename" "max"
  [ -e "$Minfile" ] || evaluate "$Sourceglob" "$Destinationfilebasename" "min"
  [ -e "$Maxfile" ] && [ -e "$Minfile" ] || {
    fehler "compose $Mode: Failed to find or create min and max files."
    return 1
  }
  
  [ "$Mode" = "all" ] && {
    for Mode in bumpmap colorburn difference linearburn linearlight modulate multiply overlay pegtoplight; do
      compose "$Sourceglob" "$Destinationfilebasename" "$Mode"
    done
    return 0
  }
  
  Destinationfile="$Destinationfilebasename.${Mode}1.jpg"
  check_destinationfile "$Destinationfile" "compose $Mode" && {
    $Convert "$Minfile" "$Maxfile" -compose "$Mode" -composite "$Destinationfile"
    showimage "$Destinationfile"
  }
#  case $Mode in # link interesting results to parent folder
#    bumpmap|multiply|overlay)
#      [ -d "$Destinationdir/../stackshot" ] && ln -f "$Destinationfile" "$Destinationdir/../"
#    ;;
#  esac
  case $Mode in
    linearburn|multiply) ;;  # skip second compose for modes with identical result
    difference)
      $Convert "$Destinationfile" -negate "$Destinationfilebasename.$Mode-negate.jpg"
    ;;
    *)
      Destinationfile="$Destinationfilebasename.${Mode}2.jpg"
      check_destinationfile "$Destinationfile" "compose $Mode" && {
        $Convert "$Maxfile" "$Minfile" -compose "$Mode" -composite "$Destinationfile"
        showimage "$Destinationfile"
      }
    ;;
  esac
}
fuse() {
  # fuse stackshot of images with enfuse
  # Usage:
  #   fuse [-m Fusemode] Sourceglob Destinationfile
  # Args:
  # -m Fusemode         Parameter set to use. Default: 1
  #    Sourceglob       Path[+glob] to image stack. Default: ./*
  #    Destinationfile  Output file. Default: fuse??.tif
  # detect_sourcedir() can help to set up Args.
  
  local Fusemode Sourceglob Destinationfile Destinationfilebasename
  local Exposureweight Saturationweight Contrastweight
  local Contrastedgescale Exposureweightfunction Exposureoptimum
  
  
  # Source and destination
  Sourceglob="${1:-"*"}"
  Destinationfilebasename="${2:-enfuse}"
  check_fileglob "$Sourceglob" || Sourceglob="$Sourceglob/*"
  check_fileglob "$Sourceglob" || {
    fehler "fuse: No source files found: $Sourceglob"
    return 1
  }
  Fusemode="${3:-1}"
  #echo "FS $Sourceglob"
  #echo "FD $Destinationfile"
  #echo ""
 
  # Predefined parameter sets
  Exposureweight=0.0
  Saturationweight=0.0
  Contrastweight=1.0
  Contrastedgescale=0
  Contrastmincurvature=""
  Contrastwindowsize="3"
  Grayprojector="luminance"
  case $Fusemode in
    all)
      fuse_all "$Sourceglob" "$Destinationfilebasename"
      return
    ;;
    1)
    ;;
    2)
      Saturationweight="0.1"
    ;;
    3) 
      Contrastwindowsize="7"
    ;;
    4) 
      Contrastwindowsize="7"
      Saturationweight="0.1"
    ;;
    5) 
      Contrastwindowsize="15"
    ;;
    6) 
      Contrastwindowsize="15"
      Saturationweight="0.1"
    ;;
    7) 
      Contrastwindowsize="23"
    ;;
    8) 
      Contrastwindowsize="23"
      Saturationweight="0.1"
    ;;
    9)
      Contrastedgescale="0.8:2000%:300%"
      Contrastmincurvature="+8.0%"
    ;;
    10)
      Contrastedgescale="0.8:500%:500%"
      Contrastmincurvature="+8.0%"
    ;;
    11)
      Contrastedgescale="1.2:16:4"
      Contrastmincurvature="+5.0%"
    ;;
    12)
      Contrastedgescale="1.2:8:4"
      Contrastmincurvature="+5.0%"
      #Saturationweight="0.1"
    ;;
    13)
      Contrastedgescale="1.6:16:4"
      Contrastmincurvature="+3.0%"
    ;;
    14)
      Contrastedgescale="1.6:8:4"
      Contrastmincurvature="+3.0%"
      #Saturationweight="0.1"
    ;;
    15)
      Contrastedgescale="1.6:16:10"
      Contrastmincurvature="+6.0%"
    ;;
    16)
      Contrastedgescale="1.6:8:10"
      Contrastmincurvature="+8.0%"
      #Saturationweight="0.1"
    ;;
    17)
      Contrastedgescale="2.0:500%:500%"
      Contrastmincurvature="+2.0%"
    ;;
    
    
    
    
    xxx7)
      Contrastedgescale="0.3:1000%:300%"
      Contrastmincurvature="+0.3%"
    ;;
    xxx8)
      Contrastedgescale="0.3:1000%:300%"
      Contrastmincurvature="+0.3%"
      Saturationweight="0.1"
    ;;
    
    
    
    
    x11)
      Grayprojector="l-star"
    ;;
    x12) 
      Contrastwindowsize="7"
      Grayprojector="l-star"
    ;;
    x13)
      Grayprojector="l-star"
      Contrastedgescale="0.3:1000%:300%"
      Contrastmincurvature="+0.3%"
      Grayprojector="l-star"
    ;;
    x14)
      Contrastedgescale="0.8:2000%:300%"
      Grayprojector="l-star"
    ;;
    x15)
      Contrastedgescale="1.2:16:4"
      Contrastmincurvature="+8.0%"
      Grayprojector="l-star"
    ;;
    x16)
      Contrastedgescale="1.6:16:4"
      Contrastmincurvature="+4.0%"
      Grayprojector="l-star"
    ;;
    x17)
      Contrastedgescale="1.6:16:4"
      Saturationweight="0.1"
      Contrastmincurvature="+5.0%"
      Grayprojector="l-star"
    ;;
    x18)
      Contrastedgescale="1.6:16:10"
      Saturationweight="0.1"
      Contrastmincurvature="+10.0%"
      Grayprojector="l-star"
    ;;
    *) return 1 ;;
  esac
  
  
  ##  Laplacian Edge Detection
  # Enfuse provides a Laplacian-based algorithm that can help in situations where weighting based on the standard deviation fails. 
  # It is activated with a positive value for SCALE in --contrast-edge-scale=SCALE. 
  # The Laplacian will detect two-dimensional curvature on the scale of SCALE. 
  # Here and in the following we simply speak of curvature where we mean magnitude of curvature. 
  # That is, we shall not distinguish between convex and concave edges. Enfuse always use the magnitude of curvature for weighting.
  #
  # Typically, SCALE ranges between 0.1 pixels and 0.5 pixels, where 0.3 pixels are a reasonable starting point. 
  # To find the best value for SCALE though, usually some experimentation will be necessary. 
  # Use --save-masks to get all soft-mask (default: softmask-%n.tif) and hard-mask files (default: hardmask-%n.tif). Check how different scales affect the artifacts. 
  #
  ## Local Contrast Enhancement
  # Sometimes Enfuse misses smoother edges with --contrast-edge-scale and a little local contrast enhancement (LCE) helps. 
  # Set --contrast-edge-scale=SCALE:LCE-SCALE:LCE-FACTOR, 
  # where LCE-SCALE and LCE-FACTOR work like the unsharp mask filters in various image manipulation programs. 
  # Start with LCE-SCALE ten times the value of SCALE and a LCE-FACTOR of 2-5.
  #
  # LCE-SCALE can be specified as a percentage of SCALE. LCE-FACTOR also can be specified as a percentage. 
  # Examples:
  #    --contrast-edge-scale=0.3:3.0:3
  #    --contrast-edge-scale=0.3:1000%:3.0
  #    --contrast-edge-scale=0.3:3:300%
  #    --contrast-edge-scale=0.3:1000%:300% 
  #  Contrastedgescale="0.3:3:3"
  #
  # --exposure-weight-function=gaussian
  # one of the built-in exposure WEIGHT-FUNCTIONs: "gaussian", "lorentzian", "half-sine", "full-sine", or "bi-square"; default: "gaussian"
  #  Exposureweightfunction=gaussian
  #
  # --exposure-optimum=0.5
  # optimum  exposure  value, usually the maximum of the weighting function (0 <= OPTIMUM <= 1); default: 0.5
  #Exposureoptimum=0.5
  #    --exposure-optimum=$Exposureoptimum \
  #
  # --contrast-window-size=SIZE
  #   set window SIZE for local-contrast analysis (SIZE >= 3); default: 5
  #   Does not take effect if --contrast-edge-scale is in use.
  #Contrastwindowsize=5
  #    --contrast-window-size=$Contrastwindowsize \

  Destinationfile="$Destinationfilebasename.fuse$(printf %02d $Fusemode).jpg"
  check_destinationfile "$Destinationfile" "fuse" || return 1
  comment "fuse: Creating $Destinationfile"
  
  Enfuseoptions="
      --exposure-weight=$Exposureweight \
      --saturation-weight=$Saturationweight \
      --contrast-weight=$Contrastweight \
      --hard-mask \
      \
      --contrast-edge-scale=$Contrastedgescale \
      --contrast-window-size=$Contrastwindowsize \
      \
      --gray-projector=$Grayprojector"
  [ "$Contrastmincurvature" ] && Enfuseoptions="$Enfuseoptions \
      --contrast-min-curvature=$Contrastmincurvature"
  
  # Fusing here
  enfuse $Enfuseoptions \
      --output=$Destinationfile \
      $(fileglob "$Sourceglob") \
      2>&1 | grep -v "does not have an alpha channel" | grep -v "assuming all pixels should contribute" | grep -v "loading next image"
        
  # Write enfuse options into EXIF data of image
  exiv2 -M"set Exif.Photo.UserComment Comment charset=Ascii enfuse $(echo $Enfuseoptions)" "$Destinationfile"

  comment "fuse is ready: ${Destinationfile}"
  showimage "$Destinationfile"
}
fuse_all() {
  # Iterate through all fuse modes of fuse(). Run as much threads as CPU cores are given.
  # detect_sourcedir() can help to set up Args.
  # Usage:
  #  fuse_all Sourceglob Destinationdir Destinationfilebasename
  # Args:
  #  Sourceglob                Path[and glob] to stackshot images.
  #  Destinationdir            folder where to store results
  #  Destinationfilebasename   Prefix of created files. Default: "fuse". Suffix will be ??.tif
  
  local Sourceglob Destinationdir Destinationfilebasename Destinationfile
  local Fusemode Fusepid Fusethreads Cpucount
  
  Sourceglob="${1:-"*"}"
  Destinationfilebasename="${2:-}"
#  [ -d "$Destinationdir" ] && {
#    Destinationfilebasename="fuse"
#  } || {
#    Destinationfilebasename="$(basename "$Destinationdir")"
#    Destinationdir="$(dirname "$Destinationdir")"
#  }
#  check_fileglob "$Sourceglob" || Sourceglob="$Sourceglob/*"
#  check_fileglob "$Sourceglob" || {
#    fehler "fuse: No source files found: $Sourceglob"
#    return 1
#  }
 
  # number of CPUs to use
  Cpucount="$(nproc)"
  #Cpucount="$((Cpucount-1))"
#  Cpucount=1
  
  # fuse with enfuse
  # some hickhack to run multiple threads at once, but not more than number of CPUs.
  for Fusemode in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25; do
    Destinationfile="$Destinationfilebasename.fuse$(printf %02d $Fusemode).jpg"
    check_destinationfile "$Destinationfile" "fuse" && {
      fuse "$Sourceglob" "$Destinationfilebasename" "$Fusemode" & Fusepid[$Fusemode]=$! 
      echo "${Fusepid[$Fusemode]} fuse" >>$Backgroundpidfile
      ps -p ${Fusepid[$Fusemode]} >/dev/null && while :; do
        sleep 1
        Fusethreads=0
        for ((i=1; i<=100; i++)); do
          [ "${Fusepid[$i]}" ] && ps -p "${Fusepid[$i]}" >/dev/null 2>&1 && Fusethreads=$((Fusethreads+1)) || Fusepid[$i]=""
        done
        [ "$Fusethreads" -lt $Cpucount ] && break
      done
    }
  done
  for ((i=1; i<=100; i++)); do
    [ "${Fusepid[$i]}" ] && ps -p "${Fusepid[$i]}" >/dev/null 2>&1 && wait ${Fusepid[$i]}
  done
}

cropcolorpermille() {
  # Function: Calculate permille part of pixels of color $2 in crop rectangle $3 of image $1
  # $1  $Image      image
  # $2  $Trimcolor  color to count
  # $3  $Cropgeometry       crop rectangle to search in
  # Output: Permille part of color in crop region
  
  local Image Trimcolor Cropgeometry
  local Colorcount Cropwidth Cropheight Permille
  
  Image="${1:-}"
  Trimcolor="${2:-}"
  Cropgeometry="${3:-}"
  
  Cropwidth=$(cut -dx -f1 <<< "$Cropgeometry")
  Cropheight=$(cut -dx -f2 <<< "$Cropgeometry" | cut -d+ -f1)

  Colorcount="$(convert "$Image" -crop "$Cropgeometry" txt: | grep -c "$Trimcolor")"
  # second way to count color, a bit slower.
#  Colorcount="$(convert "$Image" -crop "$Cropgeometry" -fill black +opaque "$Trimcolor"  -format %c histogram:info: | grep "$Trimcolor")"
#  Colorcount="$(awk '{print $1}' <<< "$Colorcount" | cut -d: -f1)"

  Permille=$((1000 * $Colorcount / ($Cropwidth*$Cropheight) ))
  echo "${Permille:-0}"
}
trim_hard() {
  # Function: Trim all border with color $2 from image $1
  # Results in a maximal inner rectangle without border color.
  # $1  $Image      image
  # $2  $Trimcolor  color to trim. Default: transparent
  # Output: crop geometry
  
  local Image Trimcolor
  local Imagewidth Imageheight
  local Left         Right         Top         Bottom
  local Skipleft     Skipright     Skiptop     Skipbottom
  local Permilleleft Permilleright Permilletop Permillebottom Permillemax
  local Return
  local Debugmode Loopcount
  
  Image="${1:-}"
  Trimcolor="${2:-"#00000000"}"
  
  Imagewidth=$(convert  -format '%w'  $Image info:)
  Imageheight=$(convert -format '%h'  $Image info:)
  
  Left=0
  Top=0
  Right=$((Imagewidth-1))
  Bottom=$((Imageheight-1))
  
  # First cut with regular trim to save some time.
  # Add a colored border so trim uses the desired color. Afterward remove border from canvas to get correct geometry values. 
  Line="$(convert "$Image" -bordercolor "$Trimcolor" -border 1x1  -trim -set page '%[fx:page.width-2]x%[fx:page.height-2]+%[fx:page.x-1]+%[fx:page.y-1]' info:)"
  Left="$(awk '{print $4}' <<< "$Line" | cut -d+ -f2)"
  Top="$(awk '{print $4}' <<< "$Line" | cut -d+ -f3)"
  Right="$(awk '{print $3}' <<< "$Line" | cut -dx -f1)"
  Right="$((Left+Right-1))"
  Bottom="$(awk '{print $3}' <<< "$Line" | cut -dx -f2)"
  Bottom="$((Top+Bottom-1))"
  
  # Workflow:
  # - Get permille amount of $Trimcolor from all sides.
  # - Remove side with greatest permille amount of $Trimcolor.
  # - Repeat check with new geometry
  while :; do
    # Get permille of $Trimcolor at each side
    [ "$Skipleft" ]   || Permilleleft=$(cropcolorpermille   $Image "$Trimcolor" 1x$((Bottom-Top+1))+$Left+$Top)
    [ "$Skipright" ]  || Permilleright=$(cropcolorpermille  $Image "$Trimcolor" 1x$((Bottom-Top+1))+$Right+$Top)
    [ "$Skiptop" ]    || Permilletop=$(cropcolorpermille    $Image "$Trimcolor" $((Right-Left+1))x1+$Left+$Top)
    [ "$Skipbottom" ] || Permillebottom=$(cropcolorpermille $Image "$Trimcolor" $((Right-Left+1))x1+$Left+$Bottom)
    
    # Determine maximal permille value
    Permillemax=$(echo "
$Permilleleft
$Permilleright
$Permilletop
$Permillebottom
" | sort -n | tail -n1)
    [ "$Permillemax" = "0" ] && break # Ready
    
    # Remove side with maximal permille of $Trimcolor.
    [ "$Permillemax" = "$Permilleleft" ]   && Left=$((Left+1))
    [ "$Permillemax" = "$Permilleright" ]  && Right=$((Right-1))
    [ "$Permillemax" = "$Permilletop" ]    && Top=$((Top+1))
    [ "$Permillemax" = "$Permillebottom" ] && Bottom=$((Bottom-1))
    
    # Skip check for sides without $Trimcolor in future to save some time
    [ "0" = "$Permilleleft" ]   && Skipleft=yes
    [ "0" = "$Permilleright" ]  && Skipright=yes
    [ "0" = "$Permilletop" ]    && Skiptop=yes
    [ "0" = "$Permillebottom" ] && Skipbottom=yes
    
    # Out-of-range error
    { [ "$Left" -gt "$Right" ] || [ "$Top" -gt "$Bottom" ] ; } && {
      echo "Error: Failed to find an inner rectangle. Unuseable result: $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top" >&2
      Return=1
      Left=0
      Top=0
      Right=$((Imagewidth-1))
      Bottom=$((Imageheight-1))
      break
    }
    
    # Debugging: show intermediate results
    Debugmode=yes
    [ "$Debugmode" ] && {
      Loopcount=$((Loopcount+1))
      [ "$Loopcount" = "25" ] && {
        Loopcount=0
        convert $Image -fill none -stroke red -strokewidth 1 -draw "rectangle $Left,$Top $Right,$Bottom" $Image.trim_hard.png
        showimage $Image.trim_hard.png
      }
    }
  done
  
  # Output of result
  #echo "$Left,$Top $Right,$Bottom"                     # "-draw rectangle" geometry
  echo $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top  # "-crop" geometry
  
  # Create image with red rectangle at crop coordinates and show it
  convert $Image -fill none -stroke red -strokewidth 1 -draw "rectangle $Left,$Top $Right,$Bottom" $Image.trim_hard.png
  showimage $Image.trim_hard.png
  
  return ${Return:-0}
}
choose_crop() {
  local Image
  local Geometry Windowid Xwininfo Displaypid
  local WinX  WinY  WinW  WinH
  local CropX CropY CropW CropH
  
  Image="${1:-}"

  display -title "Choose crop area of $Image" "$Image" & Displaypid=$!
  Geometry="$($Xmeasure)"
  
  Windowid=$(xdotool search "Choose crop area")
  Xwininfo="$(xwininfo -id "$Windowid" -stats)"
  WinX="$(( $(grep "Absolute upper-left X" <<< "$Xwininfo" | cut -d: -f2)  ))"
  WinY="$(( $(grep "Absolute upper-left Y" <<< "$Xwininfo" | cut -d: -f2)  ))"
  WinW="$(grep "geometry" <<< "$Xwininfo" | cut -dx -f1 | rev | cut -d' ' -f1 | rev)"
  WinH="$(grep "geometry" <<< "$Xwininfo" | cut -dx -f2 | cut -d+ -f1 | cut -d- -f1)"
  kill $Displaypid
    
  CropX="$(grep X <<< "$Geometry" | cut -d' ' -f2)"
  CropY="$(grep Y <<< "$Geometry" | cut -d' ' -f2)"
  CropW="$(grep W <<< "$Geometry" | cut -d' ' -f2)"
  CropH="$(grep H <<< "$Geometry" | cut -d' ' -f2)"
  CropX=$((CropX - WinX))
  CropY=$((CropY - WinY))
  
  { [ "$CropW" = "0" ] || [ "$CropH" = "0" ] || [ "$CropX" -lt "0" ] || [ "$CropY" -lt "0" ] ; } && return 1
  
  echo "${CropW}x${CropH}+$CropX+$CropY"
  return 0
}
mycrop() {
  Sourceglob="${1:-}"
  Destinationdir="${2:-}"
  Image="$Cachefolder/crop.min.tif"
  $Convert $Sourceglob -evaluate-sequence min "$Image"
  Cropgeometry="$(choose_crop "$Image")"
  rm "$Image"
  [ "$Cropgeometry" ] || return 1
  for Image in $Sourceglob ; do
    $Convert "$Image" -crop $Cropgeometry "$Destinationdir/$(basename "$Image")"
  done
}
choose_whitebalance() {
  local Image Destinationfile
  local Cropgeometry
  Image="${1:-}"
  Destinationfile="${2:-}"
  Cropgeometry="$(choose_crop "$Image")"
  [ "$Cropgeometry" ] || return 1
  echo "$Cropgeometry" > "$Destinationfile"
}
whitebalance() {
  local Sourceglob Destinationdir Cachedir
  local Cropgeometry Meancolor Destinationfile Image
  Sourceglob="${1:-}"
  Destinationdir="${2:-}"
  Cachedir="${3:-}"
  
  [ -e "$Cachedir/whitebalance.geometry" ] || return 1
  Cropgeometry="$(cat "$Cachedir/whitebalance.geometry")"
  for Image in $(fileglob "$Sourceglob"); do
    Meancolor=$(convert $Image -crop $Cropgeometry -filter box -resize 1x1! -format "%[pixel:u]" info:)
    Destinationfile="$Destinationdir/$(basename "$Image")"
    $Whitebalance -c "$Meancolor" -r '#AAAA99' "$Image" "$Destinationfile"
    showimage "$Destinationfile"
  done
  
}
#########################
# unsortiert            #

savepos() {
  ## Funktion: Derzeitige Positionen merken
  # Dient der Synchronisation der Positionsdaten über Parallelprozesse hinweg
  echo "${Poscurrent:-0} ${Pos1:-0} ${Pos2:-0}" ${Schrittweite:-1} >$Positionfile
#  comment "save: $(cat $Positionfile)"
}
readpos() {
  ## Funktion: Derzeitige Positionen auslesen
  # Dient der Synchronisation der Positionsdaten über Parallelprozesse hinweg
  read Poscurrent Pos1 Pos2 Schrittweite <$Positionfile
#  comment "read: $Poscurrent $Pos1 $Pos2 $Schrittweite"
}
hubloop_stepin() {
  ## Funktion: Permanent stepin Kommandos senden, wenn $Hubloop_stepinfile nicht leer ist
  # Wird durch L-SHIFT in keypress_watch() gesteuert
  while :; do
    [ -s $Hubloop_stepinfile ]  && cmd -w stepin  || sleep 0.1
  done
}
hubloop_stepout() {
  ## Funktion: Permanent stepout Kommandos senden, wenn $Hubloop_stepinfile nicht leer ist
  # Wird durch L-CTRL in keypress_watch() gesteuert
  while :; do
    [ -s $Hubloop_stepoutfile ] && cmd -w stepout || sleep 0.1
  done
}

keypress_watch_sendkey() {
  # Taste(n) $1 mit xdotool "tippen"
  local Capslock=
  Capslock=$(xset -q | grep Caps | awk '{print $4}')
  [ "$Capslock" = "on" ] && keypress_unlock
  xdotool key ${1:-}
  [ "$Capslock" = "on" ] && keypress_lock
}

###########################
#### Tastatursteuerung ####

keypress_lock() {
  # Tastatur blockieren
  sleep 0.1
  xtrlock & echo $! >$Xtrlockpidfile
}
keypress_unlock() {
  # Tasturblockade aufheben
  mykill $(cat $Xtrlockpidfile)
  sleep 0.2
}
keypress_watch() {
  # Einfangen aller Tastatureingaben und auf Tastendruck Befehle senden.
  # Aktivieren/Deaktivieren mit CAPSLOCK.
  # Nutzt xtrlock zum Sperren von Tastatur und Maus.
  # Einzelne Tastatureingaben werden weitergereicht, dafür wird xtrlock beendet und wieder gestartet.
  
  while read Line <&8 ; do
    Keyhub=$(awk '{print $2}' <<< $Line)
    Keycode=$(awk '{print $3}' <<< $Line)
    Capslock=$(xset -q | grep Caps | awk '{print $4}')
    case $Capslock in
      on)  [ "$Keywatch" = "off" ] && keypress_lock && Keywatch="on" ;;
      off) [ "$Keywatch" = "on" ]  && keypress_unlock && Keywatch="off" ;;
    esac
    [ "$Keywatch" = "on" ] && case $Keyhub in
      press)
        case $Keycode in
        
          # ALT-Taste freigeben (um ALT+Tab zu erlauben)
          64)  keypress_unlock ;;                     # L-Alt
          
          # Durchgehender Lauf von Stepin/Stepout
          50) echo "stepin"  >$Hubloop_stepinfile ;;  # L-Shift
          37) echo "stepout" >$Hubloop_stepoutfile ;; # L-Ctrl
          
          # Guake toggle
          96)  guake -t ;;                            # F12
          
          # Toggle window mode
          23)  cmd "win" ;;                           # TAB
          
          # Schrittweite
          10)  cmd "w 1" ;;                           # 1
          11)  cmd "w 2" ;;                           # 2
          12)  cmd "w 5" ;;                           # 3
          13)  cmd "w 10" ;;                          # 4
          14)  cmd "w 25" ;;                          # 5
          15)  cmd "w 50" ;;                          # 6
          16)  cmd "w 100" ;;                         # 7
          17)  cmd "w 200" ;;                         # 8
          18)  cmd "w 400" ;;                         # 9
          
          # stepin / stepout
          31)  cmd "i" ;;                             # i
          32)  cmd "o" ;;                             # o
          
          # Positionen speichern oder anlaufen
          87)  cmd "pos1" ;;                          # Num-1
          89)  cmd "pos2" ;;                          # Num-3
          79)  cmd "go1" ;;                           # Num-7
          81)  cmd "go2" ;;                           # Num-9
          
          # Positionen auf 0
          19)  cmd "zero" ;;                          # 0
          
          # Stackshot
          9)   :> $Stackshotfile ;;                   # ESC
          117) cmd "stack -p" ;;                      # Bild-hoch
          112) cmd "stack -c" ;;                      # Bild-runter
          
          # Programmende
          24)  cmd "exit" ;;                          # q
          
          # ISO Lichtempfindlichkeit
          25)  cmd "iso 100" ;;                       # w
          26)  cmd "iso 200" ;;                       # e
          27)  cmd "iso 400" ;;                       # r
          28)  cmd "iso 800" ;;                       # t
          29)  cmd "iso 1600" ;;                      # z
          
          # Video Vorschau/Preview
          30)  cmd "zoom toggle" ;;                   # u
          33)  cmd "preview" ;;                       # p
          34)  cmd "stop-movie" ;;                    # ü
          
          # Shutter Verschlußzeit
          38)  cmd "shutterspeed 1/10" ;;             # a
          39)  cmd "shutterspeed 1/20" ;;             # s
          40)  cmd "shutterspeed 1/40" ;;             # d
          41)  cmd "shutterspeed 1/80" ;;             # f
          42)  cmd "shutterspeed 1/125" ;;            # g
          43)  cmd "shutterspeed 1/200" ;;            # h
          44)  cmd "shutterspeed 1/320" ;;            # j
          45)  cmd "shutterspeed 1/400" ;;            # k
          46)  cmd "shutterspeed 1/800" ;;            # l
          
          # Foto
          65)  cmd "capture-image-and-download" ;;    # Space
          55)  cmd "capture-preview" ;;               # v
          
          # Videovorschau mit Zoom: Sichtfenster bewegen
          62)  Shift_r="1" ;;                         # R-Shift
          80)  [ "$Shift_r" ] && cmd "move-zoom y -640" || cmd "move-zoom y -64" ;;  # Num-8
          88)  [ "$Shift_r" ] && cmd "move-zoom y +640" || cmd "move-zoom y +64" ;;  # Num-2
          83)  [ "$Shift_r" ] && cmd "move-zoom x -640" || cmd "move-zoom x -64" ;;  # Num-4
          85)  [ "$Shift_r" ] && cmd "move-zoom x +640" || cmd "move-zoom x +64" ;;  # Num-6
          
        esac
      ;;
      release)
        case $Keycode in
          50) :> $Hubloop_stepinfile ;;               # L-Shift
          37) :> $Hubloop_stepoutfile ;;              # L-Ctrl
          62)  Shift_r="" ;;                          # R-Shift
          64)  keypress_lock ;;                       # L-Alt
        esac
      ;;
    esac
  done
}
readline_watch() {
  # Terminaleingaben lesen und weiterreichen
  local Commandline=
  while : ; do
    cd $(cat $Workdirfile)
    history -n $Historyfile
    sleep 0.5
    read -r -e Commandline
    echo "$Commandline" >> $Commandfifo
  done
}

##########################
#### Kommandozentrale ####

cmd() {
  ## Funktion: Kommando auf Kommandostapel legen
  #  -w   Auf Ende der Ausführung des Kommandos warten
  
  local Warten=
  [ "$1" = "-w" ] && Warten="yes" && shift
  
  # Kommandosperre setzen
  echo "$*" > $Pleasewaitfile
  
  ## Funktion: Kommando senden
  echo "$*" >> $Commandfifo
  
  # Warte auf Ende der Kommandosperre
  [ "$Warten" = "yes" ] && {
    while :; do
      [ -s "$Pleasewaitfile" ] || break
      sleep 0.001
    done
  }
}
cmd_loop() {
  ## Funktion: Kommandostapel zeilenweise an Parser weiterreichen
  local Commandline
  while :; do
  
    read -r Commandline <&4
    echo  "$Commandline" >> $Historyfile       # Eintrag für history von readline
    echo  "$Commandline" > "$Pleasewaitfile"   # Kommandosperre setzen

    ps -p $Imageviewerpid >/dev/null 2>&1 || Imageviewerpid=""
    ps -p $Ffplaypid      >/dev/null 2>&1 || Ffplaypid=""
    
    Lateststack="$(cat "$Lateststackfile")"
    cd "$(cat "$Workdirfile")"
    
    set -f
    cmd_parser $Commandline
    set +f
    
    [ -s "$Ardutermrunfile" ] || break
    
    # Prompt anzeigen
    Currentdir=$(pwd)
    echo -e "${WEISS} $Poscurrent  ${BLAU}Pos1:${GELB}$Pos1 ${BLAU}[$(awk 'BEGIN {print 0.048 * '$((Pos2 - Pos1))'}')µm][$(( (Pos2-Pos1) / $Schrittweite )) shots] ${BLAU}Pos2:${GELB}$Pos2 \
${BLAU}w:${WEISS}$Schrittweite(=$(awk 'BEGIN {print 0.048 * '$Schrittweite'}')µm) \
${BLAU}iso:${WEISS}${Iso:-N/A} ${BLAU}shutter:${WEISS}${Shutterspeed:-N/A}
${BLAU}dir:${Currentdir#"$Arduhome/"} $WEISS"
    # check [and show] background processes
    Batchpids=0
    Fusepids=0
    Stackpids=0
    while read Pid Name; do
      ps -p $Pid>/dev/null && case $Name in
        batch) Batchpids=$((Batchpids+1)) ;;
        fuse) Fusepids=$((Fusepids+1)) ;;
        stack) Stackpids=$((Stackpids+1)) ;;
      esac || sed -i "/$Pid /d" $Backgroundpidfile
    done <$Backgroundpidfile
    [ "$((Batchpids + Fusepids + Stackpids))" = "0" ] || echo -e "${BLAU}Background processes still running: batch:${ROT}$Batchpids${BLAU} fuse:${ROT}$Fusepids${BLAU} stack:${ROT}$Stackpids${WEISS}"
    
    # Kommandosperre aufheben
    :> "$Pleasewaitfile"
  done
}
cmd_parser() {
  ## Funktion: Kommandozentrale von arduterm
  
  local Command
  local Videomode_restore= Ordnername=
  
  Command="${1:-}"
  shift
  set +f
  
  case "$Command" in       # Laufende Videoaufnahme bei gphoto2 Aufruf unterbrechen, ggf. nach Kommando wieder starten
    "get-config"|"gc"|"set-config"|"setconfig"|"sc"|\
    "set-config-value"|"scv"|"set-config-index"|"sci"|\
    "switch"|"switch-config"|"iso"|"shutter"|"shutterspeed"|\
    "capture-image"|"cap"|"capture-image-and-download"|"capd"|"capture-preview"|"capp"|\
    "zoom"|"u"|"move-zoom"|"mirrorup"|"m"|\
    "gphoto2"|"stack")
       Videomode_restore=$Videomode
       videoaufnahme stop-movie
    ;;
  esac
  
  case "$Command" in
    #### Allgemeine Optionen ####
    "hilfe"|"help") # Hilfe anzeigen
       comment "
### Allgemeine Kommandos ###
hilfe                               Diese Hilfe
exit|q                              Arduterm beenden
home
project
name

### Gerätespezifische Kommandos ###
device ADRESSE                      Device initialisieren. Ein Arduino hat oft die Adresse /dev/ttyACM0
send [SIGNAL]                       SIGNAL an Device/Arduino senden

### Dateioperationen ###
cd [ORDNER]                         In Verzeichnis ORDNER wechseln
ls                                  Verzeichnisinhalt anzeigen.
image [BILD | OPTION]               BILD anzeigen mit Bildbetrachter 'geeqie'
                                    Ohne Optionen: alle Bilder in einer Liste zur Auswahl anbieten
                                    -rh zeigt verfügbare Optionen OPTION von geeqie
video [VIDEO]                       VIDEO abspielen. Ohne Option: Letztes aufgenommenes Video zeigen
mkdir ORDNERNAME                    Verzeichnis ORDNERNAME anlegen
mkdir-time [ORDNERNAME]             Verzeichnis ORDNERNAME mit Datum und Uhrzeit im Namen anlegen und hineingehen
### gphoto2-Aufrufe ###
gphoto2  [OPTIONEN]                 gphoto2 mit OPTIONEN direkt aufrufen
set-config | s [ENTRY]              Kamera interaktiv konfigurieren (Dialog)
get-config | g [ENTRY]              Konfiguration der Kamera anzeigen. ENTRY z.B. 'iso' oder 'shutterspeed'
                                    Ohne ENTRY: Alle Einstellungen vom TYP RADIO/MENU anzeigen
set-config-value | scv ENTRY=VALUE  Aufruf von:   gphoto2 --set-config-value ENTRY=VALUE
set-config-index | sci ENTRY=INDEX  Aufruf von:   gphoto2 --set-config-index ENTRY=INDEX
switch-config ENTRY [ + | - ][n]    Kameraeinstellung ENTRY auf nächste (+) oder vorherige (-) Stufe einstellen
                                    +n oder -n : n Stufen weiterstellen
mirrorup | m                        Spiegel hochklappen
zoom 1|5|10                         Liveview/Video-Zoom 1x, 5x oder 10x
move-zoom x|y PIXEL                 Position des Zoom-Focus relativ in X oder Y Richtung um PIXEL ändern. 
                                    Bei 'zoom 5' oder 'zoom 10' bewegt dies die Position des sichtbaren Bildes
capture-image | cap                 Foto aufnehmen und auf Kamera speichern
capture-image-and-download | capd   Foto aufnehmen und herunterladen
capture-preview | capp              Preview-Bild aufnehmen und herunterladen
preview | p                         Video: Preview anzeigen
capture-movie | start               Video: Preview anzeigen und speichern
capture-movie-no-preview            Video: Aufnehmen ohne Preview.
                                    Option: DAUER Frames oder DAUERs Sekunden 
stop-movie | stop                   Videoaufnahme stoppen
"
       ;;
    "#") comment "$*" ;;     # Kommentar anzeigen.
    "exit"|"q") :> $Ardutermrunfile ;; # Programm beenden. 
    "win")
      case $Windowmode in
        fullimage) Windowmode=fullpreview ;;
        fullpreview) Windowmode=split ;;
        split) Windowmode=fullimage ;;
      esac
      window_placement
      ;;
       
    #### Kommunikation mit Device/Arduino
    "device") # Geräteadresse setzen
       device_init $1
       comment "Beginne Überwachung von $Deviceadresse"
       ;;
    "send") # Signal an Arduino senden. Syntax: send SIGNAL1 SIGNAL2 SIGNAL3 ...
       comment "Sende an $Deviceadresse: $*"
       device_send "$*"
       device_wait
       ;;
    "0"|"zero") 
       comment "Setze alle Positionsmarker auf 0."
       Poscurrent="0" ; Pos1="0" ; Pos2="0"
       setpos0
       savepos
       ;;
    "pos0") 
       comment "Nullpunkt definiert"
       Poscurrent=0
       setpos0
       savepos
       ;;
    "pos1")
       comment "Setze Pos1 auf: $Poscurrent"
       Pos1=$Poscurrent
       savepos
       ;;
    "pos2") 
       comment "Setze Pos2 auf: $Poscurrent"
       Pos2=$Poscurrent
       savepos
       ;;
    "go1")  
       comment "Gehe zu Pos1: $Pos1"
       steplauf "$Pos1" 
       ;;
    "go2")
       comment "Gehe zu Pos2: $Pos2"
       steplauf "$Pos2" 
       ;;
    "go0")  
       comment "Gehe zu Nullpunkt Pos0: 0"
       steplauf "0" 
       ;;
    "i"|"stepin")  
       steplauf "$(bc <<< "$Poscurrent + $Schrittweite")" 
       ;;
    "o"|"stepout") 
       steplauf "$(bc <<< "$Poscurrent - $Schrittweite")" 
       ;;
    "w")
       Schrittweite="$1"
       device_send "w,$Schrittweite"
       device_wait >/dev/null
       savepos
       ;;
       
    #### Dateioperationen ####
    "home") # Basisverzeichnis für arduterm Bilder+Videos festlegen
       [ "${1:-}" ] && Arduhome="$1"
       cd "$Arduhome"
       pwd > $Workdirfile
       ;;
    "projekt"|"project") # Projektname festlegen, Ordner erzeugen und hineingehen
       setup_projectdir "$1"
       ;;
    "name")
       Stackshotname="$1"
       ;;
    "cd") # Verzeichnis wechseln
       cd ${1:-$Arduhome/$Projektname}
       pwd >$Workdirfile
       sleep 0.1
       #xdotool key Return
       ;;
    "mkdir") # Verzeichnis anlegen
       comment "Erzeuge Ordner $1"
       mkdir "$1"
       ;;
    "ls") # Verzeichnisinhalt anzeigen
       ls "$@"
       ;;
    "showimage"|"image") # Bild $1 anzeigen.
       showimage "$@"
       ;;
    "video") # Video $1 oder $Latestvideo abspielen
       ffplay -loglevel error "${1:-$Latestvideo}"
       ;;
       
    #### gphoto2 Aufrufe ####
    "get-config"|"gc")
       ardu_gphoto2 get-config $@
       ;;
    "set-config"|"setconfig"|"sc") # Kamera mit Hilfe von gphoto2 konfigurieren
       comment "Konfiguration der Kamera mittels Dialog"
       # Tastaturabfrage anhalten, um sie für Dialog freizuhalten
       kill -s STOP $Watchreadlinepid
       ardu_gphoto2 set-config "$@"
       kill -s CONT $Watchreadlinepid
       clear
       ;;
    "set-config-value"|"scv") # Kameraeinstellung setzen
       ardu_gphoto2 $Command $*
       ;;
    "set-config-index"|"sci") # Kameraeinstellung setzen
       ardu_gphoto2 $Command $*
       ;;
    "switch"|"switch-config")
       ardu_gphoto2 switch-config $@
       ;;
    "iso")
      case $1 in
        "")   ardu_gphoto2 get-config -a iso ;;
        "-")  Iso=$(ardu_gphoto2 switch-config iso -) ;;
        "+")  Iso=$(ardu_gphoto2 switch-config iso +) ;;
        *)    ardu_gphoto2 set-config-value iso=$1 && Iso=$1 ;;
      esac
      ;;
    "shutter"|"shutterspeed")
      case $1 in
        "") ardu_gphoto2 get-config -a shutterspeed ;;
        +)  Shutterspeed=$(ardu_gphoto2 switch-config shutterspeed +) ;;
        -)  Shutterspeed=$(ardu_gphoto2 switch-config shutterspeed -) ;;
        *)  ardu_gphoto2 set-config-value shutterspeed=$1 && Shutterspeed=$1 ;;
      esac
      ;;
       
    "capture-image"|"cap") 
       comment "Fotoaufnahme in Kameraspeicher"
       setup_projectdir
       ardu_gphoto2 capture-image
       ;;
    "capture-image-and-download"|"capd")
       comment "Fotoaufnahme auf Festplatte"
       setup_projectdir
       ardu_gphoto2 capture-image-and-download
       showimage "$Latestimage"
       comment "Bild gespeichert als $Latestimage"
       ;;
    "capture-preview"|"capp")
       comment "Nehme einzelnes Video-Preview-Bild auf"
       setup_projectdir
       ardu_gphoto2 capture-preview
       showimage "$Latestimage"
       comment "Bild gespeichert als $Latestimage"
       ;;
        
    "zoom"|"u") # eoszoom 1x, 5x, 10x
       case $1 in
         1|5|10) Previewzoom=$1 ;;
         toggle|"") 
           case $Previewzoom in
             1|5) Previewzoom=10 ;;
             10)  Previewzoom=1 ;;
           esac
         ;;
       esac
       ardu_gphoto2 zoom $Previewzoom
       ;;
    "move-zoom")
       ardu_gphoto2 move-zoom $1
       ;;
    "mirrorup"|"m")
       ardu_gphoto2 mirrorup $1
       ;;
         
    "gphoto2") # gphoto2 (mit Optionen) direkt aufrufen. Syntax: Normaler gphoto2-Aufruf
       ardu_gphoto2 gphoto2 $*
       ;;
         
    #### Video ####
    "preview"|"p")
       videoaufnahme preview
       ;;
    "capture-movie-no-preview")
       comment "Videoaufnahme wird gespeichert, aber nicht angezeigt."
       setup_projectdir
       videoaufnahme capture-movie
       comment "Video wird gespeichert als $Latestvideo"
       ;;
    "capture-movie"|"start")
       comment "Videoaufnahme wird gespeichert und angezeigt."
       setup_projectdir
       videoaufnahme capture-movie-and-preview
       comment "Video wird gespeichert als $Latestvideo"
       ;;
    "stop-movie"|"stop")
       comment "Videoaufnahme wird gestoppt"
       videoaufnahme stop-movie
       ;;
       
    #### Stacking ####
    "stack")
       Videomode_restore=""
       setup_projectdir
       stackshot $1 & echo $! stack >>$Backgroundpidfile
       ;;
    "median"|"med")
       Evalstack="yes"
       Evalnumber="${1:-4}"
       [ "$Evalnumber" -gt "1" ] || Evalnumber="1"
       [ "$Evalnumber" =   "1" ] && Evalstack="no"
       ;;
       
    #### Image processing ####
    "bat"|"batch")
       batch_all "$1" & echo $! batch >>$Backgroundpidfile
       ;;
    "align")
       batch_function align "${1:-}" & echo $! batch >>$Backgroundpidfile
       ;;
    "align2")
       batch_function align2 "${1:-}" & echo $! batch >>$Backgroundpidfile
       ;;
    "sharp"|"sharpen")
       batch_function sharpen "${1:-}" "${2:-12x4}"
       ;;
    "compose")
       batch_function evaluate "${1:-}" all
       batch_function compose "${1:-}" all
       ;;
    "contrast")
       batch_function contrast "${1:-}" "${2:-9x50%}"
       ;;
    "crop") batch_function crop "${1:-}"
       ;;
    "white"|"whitebalance"|"wb")
       batch_function whitebalance-choose "${1:-}"
       batch_function whitebalance "${1:-}"
       ;;
       
    "kill")
       while read Pid Name; do
         ps -p $Pid | grep -q -E 'arduterm|enfuse|align_image_stack' && kill "$Pid"
       done <$Backgroundpidfile
       ;;
    "") ;;
    *) fehler "Fehler: unbekanntes Kommando: $Command" ;;
  esac
  # ggf. Video wieder starten
  [ "$Videomode_restore" ] && videoaufnahme $Videomode_restore
}

#######################
#### Hauptprogramm ####

declare_variables() {
  Configfile="$HOME/.config/arduterm.init"
  
  # Farben für späteren Gebrauch definieren
  ROT="\e[31m"
  GELB="\e[33m"
  WEISS="\e[37m"
  BLAU="\e[1;34m"
  
  ZOOM_XPOS=1600
  ZOOM_YPOS=960
  
  Arduhome="$HOME/Bilder/arduterm"
  Latestvideo=
  
  Deviceadresse="/dev/null"
  Devicetimeout=2
  
  Targetmonitor=
  Windowmode=split       # split|fullimage|fullpreview
  
  Schrittweite=1
  Poscurrent=0
  Pos0=0
  Pos1=1000
  Pos2=1001
  
  Previewzoom=1
  Shutterspeed=
  Iso=
  
  Keyboardid=$(xinput | grep "AT Translated" | cut -d= -f2 | awk '{print $1}')
  Xinputpid=
  Watchkeypresspid=
  Watchdevicepid=
  Watchreadlinepid=
  
  Keywatch="off"
  
  Evalnumber="1"
  Evalstack="no"
  Evalwait="2.5"
  
  Fileformat="tif"

  Projektname=""
  Stackshotname="stack"
  
  Convert="convert -quality 100%"
  Xmeasure="/home/lauscher/git/microscopy-tools/xmeasure"
  Whitebalance="/home/lauscher/git/microscopy-tools/whitebalance"
}
create_cachefiles() {
  Cachefolder=/tmp/arduterm
  mkdir -p $Cachefolder
  rm $Cachefolder/* 2>/dev/null
  
  Kameradumpfile=$Cachefolder/gphoto2.dump
  :> $Kameradumpfile
  
  Devicemessagefifo=$Cachefolder/device.message.fifo
  mkfifo $Devicemessagefifo
  exec 7<> $Devicemessagefifo

  Commandfifo=$Cachefolder/command.fifo
  mkfifo $Commandfifo
  exec 4<> $Commandfifo

  Keywatchfifo=$Cachefolder/keywatch.fifo
  mkfifo $Keywatchfifo
  exec 8<>$Keywatchfifo
  
  Workdirfile=$Cachefolder/workdir
  pwd >$Workdirfile
  
  Historyfile=$Cachefolder/history
  :> $Historyfile
  
  Pleasewaitfile=$Cachefolder/parser.action
  :> $Pleasewaitfile
  
  Stackshotfile=$Cachefolder/stackshot.action
  :> $Stackshotfile
  
  Lateststackfile=$Cachefolder/stack.latest
  :> $Lateststackfile
  
  Latestimagefile=$Cachefolder/image.latest
  :> $Latestimagefile
  
  Xtrlockpidfile=$Cachefolder/xtrlock.pid
  :> $Xtrlockpidfile
  
  Latestimagelink=$Cachefolder/image.latest.link
  
  Ardutermrunfile=$Cachefolder/arduterm.action
  echo "action" >$Ardutermrunfile
  
  Backgroundpidfile=$Cachefolder/bgpids
  :> $Backgroundpidfile
  
  Hubloop_stepinfile=$Cachefolder/loop.stepin.action
  Hubloop_stepoutfile=$Cachefolder/loop.stepout.action
  :> $Hubloop_stepinfile
  :> $Hubloop_stepoutfile
  
  Positionfile=$Cachefolder/position
  savepos
}
arduterm_init() {
  local Line= Completeline=
  
  # Bei Abbruch des Programmes (z.B. STRG+C) Funktion arduterm_ende aufrufen
  trap arduterm_ende EXIT
  
  declare_variables
  create_cachefiles

  # Abhängigkeiten prüfen
  command -v gphoto2 >/dev/null || fehler "Warnung: gphoto2 nicht gefunden. Wird benötigt für Kamerasteuerung."
  command -v geeqie >/dev/null  || fehler "Warnung: geeqie nicht gefunden. Wird benötigt für Bildanzeige."
  command -v ffmpeg >/dev/null  || fehler "Warnung: ffmpeg nicht gefunden. Wird benötigt für Videovorschau."
  command -v dialog >/dev/null  || fehler "Warnung: dialog nicht gefunden. Wird benötigt für interaktive Kamerakonfiguration."
  command -v xtrlock >/dev/null || fehler "Warnung: xtrlock nicht gefunden. Wird benötigt für Tastatursteuerung mit CAPSLOCK."
  command -v xinput >/dev/null  || fehler "Warnung: xinput nicht gefunden. Wird benötigt für Tastatursteuerung mit CAPSLOCK."
  command -v xdotool >/dev/null || fehler "Warnung: xdotool nicht gefunden. Wird benötigt für Fensterkontrolle."
  command -v wmctrl >/dev/null  || fehler "Warnung: wmctrl nicht gefunden. Wird benötigt für Fensterkontrolle."
  
  # Gruppe dialout prüfen
  id | grep -q dialout          || fehler "Warnung: Benutzer $(id -un) ist nicht in Gruppe dialout. Wird benötigt, um Arduino anzusteuern."
  
  # Auf Guake Terminal prüfen
  ps -p $(ps -o ppid -p $PPID | tail -n1) | grep -q guake || fehler "Warnung: arduterm ist für Terminal Emulator Guake ausgelegt."
}
arduterm_ende() {
  ## Funktion: Programm sauber beenden
  trap - EXIT
  
  # Eventuell laufende Videoaufnahme stoppen
  videoaufnahme stop-movie
  
  # Hintergrundprozesse stoppen
  for Pid in $Watchreadlinepid $Watchdevicepid $Watchkeypresspid $Xinputpid $(cat $Xtrlockpidfile) $Imageviewerpid $Hubloopstepinpid $Hubloopstepoutpid ; do mykill $Pid ; done
  while read Pid Name; do
    ps -p $Pid | grep -q -E 'arduterm|enfuse|align_image_stack' && {
      fehler "Beende $Pid $Name"
      kill $Pid
    }
  done <$Backgroundpidfile
  
  exec 4<&-
  exec 6<&-
  exec 7<&-
  exec 8<&-

  rm -R $Cachefolder
  
  exit
}
main() {
  arduterm_init
  
  [ "$*" ] && {         # execute single command only if given on cli
    Commandline="$*"
    [ -d "$Commandline" ] || check_fileglob "$Commandline" && Commandline="batch $Commandline"
    cmd_parser $Commandline
    wait
    arduterm_ende
  }
  
  [ -s "$Configfile" ] && cat $Configfile >> $Commandfifo
  
  readline_watch <&0                      & Watchreadlinepid=$!
  
  xinput test $Keyboardid >>$Keywatchfifo & Xinputpid=$!
  keypress_watch                          & Watchkeypresspid=$!
  
  hubloop_stepin                          & Hubloopstepinpid=$!
  hubloop_stepout                         & Hubloopstepoutpid=$!
  
  cmd_loop
  arduterm_ende
}
main "$@"


XXX_align() {
  # align images with align_image_stack.
  # special: devide into two halves starting from the middle and merge again later.
  # run detect_sourcedir() first to set some variables.
  
  local Line Middle Count Filecount Filelist
  local Destinationfile
  local Alignpid

  comment "Aligning stack: ${Sourcedir-$Arduhome}/$Sourcefileglob"
  
  # read filenames in array
  Filecount=-1
  for Line in $(fileglob "$Sourcedir/$Sourcefileglob") ; do
    [ -f "$Line" ] && {
      Filecount=$((Filecount+1))
      Filelist[$Filecount]="$Line"
    }
  done
  [ "$Filecount" = "-1" ] && fehler "align: Keine Bilder gefunden" && return 1
  
  # create temporary working dirs
  mkdir $Sourcedir/align.tmp.1
  mkdir $Sourcedir/align.tmp.2
  mkdir $Sourcedir/align.tmp.3

  # split files with softlinks into two folders
  # reverse order for first half of images in folder 1
  # middle file is part of both folders and the first of both alignments
  Middle=$((Filecount / 2))
  for ((Line=0 ; Line<=Middle ; Line++)); do
    ln -s ${Filelist[$Line]} $Sourcedir/align.tmp.1/sl$(printf %04d $((Middle-Line)))
  done
  for ((Line=Middle ; Line<=Filecount ; Line++)); do
    ln -s ${Filelist[$Line]} $Sourcedir/align.tmp.2/sl$(printf %04d $Line)
  done
#  for ((Line=0 ; Line<=Filecount ; Line++)); do
#    ln -s ${Filelist[$Line]} $Sourcedir/align.tmp.2/sl$(printf %04d $Line)
#  done
  
  # align both folders
  time align_image_stack -l -m -s 0 --use-given-order -a $Sourcedir/align.tmp.1/align $Sourcedir/align.tmp.1/sl* 2>&1 | grep -v "Unable to read EXIF data" & Alignpid1=$!
  time align_image_stack -l -m -s 0 --use-given-order -a $Sourcedir/align.tmp.2/align $Sourcedir/align.tmp.2/sl* 2>&1 | grep -v "Unable to read EXIF data" & Alignpid2=$!
  echo $Alignpid1 align >>$Backgroundpidfile
  echo $Alignpid2 align >>$Backgroundpidfile
  wait $Alignpid1
  wait $Alignpid2
#  time align_image_stack -C -l -m -v -v --use-given-order -a $Sourcedir/align.tmp.2/align $Sourcedir/align.tmp.2/sl* 2>&1 | grep -v "Unable to read EXIF data" & Alignpid=$!
#  echo $Alignpid align >>$Backgroundpidfile
#  wait $Alignpid
  
  # move aligned images in right order to source dir
  [ "$Sourcefileglob" = "s_*" ] && Destinationprefix="sa_" || Destinationprefix="a_"
    for ((Line=0 ; Line<=Middle ; Line++)); do
    Destinationfile="$(basename ${Filelist[$((Middle - Line))]})"
    [ "$Sourcefileglob" = "s_*" ] && Destinationfile="${Destinationcode}_$(cut -d_ -f2- <<< "$Destinationfile")" ||  Destinationfile="${Destinationcode}_$Destinationfile"
    Destinationfile="$(echo $Destinationfile | rev | cut -d. -f2- | rev).tif"
    mv $Sourcedir/align.tmp.1/align$(printf %04d $Line).tif  $Destinationdir/$Destinationfile
#     mv $Sourcedir/align.tmp.1/align$(printf %04d $Line).tif  $Sourcedir/align.tmp.3/$Destinationfile
  done
  Count=0
  for ((Line=Middle ; Line<=Filecount ; Line++)); do
    Destinationfile="$(basename ${Filelist[$((Line))]})"
    [ "$Sourcefileglob" = "s_*" ] && Destinationfile="${Destinationcode}_$(cut -d_ -f2- <<< "$Destinationfile")" ||  Destinationfile="${Destinationcode}_$Destinationfile"
    Destinationfile="$(echo $Destinationfile | rev | cut -d. -f2- | rev).tif"
    mv $Sourcedir/align.tmp.2/align$(printf %04d $((Count))).tif $Destinationdir/$Destinationfile
#    mv $Sourcedir/align.tmp.2/align$(printf %04d $((Count))).tif $Sourcedir/align.tmp.3/$Destinationfile
    Count=$((Count+1))
  done
#  time align_image_stack -l -C --use-given-order -a $Sourcedir/align.tmp.3/align $Sourcedir/align.tmp.3/$Sourcefileglob 2>&1 | grep -v "Unable to read EXIF data" & Alignpid=$!
#  echo $Alignpid align >>$Backgroundpidfile
#  wait $Alignpid
#  for ((Line=0 ; Line<=Filecount ; Line++)); do
#    Destinationfile="$(basename ${Filelist[$((Line))]})"
#    [ "$Sourcefileglob" = "s_*" ] && Destinationfile="${Destinationcode}_$(cut -d_ -f2- <<< "$Destinationfile")" ||  Destinationfile="${Destinationcode}_$Destinationfile"
#    Destinationfile="$(echo $Destinationfile | rev | cut -d. -f2- | rev).tif"
#    mv $Sourcedir/align.tmp.3/align$(printf %04d $Line).tif $Destinationdir/$Destinationfile
#  done
#  Count=0
#  for ((Line=0 ; Line<=Filecount ; Line++)); do
#    Destinationfile="$(basename ${Filelist[$((Line))]})"
#    [ "$Sourcefileglob" = "s_*" ] && Destinationfile="${Destinationcode}_$(cut -d_ -f2- <<< "$Destinationfile")" ||  Destinationfile="${Destinationcode}_$Destinationfile"
#    Destinationfile="$(echo $Destinationfile | rev | cut -d. -f2- | rev).tif"
#    mv $Sourcedir/align.tmp.2/align$(printf %04d $((Count))).tif $Destinationdir/$Destinationfile
#    Count=$((Count+1))
#  done
  
  # remove workdirs with softlinks
  rm -R $Sourcedir/align.tmp.1
  rm -R $Sourcedir/align.tmp.2
  rm -R $Sourcedir/align.tmp.3
  
  comment "Align ready: ${Sourcedir-$Arduhome}/$Sourcefileglob"
}
XXX_trim_hard() {
  # Remove border color of image similar to -trim, but also cut the parts of image that contain the border color.
  # Weakness: Does no corner detection. Just ignores the outer 10% of each image corner and trims the inner 80%.
  # Not foolproof, but works for my use cases.
  # $1  Imagefile
  # $2  Color to trim. Default: transparent
  # Result: output of crop values for later use.
  
  local Image Trimcolor
  local Imagewidth Imageheight Xoffset Yoffset
  local Top Bottom Left Right
  
  Image="${1:-}"
  Trimcolor="${2:-"#00000000"}"
  
  Imagewidth=$($Convert  -format '%w'  $Image info:)
  Imageheight=$($Convert -format '%h'  $Image info:)
  Xoffset=$((Imagewidth / 10))
  Yoffset=$((Imageheight / 10))
  
  for ((Top=0;                Top    <= Imageheight; Top++ )); do
    $Convert $Image -crop $((Imagewidth -Xoffset*2))x1+$Xoffset+$Top    txt: | grep -q "$Trimcolor" || break
  done
  for ((Bottom=$Imageheight;  Bottom >= 0;           Bottom-- )); do
    $Convert $Image -crop $((Imagewidth -Xoffset*2))x1+$Xoffset+$Bottom txt: | grep -q "$Trimcolor" || break
  done
  for ((Left=0;               Left   <= Imagewidth;  Left++)); do
    $Convert $Image -crop 1x$((Imageheight -Yoffset*2))+$Left+$Yoffset  txt: | grep -q "$Trimcolor" || break
  done
  for ((Right=$Imagewidth;    Right  >= 0;           Right--)); do
    $Convert $Image -crop 1x$((Imageheight -Yoffset*2))+$Right+$Yoffset txt: | grep -q "$Trimcolor" || break
  done
  echo "$((Right-Left))x$((Bottom-Top))+$Left+$Top"
}
