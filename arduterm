#! /bin/bash

#############################################################################
## arduterm
# Arduino Terminal: Skript, um PC und Arduino kommunizieren zu lassen.
#                   Fragt Kommandos von der Tastatur und vom Arduino ab und kann darauf reagieren.
#                   Kann Signale an den Arduino senden und vom Arduino empfangen.
#                   Auch andere Geräte/Devices sind grundsätzlich ansteuerbar.
#                   Signalbasis: Zeichenfolgen, abgeschlossen mit NL/Newline/0xA/Enter.
#                   arduterm kann einfache Skripte mit arduterm-Kommandos ausführen.
#                   Steuerung durch andere Skripte ist durch Eintrag von Kommandos
#                   in die Datei /tmp/arduterm/arduterm.commands.execute möglich.
# Primäres Ziel:    Fotostacking automatisieren mit einem an einen Arduino angeschlossenen 
#                   Schrittmotor/Stackingschlitten und einer per USB angeschlossenen Kamera.
#                   Dabei Aufnahme von Bildern und Videos mit gphoto2
#                   Live-Vorschau von bildern und Videos mit geeqie und ffmpeg
#
# Integration von gphoto2:
#  - Videoaufnahme aus Preview-Bildern
#  - Fotoaufnahme, speichern in Kamera oder auf Festplatte
#  - Preview-Fotoaufnahme ohne Bewegung von Shutter oder Spiegel
#  - Kamera konfigurieren
# Integration von ffmpeg und geeqie
#  - Videovorschau mit ffmpeg und ffplay
#  - Video mit ffmpeg in Einzelbilder zerlegen
#  - Fotovorschau mit Bildbetrachter geeqie
#
# Benötigt gphoto2 in Version 2.5.9 oder höher, um fehlerfrei die Kamera anzusteuern
# Benötigt die Pakete gphoto2, ffmpeg, geeqie und dialog
# Getestet mit Canon EOS 1000D
#
# Steuerung durch externe Programme möglich durch Eintrag von Kommandos
# in die Datei /tmp/arduterm/arduterm.command.execute
#############################################################################

VERSION="v0.4.0-beta"

shopt -s extglob

########################################
#### Programmspezifische Funktionen ####

comment() {
  ## Funktion: Allgemeine Meldungen ausgeben
  local Message
  Message="$(sed "s%$Arduhome%-%g" <<< "$*")"
#  echo -e "${GELB}${Message}${WEISS}" >&2
  echo "Note: $Message" >>$Ardulogfile
  return 0
}
cmdstatus() {
  local Message
  Message="cmd:${1:-}"
  shift
  Message="$Message=$*"
  echo "$Message" >> $Ardulogfile
  echo "$Message" >> $Cmdstatusfile
}
fehler() {
  ## Funktion: Fehlermeldungen ausgeben
  local Message
  Message="$(sed "s%$Arduhome%-%g" <<< "$*")"
#  echo -e "${ROT}${Message}${WEISS}" >&2
echo $Message
  echo "ERROR: $Message" >>$Ardulogfile
  return 0
}
mykill() {
  # Funktion: Prozeß $1 beenden
  local Pid=
  Pid="${1:-}"
  ps -p $Pid >/dev/null 2>&1 && {
    kill $Pid
    wait $Pid 2>/dev/null
  } || return 1
}
window_wait() {
  for ((i=1 ; i<=50 ; i++)); do
    xdotool search --name "${1:-}" >/dev/null && break
    #sleep 0.01
  done
}

storeinfo() {                   # store some information for later use
  # store and provide pieces of information
  # replace entry if codeword is already present
  # Store as codeword=string:
  #   $1 codeword=string
  # Dump stored string:
  #   $1 dump
  #   #2 codeword
  # Drop stored string:
  #   $1 drop
  #   #2 codeword
  # Test for codeword: (return 1 if not found)
  #   $1 test
  #   $2 codeword
  #
  # note: sed -i causes file permission issues if called in container in Cygwin, compare ticket #187
  #       chmod 666 for $Sharefolder could probably fix that. (FIXME)
  #
  [ -e "$Storeinfofile" ] || return 1
  case "${1:-}" in
    dump) grep     "^${2:-}="   $Storeinfofile | sed "s/^${2:-}=//" ;;      # dump entry
    drop) sed -i  "/^${2:-}=/d" $Storeinfofile ;;                           # drop entry
    test) grep -q  "^${2:-}="   $Storeinfofile ;;                           # test for entry
    *)                                                                      # store entry
      sed -i "/^$(echo "${1:-}" | cut -d= -f1)=/d"     $Storeinfofile       # drop possible old entry
      echo "${1:-}"                                 >> $Storeinfofile
    ;;
  esac
}
###########################
#### Dateioperationen  ####

get_latest_file() {
  ## Funktion: Neueste erstellte Datei ermitteln
  # $1 kann Suche auf Dateien DATEI* begrenzen
  ls -p -t $1* 2> /dev/null | grep -v "/" | head -n 1
}
get_last_file() {
  ## Funktion: Die alphabetisch/numerisch letzte Datei, die mit $1 beginnt, ermitteln und Name ausgeben
  basename -a $(find "$(dirname "$(realpath ${1:-})" )" -mindepth 1 -maxdepth 1) | grep "$(basename ${1:-})" | sort | tail -n1
}
get_free_filenumber(){
  ## Funktion: Zu Dateiname $1 nächste freie Nummer ausgeben
  # $1  Dateiname ohne Nummer und _ohne_ suffix, nach dem Prinzip
  #     DATEINAME_000x.jpg nur DATEINAME übergeben. 
  #     DATEINAME darf keine Unterstriche _ oder Zahlen 0..9 oder Punkte enthalten
  local Nummer
  Nummer=$(get_last_file $1 | rev | cut -d_ -f1 | rev | cut -d. -f1)  
  printf "%04d" $(bc <<<"${Nummer:-"-1"} + 1")
}
check_fileglob() {
  # check whether files exist for glob $1
  local File
  for File in $(eval echo $@); do
    [ -f "$File" ] && return 0
  done
  return 1
}
check_dirglob() {
  # check whether directories exist for glob $1
  local File
  for File in ${1:-}; do
    [ -d "$File" ] && return 0
  done
  return 1
}
fileglob() {
  # echos files only for glob $1
  # (except those with .pto in their name)
  local File Filelist
  for File in $*; do
    [ -f "$File" ] && Filelist="$Filelist
$File"
  done
  Filelist=$(sed '/^$/d'    <<< "$Filelist" | sort)
  Filelist=$(grep -v '.pto' <<< "$Filelist")
  [ "$Filelist" ] && echo $Filelist || return 1
}
dirglob() {
  # echos directories only for glob $1
  # (except those with .pto in their name)
  local File Filelist
  for File in ${1:-}; do
    [ -d "$File" ] && Filelist="$Filelist
$File"
  done
  Filelist=$(sed '/^$/d'    <<< "$Filelist" | sort)
  Filelist=$(grep -v '.pto' <<< "$Filelist")
  [ "$Filelist" ] && echo $Filelist || return 1
}
setup_projectdir() {
  [ "${1:-}" ] && Projektname="${1:-}.$(date +%Y-%m-%d)"
  Projektname="${Projektname:-project.$(date +%Y-%m-%d)}"
  cd "$Arduhome"
  mkdir -p "$Projektname"
  cd "$Projektname"
  pwd > $Workdirfile
}
check_doubledir() {
  # splits directory name $1 at dots . and checks if a directory exists in sequence variations of the name

  local IFS Dir Basedir Line Count Combi
  
  Dir="${1:-}"
  Basedir="$(dirname "$Dir")"
  Dir="$(basename "$Dir")"
  
  IFS="."
  Count=-1
  for Line in $Dir; do
     Count=$((Count+1))
  done
  IFS=" "
  
  Dir="{$(tr '.' ',' <<< "$Dir")}"
  for ((i=0 ; i<=Count; i++));do
    Combi="$Combi.$Dir"
  done
  Combi="${Combi#'.'}"
  
  for Line in $(eval echo $Combi); do
    [ -d "$Basedir/$Line" ] && return 0
  done
  return 1
}
check_destinationfile() {
  local Destinationfile Function
  Destinationfile="${1:-}"
  Function="${2:-}"
  [ -e "$Destinationfile" ] && {
    #fehler "$Function: Destination file already exists: $Destinationfile"
    fehler "$Function: Destination file already exists: $(basename "$Destinationfile")"
    return 1
  }
  return 0
}

###########################################
#### Kommunikation mit Device/Arduino  ####

device_init() {
  ## Funktion: Device initialisieren und Überwachung starten

  # Falls eine Instanz von watch_device() läuft, beenden
  ps -p "$Watchdevicepid" >/dev/null 2>&1 && {
    comment "Überwachung von $Deviceadresse wird beendet ..."
    kill $Watchdevicepid
    wait $Watchdevicepid 2>/dev/null
    exec 6<>-
  }

  # Device auf Gültigkeit prüfen
  Deviceadresse="${1:-$Deviceadresse}"
  [ -e "$Deviceadresse" ] || {
    fehler "Fehler: Geräteadresse nicht gefunden: $Deviceadresse"
    Deviceadresse="/dev/null"
    fehler "Setze Geräteadresse auf $Deviceadresse"
  }
  
  # Daten von Device auf fifo umleiten
  comment "Beginne Überwachung von $Deviceadresse"
  exec 6<>$Deviceadresse
  cat <&6 >>$Devicemessagefifo & Watchdevicepid=$!
    
  # Seriellen Port initialisieren
  stty -F $Deviceadresse raw ispeed 9600 ospeed 9600 cs8 -hupcl -ignpar -cstopb -echo || {
    fehler "Fehler bei Initialisierung von Device $Deviceadresse"
    return 1
  }
  sleep 2
}
device_send() {

  ## Funktion: Daten an Arduino senden  
  # Alle übergebenen Optionen werden an $Deviceadresse gesendet
  echo "$*" >&6
}
device_wait() {
  ## Funktion: Auf ein beliebiges Signal vom Arduino warten
  local Antwort=
  
  read -t ${1:-$Devicetimeout} -r Antwort <&7
  
  [ "$Antwort" ] || {
    fehler "Device: TIMEOUT"
    echo "TIMEOUT"
    return 1
  }
  
  comment "Arduino meldet: $Antwort"
  echo "$Antwort"
  return 0
}
device_check() {
  # Prüfen, ob Arduino auf Kontrollsignal "c" antwortet
  device_send c
  [ "$(device_wait)" = "TIMEOUT" ] && return 1 || return 0
}
setpos0() {
  ## Funktion: Positionszähler von Arduino auf 0 setzen.
  local Antwort
  device_send z
  Antwort="$(device_wait)"
}

####################################
#### Video- und Bildfunktionen  ####

videoaufnahme() {
  ## Funktion: Videoaufnahme starten oder stoppen, mit Speichern auf Festplatte oder ohne
  # $1  Aufnahmemodus
  local Videodauer GPHOTO2 FFMPEG FFPLAY
  
  # Videoaufnahme pauschal stoppen
  mykill $Ffplaypid
  Ffplaypid=
  
  Videodauer="3600s"
  Videomode=$1
  
  GPHOTO2="mygphoto2 --capture-movie=$Videodauer --stdout"
  FFMPEG="ffmpeg -loglevel error -i -  -c:v copy -f mpjpeg  - "
  FFPLAY="ffplay -loglevel error -sync ext -window_title arduterm-Video - "

  case $1 in
    preview)
      $GPHOTO2 | $FFPLAY & Ffplaypid=$!
    ;;
    capture-movie)
      # Dateiname für neues Video
      Latestvideo="$(pwd)/movie_$(get_free_filenumber) movie).mjpg"
      $GPHOTO2 > $Latestvideo & Ffplaypid=$!
    ;;
    capture-movie-and-preview)
      # Dateiname für neues Video
      Latestvideo="$(pwd)/movie_$(get_free_filenumber) movie).mjpg"
      $GPHOTO2 | $FFMPEG | tee $Latestvideo | $FFPLAY & Ffplaypid=$!
    ;;
    stop-movie)
      # Videowiedergabe/aufnahme stoppen. 
      # Da das bereits am Anfang dieser Funktion geschieht, 
      # muß weiter nichts getan werden
      Videomode=""
    ;;
  esac
  
  # Fenster arrangieren
  ps -p $Ffplaypid >/dev/null 2>&1 && {
    [ "$Windowmode" = "fullimage" ]   && Windowmode="split"
    [ "$Imageviewerpid" ]             || Windowmode="fullpreview"
    window_wait arduterm-Video
    window_placement
  } &
}
showimage() {
  ## Funktion: Imageviewer starten
  # $1 = Bildname
  
  #mykill $Imageviewerpid
  #sxiv -sf $1 2>/dev/null & Imageviewerpid=$!
  geeqie -t -r file:"${1:-}"
  #display -remote "${1:-}"  & Imageviewerpid=$!
  #[ "${1:-}" ] && ln -f -s "$(realpath ${1:-})" $Latestimagelink
  #pgrep imvr >/dev/null || imvr "$Latestimagelink"  & Imageviewerpid=$!
  
  # Fenster arrangieren
  {  
    [ "$Windowmode" = "fullpreview" ] && Windowmode="split"
    [ "$Ffplaypid" ]                  || Windowmode="fullimage"
    window_wait Geeqie
#    window_wait imv
#    window_wait sxiv
 #
 #window_wait ImageMagick
    window_placement
  } &
}
showimagehalf() {
  local Sourceimage Destinationimage
  local Cacheimage
  Sourceimage="${1:-}"
  Destinationimage="${2:-}"
  Cacheimage=$Cachefolder/diff.jpg
  $Convert $Sourceimage -crop 50%x100%+0+0 $Cacheimage.half.jpg
  composite -geometry +0+0 $Cacheimage.half.jpg $Destinationimage $Cacheimage
  showimage $Cacheimage
}
showimagediff() {
  local Sourceimage Destinationimage Cacheimage
  Sourceimage="${1:-}"
  Destinationimage="${2:-}"
  Commentsource="${3:-previous}"
  Commentdestination="${4:-new}"
  Cacheimage=$Cachefolder/diff.jpg
  montage -geometry +0+0 -label "$Commentsource" $Sourceimage -label "$Commentdestination" -flop $Destinationimage $Cacheimage
  showimage $Cacheimage
}
window_placement() {
  ## Funktion: Fenster von Imageviewer und Videospieler nebeneinander oder maximiert anordnen.
  ## Zweiten Monitor bevorzugen. Guake Terminal oben halten.
  
  local Targetmonitor Screenpos ScreenX ScreenW
  
  # Versuche, zweiten Monitor zu finden.
  Targetmonitor=$(xrandr | grep " connected" | grep -v "+0+0" | cut -d' ' -f1 | head -n1)
  [ "$Targetmonitor" ] || Targetmonitor=$(xrandr | grep " connected" | cut -d' ' -f1 | head -n1)
  
  Screenpos=$(xrandr | grep $Targetmonitor | sed 's/primary//' | awk '{print $3}')
  ScreenX=$(cut -d+ -f2 <<< "$Screenpos")
  ScreenW=$(cut -dx -f1 <<< "$Screenpos")
  ScreenH=$(cut -dx -f2 <<< "$Screenpos" | cut -d+ -f1)

  
  case $Windowmode in
    split)
#      wmctrl -r sxiv -e 0,$ScreenX,0,$(bc <<< "$ScreenW / 2"),-1
#      wmctrl -r ImageMagick: -e 0,$ScreenX,0,$(bc <<< "$ScreenW / 2"),-1
#      wmctrl -r imv -e 0,$ScreenX,0,$(bc <<< "$ScreenW / 2"),-1
      wmctrl -r Geeqie -e 0,$ScreenX,0,$(bc <<< "$ScreenW / 2"),-1
      wmctrl -r arduterm-Video -e 0,$(bc <<< "$ScreenX + $ScreenW / 2"),0,$(bc <<< "$ScreenW / 2"),-1
#      wmctrl -r sxiv -b add,maximized_vert
#      wmctrl -r ImageMagick: -b add,maximized_vert
#      wmctrl -r imv -b add,maximized_vert
      wmctrl -r Geeqie -b add,maximized_vert
      wmctrl -r arduterm-Video -b add,maximized_vert
      wmctrl -a Guake
    ;;
    fullimage)
#      wmctrl -r sxiv -e 0,$ScreenX,0,$ScreenW,-1
#      wmctrl -r imv -e 0,$ScreenX,0,$ScreenW,-1
      wmctrl -r Geeqie -e 0,$ScreenX,0,$ScreenW,-1
      #wmctrl -r ImageMagick: -e 0,$ScreenX,0,$ScreenW,$ScreenH
#      wmctrl -r sxiv -b add,maximized_vert
#      wmctrl -r ImageMagick: -b add,maximized_vert,maximized_horz
#      wmctrl -r imv -b add,maximized_vert,maximized_horz
      wmctrl -r Geeqie -b add,maximized_vert,maximized_horz
#      wmctrl -a sxiv
      #wmctrl -a ImageMagick
      wmctrl -a Guake
    ;;
    fullpreview)
      wmctrl -r arduterm-Video -e 0,$ScreenX,0,$ScreenW,-1
      wmctrl -r arduterm-Video -b add,maximized_vert
      wmctrl -a arduterm-Video
      wmctrl -a Guake
    ;;
  esac
}

########################################
#### gphoto2-spezifische Funktionen ####

mygphoto2() {
  comment "Aufruf von: gphoto2 $@"
  gphoto2 "$@" 2>$Ardulogfile
  return $?
}
ardu_gphoto2 () {
  ## Funktion: Sammlung und Koordination der gphoto2-Aufrufe
  #
  local Command Return=0
 
  Command=$1
  shift
  case $Command in
    set-config)                               # Konfigurationsdialog
      ardu_gphoto2_set_config_dialog $@
      Return=$?
      ;; 
    get-config)                               # Kameraeinstellung lesen
      gphoto2_get_config $@
      Return=$? 
      ;;
    set-config-value|scv)                     # Kameraeinstellung setzen (Wert)
      mygphoto2 --set-config-value $@
      Return=$? 
      ;;
    set-config-index|sci)                     # Kameraeinstellung setzen (Indexnummer)
      mygphoto2 --set-config-index $@
      Return=$? 
      ;;
    switch-config)                            # Kameraeinstellung: Im Index eines weiter (+) oder zurück (-)
      gphoto2_switch_config $@
      Return=$? 
      ;;
    capture-image)                            # Bild aufnehmen und auf Kamera speichern
      mygphoto2 --capture-image
      Return=$? 
      ;;
    capture-image-and-download)               # Bild aufnehmen und herunterladen
      # %C als Suffix läßt gphoto2 Dateiende selbst richtig einsetzen (jpg oder cr2 oder ...)
      Latestimage="$(pwd)/capture_$(get_free_filenumber capture).%C"
      mygphoto2 --capture-image-and-download --filename $Latestimage
      Return=$?
      # Dateiname mit tatsächlichem Suffix ermitteln. 
      Latestimage="$(pwd)/$(get_latest_file "capture*.jpg")"
      [ "$Latestimage" ] || Latestimage="$(pwd)/$(get_latest_file "capture*")"
      echo "$Latestimage" > $Latestimagefile
      ;;
    capture-preview)                         # Einzelnes Videobild aufnehmen, ohne daß der Spiegel zuklappt
      ## Funktioniert ab gphoto2 Version >= 2.5.9 ##
      mygphoto2 --set-config-value viewfinder="1"
      mygphoto2 --capture-preview
      Return=$?
      [ "$Return" = "0" ] && {
        Latestimage="$(pwd)/preview_$(get_free_filenumber preview).jpg"
        mv capture_preview.jpg $Latestimage
        echo "$Latestimage" > $Latestimagefile
      } 
      ;;
    mirrorup)                                 # Viewfinder einschalten = Spiegel hoch
      mygphoto2 --set-config-value viewfinder="1"
      Return=$? 
      ;;
    zoom)                                     # Viewfinder-Zoom setzen. Zulässige Werte sind 1, 5, und 10
      mygphoto2 --set-config-value eoszoom=$1
      Return=$? 
      ;;
    move-zoom)                                # Position von Viewfinder-Zoom ändern
      case $1 in
        x) ZOOM_XPOS="$[$ZOOM_XPOS+$2]" ;;
        y) ZOOM_YPOS="$[$ZOOM_YPOS+$2]" ;;
      esac
      [ "$ZOOM_XPOS" -lt "0" ] && ZOOM_XPOS="0" 
      [ "$ZOOM_YPOS" -lt "0" ] && ZOOM_YPOS="0" 
      mygphoto2 --set-config-value eoszoomposition="$ZOOM_XPOS,$ZOOM_YPOS"
      Return=$? 
      ;;
    gphoto2) # gphoto2 direkt aufrufen
      mygphoto2 $@
      return=$?
      ;;
    *)
      fehler "ardu_gphoto2() mit ungültigen Parametern aufgerufen: $Command $@"
      Return=1
      ;;
  esac
  return $Return
}
gphoto2_switch_config() {
  ## Funktion=Konfiguration vom Typ RADIO umschalten mit + oder -
  # $1  Zu verändernder Konfigurationswert, Name im Config-Baum
  # $2  + oder - für nächsten oder vorherigen Wert.
  #     +n oder -n für n-weiten Schritt im config-Index
  #     keine Angabe = +1
  #     n ohne '+' oder '-' => +n
  # Bei Überschreiten/Unterschreiten des Index wird auf Anfang/Ende vom Index gesetzt 

  local Choicecount Configlabel Configtype Configcurrent 
  local Dumpline Dumplineleft Dumplineright
  
  # Derzeitige Konfiguration auslesen und speichern
  mygphoto2 --get-config $1 > $Kameradumpfile || {
    fehler "Fehler: Konfiguration der Kamera für $1 konnte nicht gelesen werden"
    return 1
  }
  
  # Konfiguration parsen
  while read Dumpline ; do
    Dumplineleft="$(cut -d: -f1 <<< $Dumpline)"
    Dumplineright="$(cut -d' ' -f2- <<< $Dumpline)"
    case $Dumplineleft in
      Label)   Configlabel="$Dumplineright" ;;
      Type)    Configtype="$Dumplineright" ;;
      Current) Configcurrent="$Dumplineright" ;;
      Readonly) ;;
      END) ;;
      Choice) 
        [ "$(cut -d' ' -f2 <<<"$Dumplineright")" = "$Configcurrent" ] && Configcurrentindex="$(cut -d' ' -f1 <<<"$Dumplineright")" 
        Choicecount=$((Choicecount + 1))
      ;;
      "") ;;
    esac
  done <$Kameradumpfile
  
  case $Configtype in
    RADIO) ;;
    TEXT|DATE|TOGGLE)
      fehler "Fehler: Werte vom Typ $TYPE können nicht mit Kommando 'switch' geändert werden."
      fehler "        Bitte Kommando 'set-config-value $1=WERT' oder 'set-config $1' verwenden."
      return 1
    ;;
  esac
  
  # Indexänderung berechnen
  case $2 in
    "+"|"") Change="+1" ;;
    "-")    Change="-1" ;;
    *)
      case $(cut -c1 <<< $2) in
        "+"|"-") Change="$2" ;;
        *)       Change="+$2" ;;
      esac
    ;;
  esac
  Newindex=$(($Configcurrentindex $Change))
  # wrap index out of range
  [ "$Newindex" -ge "$Choicecount" ] && Newindex=0
  [ "$Newindex" -lt "0" ] && Newindex=$((Choicecount -1))
  
  # Neuen Wert ermitteln
  while read Dumpline; do
    [ "$(cut -d' ' -f2 <<<"$Dumpline")" = "$Newindex" ] && Newcurrent="$(cut -d' ' -f3- <<<"$Dumpline")" && break
  done < <(grep Choice <$Kameradumpfile)
 
  # Neuen Index setzen
  mygphoto2 --set-config-index $1=$Newindex || {
    fehler "Fehler: $1: $Configlabel $Configcurrent konnte nicht geändert werden"
    echo $Configcurrent
    return 1
  }
  echo "$Newcurrent"
  return 0
}
gphoto2_get_config() {
  ## Funktion: Kameraeinstellungen anzeigen
  # Usage: [-a | all] [ENTRY]
  # ohne Optionen      Tabelle aller RADIO/MENU Einstellungen ausgeben
  # ENTRY              Einstellung von ENTRY ausgeben
  # -a, all            Tabelle aller Einstellungen ausgeben
  #                    Mit ENTRY: Dump des ENTRY Eintrags ausgeben
  
  local Tabelle Configentry Configlabel Configtype Configcurrent Dumpline Showall
  
  case "${1:-}" in
    "-a"|"all") Showall="yes" && shift ;;
    *)          Showall="no" ;;
  esac

  case $1 in
    "") # Keine einzelne Einstellung angegeben: Alle RADIO und MENU Einstellungen anzeigen
      mygphoto2 --list-all-config > $Kameradumpfile || {
        fehler "Konnte Kamera nicht auslesen"
        return 1
      }
      
      while read Dumpline ; do
      
        Dumplineleft="$(cut -d: -f1 <<< "$Dumpline")"
        case $Dumplineleft in
          Label|Type|Current) Dumplineright="$(cut -d' ' -f2- <<< "$Dumpline")" ;;
        esac
        
        case $Dumplineleft in
          Label)    Configlabel="$Dumplineright" ;;
          Type)     Configtype="$Dumplineright" ;;
          Current)  Configcurrent="$Dumplineright" ;;
          Readonly) ;;
          Choice)   ;;
          END)
            echo -n "." >&2    # ...
            case $Configtype in
              RADIO|MENU)
                Tabelle="$Tabelle
${Configentry}§${Configlabel}§${Configcurrent}"
                ;;
              *|TOGGLE|TEXT|DATE)
                [ "$Showall" = "yes" ] && Tabelle="$Tabelle
${Configentry}§${Configlabel}§${Configcurrent}"
                ;;
            esac
            ;;
          *) [ "$(cut -c1 <<< "$Dumpline")" = "/" ] && Configentry="$(basename "$Dumpline")" ;;
        esac
        
      done <$Kameradumpfile
      echo ""
  
      # Ergebnis in eine übersichtliche Tabelle verwandeln
      Tabelle="$(sort <<< "$Tabelle")"
      column -t -s"§" <<< "$Tabelle"
      ;;
    
    *) # einzelnes Config als Option angegeben
      mygphoto2 --get-config $1 > $Kameradumpfile && {
        case $Showall in
          yes) cat $Kameradumpfile ;;
          no)  grep "Current" <$Kameradumpfile | cut -d' ' -f2- ;;
        esac
      } || fehler "Fehler: Konfiguration der Kamera konnte nicht gelesen werden"
      ;;
  esac
}
ardu_gphoto2_set_config_dialog() {
  ## Funktion: Dialogboxen zur Konfiguration der Kamera erzeugen
  # $1   ENTRY, der zu konfigurieren ist. Wenn leer, alle Configentrys zur Auswahl anbieten
  local Configentry= Count= Dialogoptions= Line=

  Configentry=$1
  
  # Auswahl aus allen Konfiguartionsmöglichkeiten anbieten
  [ -z "$Configentry" ] && {
    mygphoto2 --list-all-config > $Kameradumpfile || {
      fehler "Konnte Kamerakonfiguration nicht lesen."
      return 1
    }
    
    declare -i Count="0"
    while read -r Line ; do
      Configentry[$Count]="$(basename $Line)"
      Count=$Count+1
    done < <(look "/" $Kameradumpfile)

    declare -i Count="0"
    while read -r Line ; do
      LABEL[$Count]="$(cut -d ' ' -f2- <<<"$Line")"
      Count=$Count+1
    done < <(look "Label:" $Kameradumpfile)
  
    declare -i Count="0"
    while read -r Line ; do
      TYPE[$Count]="$(cut -d ' ' -f2- <<<"$Line")"
      Count=$Count+1
    done < <(look "Type:" $Kameradumpfile)
    
    declare -i Count="0"
    while read -r Line ; do
      CURRENT[$Count]="$(cut -d ' ' -f2- <<< "$Line")"
      Count=$Count+1
    done < <(look "Current:" $Kameradumpfile)
      
    # Optionen sortieren, Type RADIO zuerst
    :> $Kameradumpfile
    while [ "$Count" -ge "1" ] ; do
      Count=$Count-1
      case ${TYPE[$Count]} in
        RADIO|MENU) echo -n "AAAA " >> $Kameradumpfile ;;
        TOGGLE) echo -n "BBBB " >> $Kameradumpfile ;;
        TEXT) echo -n "DDDD " >> $Kameradumpfile ;;
        DATE) echo -n "EEEE " >> $Kameradumpfile ;;
        *) echo -n "CCCC " >> $Kameradumpfile ;;
      esac
      echo "'${Configentry[$Count]}' '${LABEL[$Count]}§${TYPE[$Count]}§${CURRENT[$Count]}'" >> $Kameradumpfile
    done
    while read -r Line ; do
      Dialogoptions="$Dialogoptions $(echo $Line | cut -d ' ' -f2-)"
    done < <(sort -V $Kameradumpfile)
      
    Configentry=$(eval dialog --column-separator '§' --menu '"Kamera Konfiguration auswählen"' 40 120 30 $Dialogoptions 3>&1 1>&2 2>&3 3>&-)
  }

  # Einzelne Konfiguration ändern
  [ -n "$Configentry" ] && {
    comment "Lese Konfiguration von $Configentry von der Kamera, bitte warten ..."
    mygphoto2 --get-config $Configentry > $Kameradumpfile || {
      fehler "Fehler: Konfiguration der Kamera konnte nicht gelesen werden"
      return 1
    }

      INDEX="0"
      Dialogoptions=""
      LABEL=`look "Label:" $Kameradumpfile | cut -d ' ' -f2-`
      TYPE=`look "Type:" $Kameradumpfile | cut -d ' ' -f2-`
      CURRENT=`look "Current:" $Kameradumpfile | cut -d ' ' -f2-`
      while read -r Line ; do
        CHOICE[$INDEX]=`echo -n $Line | cut -d ' ' -f3-`
        Dialogoptions="$Dialogoptions $INDEX '${CHOICE[$INDEX]}'"
        if [ "${CHOICE[$INDEX]}" = "$CURRENT" ] ; then Dialogoptions="$Dialogoptions on"
        else Dialogoptions="$Dialogoptions off" ; fi
        INDEX=$[$INDEX+1]
      done < <(look "Choice:" $Kameradumpfile)

      case $TYPE in
      RADIO|MENU)
        INDEX=$(eval dialog --radiolist '"Auswahl für $Configentry: $LABEL \nDerzeit: $CURRENT"' 40 120 30 $Dialogoptions 3>&1 1>&2 2>&3 3>&-)
        if test "$INDEX" ; then 
          comment "Setze $Configentry=$INDEX => $LABEL ${CHOICE[$INDEX]}"
          mygphoto2 --set-config-index $Configentry=$INDEX
        fi
        ;;
      TEXT)
        CHOICE=$(eval dialog --inputbox '"Neuer Wert für $Configentry: $LABEL \nDerzeit: $CURRENT"' 12 78 '"$CURRENT"' 3>&1 1>&2 2>&3 3>&-)
        if test "$CHOICE" ; then
          comment "Ändere $Configentry: $LABEL von $CURRENT auf $CHOICE"
          mygphoto2 --set-config-value "$Configentry=$CHOICE"
        fi
        ;;
      TOGGLE)
        Dialogoptions="1 Ein off 0 Aus off"
        #eval echo  --radiolist '"Schalter: $Configentry: $LABEL' 15 70 2 $Dialogoptions
        CHOICE=$(eval dialog --radiolist '"Schalter: $Configentry: $LABEL"' 15 70 2 $Dialogoptions 3>&1 1>&2 2>&3 3>&-)
        if test "$CHOICE" ; then 
          comment "Stelle Schalter $Configentry auf $CHOICE"
          mygphoto2 --set-config-value $Configentry=$CHOICE 
        fi
        ;;
      *)
        DIALOGTEXT="Unbekannter Konfigurationstyp $TYPE. Ausgabe von get-config $Configentry:\n"
        while read -r LINE ; do
          DIALOGTEXT=$DIALOGTEXT$LINE"\n"
        done < $Kameradumpfile
        CHOICE=$(eval dialog --inputbox '"$DIALOGTEXT"' 12 78 '"$CURRENT"' 3>&1 1>&2 2>&3 3>&-)
        if test -n "$CHOICE" ; then 
          comment "Setze $Configentry auf $CHOICE"
          mygphoto2 --set-config-value $Configentry=$CHOICE
        fi
        ;;
      esac
  }
}

#########################
#### Stackfunktionen ####

steplauf() {
  # Zu Position $1 gehen
  # $1   Zielposition (gewolltes $Poscurrent)
  local Richtug= diff= Warten=
  
  diff="$(bc <<< "$1 - $Poscurrent")"
  [ "$diff" -eq "0" ] && return 1
  [ "$diff" -gt "0" ] && {
    Richtung="i"
  } || { 
    Richtung="o"
    diff="$(bc <<< "-1 * $diff")"
  }
  
  device_check || return 1

  [ "$diff" = "$Schrittweite" ] || {
    device_send "w,$diff"
    [ "$(device_wait)" = "TIMEOUT" ] && return 1
  }

  Warten="$(bc <<< "18 * $diff /10000 + $Devicetimeout")"

  device_send "$Richtung"
  Antwort="$(device_wait $Warten)"
  [ "$Antwort" = "TIMEOUT" ] && return 1
  
  case $Richtung in
    i)  Poscurrent="$(bc <<< "$Poscurrent + $diff")" ;;
    o)  Poscurrent="$(bc <<< "$Poscurrent - $diff")" ;;
  esac
  
  [ "$diff" = "$Schrittweite" ] || {
    device_send "w,$Schrittweite"
    device_wait >/dev/null
  }
  savepos
}
stackshot() {
  ## Funktion: Fotoserie schießen, dabei Motor weiterdrehen. Geht von $Pos1 zu $Pos2.
  # -p   Default: Serie aus Preview-Bildern.
  # -c   Serie aus richtigen Fotos / Captures.
  
  local Posmem=
  local Stepwait Evalmode Anzahl= Count= Loopcount=0 Evalcount
  local Fotomodus= Ordnername= Glob
  local Shortoptions Longoptions
  
  Shortoptions="cpm::"
  Longoptions=""
  Parsedoptions="$(getopt --options $Shortoptions --longoptions $Longoptions --name "$0" -- "$@")"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    case "${1:-}" in
      -c) Fotomodus="capture" ;;
      -p) Fotomodus="preview" ;;
      -m) 
        Evalstack="yes"
        Evalnumber="${2:-5}"
        shift
      ;;
    esac
    shift
  done
    
  [ "$1" = "-c" ] && Fotomodus="capture" && shift
  [ "$1" = "-p" ] && Fotomodus="preview" && shift
  Fotomodus="${Fotomodus:-preview}"
  
  Stepwait="0.4"
  Windowmode=fullimage
  
  # Markierung für loop, daß es weiterlaufen soll
  echo "stack $Pos1 to $Pos2" >$Stackshotfile
  
  # ggf. Positionen für stepin korrigieren
  readpos
  [ "$Pos1" -gt "$Pos2" ] && {
    comment "stack: Switching Pos1:$Pos1 and Pos2:$Pos2"
    Posmem=$Pos1
    Pos1=$Pos2
    Pos2=$Posmem
    savepos
  }
  
  Anzahl="$(bc <<< "($Pos2 - $Pos1) / $Schrittweite" | cut -d. -f1)"
  comment "stack: Number of steps: $Anzahl"
  
  # An Startposition gehen
  cmd -w go1   ### FIXME somehow does not wait
  readpos
  [ "$Poscurrent" = "$Pos1" ] || { fehler "stack: Error: Missed position $Pos1: $Poscurrent." ; return 1 ; }

  # Unterordner anlegen
  Stackshotname="${Stackshotname:-stackshot}"
  Lateststack="$Arduhome/$Projektname/${Stackshotname}_$(get_free_filenumber "$Arduhome/$Projektname/$Stackshotname")"
  mkdir -p "$Lateststack/stackshot"
  echo "$Lateststack" >"$Lateststackfile"
  [ "$Evalstack" = "yes" ] && mkdir -p $Lateststack/median.source

  # Stackshot
  comment "stack: Shooting stack $Lateststack"
  sleep 1

  mygphoto2 --set-config-value viewfinder="1"
  while [ "$Poscurrent" -lt "$Pos2" ] ; do
    Loopcount=$((Loopcount +1 ))
    
    for ((Evalcount=1 ; Evalcount<=$Evalnumber ; Evalcount++)); do
      [ -s $Stackshotfile ] || { fehler "stack: interrupted" ; break ; }
      [ "$Evalstack" = "yes" ] && sleep $Evalwait

      case $Fotomodus in
        capture) 
          #cmd -w "capture-image-and-download"
          mygphoto2 "capture-image-and-download"
        ;;
        preview)
          # cmd -w "capture-preview"
          mygphoto2 --capture-preview
          Latestimage="$Lateststack/stackshot/preview_$(printf "%04d" $Loopcount).jpg"
          mv -f capture_preview.jpg $Latestimage
        ;;
      esac
      case $Evalstack in
        yes)
          Evalgroup="$Lateststack/median.source/img_$(printf "%04d" $Loopcount)"
          Latestmedian="${Evalgroup}_m$(printf "%02d" $Evalcount).jpg"
          cp $Latestimage $Latestmedian
          comment "stack: Image stored as $Latestmedian"
          showimage "$Latestmedian"
        ;;
        no)
          comment "stack: Image stored as $Latestimage"
          showimage "$Latestimage"
        ;;
      esac
      echo "$Latestimage" > $Latestimagefile
    done
    
    [ "$Evalstack" = "yes" ] && {
      comment "stack: Aligning captures of step $Loopcount."
      align_image_stack -m --use-given-order -a ${Evalgroup}_align $Evalgroup*.jpg 2>&1 | grep -v "Unable to read EXIF data"
      Latestimage="$Lateststack/stackshot/${Fotomodus}_$(printf "%04d" $Loopcount).jpg"
      $Convert ${Evalgroup}_align*.tif -evaluate-sequence median "$Latestimage"
      showimage "$Latestimage"
    }

    # step in
    cmd -w stepin
    [ "$Evalstack" = "no" ] && sleep $Stepwait
    readpos
    
    [ -s $Stackshotfile ] || { fehler "stack: interrupted" ; break ; }
    
    # Fortschrittsanzeige %
    Count=$((Count + 1))
    for ((i=1 ; i<=100 ; i++)); do
      Prozent="$((100 * $Count / $Anzahl))"
      [ "$Prozent" -lt "$i" ] && echo -n "." || echo -n "X" 
    done
    echo " $Prozent%"
  done
  
  # Create video from stackshot
  comment "stack: Creating video from stackshot"
  [ -e "$Lateststack/stackshot" ]    && Glob="$Lateststack/stackshot/*"
  [ -e "$Lateststack/median.source" ] && Glob="$Lateststack/median.source/*"
  ffmpeg -framerate 5 -pattern_type glob -i "$Glob" -c:v libx264  -pix_fmt yuv420p "$Lateststack/stackshotvideo.mp4"
  
  comment "stack: Ready: Stackshot $Stackshotname with $((Count * Evalnumber)) images in $Count steps."
  comment "stack: Location: $Lateststack"
  :> $Stackshotfile
}

##########################
#### Image processing ####

detect_sourcedir() {
  # Detect possible source directories in $2 for function $1
  # Set up variables that can be used to call function $1
  # Usage:
  #   detect_sourcedir Function Targetdir
  # Args:
  #   Function       One of align, sharpen, fuse, median, min, max, mean, set
  #   Targetdir      Target directory [+glob] to check.
  #                  Can already be in an arduterm-structure or an arbitrary one.
  #                  Location of $Destinationdir depends on detected directory structure.
  #   Functionmode   Mode of Function
  # Sets variables:
  #   Sourcedir                 Source directory within $Targetdir
  #   Sourcefileglob            Glob to get files. Mostly just "*"
  #   Destinationdir            Recommended directory to store resulting images.
  #                             Often serves as source dir for following functions.
  #   Destinationfilebasename   Possible prefix of destination file(s). Can be "", though.
  #   Targetcachedir            Cache folder
  #
  # Run in a loop to check for next possible source dir in Targetdir.
  # Returns 0 on success and 1 if nothing more is to do.
  #
  # Stores already checked source dirs of $Targetdir in $Sourcedirchecklist. 
  # -> Set Sourcedirchecklist="" before running a loop with detect_sourcedir().
  # Use local in calling function:
  #   local Sourcedir Sourcefileglob Destinationdir Destinationfilebasename Targetptofile Targetcachedir Sourcedirchecklist

  local Targetdir Singleshotdir Stackdir Checkline Skip Targetnewdir Targetprevdir
  
  Function="${1:-}"
  Targetdir="${2:-}"
  Functionmode="${3:-}"
  
  # Check if a glob like * is given
  check_fileglob $Targetdir && {
    Sourcefileglob="$(basename "$Targetdir")"
    Targetdir="$(dirname "$Targetdir")"
  }
  Sourcefileglob="${Sourcefileglob:-"*"}"
  Destinationdir=""
  Destinationfilebasename=""
  
  Targetdir="$(realpath "$Targetdir")"
  [ -d "$Targetdir" ] || {
    fehler "No target directory found. Please specify a target directory or make a stackshot.
  Wrong Target: $Targetdir"
    return 1
  }
  
  [ -d "$Targetdir/stackshot" ]        && Singleshotdir="$Targetdir/stackshot" || Singleshotdir="$Targetdir"
  [ -d "$Targetdir/stackshot-median" ] && Singleshotdir="$Targetdir/stackshot-median"
  Targetcachedir="$Targetdir/cache"
  Targetmagickdir="$Targetcachedir/magick"
  
  Targetfusedir="$Targetdir/fuse"
  Targetcomposedir="$Targetdir/compose"
  
  #grep -q -- "-fuse" <<< "$Function"     && Targetnewdir="$Targetfusedir"
  #grep -q -- "-compose" <<< "$Function"  && Targetnewdir="$Targetcomposedir"
  #grep -q -- "-evaluate" <<< "$Function" && Targetnewdir="$Targetcomposedir" && Sourcefileglob="{*median*,*min*,*max*,*mean*}"
  grep -q -- "fuse" <<< "$Function"     && Targetnewdir="$Targetfusedir"
  grep -q -- "compose" <<< "$Function"  && Targetnewdir="$Targetcomposedir"
  grep -q -- "evaluate" <<< "$Function" && Targetnewdir="$Targetcomposedir" 
  grep -q -- "-evaluate" <<< "$Function" && Targetnewdir="$Targetcomposedir" && Sourcefileglob="{*.median.*,*.min.*,*.max.*,*.mean.*}"
  
  [ "$Targetnewdir" ] || {
    Targetnewdir="$Targetmagickdir"
    mkdir -p $Targetnewdir
    check_fileglob $Targetnewdir/$Sourcefileglob || cp $(fileglob $Singleshotdir/$Sourcefileglob) $Targetnewdir
  }
  Targetprevdir="$Targetnewdir.bak"
  
  # backup for undo
  case $Function in
    align|sharpen*|level*|contrast*|crop*|gamma*|stretch*|kuwahara*|prepare*|wizard*|whitebalance*)
      mkdir -p $Targetprevdir
      cp -f $(fileglob $Targetnewdir/*) "$Targetprevdir/"
      mv -f $(fileglob $Targetnewdir/$Sourcefileglob) "$Targetprevdir/"
    ;;
    evaluate)
      [ -e "$Targetnewdir" ] && {
        mkdir -p $Targetprevdir
        cp -f $(fileglob $Targetnewdir/*) "$Targetprevdir/"
        mv -f $(fileglob $Targetnewdir/*(*magick.median*|*magick.min*|*magick.max*|*magick.mean*)) "$Targetprevdir/"
      }
    ;;
    evaluate-fuse)
      [ -e "$Targetnewdir" ] && {
        mkdir -p $Targetprevdir
        cp -f $(fileglob $Targetnewdir/*) "$Targetprevdir/"
        mv -f $(fileglob $Targetnewdir/*(*fuse.median*|*fuse.min*|*fuse.max*|*fuse.mean*)) "$Targetprevdir/"
      }
    ;;
    compose)
      [ -e "$Targetnewdir" ] && {
        mkdir -p $Targetprevdir
        cp -f $(fileglob $Targetnewdir/*) "$Targetprevdir/"
        mv -f $(fileglob $Targetnewdir/!(*.median.*|*.min.*|*.max.*|*.mean.*|*.fuse.*)) "$Targetprevdir/" ###
      }
    ;;
    compose-fuse)
      [ -e "$Targetnewdir" ] && {
        mkdir -p $Targetprevdir
        cp -f $(fileglob $Targetnewdir/*) "$Targetprevdir/"
        ls $Targetnewdir/!(*.median.*|*.min.*|*.max.*|*.mean.*|*.magick.*)
        mv -f $(fileglob $Targetnewdir/!(*.median.*|*.min.*|*.max.*|*.mean.*|*.magick.*)) "$Targetprevdir/" ###
      }
    ;;
    fuse)
      [ -e "$Targetnewdir" ] && {
        mkdir -p $Targetprevdir
        mv -f $(fileglob $Targetnewdir/*) "$Targetprevdir/"
      }
    ;;
  esac
  
  case $Function in
    fuse)
      Sourcedir="$Targetmagickdir"
      Destinationdir="$Targetfusedir"
      Destinationfilebasename="$(basename "$Targetdir")"
    ;;
      
    evaluate|compose)
      Function=$(cut -d- -f1 <<<$Function)
      Sourcedir="$Targetmagickdir"
      Destinationdir="$Targetcomposedir"
      Destinationfilebasename="$(basename "$Targetdir").$(basename "$Sourcedir")"
    ;;
    evaluate-fuse|compose-fuse)
      Sourcedir="$Targetfusedir"
      Destinationdir="$Targetcomposedir"
      Destinationfilebasename="$(basename "$Targetdir").$(basename "$Sourcedir")"
    ;;
      
    align|sharpen*|level*|contrast*|crop*|gamma*|stretch*|kuwahara*|prepare*|wizard*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
      
    choose-whitebalance*)
      Sourcedir="$Targetnewdir"
      Destinationdir="$Targetcachedir"
    ;;
    whitebalance*)
#      mkdir -p $Targetprevdir
#      mv -f $(fileglob $Targetnewdir/$Sourcefileglob) "$Targetprevdir/"
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
      echo "$Targetnewdir" > "$Targetcachedir/lastdir"
    ;;
    
    undo*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
    
    *)
      fehler "Function not defined: $Function"
  esac
  
  check_fileglob $Sourcedir/$Sourcefileglob || return 1
  [ "$Destinationdir" ] || return 1
  mkdir -p "$Destinationdir"
  return 0
}
batch_all() {
  # Apply all image processing functions on target directory $1
  
  local Targetdir

  Targetdir="${1:-$Lateststack}"
  [ -d "$Targetdir" ] || check_fileglob $Targetdir || {
    fehler "batch_all: Target directory not found: $Targetdir"
    return 1
  }
  
  batch_function prepare           "$Targetdir"
#  batch_function gamma             "$Targetdir" auto
#  batch_function level             "$Targetdir" auto
#  batch_function contrast          "$Targetdir" "3x50%"
#  batch_function kuwahara          "$Targetdir" 0.5
#  batch_function sharpen           "$Targetdir" "6x2"
  #batch_function align             "$Targetdir"
  batch_function evaluate          "$Targetdir" all
  batch_function compose           "$Targetdir" all
  batch_function fuse              "$Targetdir" all
  batch_function compose-fuse      "$Targetdir" all
  batch_function evaluate-fuse     "$Targetdir" all
  batch_function sharpen-compose   "$Targetdir" "3x1"
  
  comment "batch_all is ready: $Targetdir"
}
batch_function() {
  # Apply image processing function $1 on all possible source dirs in target directory $2, options in $3
  
  local Function Targetdir Option
  local Sourcedir Sourcefileglob Destinationdir Destinationfilebasename Targetcachedir Sourcedirchecklist # vars of detect_sourcedir()
  local Return=0

  Function="${1:-}"
  Targetdir="${2:-$Lateststack}"
  Option="${3:-}"
  
  [ -d "$Targetdir" ] || check_fileglob $Targetdir || {
    fehler "$Function: Target directory not found: $Targetdir"
    return 1
  }
  [ "$Function" ] || {
    fehler "batch: No function defined for $Targetdir"
    return 1
  }
  
  [ -z "$Option" ] && case "$Function" in
    compose|evaluate|fuse) Option="all" ;;
  esac
  
  detect_sourcedir "$Function" "$Targetdir" "$Option" || {
    fehler "batch $Function: no source found in $Targetdir"
    #echo "$Sourcedir/$Sourcefileglob"
    return 1
  }
  echo "$Function $Option" >> $Targetcachedir/batch.log
  comment "$Function $Option is running: $(basename "$Targetdir")/*/$(basename "$Sourcedir")"
  case "$Function" in
    prepare*)                          wizard prepare      "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Option" ;;
    contrast*)                         wizard contrast     "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Option" ;;
    gamma*)                            wizard gamma        "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Option" ;;
    kuwahara*)                         wizard kuwahara     "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Option" ;;
    level*)                            wizard level        "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Option" ;;
    sharpen*)                          wizard sharpen      "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Option" ;;
    stretch*)                          wizard stretch      "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Option" ;;
    wizard*)                           wizard wizard       "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Option" ;;
    
    align)                             align               "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Option" ;;
    fuse)                              fuse                "$Sourcedir/$Sourcefileglob" "$Destinationdir/$Destinationfilebasename" "$Option" ;;
    evaluate*)                         evaluate            "$Sourcedir/$Sourcefileglob" "$Destinationdir/$Destinationfilebasename" "$Option" ;;
    compose*)                          compose             "$Sourcedir/$Sourcefileglob" "$Destinationdir/$Destinationfilebasename" "$Option" ;;
    crop*)                             mycrop              "$Sourcedir/$Sourcefileglob" "$Destinationdir" ;;
    choose-whitebalance*)              whitebalance_choose "$Sourcedir/$Sourcefileglob" "$Targetcachedir/whitebalance.geometry" "$Targetcachedir" ;;
    whitebalance*)                     whitebalance        "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$(cat "$Targetcachedir/whitebalance.geometry")" ;;
    undo*)                             undo                "$Sourcedir"                 "$Destinationdir" ;;
  esac
  Return=$?
  [ "$Return" = "0" ] && {
    comment "$Function $Option is ready: $(basename "$Targetdir")/*/$(basename "$Sourcedir")"
  } || {
    fehler "ERROR in $Function"
    undo   "$Sourcedir" "$Destinationdir"
  }
  
  [ "$(basename "$Destinationdir")" = "compose" ] && {
    [ -d "$Destinationdir/../stackshot" ] && {
      #for Image in $(fileglob $Destinationdir/*fuse.median*) $(fileglob $Destinationdir/*fuse.min*) $(fileglob $Destinationdir/*fuse.mean*) $(fileglob $Destinationdir/*fuse.max*) $(fileglob $Destinationdir/*fuse.set*) ; do
      for Image in $(fileglob $Destinationdir/{*fuse.median*,*fuse.mean*,*fuse.min*,*fuse.max*}); do
        ln -f "$Image" "$Destinationdir/../"
      done
    }
    [ "$Destinationdir" != "${Destinationdir#$Arduhome}" ] && check_fileglob $Destinationdir/*fuse.median* && {
      ln -f $(fileglob $Destinationdir/*fuse.median*) "$Destinationdir/../../"
      showimage $(fileglob $Destinationdir/*fuse.median*)
    }
  }
  echo batch $Return
  return $Return
#  done
}
wizard() {
  # Wrapper for ImageMagick convert to work on folders
  # Usage:
  #   wizard Function Sourceglob Destinationdir [Functionmode]
  # Args:
  #   Function
  #   Sourceglob       Path[+glob] to source files
  #   Destinationdir   Path where to store converted images
  #   Functionmode     Parameter for Function
  # detect_sourcedir() can help to set up Args.
  
  local Function Sourceglob Destinationdir Functionmode
  local Image Destinationfile
  local Return=0
  
  Function="${1:-}"
  Sourceglob="${2:-"*"}"
  Destinationdir="${3:-}"
  Functionmode="${4:-}"
  
  check_fileglob $Sourceglob || Sourceglob="$Sourceglob/*"
  check_fileglob $Sourceglob || {
    fehler "$Function: No source files found: $Sourceglob"
    return 1
  }
  
  [ "$Functionmode" ] || case "$Function" in
    contrast) Functionmode="3x50%" ;;
    gamma)    Functionmode="auto" ;;
    kuwahara) Functionmode="1" ;;
    level)    Functionmode="auto" ;;
    sharpen)  Functionmode="6x2" ;;
    stretch)  Functionmode="0%" ;;
  esac

  case $Function in
    gamma|level) 
      case $Functionmode in
        auto|"") Function="-auto-$Function" ; Functionmode="" ;;
        *)       Function="-$Function" ;;
      esac
    ;;
    contrast) Function="-sigmoidal-contrast" ;;
    kuwahara) Function="-kuwahara" ;;
    sharpen)  Function="-adaptive-sharpen" ;;
    stretch)  Function="-contrast-stretch" ;;
#    prepare)  Function="-sigmoidal-contrast 3x50% -kuwahara 0.5 -adaptive-sharpen 6x2" ; Functionmode="" ;;
    prepare)  Function="-auto-gamma -auto-level -sigmoidal-contrast 3x50% -kuwahara 0.5 -adaptive-sharpen 6x2" ; Functionmode="" ;;
    wizard)   Function="$Functionmode" ; Functionmode="" ;;
  esac
  
  for Image in $(fileglob $Sourcedir/$Sourcefileglob); do
    Destinationfile="$Destinationdir/$(basename "$Image")"
    check_destinationfile "$Destinationfile" "$Function" || break
    $Convert "$Image" $Function $Functionmode "$Destinationfile" >>$Ardulogfile 2>&1
    Return=$?
    [ "$Return" != "0" ] && break
#    showimage "$Destinationfile"
#    showimagehalf "$Image" "$Destinationfile"
    showimagediff "$Image" "$Destinationfile" "$(basename "$Image")" "$Function $Functionmode"
  done
  echo wizard $Return
  return $Return
}
evaluate() {
  # Evaluate image stack. Mostly used to calculate a median to eliminate moving objects.
  # Usage:
  #   evaluate Functionmode Sourceglob Destinationfile [Fileformat]
  # Args:
  #   Functionmode         Evaluation mode, e.g. median, max, min. Get a list of possible modes with: convert -list evaluate
  #   Sourceglob       Path[+glob] to image stack. Default: ./*
  #   Destinationfilebasename  Output file base name
  # detect_sourcedir() can help to set up Args.
  
  local Functionmode Sourceglob Destinationfile Destinationfilebasename Fileformat
  local Sourcedir
  Sourceglob="${1:-"*"}"
  Destinationfilebasename="${2:-evaluate}"
  Functionmode="${3:-}"
  Fileformat="${4:-jpg}"
  
  #echo "ES $Sourceglob"
  #echo "ED $Destinationfile"
  #echo "EM $Functionmode"
  
  check_fileglob $Sourceglob || Sourceglob="$Sourceglob/*"
  check_fileglob $Sourceglob || {
    fehler "evaluate $Functionmode: No source files found: $Sourceglob"
    return 1
  }
  Sourcedir="$(dirname "$Sourceglob")"
  
  [ "$Functionmode" = "all" ] && {
    for Functionmode in min mean max median; do
      evaluate "$Sourceglob" "$Destinationfilebasename" "$Functionmode" "$Fileformat"
    done
    return 0
  }
  
  Destinationfile="$Destinationfilebasename.$Functionmode.$Fileformat"
  $Convert $(fileglob $Sourceglob) -evaluate-sequence $Functionmode "$Destinationfile" || {
    fehler "evaluate $Functionmode: ERROR in excuting convert. Please check policy restrictions of ImageMagick. Note that all input images have to be the same size."
    return 1
  }
  showimage "$Destinationfile"
}
compose() {

  local Mode Sourceglob Destinationfilebasename
  local Minfile Maxfile Destinationdir
  Sourceglob="${1:-"*"}"
  Destinationfilebasename="${2:-compose}"
  Mode="${3:-linearburn}"
  Mode="$(tr '[:upper:]' '[:lower:]' <<< "$Mode")"
  Destinationdir="$(dirname "$Destinationfilebasename")"
  
  check_fileglob $Sourceglob || Sourceglob="$Sourceglob/*"
  check_fileglob $Sourceglob || {
    fehler "compose $Mode: No source files found: $Sourceglob"
    return 1
  }
  
  Maxfile="$Destinationfilebasename.max.jpg"
  Minfile="$Destinationfilebasename.min.jpg"
  [ -e "$Maxfile" ] || evaluate "$Sourceglob" "$Destinationfilebasename" "max"
  [ -e "$Minfile" ] || evaluate "$Sourceglob" "$Destinationfilebasename" "min"
  [ -e "$Maxfile" ] && [ -e "$Minfile" ] || {
    fehler "compose $Mode: Failed to find or create min and max files."
    return 1
  }
  
  [ "$Mode" = "all" ] && {
    for Mode in bumpmap colorburn difference linearburn linearlight modulate multiply overlay pegtoplight; do
      compose "$Sourceglob" "$Destinationfilebasename" "$Mode"
    done
    return 0
  }
  
  Destinationfile="$Destinationfilebasename.${Mode}1.jpg"
  #check_destinationfile "$Destinationfile" "compose $Mode" && {
    $Convert "$Minfile" "$Maxfile" -compose "$Mode" -composite "$Destinationfile"
    showimage "$Destinationfile"
  #}
#  case $Mode in # link interesting results to parent folder
#    bumpmap|multiply|overlay)
#      [ -d "$Destinationdir/../stackshot" ] && ln -f "$Destinationfile" "$Destinationdir/../"
#    ;;
#  esac
  case $Mode in
    linearburn|multiply) ;;  # skip second compose for modes with identical result
    difference)
      $Convert "$Destinationfile" -negate "$Destinationfilebasename.$Mode-negate.jpg"
    ;;
    *)
      Destinationfile="$Destinationfilebasename.${Mode}2.jpg"
      #check_destinationfile "$Destinationfile" "compose $Mode" && {
        $Convert "$Maxfile" "$Minfile" -compose "$Mode" -composite "$Destinationfile"
        showimage "$Destinationfile"
      #}
    ;;
  esac
}
fuse() {
  # fuse stackshot of images with enfuse
  # Usage:
  #   fuse [-m Fusemode] Sourceglob Destinationfile
  # Args:
  # -m Fusemode         Parameter set to use. Default: 1
  #    Sourceglob       Path[+glob] to image stack. Default: ./*
  #    Destinationfile  Output file. Default: fuse??.tif
  # detect_sourcedir() can help to set up Args.
  
  local Fusemode Sourceglob Destinationfile Destinationfilebasename
  local Exposureweight Saturationweight Contrastweight
  local Contrastedgescale Exposureweightfunction Exposureoptimum
  
  
  # Source and destination
  Sourceglob="${1:-"*"}"
  Destinationfilebasename="${2:-enfuse}"
  check_fileglob $Sourceglob || Sourceglob="$Sourceglob/*"
  check_fileglob $Sourceglob || {
    fehler "fuse: No source files found: $Sourceglob"
    return 1
  }
  Fusemode="${3:-1}"
  #echo "FS $Sourceglob"
  #echo "FD $Destinationfile"
  #echo ""
 
  # Predefined parameter sets
  Exposureweight=0.0
  Saturationweight=0.0
  Contrastweight=1.0
  Contrastedgescale=0
  Contrastmincurvature=""
  Contrastwindowsize="3"
  Grayprojector="luminance"
  case $Fusemode in
    all)
      fuse_all "$Sourceglob" "$Destinationfilebasename"
      return
    ;;
    1)
    ;;
    2)
      Saturationweight="0.1"
    ;;
    3) 
      Contrastwindowsize="7"
    ;;
    4) 
      Contrastwindowsize="7"
      Saturationweight="0.1"
    ;;
    5) 
      Contrastwindowsize="15"
    ;;
    6) 
      Contrastwindowsize="15"
      Saturationweight="0.1"
    ;;
    7) 
      Contrastwindowsize="23"
    ;;
    8) 
      Contrastwindowsize="23"
      Saturationweight="0.1"
    ;;
    9)
      Contrastedgescale="0.8:2000%:300%"
      #Contrastmincurvature="+8.0%"
    ;;
    10)
      Contrastedgescale="0.8:500%:500%"
      #Contrastmincurvature="+8.0%"
    ;;
    11)
      Contrastedgescale="1.2:16:4"
      #Contrastmincurvature="+5.0%"
    ;;
    12)
      Contrastedgescale="1.2:8:4"
      #Contrastmincurvature="+5.0%"
      #Saturationweight="0.1"
    ;;
    13)
      Contrastedgescale="1.6:16:4"
      #Contrastmincurvature="+3.0%"
    ;;
    14)
      Contrastedgescale="1.6:8:4"
      #Contrastmincurvature="+3.0%"
      #Saturationweight="0.1"
    ;;
    15)
      Contrastedgescale="1.6:16:10"
      #Contrastmincurvature="+6.0%"
    ;;
    16)
      Contrastedgescale="1.6:8:10"
      #Contrastmincurvature="+8.0%"
      #Saturationweight="0.1"
    ;;
    17)
      Contrastedgescale="2.0:500%:500%"
      #Contrastmincurvature="+2.0%"
    ;;
    18)
      Contrastwindowsize="15"
      Contrastedgescale="1.2:16:4"
      Contrastmincurvature="+8.01%"
    ;;
    19)
      Contrastwindowsize="23"
      Contrastedgescale="1.2:16:4"
      Contrastmincurvature="+8.01%"
    ;;
    20)
      Contrastedgescale="3.0:4:4"
    ;;
    
    
    ###############
    22x) #*
      Contrastwindowsize="23"
      Contrastedgescale="2.5:8:4"
      Contrastmincurvature="+8.01%"
    ;;
    
    23x) #*
      Contrastwindowsize="23"
      Contrastedgescale="2.5:4:2"
      Contrastmincurvature="+8.01%"
    ;;
    
    
    
    20x)
      Contrastwindowsize="23"
      Contrastedgescale="1.2:24:8"
    ;;
    21x)
      Contrastwindowsize="23"
      Contrastedgescale="0.5:36:24"
      Contrastmincurvature="+8.01%"
    ;;
    27x) #*
      Contrastwindowsize="15"
      Contrastedgescale="2.5:4:2"
      Contrastmincurvature="+8.01%"
    ;;
    
    
    xxx7)
      Contrastedgescale="0.3:1000%:300%"
      Contrastmincurvature="+0.3%"
    ;;
    xxx8)
      Contrastedgescale="0.3:1000%:300%"
      Contrastmincurvature="+0.3%"
      Saturationweight="0.1"
    ;;
    
    
    
    
    x11)
      Grayprojector="l-star"
    ;;
    x12) 
      Contrastwindowsize="7"
      Grayprojector="l-star"
    ;;
    x13)
      Grayprojector="l-star"
      Contrastedgescale="0.3:1000%:300%"
      Contrastmincurvature="+0.3%"
      Grayprojector="l-star"
    ;;
    x14)
      Contrastedgescale="0.8:2000%:300%"
      Grayprojector="l-star"
    ;;
    x15)
      Contrastedgescale="1.2:16:4"
      Contrastmincurvature="+8.0%"
      Grayprojector="l-star"
    ;;
    x16)
      Contrastedgescale="1.6:16:4"
      Contrastmincurvature="+4.0%"
      Grayprojector="l-star"
    ;;
    x17)
      Contrastedgescale="1.6:16:4"
      Saturationweight="0.1"
      Contrastmincurvature="+5.0%"
      Grayprojector="l-star"
    ;;
    x18)
      Contrastedgescale="1.6:16:10"
      Saturationweight="0.1"
      Contrastmincurvature="+10.0%"
      Grayprojector="l-star"
    ;;
    *) return 1 ;;
  esac
  
  
  ##  Laplacian Edge Detection
  # Enfuse provides a Laplacian-based algorithm that can help in situations where weighting based on the standard deviation fails. 
  # It is activated with a positive value for SCALE in --contrast-edge-scale=SCALE. 
  # The Laplacian will detect two-dimensional curvature on the scale of SCALE. 
  # Here and in the following we simply speak of curvature where we mean magnitude of curvature. 
  # That is, we shall not distinguish between convex and concave edges. Enfuse always use the magnitude of curvature for weighting.
  #
  # Typically, SCALE ranges between 0.1 pixels and 0.5 pixels, where 0.3 pixels are a reasonable starting point. 
  # To find the best value for SCALE though, usually some experimentation will be necessary. 
  # Use --save-masks to get all soft-mask (default: softmask-%n.tif) and hard-mask files (default: hardmask-%n.tif). Check how different scales affect the artifacts. 
  #
  ## Local Contrast Enhancement
  # Sometimes Enfuse misses smoother edges with --contrast-edge-scale and a little local contrast enhancement (LCE) helps. 
  # Set --contrast-edge-scale=SCALE:LCE-SCALE:LCE-FACTOR, 
  # where LCE-SCALE and LCE-FACTOR work like the unsharp mask filters in various image manipulation programs. 
  # Start with LCE-SCALE ten times the value of SCALE and a LCE-FACTOR of 2-5.
  #
  # LCE-SCALE can be specified as a percentage of SCALE. LCE-FACTOR also can be specified as a percentage. 
  # Examples:
  #    --contrast-edge-scale=0.3:3.0:3
  #    --contrast-edge-scale=0.3:1000%:3.0
  #    --contrast-edge-scale=0.3:3:300%
  #    --contrast-edge-scale=0.3:1000%:300% 
  #  Contrastedgescale="0.3:3:3"
  #
  # --exposure-weight-function=gaussian
  # one of the built-in exposure WEIGHT-FUNCTIONs: "gaussian", "lorentzian", "half-sine", "full-sine", or "bi-square"; default: "gaussian"
  #  Exposureweightfunction=gaussian
  #
  # --exposure-optimum=0.5
  # optimum  exposure  value, usually the maximum of the weighting function (0 <= OPTIMUM <= 1); default: 0.5
  #Exposureoptimum=0.5
  #    --exposure-optimum=$Exposureoptimum \
  #
  # --contrast-window-size=SIZE
  #   set window SIZE for local-contrast analysis (SIZE >= 3); default: 5
  #   Does not take effect if --contrast-edge-scale is in use.
  #Contrastwindowsize=5
  #    --contrast-window-size=$Contrastwindowsize \

  Destinationfile="$Destinationfilebasename.fuse$(printf %02d $Fusemode).jpg"
  check_destinationfile "$Destinationfile" "fuse" || return 1
  comment "fuse: Creating $Destinationfile"
  
  Enfuseoptions="
      --exposure-weight=$Exposureweight \
      --saturation-weight=$Saturationweight \
      --contrast-weight=$Contrastweight \
      --hard-mask \
      \
      --contrast-edge-scale=$Contrastedgescale \
      --contrast-window-size=$Contrastwindowsize \
      \
      --gray-projector=$Grayprojector"
  [ "$Contrastmincurvature" ] && Enfuseoptions="$Enfuseoptions \
      --contrast-min-curvature=$Contrastmincurvature"
  
  # Fusing here
  enfuse $Enfuseoptions \
      --output=$Destinationfile \
      $(fileglob $Sourceglob) \
      2>&1 | grep -v "does not have an alpha channel" | grep -v "assuming all pixels should contribute" | grep -v "loading next image" >>$Ardulogfile
        
  # Write enfuse options into EXIF data of image
  exiv2 -M"set Exif.Photo.UserComment Comment charset=Ascii enfuse $(echo $Enfuseoptions)" "$Destinationfile" >>$Ardulogfile 2>&1

  comment "fuse is ready: ${Destinationfile}"
  showimage "$Destinationfile"
}
fuse_all() {
  # Iterate through all fuse modes of fuse(). Run as much threads as CPU cores are given.
  # detect_sourcedir() can help to set up Args.
  # Usage:
  #  fuse_all Sourceglob Destinationdir Destinationfilebasename
  # Args:
  #  Sourceglob                Path[and glob] to stackshot images.
  #  Destinationdir            folder where to store results
  #  Destinationfilebasename   Prefix of created files. Default: "fuse". Suffix will be ??.tif
  
  local Sourceglob Destinationdir Destinationfilebasename Destinationfile
  local Fusemode Fusepid Fusethreads Cpucount
  
  Sourceglob="${1:-"*"}"
  Destinationfilebasename="${2:-}"
#  [ -d "$Destinationdir" ] && {
#    Destinationfilebasename="fuse"
#  } || {
#    Destinationfilebasename="$(basename "$Destinationdir")"
#    Destinationdir="$(dirname "$Destinationdir")"
#  }
#  check_fileglob "$Sourceglob" || Sourceglob="$Sourceglob/*"
#  check_fileglob "$Sourceglob" || {
#    fehler "fuse: No source files found: $Sourceglob"
#    return 1
#  }
 
  # number of CPUs to use
  Cpucount="$(nproc)"
  #Cpucount="$((Cpucount-1))"
#  Cpucount=1
  
  # fuse with enfuse
  # some hickhack to run multiple threads at once, but not more than number of CPUs.
  for Fusemode in $(seq 50); do
    Destinationfile="$Destinationfilebasename.fuse$(printf %02d $Fusemode).jpg"
    check_destinationfile "$Destinationfile" "fuse" && {
      fuse "$Sourceglob" "$Destinationfilebasename" "$Fusemode" & Fusepid[$Fusemode]=$! 
      echo "${Fusepid[$Fusemode]} fuse" >>$Backgroundpidfile
      ps -p ${Fusepid[$Fusemode]} >/dev/null && while :; do
        sleep 1
        Fusethreads=0
        for ((i=1; i<=100; i++)); do
          [ "${Fusepid[$i]}" ] && ps -p "${Fusepid[$i]}" >/dev/null 2>&1 && Fusethreads=$((Fusethreads+1)) || Fusepid[$i]=""
        done
        [ "$Fusethreads" -lt $Cpucount ] && break
      done
    }
  done
  for ((i=1; i<=100; i++)); do
    [ "${Fusepid[$i]}" ] && ps -p "${Fusepid[$i]}" >/dev/null 2>&1 && wait ${Fusepid[$i]}
  done
  return 0
}
undo() {
  local Sourcedir Destinationdir
  Sourcedir="${1:-}"
  Destinationdir="${2:-}"
  mkdir -p "$Sourcedir.undobackup"
  mv "$Sourcedir"/* "$Sourcedir.undobackup"
  mv "$Destinationdir"/* "$Sourcedir"
  mv "$Sourcedir.undobackup"/* "$Destinationdir"
  cp -n "$Sourcedir"/* "$Destinationdir"
  rm -R "$Sourcedir.undobackup"
  #mv "$Sourcedir" "$Sourcedir.rename"
  #mv "$Destinationdir" "$Sourcedir"
  #mv "$Sourcedir.rename" "$Destinationdir"
}

align() {
  local Sourcedir Destinationdir Sourcefileglob Alignmode
  local Cachedir
  
  Sourcedir="${1:-"*"}"
  Destinationdir="${2:-}"
  Alignmode="${3:-hugin}"
  
  [ -d "$Sourcedir" ] && {
    Sourcefileglob="*"
  }
  check_fileglob $Sourcedir && {
    Sourcefileglob="$(basename "$Sourcedir")"
    Sourcedir="$(dirname "$Sourcedir")"
  }
  check_fileglob $Sourcedir/$Sourcefileglob || {
    fehler "align: No source files found: $Sourcedir/$Sourcefileglob"
    return 1
  }
  
  Cachedir="$(realpath "$Sourcedir/.." )/align"
  rm -R $Cachedir
  mkdir -p $Cachedir
  
  case $Alignmode in
    hugin)  align_hugin  "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Cachedir" ;;
    ais)    align_ais    "$Sourcedir/$Sourcefileglob" "$Destinationdir" ;;
    ffmpeg) align_ffmpeg "$Sourcedir/$Sourcefileglob" "$Destinationdir" "$Cachedir" ;;
  esac
}
align_hugin() {
  # Align image stack with some panotools. Similar to align_image_stack
  # Advantage: pto file with aligned control points can be reused for multiple similar stacks
  # Usage:
  #  align Sourceglob Destinationdir [Cachedir]
  # Args:
  #  Sourcedir         Path[+glob] to source image stack
  #  Destinationdir    Path where to store aligned images
  #  Cachedir          Cache folder will contain align.pto file with control points. Can be reused to skip control point calculation.
  
  local Sourcedir Destinationdir Ptofile
  local Sourcefileglob Prevdir
  local Imagewidth Imageheight
  local Count Line Filearray Destinationfile
  local Logfile Cachedir
  local Crop Cropx Cropy Cropsize
  
  
  Sourcedir="${1:-"*"}"
  Destinationdir="${2:-}"
  Cachedir="${3:-"/tmp/align$(mcookie)"}"
  mkdir -p "$Cachedir"
  
  [ -d "$Sourcedir" ] && {
    Sourcefileglob="*"
  }
  check_fileglob $Sourcedir && {
    Sourcefileglob="$(basename "$Sourcedir")"
    Sourcedir="$(dirname "$Sourcedir")"
  }
  check_fileglob $Sourcedir/$Sourcefileglob || {
    fehler "align: No source files found: $Sourcedir/$Sourcefileglob"
    return 1
  }
  
  # cd to source dir to collect base file names only. Allows multiple use of aligned $Ptofile
  Prevdir="$(pwd)"
  cd "$Sourcedir"
  
  # read source file names in array
  Count=-1
  for Line in $(fileglob $Sourcefileglob); do
    Count=$((Count +1))
    Filearray[$Count]="$Line"
  done
  
  # Use existing pto file if possible
  Ptofile="align.pto"
  [ -f "$Cachedir/$Ptofile" ] && cp "$Cachedir/$Ptofile" "$Sourcedir/$Ptofile"
  Logfile="$Cachedir/$Ptofile.log"
  :> $Logfile
  #tail -f "$Logfile" &
  
  comment "align: Aligning $Sourcedir/$Sourcefileglob"
  check_destinationfile "$Destinationdir/${Filearray[0]}" align || {
    cd "$Prevdir"
    return 1
  }
  
  # Get image size. Assuming same size for all images.
  Imagewidth=$($Convert  -format '%w'  ${Filearray[0]} info:)
  Imageheight=$($Convert -format '%h'  ${Filearray[0]} info:)
  
  [ -e "$Ptofile" ] && {
    comment "align: Using control points of given pto file $Ptofile"
  } || {
    echo "########## pto_gen ##########" >> "$Logfile"
    comment "align: Running pto_gen to create list of files"
    pto_gen -o "$Ptofile.pto_gen.pto" -p 0 -f 40 --crop=0,${Imagewidth},0,${Imageheight} $(fileglob $Sourcefileglob) >> "$Logfile" 2>&1 || {
      fehler "Error in pto_gen
$(tail $Logfile)"
      cd "$Prevdir"
      return 1
    }
    sed -i '3 s/r:CROP//'                     "$Ptofile.pto_gen.pto"
    sed -i '3 s/\bf[0-9]*\b/f0/'              "$Ptofile.pto_gen.pto"
    sed -i "3 s/\bw[0-9]*\b/w${Imagewidth}/"  "$Ptofile.pto_gen.pto"
    sed -i "3 s/\bh[0-9]*\b/h${Imageheight}/" "$Ptofile.pto_gen.pto"
    sed -i "3 s/\bv[0-9]*\b/v40/"             "$Ptofile.pto_gen.pto"
    
#    pano_modify --projection=0 $Ptofile.pto_gen.pto
#    pano_modify --canvas=${Imagewidth}x${Imageheight} $Ptofile.pto_gen.pto
#    pano_modify --output-type=FUSEDSTACKS $Ptofile.pto_gen.pto

    # find control points
    echo "########## cpfind ##########" >> "$Logfile"
    comment "align: Running cpfind to find control points for alignment. That will take a while."
    cpfind -o "$Ptofile.cpfind.pto"  \
        --fullscale \
        --minmatches 4 \
        --linearmatch \
        --linearmatchlen 10 \
        --ransacmode rpyv \
        "$Ptofile.pto_gen.pto" 2>&1 >> "$Logfile" || {
      fehler "Error in cpfind
$(tail $Logfile)"
      cd "$Prevdir"
      return 1
    }
#        --linearmatchlen $Count \

    # clean up useless/wrong control points
    echo "########## cpclean ##########" >> "$Logfile"
    comment "align: Running cpclean to remove wrong control points"
    cpclean -s -o "$Ptofile.cpclean.pto" --pairwise-checking "$Ptofile.cpfind.pto" >> "$Logfile" || {
      fehler "Error in cpclean
$(tail $Logfile)"
      cd "$Prevdir"
      return 1
    }

    #pano_modify --crop=AUTO $Ptofile.cpclean.pto
    
    # calculate distortion of images to align control points
    echo "########## autooptimiser ##########" >> "$Logfile"
    comment "align: Running autooptimiser to transform control points into image distortion"
    autooptimiser -p -o "$Ptofile" "$Ptofile.cpclean.pto" >> "$Logfile" || {
      fehler "Error in autooptimiser
$(tail $Logfile)"
      cd "$Prevdir"
      return 1
    }
    #pano_modify --crop=AUTO $Ptofile
    
    # remove all pto files except the final one
    rm $Ptofile.*.pto
  }

  grep -q "Strange values may result!" < "$Logfile" && {
    fehler "align did not find enough control points!
  Check out log file $Logfile
  Probably source images are distorted too much."
    return 1
  }

  # distort images to align them
  echo "########## nona ##########" >> "$Logfile"
  comment "align: Running nona to transform images"
  nona -o "$Destinationdir/PTO_ALIGN" "$Ptofile" >> "$Logfile" || {
    fehler "Error in nona
$(tail $Logfile)"
    cd "$Prevdir"
    return 1
  }
  
  mv -f "$Sourcedir/$Ptofile" "$Cachedir/$Ptofile.bak"

  
  cd "$Destinationdir"
  
  # Crop images
  #Crop="$(grep "arducrop" < "$Cachedir/$Ptofile" | tail -n1 | cut -d: -f2)"
  #[ "$Crop" ] && {
  #  comment "align: Found crop values in $Cachedir/$Ptofile: $Crop"
  #} || {
    comment "align: Checking crop coordinates of common area of all aligned images"
    evaluate "$Destinationdir/PTO_ALIGN*" "$Cachedir/align_PTO" min tif
    Crop="$(trim_hard "$Cachedir/align_PTO.min.tif")"
    #[ "$Crop" = "${Imagewidth}x${Imageheight}+0+0" ] || echo "# arducrop:$Crop" >> "$Cachedir/$Ptofile"
  #}
  #[ "$Crop" ] && comment "align: Crop at $Crop" || {
  #  fehler "align: Crop failed. Continuing image processing with possibly damaged edges."
  #  Crop="${Imagewidth}x${Imageheight}+0+0"
  #}

  Count=-1
  for Line in $(fileglob PTO_ALIGN*); do
    Count=$((Count +1))
    $Convert -crop "$Crop" "$Destinationdir/$Line" "$Destinationdir/${Filearray[$Count]}"
    #$Convert "$Destinationdir/$Line" "$Cachedir/${Line%.tif}.jpg" 
    rm "$Line"
  done
  
  [ "$(dirname "$Cachedir")" = "/tmp" ] && rm -R "$Cachedir"
  cd "$Prevdir"
}
align_ais() {
  local Sourceglob Destinationdir
  local Count Image Alignarray Return
  Sourceglob="${1:-"*"}"
  Destinationdir="${2:-}"

  time align_image_stack -l -s 0 -C --use-given-order -a $Destinationdir/align $(fileglob $Sourceglob) 2>&1 >>$Ardulogfile || return 1
  Count="-1"
  for Image in $(fileglob $Destinationdir/align*) ; do
    Count=$((Count+1))
    Alignarray[Count]="$Image"
  done
  Count="-1"
  for Image in $(fileglob $Sourceglob) ; do
    Count=$((Count+1))
    $Convert ${Alignarray[Count]} "$Destinationdir/$(basename "$Image")"
  done
  rm $Destinationdir/align*
}
align_ffmpeg() {
  local Sourcedir Destinationdir
  local Sourcefileglob
  local Sourcefilelist Cachedir
  local Line Count=0 Targetname
  local Ffmode Tripodframe
  
#  Ffmode=deshake
  Ffmode=vidstab
  
  Sourcedir="${1:-"*"}"
  Destinationdir="${2:-}"
  Cachedir="${3:-"/tmp/align$(mcookie)"}"
  mkdir -p "$Cachedir"
  
  [ -d "$Sourcedir" ] && {
    Sourcefileglob="*"
  }
  check_fileglob $Sourcedir && {
    Sourcefileglob="$(basename "$Sourcedir")"
    Sourcedir="$(dirname "$Sourcedir")"
  }
  check_fileglob $Sourcedir/$Sourcefileglob || {
    fehler "align: No source files found: $Sourcedir/$Sourcefileglob"
    return 1
  }
  Sourcefilelist=$Cachedir/align.source.list
  :> $Sourcefilelist
  for Line in $(fileglob $Sourcedir/$Sourcefileglob); do
    echo "file $Line" >>$Sourcefilelist
  done
  cropeven "$Sourcedir/$Sourcefileglob"
  comment "ffmpeg: generating video"
  ffmpeg -y -safe 0 -f concat -i "$Sourcefilelist"  -vcodec libx264 -profile:v high444 -refs 16 -crf 0 -preset ultrafast $Cachedir/align.source.mp4 >> $Ardulogfile 2>&1 || return 1
  comment "ffmpeg: stabilizing video ($Ffmode)"
  case $Ffmode in
    vidstab)
      Tripodframe=$(grep -c . $Sourcefilelist)
      Tripodframe=$((Tripodframe / 2))
      ffmpeg -y -i $Cachedir/align.source.mp4 -vf vidstabdetect=shakiness=10:accuracy=15:mincontrast=0.1:show=1:result=$Cachedir/transforms1.trf $Cachedir/align.unshake1-show.mp4
#      ffmpeg -y -i $Cachedir/align.source.mp4 -vf vidstabtransform=smoothing=30:crop=black:optzoom=0:input=$Cachedir/transforms.trf $Cachedir/align.unshake.mp4 >> $Ardulogfile 2>&1 || return 1
#      ffmpeg -y -i $Cachedir/align.source.mp4 -vf "vidstabtransform=smoothing=100:crop=black:optzoom=0:input=$Cachedir/transforms.trf,unsharp=5:5:0.8:3:3:0.4" $Cachedir/align.unshake.mp4 >> $Ardulogfile 2>&1 || return 1
#      ffmpeg -y -i $Cachedir/align.source.mp4 -vf "vidstabtransform=smoothing=100:crop=black:optzoom=0:interpol=bicubic:input=$Cachedir/transforms.trf,unsharp=5:5:0.8:3:3:0.4" $Cachedir/align.unshake.mp4 >> $Ardulogfile 2>&1 || return 1
#      ffmpeg -y -i $Cachedir/align.source.mp4 -vf "vidstabtransform=smoothing=0:crop=black:optzoom=0:interpol=bicubic:relative=1:input=$Cachedir/transforms.trf,unsharp=5:5:0.8:3:3:0.4" $Cachedir/align.unshake.mp4 >> $Ardulogfile 2>&1 || return 1
#      ffmpeg -y -i $Cachedir/align.source.mp4 -vf "vidstabtransform=smoothing=0:optzoom=0:interpol=bicubic:relative=1:crop=black:debug=1:input=$Cachedir/transforms.trf" $Cachedir/align.unshake1.mp4 >> $Ardulogfile 2>&1 || return 1

      #ffmpeg -y -i $Cachedir/align.source.mp4 -vf "vidstabtransform=smoothing=0:optzoom=0:interpol=bicubic:relative=1:debug=1:input=$Cachedir/transforms1.trf,unsharp=5:5:0.8:3:3:0.4" $Cachedir/align.unshake1.mp4 >> $Ardulogfile 2>&1 || return 1
      #ffmpeg -y -i $Cachedir/align.source.mp4 -vf "vidstabtransform=smoothing=0:optzoom=0:interpol=bicubic:relative=1:crop=black:debug=1:input=$Cachedir/transforms1.trf,unsharp=5:5:0.8:3:3:0.4" $Cachedir/align.unshake1.mp4 >> $Ardulogfile 2>&1 || return 1
      mv $Cachedir/transforms1.trf $Cachedir/transforms2.trf
      mv $Cachedir/align.source.mp4 $Cachedir/align.unshake1.mp4
      #########Keep for later, must not have crop=black before
      ffmpeg -y -i $Cachedir/align.unshake1.mp4 -vf vidstabdetect=shakiness=2:accuracy=15:mincontrast=0.1:show=1:result=$Cachedir/transforms2.trf $Cachedir/align.unshake2-show.mp4
      ffmpeg -y -i $Cachedir/align.unshake1.mp4 -vf "vidstabtransform=smoothing=0:crop=black:optzoom=0:interpol=bicubic:relative=1:input=$Cachedir/transforms2.trf,unsharp=5:5:0.8:3:3:0.4" $Cachedir/align.unshake2.mp4 >> $Ardulogfile 2>&1 || return 1
      #mv $Cachedir/align.unshake1.mp4 $Cachedir/align.unshake2.mp4
    ;;
    deshake)
      ffmpeg -y -i $Cachedir/align.source.mp4 -vf "deshake=edge=blank:contrast=16:rx=64:ry=64:blocksize=32:filename=$Cachedir/align.ffmpeg.log" $Cachedir/align.unshake.mp4 >> $Ardulogfile 2>&1 || return 1
    ;;
  esac
  comment "ffmpeg: splitting video"
  ffmpeg -y -i $Cachedir/align.unshake2.mp4 $Destinationdir/img%04d.png -hide_banner >> $Ardulogfile 2>&1 || return 1
  for Line in $(fileglob $Destinationdir/*.png); do
    Count=$((Count+1))
    Targetname=$(sed "s/file // ; ${Count}q;d" $Sourcefilelist)
    Targetname="$(dirname $Line)/$(basename $Targetname)"
    convert $Line $Targetname
    rm $Line
  done
  
  comment "align: Checking crop coordinates of common area of all aligned images"
  evaluate "$Destinationdir/*" "$Cachedir/align_crop" min tif
  Crop="$(trim_hard "$Cachedir/align_crop.min.tif" "#000000")"
  
  #for Line in $(fileglob $Destinationdir/*); do
  #  $Convert $Line -crop "$Crop" $Line.crop.jpg
  #  mv -f $Line.crop.jpg $Line
  #  showimage $Line
  #done
}

cropeven() {
  # crop images to even width and height values.
  # needed for ffmpeg codecs that cannot handle odd values
  local Image Infoline Width Height Newwidth Newheight
  comment "Cropping images to even width and height"
  for Image in $(fileglob ${1:-}); do
    Infoline="$($Convert $Image info:)"
    Width="$(echo $Infoline | awk '{print $3}' | cut -dx -f1)"
    Height="$(echo $Infoline | awk '{print $3}' | cut -dx -f2)"
    Newwidth=$((Width/2))
    Newwidth=$((Newwidth*2))
    Newheight=$((Newheight/2))
    Newheight=$((Newheight*2))
    { [ "$Newwidth" != "$Width" ] || [ "$Newheight" != "$Height" ] ; } && {
      $Convert $Image -crop "${Newwidth}x${Newheight}+0+0" $Image.crop.tif
      $Convert $Image.crop.tif $Image
    }
    rm $Image.crop.tif
  done
}

cropcolorpermille() {
  # Function: Calculate permille part of pixels of color $2 in crop rectangle $3 of image $1
  # $1  $Image      image
  # $2  $Trimcolor  color to count
  # $3  $Cropgeometry       crop rectangle to search in
  # Output: Permille part of color in crop region
  
  local Image Trimcolor Cropgeometry
  local Colorcount Cropwidth Cropheight Permille
  
  Image="${1:-}"
  Trimcolor="${2:-}"
  Cropgeometry="${3:-}"
  
  Cropwidth=$(cut -dx -f1 <<< "$Cropgeometry")
  Cropheight=$(cut -dx -f2 <<< "$Cropgeometry" | cut -d+ -f1)

  Colorcount="$(convert "$Image" -crop "$Cropgeometry" txt: | grep -c "$Trimcolor")"
  # second way to count color, a bit slower.
#  Colorcount="$(convert "$Image" -crop "$Cropgeometry" -fill black +opaque "$Trimcolor"  -format %c histogram:info: | grep "$Trimcolor")"
#  Colorcount="$(awk '{print $1}' <<< "$Colorcount" | cut -d: -f1)"

  Permille=$((1000 * $Colorcount / ($Cropwidth*$Cropheight) ))
  echo "${Permille:-0}"
}
trim_hard() {
  # Function: Trim all border with color $2 from image $1
  # Results in a maximal inner rectangle without border color.
  # $1  $Image      image
  # $2  $Trimcolor  color to trim. Default: transparent
  # Output: crop geometry
  
  local Image Trimcolor
  local Imagewidth Imageheight
  local Left         Right         Top         Bottom
  local Skipleft     Skipright     Skiptop     Skipbottom
  local Permilleleft Permilleright Permilletop Permillebottom Permillemax
  local Return
  local Debugmode Loopcount
  
  Image="${1:-}"
  Trimcolor="${2:-"#00000000"}"
  
  Imagewidth=$(convert  -format '%w'  $Image info:)
  Imageheight=$(convert -format '%h'  $Image info:)
  
  Left=0
  Top=0
  Right=$((Imagewidth-1))
  Bottom=$((Imageheight-1))
  
  # First cut with regular trim to save some time.
  # Add a colored border so trim uses the desired color. Afterward remove border from canvas to get correct geometry values. 
  Line="$(convert "$Image" -bordercolor "$Trimcolor" -border 1x1  -trim -set page '%[fx:page.width-2]x%[fx:page.height-2]+%[fx:page.x-1]+%[fx:page.y-1]' info:)"
  Left="$(awk '{print $4}' <<< "$Line" | cut -d+ -f2)"
  Top="$(awk '{print $4}' <<< "$Line" | cut -d+ -f3)"
  Right="$(awk '{print $3}' <<< "$Line" | cut -dx -f1)"
  Right="$((Left+Right-1))"
  Bottom="$(awk '{print $3}' <<< "$Line" | cut -dx -f2)"
  Bottom="$((Top+Bottom-1))"
  
  # Workflow:
  # - Get permille amount of $Trimcolor from all sides.
  # - Remove side with greatest permille amount of $Trimcolor.
  # - Repeat check with new geometry
  while :; do
    # Get permille of $Trimcolor at each side
    [ "$Skipleft" ]   || Permilleleft=$(cropcolorpermille   $Image "$Trimcolor" 1x$((Bottom-Top+1))+$Left+$Top)
    [ "$Skipright" ]  || Permilleright=$(cropcolorpermille  $Image "$Trimcolor" 1x$((Bottom-Top+1))+$Right+$Top)
    [ "$Skiptop" ]    || Permilletop=$(cropcolorpermille    $Image "$Trimcolor" $((Right-Left+1))x1+$Left+$Top)
    [ "$Skipbottom" ] || Permillebottom=$(cropcolorpermille $Image "$Trimcolor" $((Right-Left+1))x1+$Left+$Bottom)
    
    # Determine maximal permille value
    Permillemax=$(echo "
$Permilleleft
$Permilleright
$Permilletop
$Permillebottom
" | sort -n | tail -n1)
    [ "$Permillemax" = "0" ] && break # Ready
    
    # Remove side with maximal permille of $Trimcolor.
    [ "$Permillemax" = "$Permilleleft" ]   && Left=$((Left+1))
    [ "$Permillemax" = "$Permilleright" ]  && Right=$((Right-1))
    [ "$Permillemax" = "$Permilletop" ]    && Top=$((Top+1))
    [ "$Permillemax" = "$Permillebottom" ] && Bottom=$((Bottom-1))
    
    # Skip check for sides without $Trimcolor in future to save some time
    [ "0" = "$Permilleleft" ]   && Skipleft=yes
    [ "0" = "$Permilleright" ]  && Skipright=yes
    [ "0" = "$Permilletop" ]    && Skiptop=yes
    [ "0" = "$Permillebottom" ] && Skipbottom=yes
    
    # Out-of-range error
    { [ "$Left" -gt "$Right" ] || [ "$Top" -gt "$Bottom" ] ; } && {
#      echo "Error: Failed to find an inner rectangle. Unuseable result: $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top" >&2
      fehler "Error: Failed to find an inner rectangle. Unuseable result: $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top" 
      Return=1
      Left=0
      Top=0
      Right=$((Imagewidth-1))
      Bottom=$((Imageheight-1))
      break
    }
    
    # Debugging: show intermediate results
    Debugmode=yes
    [ "$Debugmode" ] && {
      Loopcount=$((Loopcount+1))
      [ "$Loopcount" = "1" ] && {
        Loopcount=0
        convert $Image -fill none -stroke red -strokewidth 1 -draw "rectangle $Left,$Top $Right,$Bottom" $Image.trim_hard.png
        showimage $Image.trim_hard.png
      }
    }
  done
  
  # Output of result
  #echo "$Left,$Top $Right,$Bottom"                     # "-draw rectangle" geometry
  echo $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top  # "-crop" geometry
  
  # Create image with red rectangle at crop coordinates and show it
  convert $Image -fill none -stroke red -strokewidth 1 -draw "rectangle $Left,$Top $Right,$Bottom" $Image.trim_hard.png
  showimage $Image.trim_hard.png
  
  return ${Return:-0}
}
choose_crop() {
  local Image
  local Geometry Windowid Xwininfo Displaypid
  local WinX  WinY  WinW  WinH
  local CropX CropY CropW CropH
  
  Image="${1:-}"

  display -title "Choose crop area of $Image" "$Image" & Displaypid=$!
  Geometry="$($Xmeasure)"
  
  Windowid=$(xdotool search "Choose crop area")
  Xwininfo="$(xwininfo -id "$Windowid" -stats)"
  WinX="$(( $(grep "Absolute upper-left X" <<< "$Xwininfo" | cut -d: -f2)  ))"
  WinY="$(( $(grep "Absolute upper-left Y" <<< "$Xwininfo" | cut -d: -f2)  ))"
  WinW="$(grep "geometry" <<< "$Xwininfo" | cut -dx -f1 | rev | cut -d' ' -f1 | rev)"
  WinH="$(grep "geometry" <<< "$Xwininfo" | cut -dx -f2 | cut -d+ -f1 | cut -d- -f1)"
  kill $Displaypid
    
  CropX="$(grep X <<< "$Geometry" | cut -d' ' -f2)"
  CropY="$(grep Y <<< "$Geometry" | cut -d' ' -f2)"
  CropW="$(grep W <<< "$Geometry" | cut -d' ' -f2)"
  CropH="$(grep H <<< "$Geometry" | cut -d' ' -f2)"
  CropX=$((CropX - WinX))
  CropY=$((CropY - WinY))
  
  { [ "$CropW" = "0" ] || [ "$CropH" = "0" ] || [ "$CropX" -lt "0" ] || [ "$CropY" -lt "0" ] ; } && return 1
  
  echo "${CropW}x${CropH}+$CropX+$CropY"
  return 0
}
mycrop() {
  local Sourceglob Destinationdir
  local Image Cropgeometry Destinationfile
  Sourceglob="${1:-}"
  Destinationdir="${2:-}"
  Image="$Cachefolder/crop.min.tif"
  $Convert $(fileglob $Sourceglob) -evaluate-sequence min "$Image"
  Cropgeometry="$(choose_crop "$Image")"
  rm "$Image"
  [ "$Cropgeometry" ] || return 1
  for Image in $Sourceglob ; do
    Destinationfile="$Destinationdir/$(basename "$Image")"
    $Convert "$Image" -crop $Cropgeometry "$Destinationfile"
    showimage "$Destinationfile"
  done
}
whitebalance_choose() {
  local Sourcefileglob Destinationfile Cachedir
  local Image Cropgeometry
  
  Sourcefileglob="${1:-}"
  Destinationfile="${2:-}"
  Cachedir="${3:-}"
  
  Image="$Cachedir/wb.choose.jpg"
  $Convert $(fileglob $Sourcefileglob) -evaluate-sequence mean "$Image"
  
  Cropgeometry="$(choose_crop "$Image")"
  [ "$Cropgeometry" ] || return 1
  
  echo "$Cropgeometry" > "$Destinationfile"
}
whitebalance() {
  local Sourceglob Destinationdir Cropgeometry Referencecolor
  local Cropgeometry Meancolor Destinationfile Image
  Sourceglob="${1:-}"
  Destinationdir="${2:-}"
  Cropgeometry="${3:-10x10+0+0}"
  Referencecolor="${4:-#AAAA99}"
  
  for Image in $(fileglob $Sourceglob); do
    Meancolor=$(convert $Image -crop $Cropgeometry -filter box -resize 1x1! -format "%[pixel:u]" info:)
    Destinationfile="$Destinationdir/$(basename "$Image")"
    $Whitebalance -c "$Meancolor" -r "$Referencecolor" "$Image" "$Destinationfile"
    showimage "$Destinationfile"
  done
  
}
#########################
# unsortiert            #

savepos() {
  ## Funktion: Derzeitige Positionen merken
  # Dient der Synchronisation der Positionsdaten über Parallelprozesse hinweg
  echo "${Poscurrent:-0} ${Pos1:-0} ${Pos2:-0}" ${Schrittweite:-1} >$Positionfile
#  comment "save: $(cat $Positionfile)"
}
readpos() {
  ## Funktion: Derzeitige Positionen auslesen
  # Dient der Synchronisation der Positionsdaten über Parallelprozesse hinweg
  read Poscurrent Pos1 Pos2 Schrittweite <$Positionfile
#  comment "read: $Poscurrent $Pos1 $Pos2 $Schrittweite"
}
hubloop_stepin() {
  ## Funktion: Permanent stepin Kommandos senden, wenn $Hubloop_stepinfile nicht leer ist
  # Wird durch L-SHIFT in keypress_watch() gesteuert
  while :; do
    [ -s $Hubloop_stepinfile ]  && cmd -w stepin  || sleep 0.1
  done
}
hubloop_stepout() {
  ## Funktion: Permanent stepout Kommandos senden, wenn $Hubloop_stepinfile nicht leer ist
  # Wird durch L-CTRL in keypress_watch() gesteuert
  while :; do
    [ -s $Hubloop_stepoutfile ] && cmd -w stepout || sleep 0.1
  done
}

keypress_watch_sendkey() {
  # Taste(n) $1 mit xdotool "tippen"
  local Capslock=
  Capslock=$(xset -q | grep Caps | awk '{print $4}')
  [ "$Capslock" = "on" ] && keypress_unlock
  xdotool key ${1:-}
  [ "$Capslock" = "on" ] && keypress_lock
}

###########################
#### Tastatursteuerung ####

keypress_lock() {
  # Tastatur blockieren
  sleep 0.1
  xtrlock & echo $! >$Xtrlockpidfile
}
keypress_unlock() {
  # Tasturblockade aufheben
  mykill $(cat $Xtrlockpidfile)
  sleep 0.2
}
keypress_watch() {
  # Einfangen aller Tastatureingaben und auf Tastendruck Befehle senden.
  # Aktivieren/Deaktivieren mit CAPSLOCK.
  # Nutzt xtrlock zum Sperren von Tastatur und Maus.
  # Einzelne Tastatureingaben werden weitergereicht, dafür wird xtrlock beendet und wieder gestartet.
  
  while read Line <&8 ; do
    Keyhub=$(awk '{print $2}' <<< $Line)
    Keycode=$(awk '{print $3}' <<< $Line)
    Capslock=$(xset -q | grep Caps | awk '{print $4}')
    case $Capslock in
      on)  [ "$Keywatch" = "off" ] && keypress_lock && Keywatch="on" ;;
      off) [ "$Keywatch" = "on" ]  && keypress_unlock && Keywatch="off" ;;
    esac
    [ "$Keywatch" = "on" ] && case $Keyhub in
      press)
        case $Keycode in
        
          # ALT-Taste freigeben (um ALT+Tab zu erlauben)
          64)  keypress_unlock ;;                     # L-Alt
          
          # Durchgehender Lauf von Stepin/Stepout
          50) echo "stepin"  >$Hubloop_stepinfile ;;  # L-Shift
          37) echo "stepout" >$Hubloop_stepoutfile ;; # L-Ctrl
          
          # Guake toggle
          96)  guake -t ;;                            # F12
          
          # Toggle window mode
          23)  cmd "win" ;;                           # TAB
          
          # Schrittweite
          10)  cmd "w 1" ;;                           # 1
          11)  cmd "w 2" ;;                           # 2
          12)  cmd "w 5" ;;                           # 3
          13)  cmd "w 10" ;;                          # 4
          14)  cmd "w 25" ;;                          # 5
          15)  cmd "w 50" ;;                          # 6
          16)  cmd "w 100" ;;                         # 7
          17)  cmd "w 200" ;;                         # 8
          18)  cmd "w 400" ;;                         # 9
          
          # stepin / stepout
          31)  cmd "i" ;;                             # i
          32)  cmd "o" ;;                             # o
          
          # Positionen speichern oder anlaufen
          87)  cmd "pos1" ;;                          # Num-1
          89)  cmd "pos2" ;;                          # Num-3
          79)  cmd "go1" ;;                           # Num-7
          81)  cmd "go2" ;;                           # Num-9
          
          # Positionen auf 0
          19)  cmd "zero" ;;                          # 0
          
          # Stackshot
          9)   :> $Stackshotfile ;;                   # ESC
          117) cmd "stack -p" ;;                      # Bild-hoch
          112) cmd "stack -c" ;;                      # Bild-runter
          
          # Programmende
          24)  cmd "exit" ;;                          # q
          
          # ISO Lichtempfindlichkeit
          25)  cmd "iso 100" ;;                       # w
          26)  cmd "iso 200" ;;                       # e
          27)  cmd "iso 400" ;;                       # r
          28)  cmd "iso 800" ;;                       # t
          29)  cmd "iso 1600" ;;                      # z
          
          # Video Vorschau/Preview
          30)  cmd "zoom toggle" ;;                   # u
          33)  cmd "preview" ;;                       # p
          34)  cmd "stop-movie" ;;                    # ü
          
          # Shutter Verschlußzeit
          38)  cmd "shutterspeed 1/10" ;;             # a
          39)  cmd "shutterspeed 1/20" ;;             # s
          40)  cmd "shutterspeed 1/40" ;;             # d
          41)  cmd "shutterspeed 1/80" ;;             # f
          42)  cmd "shutterspeed 1/125" ;;            # g
          43)  cmd "shutterspeed 1/200" ;;            # h
          44)  cmd "shutterspeed 1/320" ;;            # j
          45)  cmd "shutterspeed 1/400" ;;            # k
          46)  cmd "shutterspeed 1/800" ;;            # l
          
          # Foto
          65)  cmd "capture-image-and-download" ;;    # Space
          55)  cmd "capture-preview" ;;               # v
          
          # Videovorschau mit Zoom: Sichtfenster bewegen
          62)  Shift_r="1" ;;                         # R-Shift
          80)  [ "$Shift_r" ] && cmd "move-zoom y -640" || cmd "move-zoom y -64" ;;  # Num-8
          88)  [ "$Shift_r" ] && cmd "move-zoom y +640" || cmd "move-zoom y +64" ;;  # Num-2
          83)  [ "$Shift_r" ] && cmd "move-zoom x -640" || cmd "move-zoom x -64" ;;  # Num-4
          85)  [ "$Shift_r" ] && cmd "move-zoom x +640" || cmd "move-zoom x +64" ;;  # Num-6
          
        esac
      ;;
      release)
        case $Keycode in
          50) :> $Hubloop_stepinfile ;;               # L-Shift
          37) :> $Hubloop_stepoutfile ;;              # L-Ctrl
          62)  Shift_r="" ;;                          # R-Shift
          64)  keypress_lock ;;                       # L-Alt
        esac
      ;;
    esac
  done
}
readline_watch() {
  # Terminaleingaben lesen und weiterreichen
  local Commandline=
  while : ; do
    cd $(cat $Workdirfile)
    history -n $Historyfile
    sleep 0.5
    read -r -e Commandline
    echo "$Commandline" >> $Commandfifo
  done
}
stdin_watch() {
  # Von stdin lesen und weiterreichen
  local Commandline=
  while : ; do
    cd $(cat $Workdirfile)
    sleep 0.5
    read -r Commandline
    cmdstatus receive "$Commandline"
    echo "$Commandline" >> $Commandfifo
  done
}

##########################
#### Kommandozentrale ####

cmd() {
  ## Funktion: Kommando auf Kommandostapel legen
  #  -w   Auf Ende der Ausführung des Kommandos warten
  
  local Warten=
  [ "$1" = "-w" ] && Warten="yes" && shift
  
  # Kommandosperre setzen
  echo "$*" > $Pleasewaitfile
  
  ## Funktion: Kommando senden
  echo "$*" >> $Commandfifo
  
  # Warte auf Ende der Kommandosperre
  [ "$Warten" = "yes" ] && {
    while :; do
      [ -s "$Pleasewaitfile" ] || break
      sleep 0.001
    done
  }
}
cmd_loop() {
  ## Funktion: Kommandostapel zeilenweise an Parser weiterreichen
  local Commandline
  while :; do
  
    read -r -t1  Commandline <&4
#    [ -z "$Commandline" ] && echo "idle" >>$Ardutermstatusfile
    [ -z "$Commandline" ] && storeinfo arduterm.status=idle
#    [ -n "$Commandline" ] && echo "busy" >>$Ardutermstatusfile && {
    [ -n "$Commandline" ] && storeinfo arduterm.status=busy && {
      echo  "$Commandline" >> $Historyfile       # Eintrag für history von readline
      echo  "$Commandline" > "$Pleasewaitfile"   # Kommandosperre setzen

      ps -p $Imageviewerpid >/dev/null 2>&1 || Imageviewerpid=""
      ps -p $Ffplaypid      >/dev/null 2>&1 || Ffplaypid=""
    
      Lateststack="$(cat "$Lateststackfile")"
      cd "$(cat "$Workdirfile")"
    
      #set -f
      cmdstatus work "$Commandline"
      cmd_parser $Commandline
      case $? in
        0) cmdstatus ready "$Commandline" ;;
        *) cmdstatus error "$Commandline" ;;
      esac
    #set +f
    
      [ -s "$Ardutermrunfile" ] || break
    
      # Prompt anzeigen
      Currentdir=$(pwd)
      echo -e "${WEISS} $Poscurrent  ${BLAU}Pos1:${GELB}$Pos1 ${BLAU}[$(awk 'BEGIN {print 0.048 * '$((Pos2 - Pos1))'}')µm][$(( (Pos2-Pos1) / $Schrittweite )) shots] ${BLAU}Pos2:${GELB}$Pos2 \
${BLAU}w:${WEISS}$Schrittweite(=$(awk 'BEGIN {print 0.048 * '$Schrittweite'}')µm) \
${BLAU}iso:${WEISS}${Iso:-N/A} ${BLAU}shutter:${WEISS}${Shutterspeed:-N/A}
${BLAU}dir:${Currentdir#"$Arduhome/"} $WEISS"
      # check [and show] background processes
      Batchpids=0
      Fusepids=0
      Stackpids=0
      while read Pid Name; do
        ps -p $Pid>/dev/null && case $Name in
          batch) Batchpids=$((Batchpids+1)) ;;
          fuse) Fusepids=$((Fusepids+1)) ;;
          stack) Stackpids=$((Stackpids+1)) ;;
        esac || sed -i "/$Pid /d" $Backgroundpidfile
      done <$Backgroundpidfile
      [ "$((Batchpids + Fusepids + Stackpids))" = "0" ] || echo -e "${BLAU}Background processes still running: batch:${ROT}$Batchpids${BLAU} fuse:${ROT}$Fusepids${BLAU} stack:${ROT}$Stackpids${WEISS}"
    
      # Kommandosperre aufheben
      :> "$Pleasewaitfile"
    }
  done
}
cmd_parser() {
  ## Funktion: Kommandozentrale von arduterm
  
  local Command
  local Videomode_restore= Ordnername=
  local Return=
  
  Command="${1:-}"
  shift
  #set +f
  
  case "$Command" in       # Laufende Videoaufnahme bei gphoto2 Aufruf unterbrechen, ggf. nach Kommando wieder starten
    "get-config"|"gc"|"set-config"|"setconfig"|"sc"|\
    "set-config-value"|"scv"|"set-config-index"|"sci"|\
    "switch"|"switch-config"|"iso"|"shutter"|"shutterspeed"|\
    "capture-image"|"cap"|"capture-image-and-download"|"capd"|"capture-preview"|"capp"|\
    "zoom"|"u"|"move-zoom"|"mirrorup"|"m"|\
    "gphoto2"|"stack")
       Videomode_restore=$Videomode
       videoaufnahme stop-movie
    ;;
  esac
  
  case "$Command" in
    #### Allgemeine Optionen ####
    "hilfe"|"help") # Hilfe anzeigen
       comment "
### Allgemeine Kommandos ###
hilfe                               Diese Hilfe
exit|q                              Arduterm beenden
home
project
name

### Gerätespezifische Kommandos ###
device ADRESSE                      Device initialisieren. Ein Arduino hat oft die Adresse /dev/ttyACM0
send [SIGNAL]                       SIGNAL an Device/Arduino senden

### Dateioperationen ###
cd [ORDNER]                         In Verzeichnis ORDNER wechseln
ls                                  Verzeichnisinhalt anzeigen.
image [BILD | OPTION]               BILD anzeigen mit Bildbetrachter 'geeqie'
                                    Ohne Optionen: alle Bilder in einer Liste zur Auswahl anbieten
                                    -rh zeigt verfügbare Optionen OPTION von geeqie
video [VIDEO]                       VIDEO abspielen. Ohne Option: Letztes aufgenommenes Video zeigen
mkdir ORDNERNAME                    Verzeichnis ORDNERNAME anlegen
mkdir-time [ORDNERNAME]             Verzeichnis ORDNERNAME mit Datum und Uhrzeit im Namen anlegen und hineingehen
### gphoto2-Aufrufe ###
gphoto2  [OPTIONEN]                 gphoto2 mit OPTIONEN direkt aufrufen
set-config | s [ENTRY]              Kamera interaktiv konfigurieren (Dialog)
get-config | g [ENTRY]              Konfiguration der Kamera anzeigen. ENTRY z.B. 'iso' oder 'shutterspeed'
                                    Ohne ENTRY: Alle Einstellungen vom TYP RADIO/MENU anzeigen
set-config-value | scv ENTRY=VALUE  Aufruf von:   gphoto2 --set-config-value ENTRY=VALUE
set-config-index | sci ENTRY=INDEX  Aufruf von:   gphoto2 --set-config-index ENTRY=INDEX
switch-config ENTRY [ + | - ][n]    Kameraeinstellung ENTRY auf nächste (+) oder vorherige (-) Stufe einstellen
                                    +n oder -n : n Stufen weiterstellen
mirrorup | m                        Spiegel hochklappen
zoom 1|5|10                         Liveview/Video-Zoom 1x, 5x oder 10x
move-zoom x|y PIXEL                 Position des Zoom-Focus relativ in X oder Y Richtung um PIXEL ändern. 
                                    Bei 'zoom 5' oder 'zoom 10' bewegt dies die Position des sichtbaren Bildes
capture-image | cap                 Foto aufnehmen und auf Kamera speichern
capture-image-and-download | capd   Foto aufnehmen und herunterladen
capture-preview | capp              Preview-Bild aufnehmen und herunterladen
preview | p                         Video: Preview anzeigen
capture-movie | start               Video: Preview anzeigen und speichern
capture-movie-no-preview            Video: Aufnehmen ohne Preview.
                                    Option: DAUER Frames oder DAUERs Sekunden 
stop-movie | stop                   Videoaufnahme stoppen
"
       ;;
    "#") comment "$*" ;;     # Kommentar anzeigen.
    "exit"|"q") :> $Ardutermrunfile ;; # Programm beenden. 
    "win")
      case $Windowmode in
        fullimage)   Windowmode=fullpreview ;;
        fullpreview) Windowmode=split ;;
        split)       Windowmode=fullimage ;;
      esac
      window_placement
      ;;
       
    #### Kommunikation mit Device/Arduino
    "device") # Geräteadresse setzen
       device_init $1
       comment "Beginne Überwachung von $Deviceadresse"
       ;;
    "send") # Signal an Arduino senden. Syntax: send SIGNAL1 SIGNAL2 SIGNAL3 ...
       comment "Sende an $Deviceadresse: $*"
       device_send "$*"
       device_wait
       Return=$?
       ;;
    "0"|"zero") 
       comment "Setze alle Positionsmarker auf 0."
       Poscurrent="0" ; Pos1="0" ; Pos2="0"
       setpos0
       savepos
       ;;
    "pos0") 
       comment "Nullpunkt definiert"
       Poscurrent=0
       setpos0
       savepos
       ;;
    "pos1")
       comment "Setze Pos1 auf: $Poscurrent"
       Pos1=$Poscurrent
       savepos
       ;;
    "pos2") 
       comment "Setze Pos2 auf: $Poscurrent"
       Pos2=$Poscurrent
       savepos
       ;;
    "go1")  
       comment "Gehe zu Pos1: $Pos1"
       steplauf "$Pos1" 
       ;;
    "go2")
       comment "Gehe zu Pos2: $Pos2"
       steplauf "$Pos2" 
       ;;
    "go0")  
       comment "Gehe zu Nullpunkt Pos0: 0"
       steplauf "0" 
       ;;
    "i"|"stepin")  
       steplauf "$(bc <<< "$Poscurrent + $Schrittweite")" 
       ;;
    "o"|"stepout") 
       steplauf "$(bc <<< "$Poscurrent - $Schrittweite")" 
       ;;
    "w")
       Schrittweite="$1"
       device_send "w,$Schrittweite"
       device_wait >/dev/null
       Return=$?
       savepos
       ;;
       
    #### Dateioperationen ####
    "home") # Basisverzeichnis für arduterm Bilder+Videos festlegen
       [ "${1:-}" ] && Arduhome="$1"
       cd "$Arduhome"
       pwd > $Workdirfile
       ;;
    "projekt"|"project") # Projektname festlegen, Ordner erzeugen und hineingehen
       setup_projectdir "$1"
       ;;
    "name")
       Stackshotname="$1"
       ;;
    "cd") # Verzeichnis wechseln
       cd ${1:-$Arduhome/$Projektname}
       pwd >$Workdirfile
       sleep 0.1
       #xdotool key Return
       ;;
    "mkdir") # Verzeichnis anlegen
       comment "Erzeuge Ordner $1"
       mkdir "$1"
       ;;
    "ls") # Verzeichnisinhalt anzeigen
       ls "$@"
       ;;
    "showimage"|"image") # Bild $1 anzeigen.
       showimage "$@"
       ;;
    "video") # Video $1 oder $Latestvideo abspielen
       ffplay -loglevel error "${1:-$Latestvideo}"
       ;;
       
    #### gphoto2 Aufrufe ####
    "get-config"|"gc")
       ardu_gphoto2 get-config $@
       ;;
    "set-config"|"setconfig"|"sc") # Kamera mit Hilfe von gphoto2 konfigurieren
       comment "Konfiguration der Kamera mittels Dialog"
       # Tastaturabfrage anhalten, um sie für Dialog freizuhalten
       kill -s STOP $Watchreadlinepid
       ardu_gphoto2 set-config "$@"
       kill -s CONT $Watchreadlinepid
       clear
       ;;
    "set-config-value"|"scv") # Kameraeinstellung setzen
       ardu_gphoto2 $Command $*
       ;;
    "set-config-index"|"sci") # Kameraeinstellung setzen
       ardu_gphoto2 $Command $*
       ;;
    "switch"|"switch-config")
       ardu_gphoto2 switch-config $@
       ;;
    "iso")
      case $1 in
        "")   ardu_gphoto2 get-config -a iso ;;
        "-")  Iso=$(ardu_gphoto2 switch-config iso -) ;;
        "+")  Iso=$(ardu_gphoto2 switch-config iso +) ;;
        *)    ardu_gphoto2 set-config-value iso=$1 && Iso=$1 ;;
      esac
      ;;
    "shutter"|"shutterspeed")
      case $1 in
        "") ardu_gphoto2 get-config -a shutterspeed ;;
        +)  Shutterspeed=$(ardu_gphoto2 switch-config shutterspeed +) ;;
        -)  Shutterspeed=$(ardu_gphoto2 switch-config shutterspeed -) ;;
        *)  ardu_gphoto2 set-config-value shutterspeed=$1 && Shutterspeed=$1 ;;
      esac
      ;;
       
    "capture-image"|"cap") 
       comment "Fotoaufnahme in Kameraspeicher"
       setup_projectdir
       ardu_gphoto2 capture-image
       ;;
    "capture-image-and-download"|"capd")
       comment "Fotoaufnahme auf Festplatte"
       setup_projectdir
       ardu_gphoto2 capture-image-and-download
       showimage "$Latestimage"
       comment "Bild gespeichert als $Latestimage"
       ;;
    "capture-preview"|"capp")
       comment "Nehme einzelnes Video-Preview-Bild auf"
       setup_projectdir
       ardu_gphoto2 capture-preview
       showimage "$Latestimage"
       comment "Bild gespeichert als $Latestimage"
       ;;
        
    "zoom"|"u") # eoszoom 1x, 5x, 10x
       case $1 in
         1|5|10) Previewzoom=$1 ;;
         toggle|"") 
           case $Previewzoom in
             1|5) Previewzoom=10 ;;
             10)  Previewzoom=1 ;;
           esac
         ;;
       esac
       ardu_gphoto2 zoom $Previewzoom
       ;;
    "move-zoom")
       ardu_gphoto2 move-zoom $1
       ;;
    "mirrorup"|"m")
       ardu_gphoto2 mirrorup $1
       ;;
         
    "gphoto2") # gphoto2 (mit Optionen) direkt aufrufen. Syntax: Normaler gphoto2-Aufruf
       ardu_gphoto2 gphoto2 $*
       ;;
         
    #### Video ####
    "preview"|"p")
       videoaufnahme preview
       ;;
    "capture-movie-no-preview")
       comment "Videoaufnahme wird gespeichert, aber nicht angezeigt."
       setup_projectdir
       videoaufnahme capture-movie
       comment "Video wird gespeichert als $Latestvideo"
       ;;
    "capture-movie"|"start")
       comment "Videoaufnahme wird gespeichert und angezeigt."
       setup_projectdir
       videoaufnahme capture-movie-and-preview
       comment "Video wird gespeichert als $Latestvideo"
       ;;
    "stop-movie"|"stop")
       comment "Videoaufnahme wird gestoppt"
       videoaufnahme stop-movie
       ;;
       
    #### Stacking ####
    "stack")
       Videomode_restore=""
       setup_projectdir
       stackshot $1 & echo $! stack >>$Backgroundpidfile
       ;;
    "median"|"med")
       Evalstack="yes"
       Evalnumber="${1:-4}"
       [ "$Evalnumber" -gt "1" ] || Evalnumber="1"
       [ "$Evalnumber" =   "1" ] && Evalstack="no"
       ;;
       
    #### Image processing ####
    "bat"|"batch")
       batch_all "$1" #& echo $! batch >>$Backgroundpidfile
       Return=$?
       ;;
    "align")
       batch_function align "${1:-}" "${2:-}" #& echo $! batch >>$Backgroundpidfile
       Return=$?
       ;;
    "prepare"|"level"|"gamma"|"contrast"|"sharpen"|"crop"|"stretch"|"kuwahara"|"wizard"|"undo")
       Function="$Command"
       [ "${1:-}" = "-c" ] && Functionsuffix="-compose" && shift
       [ "${1:-}" = "-f" ] && Functionsuffix="-fuse" && shift
       [ "${1:-}" = "-e" ] && Functionsuffix="-evaluate" && shift
       Path="${1:-}" ; shift
       batch_function $Function$Functionsuffix "$Path" "$*"
       Return=$?
       ;;
    "white"|"whitebalance"|"wb")
       [ "${1:-}" = "-c" ] && Functionsuffix="-compose" && shift
       [ "${1:-}" = "-f" ] && Functionsuffix="-fuse" && shift
       [ "${1:-}" = "-e" ] && Functionsuffix="-evaluate" && shift
       batch_function choose-whitebalance$Functionsuffix "${1:-}" && batch_function whitebalance$Functionsuffix "${1:-}"
       Return=$?
       ;;
    "compose-cache")
       batch_function evaluate "${1:-}" all
       Return=$?
       [ "$Return" = "0" ] && batch_function compose "${1:-}" all
       Return=$?
       ;;
    "compose-fuse")
       batch_function evaluate-fuse "${1:-}" all
       Return=$?
       [ "$Return" = "0" ] && batch_function compose-fuse "${1:-}" all
       Return=$?
       ;;
    "compose")
       #[ "${1:-}" = "-c" ] && Functionsuffix="-compose" && shift
       #[ "${1:-}" = "-f" ] && Functionsuffix="-fuse" && shift
       #[ "${1:-}" = "-e" ] && Functionsuffix="-evaluate" && shift
       batch_function evaluate "${1:-}" all
       Return=$?
       [ "$Return" = "0" ] && batch_function compose "${1:-}" all
       Return=$?
       [ "$Return" = "0" ] && batch_function evaluate-fuse "${1:-}" all
       Return=$?
       [ "$Return" = "0" ] && batch_function compose-fuse "${1:-}" all
       Return=$?
       ;;
    "fuse") 
       batch_function fuse "${1:-}"
       Return=$?
       ;;
       
    "kill")
       while read Pid Name; do
         ps -p $Pid | grep -q -E 'arduterm|enfuse|align_image_stack' && kill "$Pid"
       done <$Backgroundpidfile
       ;;
    "") ;;
    *) fehler "Fehler: unbekanntes Kommando: $Command" ;;
  esac
  [ -z "$Return" ] && Return=$?
  # ggf. Video wieder starten
  [ "$Videomode_restore" ] && videoaufnahme $Videomode_restore
  return ${Return:-0}
}

#######################
#### Hauptprogramm ####

declare_variables() {
  Configfile="$HOME/.config/arduterm.init"
  
  # Farben für späteren Gebrauch definieren
  ROT="\e[31m"
  GELB="\e[33m"
  WEISS="\e[37m"
  BLAU="\e[1;34m"
  
  ZOOM_XPOS=1600
  ZOOM_YPOS=960
  
  Arduhome="$HOME/Bilder/arduterm"
  Latestvideo=
  
  Deviceadresse="/dev/null"
  Devicetimeout=2
  
  Targetmonitor=
  Windowmode=split       # split|fullimage|fullpreview
  
  Schrittweite=1
  Poscurrent=0
  Pos0=0
  Pos1=1000
  Pos2=1001
  
  Previewzoom=1
  Shutterspeed=
  Iso=
  
  Keyboardid=$(xinput | grep "AT Translated" | cut -d= -f2 | awk '{print $1}')
  Xinputpid=
  Watchkeypresspid=
  Watchdevicepid=
  Watchreadlinepid=
  
  Inputmethod="cli"
  Keywatch="off"
  
  Evalnumber="1"
  Evalstack="no"
  Evalwait="2.5"
  
  Fileformat="tif"

  Projektname=""
  Stackshotname="stack"
  
  Convert="convert -quality 100%"
  Xmeasure="/home/lauscher/git/microscopy-tools/xmeasure"
  Whitebalance="/home/lauscher/git/microscopy-tools/whitebalance"
}
parse_options() {
  local Longoptions Shortoptions Parsedoptions
  local Parsererror Parsererrorfile
  
  Shortoptions=""
  Longoptions="cache:,stdin"
  Parsererrorfile="/tmp/arduterm.parserserror"
  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@" 2>$Parsererrorfile)"
  [ -e $Parsererrorfile ] && Parsererror=$(cat $Parsererrorfile) && rm $Parsererrorfile
  [ "$Parsererror" ] && fehler "$Parsererror" && exit 1
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ]; do
    case "${1:-}" in
      --cache)      Cachefolder="${2:-}"   ; shift ;;
      --stdin)      Inputmethod="stdin" ;;
      --) ;;
      *) fehler "Unknown option:${1:-}" ;;
    esac
    shift
  done
}
create_cachefiles() {
  [ -z "${Cachefolder:-}" ] && {
    Cachefolder=/tmp/arduterm$(mcookie | cut -c1-4)
    mkdir -p $Cachefolder
    rm $Cachefolder/* 2>/dev/null
  }
  
  Ardulogfile=$Cachefolder/arduterm.log
  :> $Ardulogfile
  
  Storeinfofile="$Cachefolder/store.info"
  [ -e "$Storeinfofile" ] || :> $Storeinfofile
  
  Kameradumpfile=$Cachefolder/gphoto2.dump
  :> $Kameradumpfile
  
  Devicemessagefifo=$Cachefolder/device.message.fifo
  mkfifo $Devicemessagefifo
  exec 7<> $Devicemessagefifo

  Commandfifo=$Cachefolder/command.fifo
  mkfifo $Commandfifo
 # :> $Commandfifo
  exec 4<> $Commandfifo

  Keywatchfifo=$Cachefolder/keywatch.fifo
  mkfifo $Keywatchfifo
  exec 8<>$Keywatchfifo
  
  Workdirfile=$Cachefolder/workdir
  pwd >$Workdirfile
  
  Cmdstatusfile="$Cachefolder/arduterm.cmdstatus"
#  :> $Cmdstatusfile
  
  Historyfile=$Cachefolder/history
  :> $Historyfile
  
  Pleasewaitfile=$Cachefolder/parser.action
  :> $Pleasewaitfile
  
  Stackshotfile=$Cachefolder/stackshot.action
  :> $Stackshotfile
  
  Lateststackfile=$Cachefolder/stack.latest
  :> $Lateststackfile
  
  Latestimagefile=$Cachefolder/image.latest
  :> $Latestimagefile
  
  Xtrlockpidfile=$Cachefolder/xtrlock.pid
  :> $Xtrlockpidfile
  
  Latestimagelink=$Cachefolder/image.latest.link
  
  Ardutermrunfile=$Cachefolder/arduterm.action
  echo "action" >$Ardutermrunfile
  
  Backgroundpidfile=$Cachefolder/bgpids
  :> $Backgroundpidfile
  
  Hubloop_stepinfile=$Cachefolder/loop.stepin.action
  Hubloop_stepoutfile=$Cachefolder/loop.stepout.action
  :> $Hubloop_stepinfile
  :> $Hubloop_stepoutfile
  
  Positionfile=$Cachefolder/position
  savepos
}
check_dependencies() {

  command -v gphoto2 >/dev/null || fehler "Warnung: gphoto2 nicht gefunden. Wird benötigt für Kamerasteuerung."
  command -v geeqie >/dev/null  || fehler "Warnung: geeqie nicht gefunden. Wird benötigt für Bildanzeige."
  command -v ffmpeg >/dev/null  || fehler "Warnung: ffmpeg nicht gefunden. Wird benötigt für Videovorschau."
  command -v dialog >/dev/null  || fehler "Warnung: dialog nicht gefunden. Wird benötigt für interaktive Kamerakonfiguration."
  command -v xtrlock >/dev/null || fehler "Warnung: xtrlock nicht gefunden. Wird benötigt für Tastatursteuerung mit CAPSLOCK."
  command -v xinput >/dev/null  || fehler "Warnung: xinput nicht gefunden. Wird benötigt für Tastatursteuerung mit CAPSLOCK."
  command -v xdotool >/dev/null || fehler "Warnung: xdotool nicht gefunden. Wird benötigt für Fensterkontrolle."
  command -v wmctrl >/dev/null  || fehler "Warnung: wmctrl nicht gefunden. Wird benötigt für Fensterkontrolle."
  
  # Gruppe dialout prüfen
  id | grep -q dialout          || fehler "Warnung: Benutzer $(id -un) ist nicht in Gruppe dialout. Wird benötigt, um Arduino anzusteuern."
  
  # Auf Guake Terminal prüfen
  ps -p $(ps -o ppid -p $PPID | tail -n1) | grep -q guake || fehler "Warnung: arduterm ist für Terminal Emulator Guake ausgelegt."
}
arduterm_ende() {
  ## Funktion: Programm sauber beenden
  trap - EXIT
  
  # Eventuell laufende Videoaufnahme stoppen
  videoaufnahme stop-movie
  
  # Hintergrundprozesse stoppen
  for Pid in $Watchreadlinepid $Watchdevicepid $Watchkeypresspid $Xinputpid $(cat $Xtrlockpidfile) $Imageviewerpid $Hubloopstepinpid $Hubloopstepoutpid ; do mykill $Pid ; done
  while read Pid Name; do
    ps -p $Pid | grep -q -E 'arduterm|enfuse|align_image_stack' && {
      fehler "Beende $Pid $Name"
      kill $Pid
    }
  done <$Backgroundpidfile
  
  exec 4<&-
  exec 6<&-
  exec 7<&-
  exec 8<&-

 # rm -R $Cachefolder
  
  exit
}
main() {
  trap arduterm_ende EXIT
  
  declare_variables
  parse_options "$@"
  create_cachefiles
  check_dependencies
  
  tail --pid=$$ -F $Ardulogfile 2>/dev/null &
  
  [ -s "$Configfile" ] && cat $Configfile >> $Commandfifo
  
  case "$Inputmethod" in
    stdin) 
      stdin_watch <&0                     & Watchreadlinepid=$!
    ;;
    cli)  
      readline_watch <&0                  & Watchreadlinepid=$!
    ;;
    oneshot)    # execute single command only if given on cli
      Commandline="$*"
      [ -d "$Commandline" ] || check_fileglob $Commandline && Commandline="batch $Commandline"
      cmd_parser $Commandline
      wait
      arduterm_ende
    ;;
  esac
  
  xinput test $Keyboardid >>$Keywatchfifo & Xinputpid=$!
  keypress_watch                          & Watchkeypresspid=$!
  
  hubloop_stepin                          & Hubloopstepinpid=$!
  hubloop_stepout                         & Hubloopstepoutpid=$!
  
  cmd_loop
  arduterm_ende
}
main "$@"


XXX_align() {
  # align images with align_image_stack.
  # special: devide into two halves starting from the middle and merge again later.
  # run detect_sourcedir() first to set some variables.
  
  local Line Middle Count Filecount Filelist
  local Destinationfile
  local Alignpid

  comment "Aligning stack: ${Sourcedir-$Arduhome}/$Sourcefileglob"
  
  # read filenames in array
  Filecount=-1
  for Line in $(fileglob $Sourcedir/$Sourcefileglob) ; do
    [ -f "$Line" ] && {
      Filecount=$((Filecount+1))
      Filelist[$Filecount]="$Line"
    }
  done
  [ "$Filecount" = "-1" ] && fehler "align: Keine Bilder gefunden" && return 1
  
  # create temporary working dirs
  mkdir $Sourcedir/align.tmp.1
  mkdir $Sourcedir/align.tmp.2
  mkdir $Sourcedir/align.tmp.3

  # split files with softlinks into two folders
  # reverse order for first half of images in folder 1
  # middle file is part of both folders and the first of both alignments
  Middle=$((Filecount / 2))
  for ((Line=0 ; Line<=Middle ; Line++)); do
    ln -s ${Filelist[$Line]} $Sourcedir/align.tmp.1/sl$(printf %04d $((Middle-Line)))
  done
  for ((Line=Middle ; Line<=Filecount ; Line++)); do
    ln -s ${Filelist[$Line]} $Sourcedir/align.tmp.2/sl$(printf %04d $Line)
  done
#  for ((Line=0 ; Line<=Filecount ; Line++)); do
#    ln -s ${Filelist[$Line]} $Sourcedir/align.tmp.2/sl$(printf %04d $Line)
#  done
  
  # align both folders
  time align_image_stack -l -m -s 0 --use-given-order -a $Sourcedir/align.tmp.1/align $Sourcedir/align.tmp.1/sl* 2>&1 | grep -v "Unable to read EXIF data" & Alignpid1=$!
  time align_image_stack -l -m -s 0 --use-given-order -a $Sourcedir/align.tmp.2/align $Sourcedir/align.tmp.2/sl* 2>&1 | grep -v "Unable to read EXIF data" & Alignpid2=$!
  echo $Alignpid1 align >>$Backgroundpidfile
  echo $Alignpid2 align >>$Backgroundpidfile
  wait $Alignpid1
  wait $Alignpid2
#  time align_image_stack -C -l -m -v -v --use-given-order -a $Sourcedir/align.tmp.2/align $Sourcedir/align.tmp.2/sl* 2>&1 | grep -v "Unable to read EXIF data" & Alignpid=$!
#  echo $Alignpid align >>$Backgroundpidfile
#  wait $Alignpid
  
  # move aligned images in right order to source dir
  [ "$Sourcefileglob" = "s_*" ] && Destinationprefix="sa_" || Destinationprefix="a_"
    for ((Line=0 ; Line<=Middle ; Line++)); do
    Destinationfile="$(basename ${Filelist[$((Middle - Line))]})"
    [ "$Sourcefileglob" = "s_*" ] && Destinationfile="${Destinationcode}_$(cut -d_ -f2- <<< "$Destinationfile")" ||  Destinationfile="${Destinationcode}_$Destinationfile"
    Destinationfile="$(echo $Destinationfile | rev | cut -d. -f2- | rev).tif"
    mv $Sourcedir/align.tmp.1/align$(printf %04d $Line).tif  $Destinationdir/$Destinationfile
#     mv $Sourcedir/align.tmp.1/align$(printf %04d $Line).tif  $Sourcedir/align.tmp.3/$Destinationfile
  done
  Count=0
  for ((Line=Middle ; Line<=Filecount ; Line++)); do
    Destinationfile="$(basename ${Filelist[$((Line))]})"
    [ "$Sourcefileglob" = "s_*" ] && Destinationfile="${Destinationcode}_$(cut -d_ -f2- <<< "$Destinationfile")" ||  Destinationfile="${Destinationcode}_$Destinationfile"
    Destinationfile="$(echo $Destinationfile | rev | cut -d. -f2- | rev).tif"
    mv $Sourcedir/align.tmp.2/align$(printf %04d $((Count))).tif $Destinationdir/$Destinationfile
#    mv $Sourcedir/align.tmp.2/align$(printf %04d $((Count))).tif $Sourcedir/align.tmp.3/$Destinationfile
    Count=$((Count+1))
  done
#  time align_image_stack -l -C --use-given-order -a $Sourcedir/align.tmp.3/align $Sourcedir/align.tmp.3/$Sourcefileglob 2>&1 | grep -v "Unable to read EXIF data" & Alignpid=$!
#  echo $Alignpid align >>$Backgroundpidfile
#  wait $Alignpid
#  for ((Line=0 ; Line<=Filecount ; Line++)); do
#    Destinationfile="$(basename ${Filelist[$((Line))]})"
#    [ "$Sourcefileglob" = "s_*" ] && Destinationfile="${Destinationcode}_$(cut -d_ -f2- <<< "$Destinationfile")" ||  Destinationfile="${Destinationcode}_$Destinationfile"
#    Destinationfile="$(echo $Destinationfile | rev | cut -d. -f2- | rev).tif"
#    mv $Sourcedir/align.tmp.3/align$(printf %04d $Line).tif $Destinationdir/$Destinationfile
#  done
#  Count=0
#  for ((Line=0 ; Line<=Filecount ; Line++)); do
#    Destinationfile="$(basename ${Filelist[$((Line))]})"
#    [ "$Sourcefileglob" = "s_*" ] && Destinationfile="${Destinationcode}_$(cut -d_ -f2- <<< "$Destinationfile")" ||  Destinationfile="${Destinationcode}_$Destinationfile"
#    Destinationfile="$(echo $Destinationfile | rev | cut -d. -f2- | rev).tif"
#    mv $Sourcedir/align.tmp.2/align$(printf %04d $((Count))).tif $Destinationdir/$Destinationfile
#    Count=$((Count+1))
#  done
  
  # remove workdirs with softlinks
  rm -R $Sourcedir/align.tmp.1
  rm -R $Sourcedir/align.tmp.2
  rm -R $Sourcedir/align.tmp.3
  
  comment "Align ready: ${Sourcedir-$Arduhome}/$Sourcefileglob"
}
XXX_trim_hard() {
  # Remove border color of image similar to -trim, but also cut the parts of image that contain the border color.
  # Weakness: Does no corner detection. Just ignores the outer 10% of each image corner and trims the inner 80%.
  # Not foolproof, but works for my use cases.
  # $1  Imagefile
  # $2  Color to trim. Default: transparent
  # Result: output of crop values for later use.
  
  local Image Trimcolor
  local Imagewidth Imageheight Xoffset Yoffset
  local Top Bottom Left Right
  
  Image="${1:-}"
  Trimcolor="${2:-"#00000000"}"
  
  Imagewidth=$($Convert  -format '%w'  $Image info:)
  Imageheight=$($Convert -format '%h'  $Image info:)
  Xoffset=$((Imagewidth / 10))
  Yoffset=$((Imageheight / 10))
  
  for ((Top=0;                Top    <= Imageheight; Top++ )); do
    $Convert $Image -crop $((Imagewidth -Xoffset*2))x1+$Xoffset+$Top    txt: | grep -q "$Trimcolor" || break
  done
  for ((Bottom=$Imageheight;  Bottom >= 0;           Bottom-- )); do
    $Convert $Image -crop $((Imagewidth -Xoffset*2))x1+$Xoffset+$Bottom txt: | grep -q "$Trimcolor" || break
  done
  for ((Left=0;               Left   <= Imagewidth;  Left++)); do
    $Convert $Image -crop 1x$((Imageheight -Yoffset*2))+$Left+$Yoffset  txt: | grep -q "$Trimcolor" || break
  done
  for ((Right=$Imagewidth;    Right  >= 0;           Right--)); do
    $Convert $Image -crop 1x$((Imageheight -Yoffset*2))+$Right+$Yoffset txt: | grep -q "$Trimcolor" || break
  done
  echo "$((Right-Left))x$((Bottom-Top))+$Left+$Top"
}
