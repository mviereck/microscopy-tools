#! /bin/bash

#### Messages, Log

note() {
  echo "note: $(shortpath "$*")"    >> $Wizardmessagefifo
}

worknote() {
  echo "@work: $(shortpath "$*")"   >> $Wizardmessagefifo
}

warning() {
  echo "WARNING: $(shortpath "$*")" >> $Wizardmessagefifo
}

failure() {
  echo "Failure: $(shortpath "$*")" >> $Wizardmessagefifo
}

error() {
  echo "ERROR: $(shortpath "$*")"   >> $Wizardmessagefifo
}

storeinfo() {
  # store and provide pieces of information
  # replace entry if codeword is already present
  # Store as codeword=string:
  #   $1 codeword=string
  # Dump stored string:
  #   $1 dump
  #   #2 codeword
  # Drop stored string:
  #   $1 drop
  #   #2 codeword
  # Test for codeword: (return 1 if not found)
  #   $1 test
  #   $2 codeword
  #
  # note: sed -i causes file permission issues if called in container in Cygwin, compare ticket #187
  #       chmod 666 for $Sharefolder could probably fix that. (FIXME)
  #
  [ -e "$Storeinfofile" ] || return 1
  case "${1:-}" in
    dump) grep     "^${2:-}="   $Storeinfofile | sed "s/^${2:-}=//" ;;      # dump entry
    drop) sed -i  "/^${2:-}=/d" $Storeinfofile ;;                           # drop entry
    test) grep -q  "^${2:-}="   $Storeinfofile ;;                           # test for entry
    *)                                                                      # store entry
      sed -i "/^$(echo "${1:-}" | cut -d= -f1)=/d"     $Storeinfofile       # drop possible old entry
      echo "${1:-}"                                 >> $Storeinfofile
    ;;
  esac
}

showlog() {
  local Line
  while read Line; do
    echo "$Line"
    echo "$Line" >> $Wizardlogfile
  done < $Wizardlogfifo
}

showmessages() {
  local Line
  while read Line; do
    echo "$Line"
    echo "$Line" >> $Wizardmessagefile
    sendkaptain 'wizardlog=`tail -n1 '$Wizardmessagefile'`'
  done <&${FDmessage}
}

shortpath() {
  LC_ALL=C sed "s!$Projecthome!.!g" <<< "${1:-}"
#  echo "${1:-}"
}

#### file operations

checkvar() {
  local Arg
  
  Arg="${1:-}"
  [ "$(cut -c1 <<< "$Arg")" = "-" ] && shift || Arg=""
  
  [ -z "${3:-}" ] && {
    failure "${1:-}: Variable ${2:-} is empty."
    return 1
  }
  
  case "$Arg" in
    -d) 
      [ -d "${3:-}" ] || {
        failure "${1:-}: ${2:-} is not a directory: ${3:-}"
        return 1
      }
    ;;
    -e) 
      [ -e "${3:-}" ] || {
        failure "${1:-}: ${2:-} does not exist: ${3:-}"
        return 1
      }
    ;;
  esac
  case "$Arg" in
    -D) 
      check_fileglob "${3:-}/*" || {
        failure "${1:-}: ${2:-}: directory is empty: ${3:-}"
        return 1
      }
    ;;
    -E) 
      [ -s "${3:-}" ] || {
        failure "${1:-}: ${2:-}: file is empty: ${3:-}"
        return 1
      }
    ;;
  esac
  return 0
}

myrm() {
  local Line
  for Line in "$@" ; do
    [ -e "$Line" ] && {
      worknote "rm: deleting $Line"
      rm -rf $Line
    }
  done
}

mymv() {
  check_fileglob "${1:-}" || {
    failure "mv: Source is empty: ${1:-}"
    return 1
  }
  [ -d "${2:-}" ] || {
    failure "mv: Target is not a directory: ${2:-}"
    return 1
  }
  worknote "mv: moving ${1:-} to ${2:-}"
  mv -f $(fileglob "${1:-}") "${2:-}"
}

mycp() {
  check_fileglob "${1:-}" || {
    failure "cp: Source is empty: ${1:-}"
    return 1
  }
  [ -d "${2:-}" ] || {
    failure "cp: Target is not a directory: ${2:-}"
    return 1
  }
  worknote "cp: copy ${1:-} to ${2:-}"
  cp $(fileglob "${1:-}") "${2:-}"
}

check_fileglob() {
  # check whether files exist for glob $1
  #[ -d "$1" ] && return 1
  [ -n "$(find ${1:-} -maxdepth 0 -type f -print -quit 2>/dev/null)" ]
}

check_dirglob() {
  # check whether directories exist for glob $1
  [ -f "${1:-}" ] && return 1
  [ -n "$(find ${1:-} -maxdepth 0 -type d -print -quit)" ]
}

fileglob() {
  # echos files only for glob $1
  local Path Glob Filelist
  
  [ -d "${1:-}" ] && {
    Path="${1:-}"
    Glob="*"
  } || {
    Path="$(dirname  "${1:-}")"
    Glob="$(basename "${1:-}")"
  }
  Path="$(realpath "$Path")"
  
  Filelist="$(find ${1:-} -maxdepth 0 -type f 2>/dev/null)"
  Filelist="$(sort -V <<< "$Filelist")"
  
  [ "$Filelist" ] && echo "$Filelist" || return 1
}

check_destinationfile() {
  local Destinationfile Function
  Destinationfile="${1:-}"
  Function="${2:-}"
  [ -e "$Destinationfile" ] && {
    #failure "$Function: Destination file already exists: $Destinationfile"
    failure "$Function: Destination file already exists: $(basename "$Destinationfile")"
    return 1
  }
  return 0
}

setup_workdir() {
  # Detect possible source directories in $2 for function $1
  # Set up variables that can be used to call function $1
  # Usage:
  #   setup_workdir Function Targetdir
  # Args:
  #   Function       One of align, sharpen, fuse, median, min, max, mean, set
  #   Targetdir      Target directory [+glob] to check.
  #                  Can already be in an ardustack-structure or an arbitrary one.
  #                  Location of $Destinationdir depends on detected directory structure.
  #   Functionoption   Mode of Function
  # Sets variables:
  #   Sourcedir                 Source directory within $Targetdir
  #   Sourcefileglob            Glob to get files. Mostly just "*"
  #   Destinationdir            Recommended directory to store resulting images.
  #                             Often serves as source dir for following functions.
  #   Destinationfile   Possible prefix of destination file(s). Can be "", though.
  #   Targetcachedir            Cache folder
  #
  # Run in a loop to check for next possible source dir in Targetdir.
  # Returns 0 on success and 1 if nothing more is to do.
  #
  # Stores already checked source dirs of $Targetdir in $Sourcedirchecklist. 
  # -> Set Sourcedirchecklist="" before running a loop with setup_workdir().
  # Use local in calling function:
  #   local Sourcedir Sourcefileglob Destinationdir Destinationfile Targetptofile Targetcachedir Sourcedirchecklist

  local Targetdir Targetstackshotdir Targetnewdir Targetprevdir 
  local Targetmagickdir Targetfusedir Targetevaluatedir Targetcomposedir Targetcachedir
  local Projectname
  
  Function="${1:-}"
  Targetdir="${2:-}"
  Function="${Function%magick}"

  # Check if a glob like * is given
  check_fileglob "$Targetdir" && {
    Sourcefileglob="$(basename "$Targetdir")"
    Targetdir="$(dirname "$Targetdir")"
  }
  Sourcefileglob="${Sourcefileglob:-"*"}"
  Destinationdir=""
  Destinationfile=""

  Targetdir="$(realpath "$Targetdir")"
  [ -d "$Targetdir" ] || {
    failure "No target directory found. Please specify a target directory or make a stackshot.
  Wrong Target: $Targetdir"
    return 1
  }
  
  Projectname="${Targetdir#$Projecthome/}" ### FIXME
  [ "$Projectname" = "$(basename "$Targetdir")" ] && Projectname="np" || Projectname="$(cut -d/ -f1 <<< "$Projectname")"
  [ -z "$Projectname" ] && Projectname="np"
  
  [ -d "$Targetdir/stackshot" ]          && Targetstackshotdir="$Targetdir/stackshot" || Targetstackshotdir="$Targetdir"
  [ -d "$Targetdir/stackshot-median" ]   && Targetstackshotdir="$Targetdir/stackshot-median"
  Targetmagickdir="$Targetdir/magick"
  Targetfusedir="$Targetdir/fuse"
  Targetcomposedir="$Targetdir/compose"
  Targetevaluatedir="$Targetdir/evaluate"
  
  Targetcachedir="$Targetdir/cache"
  myrm     "$Targetcachedir"
  mkdir -p "$Targetcachedir"
  Cachedir="$Targetcachedir"
  
  grep -q -- "fuse" <<< "$Function"      && Targetnewdir="$Targetfusedir"
  grep -q -- "compose" <<< "$Function"   && Targetnewdir="$Targetcomposedir"
  grep -q -- "evaluate" <<< "$Function"  && Targetnewdir="$Targetevaluatedir" 
  [ "$Targetnewdir" ] || Targetnewdir="$Targetmagickdir"
  
  [ "$Targetnewdir" = "$Targetmagickdir" ] && {
    mkdir -p $Targetnewdir
    check_fileglob "$Targetmagickdir/$Sourcefileglob" || mycp "$Targetstackshotdir/$Sourcefileglob" "$Targetmagickdir"
  }
  
  Targetprevdir="$Targetnewdir.bak"

  # backup for undo, serving also as source for batch operations
  case $Function in
    undo*) ;;
    *)
      mkdir -p $Targetprevdir
      check_fileglob "$Targetnewdir/*" && mymv "$Targetnewdir/*" "$Targetprevdir/"
    ;;
    
    #align*|brightness*|sharpen*|level*|contrast*|crop*|gamma*|stretch*|kuwahara*|prepare*|wizard*|whitebalance*)
    #  mkdir -p $Targetprevdir
    #  mymv "$Targetnewdir/*" "$Targetprevdir/"
    #;;
    #evaluate*|compose*|fuse)
    #  [ -e "$Targetnewdir" ] && {
    #    mkdir -p $Targetprevdir
    #    mymv "$Targetnewdir/*" "$Targetprevdir/"
    #  }
    #;;
  esac

  case $Function in
    fuse)
      Sourcedir="$Targetmagickdir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir")"
    ;;
      
    evaluate)
      Sourcedir="$Targetmagickdir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir").$(basename "$Sourcedir")"
    ;;
    evaluatefuse)
      Sourcedir="$Targetfusedir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir").$(basename "$Sourcedir")"
    ;;
    compose)
      Sourcedir="$Targetevaluatedir"
      Destinationdir="$Targetnewdir"
      #Destinationfile="$Projectname.$(basename "$Targetdir").$(basename "$Sourcedir")"
    ;;
      
    align*|brightness*|sharpen*|level*|contrast*|crop*|gamma*|stretch*|kuwahara*|prepare*|ruler*|wizard*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
      
    whitebalance*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
    
    undo*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
    
    *)
      failure "setup_workdir(): Function not defined: $Function"
      return 1
  esac
  
  [ "$Sourcedir" = "$Targetmagickdir" ] && {
    mkdir -p $Targetmagickdir
    check_fileglob "$Targetmagickdir/$Sourcefileglob" || mycp "$Targetstackshotdir/$Sourcefileglob" "$Targetmagickdir"
  }
  check_fileglob "$Sourcedir/$Sourcefileglob" || {
    failure "setup_workdir(): No source found: $Sourcedir/$Sourcefileglob"
    return 1
  }
  
  [ "$Destinationdir" ] || {
    failure "setup_workdir(): Destinationdir not specified"
    return 1
  }
  mkdir -p "$Destinationdir"
  
  return 0
}

#### show images

generate_doubleimage() {
  local Leftimage Rightimage Destinationfile Commentleft Commentright
  
  Leftimage="${1:-}"
  Rightimage="${2:-}"
  Destinationfile="${3:-}"
  Commentleft="${4:-previous}"
  Commentright="${5:-new}"
  
#  montage -geometry +0+0 -label "$Commentleft" "$Leftimage" -label "$Commentright" -flop "$Rightimage" "$Destinationfile"
  montage -geometry +0+0 -label "$Commentleft" "$Leftimage" -label "$Commentright" "$Rightimage" "$Destinationfile"
}

showimage() {
  local Imagelist Image Shrinkimage
  Imagelist="$(fileglob "${1:-}")" >&2
  case $(grep -c . <<< "$Imagelist") in
    0) 
      failure "showimage: Not found: ${1:-}" 
      #sendkaptain "showimage('')=''" 
      #sendkaptain "showimagename=''"
      storeinfo drop showimage
    ;;
    1) 
      Image="$Imagelist"
      #Shrinkimage="$Wizardcache/showimage.png"
      #convert "$Image" -scale 800x800\> "$Shrinkimage" 
      #sendkaptain "showimage('$Shrinkimage')=''" 
      #sendkaptain "showimagename='$(shortpath "$Image")'"
      #storeinfo   "showimage=$Image"
      geeqie -t -r File:"$Image"
    ;;
#    1) geeqie -t -r File:"$Imagelist" ;;
    *) viewnior           $Imagelist & ;;
  esac
}

showimagehalf() {
  local Sourceimage Destinationimage
  local Cacheimage
  Sourceimage="${1:-}"
  Destinationimage="${2:-}"
  Cacheimage=$Wizardcache/diff.jpg
  $Convert $Sourceimage -crop 50%x100%+0+0 $Cacheimage.half.jpg
  composite -geometry +0+0 $Cacheimage.half.jpg $Destinationimage $Cacheimage
  showimage $Cacheimage
}

showimagediff() {
  local Leftimage Rightimage Commentleft Commentright
  local Cacheimage
  
  Leftimage="${1:-}"
  Rightimage="${2:-}"
  Commentleft="${3:-previous}"
  Commentright="${4:-new}"
  
  Cacheimage="$Wizardcache/diff.jpg"
  
  generate_doubleimage "$Leftimage" "$Rightimage" "$Cacheimage" "$Commentleft" "$Commentright"
  showimage "$Cacheimage"
}

showimage_gui() {

  local Kaptaingrammar Kaptainpid Kaptainstdinfifo Kaptainstdoutfifo Kaptainsignal
  local Image
  
  Image="$Wizardcache/showimage.tif"
  
  Kaptaingrammar="$Cachedir/crop.kaptain.grammar"
  Kaptainstdinfifo="$Cachedir/crop.kaptain.stdin"
  Kaptainstdoutfifo="$Cachedir/crop.kaptain.stdout"
  mkfifo   $Kaptainstdinfifo
  mkfifo   $Kaptainstdoutfifo
  exec {FDin}<>$Kaptainstdinfifo
  exec {FDout}<>$kaptainstdoutfifo
  
#  kaptain --stdio $Wizardcache/test.kaptn <&${FDin} >&${FDout} &
  
  echo "#! /usr/bin/kaptain
start 'View image stack' -> image directoryline resultline;
  image -> @icon('$Cropimage');
  directoryline -> stackshot magick;
    stackshot     -> @button='stackshot';
    magick        -> @button='magick';
  resultline    -> fusemedian fusemean fusemin fusemax;
    fusemedian    -> @button='fuse.median';
    fusemean      -> @button='fuse.median';
    fusemin       -> @button='fuse.median';
    fusemax       -> @button='fuse.median';
" >> "$Kaptaingrammar"
  kaptain --stdio "$Kaptaingrammar" <&${FDin} >&${FDout} & Kaptainpid=$!

  while ps -p $Kaptainpid >/dev/null; do
    [ "$Refresh" = "yes" ] && {
      echo "image('$Image')='x'" >${FDin}
      Refresh="no"
    }

    read -t1 Kaptainsignal <&${FDout}
    
    [ "$Kaptainsignal" ] && {
      Kaptainsignal="${Kaptainsignal%:pressed}"
      case $Kaptainsignal in
        ok)         Return=0; break ;;
      esac
      Refresh="yes"
    }
  done 
  
  exec ${FDin}>&- ${FDout}>&-
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
  return 0
}

#### image batch processing

batch_function() {
  # Apply image processing function $1 on all possible source dirs in target directory $2, options in $3
  
  local $Batchlocal
  local Sourcedirchecklist Return=0
    
  parse_batchoptions "$@"  || return 1
  storeinfo test pwd_valid || return 1
  
  checkvar -d batch Targetdir "$Targetdir" || return 1
  checkvar    batch Function  "$Function"  || return 1
  
  ifcmdbreak && return 1
  
  setup_workdir "$Function" "$Targetdir" || {
    failure "batch $Function: no source found in $Targetdir
    $@"
    return 1
  }
  cd "$Targetdir"
  
  case $Function in
    compose|evaluate|fuse) ;;
    *)
      Function="${Function%magick}"
      Function="${Function%compose}"
      Function="${Function%evaluate}"
      Function="${Function%fuse}"
    ;;
  esac
  
  case "$Function" in
    brightness|contrast|gamma|kuwahara|level|prepare|sharpen|stretch|wizard)
      Functionmode="$Function"
      Function="wizard"
    ;;
  esac
  
  checkvar           -D $Function Sourcedir      "$Sourcedir"        || return 1
  checkvar           -d $Function Destinationdir "$Destinationdir"   || return 1
  case $Function in
    undo|compose) ;;
    *) checkvar         $Function Sourcefileglob "$Sourcefileglob"   || return 1 ;;
  esac
  case $Function in
    wizard) checkvar    $Function Functionmode   "$Functionmode"     || return 1 ;;
  esac
  case $Function in
    align*|crop|undo|whitebalance)
      checkvar       -d $Function Cachedir       "$Cachedir"         || return 1 ;;
  esac
  
  [ -z "$Functionmode" ] && case "$Function" in
    compose|evaluate|fuse) Functionmode="all" ;;
  esac
  
  note "Running: $Function $Functionmode $Functionoption: $(basename "$Sourcedir") -> $(basename "$Destinationdir")"
  storeinfo "cmd=$@"
  storeinfo "cmd_source=$Sourcedir"
  storeinfo "cmd_destination=$Destinationdir"
  storeinfo "cmd_cache=$Cachedir"
  cd "$Cachedir"
  $Function -m "$Functionmode" -o "$Functionoption" -s "$Sourcedir" -g "$Sourcefileglob" -d "$Destinationdir" -b "$Destinationfile" -c "$Cachedir"
  Return=$?
  cd "$Targetdir"
  storeinfo drop cmd
  storeinfo drop cmd_source
  storeinfo drop cmd_destination
  storeinfo drop cmd_cache
  
  [ "$Return" = "0" ] && {
    note "Ready: $Function $Functionmode $Functionoption: $(basename "$Sourcedir") -> $(basename "$Destinationdir")"
  } || {
    failure "ERROR in $Function $Functionmode $Functionoption: $(basename "$Sourcedir") -> $(basename "$Destinationdir")"
    undo -s "$Sourcedir" -d "$Destinationdir" -c "$Cachedir"
  }
  
  [ "$Return" = "0" ] && [ "$(basename "$Destinationdir")" = "evaluate" ] && [ -d "$Destinationdir/../stackshot" ] && {
    ls $Destinationdir/*fuse.median* >/dev/null 2>&1 && {
      # link fuse.median result into parent directory
      ln -f $(fileglob "$Destinationdir/*fuse.median*") "$Destinationdir/../"
      # link into project dir
      ln -f $(fileglob "$Destinationdir/*fuse.median*") "$Destinationdir/../../"
      # link fuse.median result into $Gallerydir directory
      ln -f $(fileglob "$Destinationdir/*fuse.median*") "$Gallerydir"
    }
  }
  
  return $Return
}

parse_batchoptions() {
  # To be called by batch functions to parse options.
  # Include this local line in the calling function:
  #   local Targetdir Sourcedir Sourcefileglob Destinationdir Destinationfile Cachedir Function Functionmode Functionoption

  local Shortoptions Longoptions Parsedoptions
  Shortoptions="b:c:d:f:g:m:o:s:t:"
  Longoptions=""

  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@" )"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ] ; do
    case "${1:-}" in
      -t) Targetdir="${2:-}" ;;
      -s) Sourcedir="${2:-}" ;;
      -g) Sourcefileglob="${2:-}" ;;
      -d) Destinationdir="${2:-}" ;;
      -b) Destinationfile="${2:-}" ;;
      -c) Cachedir="${2:-}" ;;
      -f) Function="${2:-}" ;;
      -m) Functionmode="${2:-}" ;;
      -o) Functionoption="${2:-}" ;;
      --) ;;
      *) failure "Unbekannte Option ${1:-} ($Function)" ;;
    esac
    #[ "${1:-}" != "--" ] && [ -z "${2:-}" ] && failure "Option ${1:-} has no argument ($Function)" && return 1
    shift
    shift
  done

  [ "$Sourcefileglob" ] || Sourcefileglob="*"
  #[ ! -d "$Sourcedir" ]      && failure "$Function: source dir not found: $Sourcedir" && return 1
  #[ ! -d "$Destinationdir" ] && failure "$Function: destination dir not found: $Destinationdir"&& return 1
  #! check_fileglob "$Sourcedir/$Sourcefileglob" && failure "$Function: No source files found: $Sourcedir/$Sourcefileglob"  && return 1
  return 0
}

getbatch1() {
  local Command= Line Argument
  for Line in contrast sharpen kuwahara brightness gamma level stretch wizard; do
    Argument="$(askkaptain "$Line")"
    case $Line in
      brightness) Line="-brightness-contrast" ;;
      contrast)   Line="-sigmoidal-contrast" ;;
      sharpen)    Line="-adaptive-sharpen" ;;
      stretch)    Line="-contrast-stretch" ;;
      wizard)     Line="" ;;
      *)          Line="-$Line" ;;
    esac
    case $Argument in
      "") ;;
      auto) Command="$Command -auto$Line" ;;
      *)    Command="$Command $Line $Argument" ;;
    esac
  done
  echo "$Command"
}

getfunctionsettings() {
  Functionmode="$(askkaptain ${Function}modecombo)"
  Functionoption="$(askkaptain ${Function}combo)"
}

runbatch1() {
  local Function Functionmode Functionoption
  askkaptain crop > /dev/null && {
    Function="crop"
    getfunctionsettings
    cmd -f "$Function" -m "$Functionmode" -o "$Functionoption" -t "$Stackdir"
  }
  cmd -f wizard -o "$(getbatch1)" -t "$Stackdir"
}

runbatch2() {
  local Function Functionmode Functionoption
  local Iterate
  for Function in whitebalance align_ais align_hugin align_vidstab1 align_vidstab2 align_vidstab3 ; do
    askkaptain $Function > /dev/null && {
      getfunctionsettings
      Function="$(tr -c -d "a-z_" <<< "$Function")"  # remove 1 2 3 from align_vidstab
      cmd -f "$Function" -m "$Functionmode" -o "$Functionoption" -t "$Stackdir"
    }
  done
  return 0
}

runbatch3() {
  askkaptain fuse >/dev/null             && cmd -f fuse -m all -t "$Stackdir"
  askkaptain evaluate >/dev/null         && {
    cmd -f evaluate     -m all -t "$Stackdir"
    cmd -f evaluatefuse -m all -t "$Stackdir"
  }  
  askkaptain sharpen_evaluate >/dev/null && cmd -f sharpenevaluate -o 3x1 -t "$Stackdir"
  askkaptain kuwahara_evaluate           && cmd -f kuwaharaevaluate -o 1.0 -t "$Stackdir"
  askkaptain compose >/dev/null          && cmd -f compose -t "$Stackdir"
  
  cmd -f showimage -s "$Stackdir/evaluate" -g "*fuse.median*"
}

#### multiple image operations

align_ais() {
  local $Batchlocal
  local Count Image Destinationfile Alignarray Return

  parse_batchoptions "$@" || return 1

  # -z? -s0? -m?
  time align_image_stack -vv -l -d -i -x -y -s 0 -C --use-given-order -a "$Cachedir/align" $(fileglob "$Sourcedir/$Sourcefileglob") || return 1
  Count="-1"
  for Image in $(fileglob "$Cachedir/align*") ; do
    Count=$((Count+1))
    Alignarray[Count]="$Image"
  done
  Count="-1"
  for Image in $(fileglob "$Sourcedir/$Sourcefileglob") ; do
    Count=$((Count+1))
    Destinationfile="$Destinationdir/$(basename "$Image")"
    $Convert ${Alignarray[Count]} "$Destinationfile"
    showimage "$Destinationfile"
  done
}

align_vidstab() {
  local $Batchlocal
  local Sourcefilelist Imagelist Destinationfile Sourcefile
  local Image Imagewidth Imageheight
  local CropW CropH CropX CropY Cropgeometry Zoom
  local Cropinteractive 
  local Shakiness Stepsize
  local Xoffset Xoffsetrelative Xoffsetlist Yoffset Yoffsetrelative Yoffsetlist Radians Radiansrelative Radianslist Degree 
  local Framedir Motionsfile Rotatedir Rotateminimage 
  local Count Imagecount

  parse_batchoptions "$@" || return 1
  
  cd $Cachedir
  
  Shakiness="$Functionmode"
  Shakiness="${Shakiness:-1}"
  Cropinteractive="$Functionoption"
  [ "$Cropinteractive" ] && Cropinteractive="yes"
  Stepsize=6
  
  Framedir="$Cachedir/frames"
  mkdir -p "$Framedir"
  
  crop -m even -s "$Sourcedir" -g "$Sourcefileglob" -d "$Framedir"

  Sourcefilelist=$Cachedir/align.source.list
  :> $Sourcefilelist
  
  Imagelist="$(fileglob "$Framedir/$Sourcefileglob")"
  for Image in $Imagelist; do
    echo "file $Image" >>$Sourcefilelist
  done
  Imagecount="$(grep -c . <<< "$Imagelist")"

  worknote "align_vidstab: generating 1. video from images"
  ffmpeg -y -hide_banner -nostdin -safe "0" -f "concat" -i "$Sourcefilelist" \
         -vcodec "libx264" -profile:v "high444" -refs "16" -crf "0" -preset "ultrafast" \
         "$Cachedir/align.orig.mp4" || return 1
  ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.orig.mp4"
  showpercent 1 100
  ifcmdbreak && return 1
  
  worknote "align_vidstab: Splitting generated 1. video into .png images"
  rm $Framedir/*
  ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.orig.mp4" "$Framedir/sourceimg%04d.png" || return 1
  showpercent 2 100
  ifcmdbreak && return 1

  :> $Sourcefilelist
  Imagelist="$(fileglob "$Framedir/*")"
  for Image in $Imagelist; do
    echo "file $Image" >>$Sourcefilelist
  done
  
  worknote "align_vidstab: generating 2. video from .png images"
  ffmpeg -y -hide_banner -nostdin -f image2 -start_number 1 -i $Framedir/sourceimg%04d.png -safe "0" -vframes 1000 -vcodec libx264 -crf 25  -pix_fmt yuv420p "$Cachedir/align.source.mp4" || return 1
  showpercent 3 100
  ifcmdbreak && return 1

  worknote "align_vidstab: Analyzing video with shakiness=$Shakiness"
  ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.source.mp4" \
         -vf "vidstabdetect=shakiness=$Shakiness:accuracy=15:mincontrast=0.1:stepsize=$Stepsize:show=1:result=$Cachedir/transforms$Shakiness.trf" \
         "$Cachedir/align.vidstab-show.mp4" || return 1
  ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.vidstab-show.mp4"
  showpercent 4 100
  ifcmdbreak && return 1
            
  worknote "align_vidstab: Transforming video with shakiness=$Shakiness"
  ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.source.mp4" \
         -vf "vidstabtransform=optzoom=0:smoothing=0:interpol=bicubic:relative=1:crop=black:debug=1:input=$Cachedir/transforms$Shakiness.trf,unsharp=5:5:0.8:3:3:0.4" \
         "$Cachedir/align.result.mp4" || return 1
  ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.result.mp4"
  showpercent 5 100
  ifcmdbreak && return 1

  worknote "align_vidstab: Splitting aligned video into images (shakiness=$Shakiness)"
  rm $Framedir/*
  ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.result.mp4" "$Framedir/alignimg%04d.tif" || return 1
  showpercent 6 100
  ifcmdbreak && return 1
      
  Imagelist="$(fileglob "$Framedir/*")"
  Image="$(head -n1 <<< "$Imagelist")"
  Imagewidth=$(convert  -format '%w'  $Image info:)
  Imageheight=$(convert -format '%h'  $Image info:)
      
  Motionsfile="$Cachedir/global_motions.trf"

  Xoffsetlist="$(cat $Motionsfile | grep -v '#' | awk '{print $2}')"
  Yoffsetlist="$(cat $Motionsfile | grep -v '#' | awk '{print $3}')"
  Radianslist="$(cat $Motionsfile | grep -v '#' | awk '{print $4}')"
      
  Rotatedir="$Cachedir/rotate"
  mkdir -p "$Rotatedir"
      
  worknote "align_vidstab: Cutting of black border (shakiness=$Shakiness)"
  Count=0
  for Image in $Imagelist; do
    Count="$((Count + 1))"
    Xoffsetrelative="$(sed "${Count}q;d" <<<"$Xoffsetlist")"
    Xoffset="$(awk "BEGIN { print $Xoffset + $Xoffsetrelative }")"
    Yoffsetrelative="$(sed "${Count}q;d" <<<"$Yoffsetlist")"
    Yoffset="$(awk "BEGIN { print $Yoffset + $Yoffsetrelative }")"
    Radiansrelative="$(sed "${Count}q;d" <<<"$Radianslist")"
    Radians="$(awk "BEGIN { print $Radians - $Radiansrelative }")"
    Degree="$(awk  "BEGIN { print $Radians * 180 / 3.141592652}")"
        
    Destinationfile="$Rotatedir/rotate$Count.png"
    #multicore "$Convert -size ${Imagewidth}x${Imageheight} xc:transparent -fill white -stroke white \
    #           -draw 'translate $((Imagewidth/2)),$((Imageheight/2)) \
    #                  rotate $Degree \
    #                  polygon $(awk "BEGIN {print -$Imagewidth/2  +$Xoffset +1}"),$(awk "BEGIN {print -$Imageheight/2 +$Yoffset +1}") \
    #                          $(awk "BEGIN {print +$Imagewidth/2  +$Xoffset -2}"),$(awk "BEGIN {print -$Imageheight/2 +$Yoffset +1}") \
    #                          $(awk "BEGIN {print +$Imagewidth/2  +$Xoffset -2}"),$(awk "BEGIN {print +$Imageheight/2 +$Yoffset -2}") \
    #                          $(awk "BEGIN {print -$Imagewidth/2  +$Xoffset +1}"),$(awk "BEGIN {print +$Imageheight/2 +$Yoffset -2}") \
    #                          $(awk "BEGIN {print -$Imagewidth/2  +$Xoffset +1}"),$(awk "BEGIN {print -$Imageheight/2 +$Yoffset +1}") '\
    #           $Image -evaluate-sequence min $Destinationfile" "$Destinationfile" || return 1
    multicore "$Convert -size ${Imagewidth}x${Imageheight} xc:transparent -fill white -stroke white \
               -draw 'translate $((Imagewidth/2)),$((Imageheight/2)) \
                      rotate $Degree \
                      polygon $(awk "BEGIN {print -$Imagewidth/2  +$Xoffset}"),$(awk "BEGIN {print -$Imageheight/2 +$Yoffset}") \
                              $(awk "BEGIN {print +$Imagewidth/2  +$Xoffset}"),$(awk "BEGIN {print -$Imageheight/2 +$Yoffset}") \
                              $(awk "BEGIN {print +$Imagewidth/2  +$Xoffset}"),$(awk "BEGIN {print +$Imageheight/2 +$Yoffset}") \
                              $(awk "BEGIN {print -$Imagewidth/2  +$Xoffset}"),$(awk "BEGIN {print +$Imageheight/2 +$Yoffset}") \
                              $(awk "BEGIN {print -$Imagewidth/2  +$Xoffset}"),$(awk "BEGIN {print -$Imageheight/2 +$Yoffset}") '\
               $Image -evaluate-sequence min $Destinationfile" "$Destinationfile" || return 1
    showpercent "$Count" "$Imagecount"
  done
  multicore_wait || return 1
      
#  Rotateminimage="$Cachedir/rotate.min.png"
  Rotateminimage="$Cachedir/rotate.min.mpc"
  convert $(fileglob "$Cachedir/rotate/*") -evaluate-sequence min "$Rotateminimage" || return 1
  case $Cropinteractive in
    yes) notify-send "align_vidstab(): Ready for interactive crop"
         Cropgeometry="$(cropgeometry_interactive "$Rotateminimage" "$Cachedir")" || return 1 ;;
    *)   Cropgeometry="$(trim_hard "$Rotateminimage" "$Cropgeometry")" || return 1 ;;
  esac
      
  Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
  Rotate="${Rotate:-0}"
  Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
  Cropgeometry="$(calc_evengeometry "$Cropgeometry")"
      
  [ "$Cropgeometry" ] || {
    failure "align_vidstab: crop geometry is empty"
    return 1
  }
      
  worknote "align_vidstab: Cropping aligned images to $Cropgeometry (shakiness=$Shakiness)"
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Count=0
  for Image in $(fileglob "$Rotatedir/*"); do
    Count="$((Count+1))"
    Destinationfile="$(sed "${Count}q;d" <<< "$Imagelist")"
    Destinationfile="$Destinationdir/$(basename "$Destinationfile")"
    multicore "$Convert $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || return 1
    showpercent "$Count" "$Imagecount"
  done
  multicore_wait || return 1
            
  showimage "$Rotateminimage.trim_hard.tif"
  return 0    
}

align_hugin() {
  # Align image stack with some panotools. Similar to align_image_stack
  # Advantage: pto file with aligned control points can be reused for multiple similar stacks
  # Usage:
  #  align Sourceglob Destinationdir [Cachedir]
  # Args:
  #  Sourcedir         Path[+glob] to source image stack
  #  Destinationdir    Path where to store aligned images
  #  Cachedir          Cache folder will contain align.pto file with control points. Can be reused to skip control point calculation.
  
  local Ptofile
  local Count Image Filearray Destinationfile
  local Logfile
  local Crop Cropx Cropy Cropsize
  
  
  local $Batchlocal
  local Imagewidth Imageheight

  parse_batchoptions "$@" || return 1
  
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Ptofile="$Cachedir/align_PTO.pto"
  
  worknote "align_hugin: Aligning $Sourcedir/$Sourcefileglob"
  
  # Get image size. Assuming same size for all images.
  Imagewidth=$($Convert  -format '%w'  "$(head -n1 <<< "$Imagelist")" info:)
  Imageheight=$($Convert -format '%h'  "$(head -n1 <<< "$Imagelist")" info:)
  
  echo "########## pto_gen ##########"
  worknote "align_hugin: Running pto_gen to create list of files"
  cd "$Sourcedir"
  pto_gen -o "$Ptofile.pto_gen.pto" -p 0 -f 40 --crop=0,${Imagewidth},0,${Imageheight} $Sourcefileglob || return 1
  
  sed -i '3 s/r:CROP//'                     "$Ptofile.pto_gen.pto"
  sed -i '3 s/\bf[0-9]*\b/f0/'              "$Ptofile.pto_gen.pto"
  sed -i "3 s/\bw[0-9]*\b/w${Imagewidth}/"  "$Ptofile.pto_gen.pto"
  sed -i "3 s/\bh[0-9]*\b/h${Imageheight}/" "$Ptofile.pto_gen.pto"
  sed -i "3 s/\bv[0-9]*\b/v40/"             "$Ptofile.pto_gen.pto"
    
#    pano_modify --projection=0 $Ptofile.pto_gen.pto
#    pano_modify --canvas=${Imagewidth}x${Imageheight} $Ptofile.pto_gen.pto
#    pano_modify --output-type=FUSEDSTACKS $Ptofile.pto_gen.pto

  # find control points
  echo "########## cpfind ##########"
  worknote "align_hugin: Running cpfind to find control points for alignment. That will take a while."
  cpfind -o "$Ptofile.cpfind.pto"  \
        --fullscale \
        --minmatches 4 \
        --linearmatch \
        --linearmatchlen 10 \
        --ransacmode rpyv \
        "$Ptofile.pto_gen.pto" || return 1
#        --linearmatchlen $Count \

  # clean up useless/wrong control points
  echo "########## cpclean ##########"
  worknote "align_hugin: Running cpclean to remove wrong control points"
  cpclean -s -o "$Ptofile.cpclean.pto" --pairwise-checking "$Ptofile.cpfind.pto" || return 1

#    pano_modify --crop=AUTO $Ptofile.cpclean.pto
    
  # calculate distortion of images to align control points
  echo "########## autooptimiser ##########"
  worknote "align_hugin: Running autooptimiser to transform control points into image distortion"
  autooptimiser -p -o "$Ptofile" "$Ptofile.cpclean.pto" || return 1
#    pano_modify --crop=AUTO $Ptofile
    
  # remove all pto files except the final one
  rm $Ptofile.*.pto

#  grep -q "Strange values may result!" < "$Logfile" && { ### FIXME
#    failure "align did not find enough control points!
#  Check out log file $Logfile
#  Probably source images are distorted too much."
#    return 1
#  }

  # distort images to align them
  echo "########## nona ##########"
  worknote "align_hugin: Running nona to transform images"
  nona -o "$Cachedir/PTO_ALIGN" "$Ptofile" || return 1
  
  cd "$Destinationdir"
  
  # Crop images
  worknote "align_hugin: Checking crop coordinates of common area of all aligned images"
  evaluate -s "$Cachedir" -g "PTO_ALIGN*" -b "$Cachedir/align_PTO" -m "min" -o "tif"
  Crop="$(trim_hard "$Cachedir/align_PTO.min.tif")"

  Count=0
  for Image in $(fileglob "$Cachedir/PTO_ALIGN*"); do
    Count=$((Count +1))
    Destinationfile="$(sed "${Count}q;d" <<< "$Imagelist")"
    Destinationfile="$Destinationdir/$(basename "$Destinationfile")"
    $Convert -crop "$Crop" "$Image" "$Destinationfile"
    showimage "$Destinationfile"
  done
}

whitebalance() {
  local $Batchlocal
  local Image Cropgeometry Imagewidth Imageheight
  local Referencecolor Referencecolorimage Meancolorimage 
  local Destinationfile Imagelist Imagecount Count
  local Refred  Refgreen  Refblue
  local Meanred Meangreen Meanblue
  local Partred Partgreen Partblue
  
  parse_batchoptions "$@" || return 1
    
  Functionmode="${Functionmode:-topleft}"
  Referencecolor="${Functionoption:-#BBBBBB}"
  
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagecount="$(grep -c . <<< "$Imagelist")"
  Imagewidth=$($Convert  -format '%w'  "$(head -n1 <<< "$Imagelist")" info:)
  Imageheight=$($Convert -format '%h'  "$(head -n1 <<< "$Imagelist")" info:)
  
  Meancolorimage="$Cachedir/meancolor.mpc"
  Referencecolorimage="$Cachedir/referencecolor.mpc"
  
  case $Functionmode in
    topleft)     Cropgeometry="10x10+5+5" ;;
    topright)    Cropgeometry="10x10+$((Imagewidth-15))+5" ;;
    bottomleft)  Cropgeometry="10x10+5+$((Imageheight-15))" ;;
    bottomright) Cropgeometry="10x10+$((Imagewidth-15))+$((Imageheight-15))" ;;
    full)        Cropgeometry="${Imagewidth}x${Imageheight}+0+0" ;;
    interactive) 
#      Image="$Cachedir/whitebalance.min.jpg"
      Image="$Cachedir/whitebalance.min.mpc"
      $Convert $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence min "$Image"
      Cropgeometry="$(cropgeometry_interactive "$Image" "$Cachedir" "50x50+10+10")"  ### FIXME rotate
      Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")" 
      [ "$Cropgeometry" ] || {
        failure "whitebalance: Got no crop geometry"
        return 1
      }
    ;;
  esac
  
  [ "$Referencecolor" = "mean" ] && {
    Image="$Cachedir/whitebalance.mean.mpc"
    convert $(fileglob "$Sourcedir/$Sourcefileglob") -crop "$Cropgeometry" -evaluate-sequence mean "$Image"
    Referencecolor=$($Convert "$Image" -filter box -resize 1x1! -format "%[pixel:u]" info:)
  }
  
  convert -size 1x1 xc:"$Referencecolor" $Referencecolorimage
  Refred="$(convert   $Referencecolorimage -format "%[fx:255*u.p{0,0}.r]" info:)"
  Refgreen="$(convert $Referencecolorimage -format "%[fx:255*u.p{0,0}.g]" info:)"
  Refblue="$(convert  $Referencecolorimage -format "%[fx:255*u.p{0,0}.b]" info:)"

#  echo "# whitebalance geometry: $Cropgeometry" >> "$Historyfile"

  Count=0
  for Image in $Imagelist; do
    Count="$((Count + 1))"
    Destinationfile="$Destinationdir/$(basename "$Image")"
    
    convert $Image -crop $Cropgeometry -resize 1x1! "$Meancolorimage"
    
    Meanred="$(convert   $Meancolorimage -format "%[fx:255*u.p{0,0}.r]" info:)"
    Meangreen="$(convert $Meancolorimage -format "%[fx:255*u.p{0,0}.g]" info:)"
    Meanblue="$(convert  $Meancolorimage -format "%[fx:255*u.p{0,0}.b]" info:)"
    
    [ "$Meanred"   = "0" ] && Partred=255   || Partred="$(awk   "BEGIN { print $Refred   / $Meanred }")"
    [ "$Meangreen" = "0" ] && Partgreen=255 || Partgreen="$(awk "BEGIN { print $Refgreen / $Meangreen }")"
    [ "$Meanblue"  = "0" ] && Partblue=255  || Partblue="$(awk  "BEGIN { print $Refblue  / $Meanblue }")"
    
    multicore "convert $Image -color-matrix '$Partred 0 0 0 $Partgreen 0 0 0 $Partblue' $Destinationfile" "$Destinationfile" || return 1
    showpercent "$Count" "$Imagecount"
  done
  multicore_wait || return 1
  return 0
}

compose() {
  local $Batchlocal
  local Evalmaxfile Evalminfile Minfile Maxfile 
  local Destinationfilebasename
  local i Count
  
  parse_batchoptions "$@" || return 1
  
  Evalmaxfile[0]="$(fileglob "$Sourcedir/*magick.max*")"
  Evalminfile[0]="$(fileglob "$Sourcedir/*magick.min*")"
  Evalmaxfile[1]="$(fileglob "$Sourcedir/*fuse.max*")"
  Evalminfile[1]="$(fileglob "$Sourcedir/*fuse.min*")"
  
  [ -z "${Evalmaxfile[0]}${Evalmaxfile[1]}" ] && {
    failure "compose: No source found. Please run evaluate first."
    return 1
  }

  Count=0
  for i in 0 1 ; do
    Maxfile="${Evalmaxfile[$i]}"
    Minfile="${Evalminfile[$i]}"
    [ -z "$Maxfile" ] && break
    Destinationfilebasename="$(sed 's/.max.*//' <<< "$Maxfile")"
    Destinationfilebasename="$(basename "$Destinationfilebasename")"
    
    for Functionmode in bumpmap colorburn difference linearburn linearlight modulate multiply overlay pegtoplight; do
      Count="$((Count + 1))"
      
      ifcmdbreak && return 1
    
      Destinationfile="$Destinationdir/$Destinationfilebasename.${Functionmode}1.jpg"
      $Convert "$Minfile" "$Maxfile" -compose "$Functionmode" -composite "$Destinationfile"
      worknote "compose $Functionmode: $Destinationfile"
      showimage "$Destinationfile"
  
      case $Functionmode in
        linearburn|multiply) ;;  # skip second compose for modes with identical result
        difference)
          $Convert "$Destinationfile" -negate "$Destinationdir/$Destinationfilebasename.${Functionmode}1-negate.jpg"
          showimage "$Destinationdir/$Destinationfilebasename.${Functionmode}1-negate.jpg"
        ;;
        *)
          Destinationfile="$Destinationdir/$Destinationfilebasename.${Functionmode}2.jpg"
          $Convert "$Maxfile" "$Minfile" -compose "$Functionmode" -composite "$Destinationfile"
          echo "$Destinationfile"
          showimage "$Destinationfile"
        ;;
      esac
      
      showpercent "$Count" "18"
    done
  done
  return 0
}

crop() {
  local $Batchlocal
  local Image Imagelist Cropgeometry Destinationfile
  local Imagewidth Imageheight Newwidth Newheight Shrink
  local Count Imagecount
  local Rotate Rotatedir
  
  parse_batchoptions "$@" || return 1
  
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagecount="$(grep -c . <<< "$Imagelist")"
  Imagewidth=$($Convert  -format '%w'  "$(head -n1 <<< "$Imagelist")" info:)
  Imageheight=$($Convert -format '%h'  "$(head -n1 <<< "$Imagelist")" info:)

  case $Functionmode in
    even)
      Newwidth=$((Imagewidth/2))
      Newwidth=$((Newwidth*2))
      Newheight=$((Imageheight/2))
      Newheight=$((Newheight*2))
      Cropgeometry="${Newwidth}x${Newheight}+0+0"
    ;;
    shrink) 
      Shrink="$Functionoption"
      Cropgeometry="$((Imagewidth - $((Shrink * 2))))x$((Imageheight - $((Shrink * 2))))+$Shrink+$Shrink"
    ;;
    geometry)
      Cropgeometry="$Functionoption"
    ;;
    interactive) 
#      Image="$Cachedir/crop.min.jpg"
      Image="$Cachedir/crop.min.mpc"
      showpercent 1 100
      convert $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence min "$Image"
      Cropgeometry="$(cropgeometry_interactive "$Image" "$Cachedir" "$Functionoption")"
      Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
      Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
    ;;
  esac
  
  Rotate="${Rotate:-0}"

  [ "$Cropgeometry" ] || {
    failure "crop $Functionmode: crop geometry is empty"
    return 1
  }
  
  [ "$Cropgeometry" = "${Imagewidth}x${Imageheight}+0+0" ] && [ "$Rotate" = "0" ] && {
    worknote "crop $Functionmode: Images already have desired geometry: $Cropgeometry"
    cp $Imagelist "$Destinationdir" ### FIXME mycp()
    return
  }
  
  worknote "crop $Functionmode: Cropping images with rotation $Rotate and geometry $Cropgeometry"
  Rotatedir="$Cachedir/rotate"
  mkdir -p $Rotatedir
  Count="0"
  for Image in $Imagelist; do
    Count="$((Count+1))"
    Destinationfile="$Destinationdir/$(basename "$Image")"
    multicore "$Convert $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || return 1
    showpercent "$Count" "$Imagecount"
  done
  multicore_wait || return 1
  Imagelist="$(fileglob "$Rotatedir/*")"
  
  echo "# crop geometry: $Cropgeometry rotation: $Rotate" >> "$Historyfile"
  return 0
}

evaluate() {
  # Evaluate image stack.
  
  local $Batchlocal
  local Destinationfilebasename Fileformat Count
  
  parse_batchoptions "$@" || return 1
  
  Destinationfilebasename="${Destinationfile:-evaluate}"  
  Fileformat="${Functionoption:-jpg}"
  Functionmode="${Functionmode:-all}"
  
  case "$Functionmode" in
    all)
      Count=0
      for Functionmode in min mean max median; do
        Count="$((Count + 1))"
        multicore "evaluate -s '$Sourcedir' -g '$Sourcefileglob' -d '$Destinationdir' -b '$Destinationfilebasename' -m '$Functionmode' -o '$Fileformat'" || return 1
        showpercent "$Count" "4"
      done
      multicore_wait || return 1
    ;;
    min|max|mean|median) ;;
    *) failure "evaluate: Unknown function mode $Functionmode" ; return 1 ;;
  esac
  
  Destinationfile="$Destinationdir/$Destinationfilebasename.$Functionmode.$Fileformat"
  $Convert $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence $Functionmode "$Destinationfile" || {
    failure "evaluate $Functionmode: ERROR in excuting convert. Please check policy restrictions of ImageMagick. Note that all input images have to be the same size."
    return 1
  }
  showimage "$Destinationfile"
  return 0
}

fuse() {
  # fuse stackshot of images with enfuse
  
  local $Batchlocal
  local Destinationfilebasename
  local Exposureweight Saturationweight Contrastweight
  local Contrastedgescale Contrastmincurvature Contrastwindowsize
  local Grayprojector
  
  parse_batchoptions "$@" || return 1
  
  Destinationfilebasename="${Destinationfile:-fuse}"
  Functionmode="${Functionmode:-1}"
 
  # Predefined parameter sets
  Exposureweight=0.0
  Saturationweight=0.0
  Contrastweight=1.0
  Contrastedgescale=0
  Contrastmincurvature=""
  Contrastwindowsize="3"
  Grayprojector="luminance"
  
  case $Functionmode in
    all)
      for Fusemode in $(seq 50); do
        multicore "fuse -s '$Sourcedir' -g '$Sourcefileglob' -d '$Destinationdir' -b '$Destinationfilebasename' -m '$Fusemode'" || return 1
        showpercent "$Fusemode" "50"
      done
      multicore_wait || return 1
      return 0
    ;;
    1)
    ;;
    2)
      Saturationweight="0.1"
    ;;
    3)
      Contrastwindowsize="7"
    ;;
    4)
      Contrastwindowsize="7"
      Saturationweight="0.1"
    ;;
    5) 
      Contrastwindowsize="15"
    ;;
    6) 
      Contrastwindowsize="15"
      Saturationweight="0.1"
    ;;
    7) 
      Contrastwindowsize="23"
    ;;
    8) 
      Contrastwindowsize="23"
      Saturationweight="0.1"
    ;;
   x9)
      Contrastedgescale="0.8:2000%:300%"
      #Contrastmincurvature="+8.0%"
    ;;
   x10)
      Contrastedgescale="0.8:500%:500%"
      #Contrastmincurvature="+8.0%"
    ;;
   x11)
      Contrastedgescale="1.2:16:4"
      #Contrastmincurvature="+5.0%"
    ;;
   x12)
      Contrastedgescale="1.2:8:4"
      #Contrastmincurvature="+5.0%"
      #Saturationweight="0.1"
    ;;
   x13)
      Contrastedgescale="1.6:16:4"
      #Contrastmincurvature="+3.0%"
    ;;
   x14)
      Contrastedgescale="1.6:8:4"
      #Contrastmincurvature="+3.0%"
      #Saturationweight="0.1"
    ;;
    15)
      Contrastedgescale="1.6:16:10"
      #Contrastmincurvature="+6.0%"
    ;;
    16)
      Contrastedgescale="1.6:8:10"
      #Contrastmincurvature="+8.0%"
      #Saturationweight="0.1"
    ;;
    17)
      Contrastedgescale="2.0:500%:500%"
      #Contrastmincurvature="+2.0%"
    ;;
   x18)
      Contrastwindowsize="15"
      Contrastedgescale="1.2:16:4"
      Contrastmincurvature="+8.01%"
    ;;
   x19)
      Contrastwindowsize="23"
      Contrastedgescale="1.2:16:4"
      Contrastmincurvature="+8.01%"
    ;;
    20)
      Contrastedgescale="3.0:4:4"
    ;;
    
    
    ###############
    22x) #*
      Contrastwindowsize="23"
      Contrastedgescale="2.5:8:4"
      Contrastmincurvature="+8.01%"
    ;;
    
    23x) #*
      Contrastwindowsize="23"
      Contrastedgescale="2.5:4:2"
      Contrastmincurvature="+8.01%"
    ;;
    
    
    
    20x)
      Contrastwindowsize="23"
      Contrastedgescale="1.2:24:8"
    ;;
    21x)
      Contrastwindowsize="23"
      Contrastedgescale="0.5:36:24"
      Contrastmincurvature="+8.01%"
    ;;
    27x) #*
      Contrastwindowsize="15"
      Contrastedgescale="2.5:4:2"
      Contrastmincurvature="+8.01%"
    ;;
    
    
    xxx7)
      Contrastedgescale="0.3:1000%:300%"
      Contrastmincurvature="+0.3%"
    ;;
    xxx8)
      Contrastedgescale="0.3:1000%:300%"
      Contrastmincurvature="+0.3%"
      Saturationweight="0.1"
    ;;
    
    
    
    
    x11)
      Grayprojector="l-star"
    ;;
    x12) 
      Contrastwindowsize="7"
      Grayprojector="l-star"
    ;;
    x13)
      Grayprojector="l-star"
      Contrastedgescale="0.3:1000%:300%"
      Contrastmincurvature="+0.3%"
      Grayprojector="l-star"
    ;;
    x14)
      Contrastedgescale="0.8:2000%:300%"
      Grayprojector="l-star"
    ;;
    x15)
      Contrastedgescale="1.2:16:4"
      Contrastmincurvature="+8.0%"
      Grayprojector="l-star"
    ;;
    x16)
      Contrastedgescale="1.6:16:4"
      Contrastmincurvature="+4.0%"
      Grayprojector="l-star"
    ;;
    x17)
      Contrastedgescale="1.6:16:4"
      Saturationweight="0.1"
      Contrastmincurvature="+5.0%"
      Grayprojector="l-star"
    ;;
    x18)
      Contrastedgescale="1.6:16:10"
      Saturationweight="0.1"
      Contrastmincurvature="+10.0%"
      Grayprojector="l-star"
    ;;
    *) return 0 ;;
  esac

  Destinationfile="$Destinationdir/$Destinationfilebasename.fuse$(printf %02d $Fusemode).jpg"
  #check_destinationfile "$Destinationfile" "fuse" || return 1
  worknote "fuse $Functionmode: Creating $(basename "$Destinationfile")"
  
  Enfuseoptions="
      --exposure-weight=$Exposureweight \
      --saturation-weight=$Saturationweight \
      --contrast-weight=$Contrastweight \
      --hard-mask \
      \
      --contrast-edge-scale=$Contrastedgescale \
      --contrast-window-size=$Contrastwindowsize \
      \
      --gray-projector=$Grayprojector"
  [ "$Contrastmincurvature" ] && Enfuseoptions="$Enfuseoptions \
      --contrast-min-curvature=$Contrastmincurvature"
  
  # Fusing here
  enfuse $Enfuseoptions \
         --output="$Destinationfile" \
         $(fileglob "$Sourcedir/$Sourcefileglob") \
         2>&1 | grep -v "does not have an alpha channel" | grep -v "assuming all pixels should contribute" | grep -v "loading next image" || {
    failure "fuse $Functionmode failed"
    return 1
  }
        
  # Write enfuse options into EXIF data of image
  exiv2 -M"set Exif.Photo.UserComment Comment charset=Ascii enfuse $(echo $Enfuseoptions)" "$Destinationfile" 

  #note "fuse $Functionmode is ready: ${Destinationfile}"
  showimage "$Destinationfile"
  return 0
}

ruler() {
  local $Batchlocal
  local Destinationfile
  local Count Imagecount Imagelist
  
  parse_batchoptions "$@" || return 1
  
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagecount="$(grep -c . <<< "$Imagelist")"
  
  Count="0"
  for Image in $Imagelist; do
    Count="$((Count+1))"
    Destinationfile="$Destinationdir/$(basename $Image)"
    multicore "$Imgruler -m $Functionmode -t '$Functionoption' -o $Destinationfile $Image" "$Destinationfile" || return 1
    showpercent "$Count" "$Imagecount"
  done
  multicore_wait || return 1
  return 0
}

undo() {
  local $Batchlocal
  local Undocache
  
  parse_batchoptions "$@" || return 1

  Undocache="$Cachedir/undo"
  mkdir -p "$Undocache"
  
  mymv "$Sourcedir/*"      "$Undocache"      || return 1
  mymv "$Destinationdir/*" "$Sourcedir" 
  mymv "$Undocache/*"      "$Destinationdir"
  
  myrm "$Undocache"
}

wizard() {
  # Wrapper for ImageMagick convert to work on folders
  # Args:
  #  mandatory:
  #   -m Functionmode
  #   -s Sourcedir
  #   -d Destinationdir
  #  optional:
  #   -g Sourcefileglob
  #   -o Functionoption
  
  local $Batchlocal
  local Image Destinationfile Imagelist
  
  parse_batchoptions "$@" || return 1
  
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagecount="$(grep -c . <<< "$Imagelist")"
  
  [ "$Functionoption" ] || case "$Function" in
    brightness) Functionoption="10x10" ;;
    contrast)   Functionoption="3x50%" ;;
    gamma)      Functionoption="auto" ;;
    kuwahara)   Functionoption="1" ;;
    level)      Functionoption="auto" ;;
    sharpen)    Functionoption="6x2" ;;
    stretch)    Functionoption="0%" ;;
  esac

  case "$Functionmode" in
    gamma|level) 
      case "$Functionoption" in
        auto|"") Functionmode="-auto-$Functionmode" ; Functionoption="" ;;
        *)       Functionmode="-$Functionmode" ;;
      esac
    ;;
    brightness)  Functionmode="-brightness-contrast" ;;
    contrast)    Functionmode="-sigmoidal-contrast" ;;
    kuwahara)    Functionmode="-kuwahara" ;;
    sharpen)     Functionmode="-adaptive-sharpen" ;;
    stretch)     Functionmode="-contrast-stretch" ;;
#    prepare)     Function="-sigmoidal-contrast 3x50% -kuwahara 0.5 -adaptive-sharpen 6x2" ; Functionoption="" ;;
    prepare)     Functionmode="-auto-gamma -auto-level -sigmoidal-contrast 3x50% -kuwahara 0.5 -adaptive-sharpen 6x2" ; Functionoption="" ;;
    wizard)      Functionmode="" ;;
  esac
  
  Count=0
  for Image in $Imagelist; do
    Count="$((Count + 1 ))"
    Destinationfile="$Destinationdir/$(basename "$Image")"
    multicore "$Convert $Image $Functionmode $Functionoption $Destinationfile" "$Destinationfile" || return 1
    showpercent "$Count" "$Imagecount"
  done
  multicore_wait || return 1
  
  return 0
}

#### single image operations

calc_evengeometry() {
  local Geometry XY W H
  Geometry="${1:-}"
  W=$(cut -dx -f1 <<< "$Geometry")
  H=$(cut -dx -f2 <<< "$Geometry" | cut -d+ -f1)
  XY="$(cut -d+ -f2- <<< "$Geometry")"
  W=$((W/2))
  W=$((W*2))
  H=$((H/2))
  H=$((H*2))
  Geometry="${W}x${H}+${XY}"
  echo $Geometry
}

trim_hard() {
  # Function: Trim all border with transparency from image $1
  # Results in a maximal inner rectangle without border color.
  # $1  $Image      image
  # $2  $Trimcolor  color to trim. Default: transparent
  # $3  Geometry seed value (optional)
  # $4  additional command to run on each iteration (optional, special use case for cropgeometry_interactive() )
  # Output: crop geometry
  
  local Imagemask Trimcolor Cropgeometry Addcommand
  local Sourceimage Sourceimagempc Cropgeometryimage Imagewidth Imageheight
  local Left         Right         Top         Bottom
  local Skipleft     Skipright     Skiptop     Skipbottom
  local Permilleleft Permilleright Permilletop Permillebottom Permillemax
  local Return
  local Debugmode Loopcount
  local pid1 pid2 pid3 pid4
  
  Sourceimage="${1:-}"
  Cropgeometry="${2:-}"
  Addcommand="${3:-}"
  
  Trimcolor="#00000000" # to support other colors, creating mask must be fixed FIXME
  
  # check source for mpc format, convert if not
  [ "$Sourceimage" = "${Sourceimage%.mpc}" ] && {
    Sourceimagempc="$Sourceimage.mpc"
    convert "$Sourceimage" "$Sourceimagempc"
  } || {
    Sourceimagempc="$Sourceimage"
  }
  Cropgeometryimage="$Sourceimage.trim_hard.png"
  
  # Generate alpha mask image in imagemagick memory format for fastest possible access
  Imagemask="$Sourceimage.mask.mpc"
  convert "$Sourceimagempc" -alpha extract "$Imagemask"
  
  worknote "trim_hard(): Searching for inner rectangle of $(basename $Image)"
  
  Imagewidth=$(convert  -format '%w'  $Imagemask info:)
  Imageheight=$(convert -format '%h'  $Imagemask info:)
  Left=0
  Top=0
  Right=$((Imagewidth-1))
  Bottom=$((Imageheight-1))
  
  # First cut with regular trim to save some time.
  # Add a colored border so trim uses the desired color. Afterward remove border from canvas to get correct geometry values. 
  Line="$(convert "$Sourceimagempc" -bordercolor "$Trimcolor" -border 1x1  -trim -set page '%[fx:page.width-2]x%[fx:page.height-2]+%[fx:page.x-1]+%[fx:page.y-1]' info:)"
  Left="$(awk '{print $4}' <<< "$Line" | cut -d+ -f2)"
  Top="$(awk '{print $4}' <<< "$Line" | cut -d+ -f3)"
  Right="$(awk '{print $3}' <<< "$Line" | cut -dx -f1)"
  Right="$((Left+Right-1))"
  Bottom="$(awk '{print $3}' <<< "$Line" | cut -dx -f2)"
  Bottom="$((Top+Bottom-1))"
  
  [ "$Cropgeometry" ] && {
    Left=$(cut -d+ -f2 <<< "$Cropgeometry")
    Top=$(cut -d+ -f3 <<< "$Cropgeometry")
    Right=$(cut -dx -f1 <<< "$Cropgeometry")
    Right=$((Left+Right-1))
    Bottom=$(cut -dx -f2 <<< "$Cropgeometry")
    Bottom=$(cut -d+ -f1 <<< "$Bottom")
    Bottom=$((Top+Bottom-1))
  }
  
  # Workflow:
  # - Get permille amount of $Trimcolor from all sides.
  # - Remove side with greatest permille amount of $Trimcolor.
  # - Repeat check with new geometry
  while :; do
    # Get part of non-$Trimcolor at each side
    [ "$Skipleft" ]   || convert $Imagemask -crop 1x$((Bottom-Top+1))+$Left+$Top    +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permilleleft    & pid1=$!
    [ "$Skipright" ]  || convert $Imagemask -crop 1x$((Bottom-Top+1))+$Right+$Top   +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permilleright   & pid2=$!
    [ "$Skiptop" ]    || convert $Imagemask -crop $((Right-Left+1))x1+$Left+$Top    +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permilletop     & pid3=$!
    [ "$Skipbottom" ] || convert $Imagemask -crop $((Right-Left+1))x1+$Left+$Bottom +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permillebottom  & pid4=$!
    wait $pid1
    wait $pid2
    wait $pid3
    wait $pid4
    Permilleleft=$(  LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permilleleft)
    Permilleright=$( LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permilleright)
    Permilletop=$(   LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permilletop)
    Permillebottom=$(LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permillebottom )
    
    # Determine maximal permille value
    Permillemax=$(echo "$Permilleleft
$Permilleright
$Permilletop
$Permillebottom" | sort -n | head -n1)
    showpercent "$(awk "BEGIN {print 1000*$Permillemax}" | cut -d. -f1)" "1000"
    [ "$Permillemax" = "1.0000" ] && break # Ready
    
    # Remove side with maximal permille of $Trimcolor.
    [ "$Permillemax" = "$Permilleleft" ]   && Left=$((Left+1))
    [ "$Permillemax" = "$Permilleright" ]  && Right=$((Right-1))
    [ "$Permillemax" = "$Permilletop" ]    && Top=$((Top+1))
    [ "$Permillemax" = "$Permillebottom" ] && Bottom=$((Bottom-1))
    Cropgeometry="$((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top"
    
    # Skip check for sides without $Trimcolor in future to save some time
    [ "1.0000" = "$Permilleleft" ]   && Skipleft=yes
    [ "1.0000" = "$Permilleright" ]  && Skipright=yes
    [ "1.0000" = "$Permilletop" ]    && Skiptop=yes
    [ "1.0000" = "$Permillebottom" ] && Skipbottom=yes
    
    # break signal of fusewizard
    ifcmdbreak && return 1

    # Out-of-range error
    { [ "$Left" -gt "$Right" ] || [ "$Top" -gt "$Bottom" ] ; } && {
#      echo "Error: Failed to find an inner rectangle. Unuseable result: $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top" >&2
      failure "trim_hard(): Failed to find an inner rectangle. Unuseable result: $Cropgeometry" 
      Return=1
      Left=0
      Top=0
      Right=$((Imagewidth-1))
      Bottom=$((Imageheight-1))
      break
    }
    
    # Debugging: show intermediate results
    Debugmode=yes
    [ "$Debugmode" ] && {
      Loopcount=$((Loopcount+1))
      [ "$Loopcount" = "10" ] && {
        Loopcount=0
        convert $Sourceimagempc -fill none -stroke red -strokewidth 1 -pointsize 18 -undercolor white -gravity south -draw "rectangle $Left,$Top $Right,$Bottom  text 0,0 '$Cropgeometry'" $Cropgeometryimage
        showimage $Cropgeometryimage
        eval "$Addcommand"
      }
    }
  done

  # show result
  showpercent 100 100
  convert $Sourceimagempc -fill none -stroke red -strokewidth 1 -pointsize 18 -undercolor white -gravity south -draw "rectangle $Left,$Top $Right,$Bottom  text 0,0 '$Cropgeometry'" $Cropgeometryimage
  showimage $Cropgeometryimage
  
  # Output of result
  #echo "$Left,$Top $Right,$Bottom"                     # "-draw rectangle" geometry
  #echo $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top  # "-crop" geometry
  echo "$Cropgeometry"

  return ${Return:-0}
}

#### GUI

kaptaingrammar() {
  echo '#! /usr/bin/kaptain
start "fusewizard" -> frameset;

  frameset -> topframe bottomframe;
    topframe:beside   -> topleftframe ;
      topleftframe:framed   -> batchoptionframe topleftbottomframe ;
      toprightframe:framed  -> showimageframe ;
    bottomframe     -> statusframe ;
  
  showimageframe -> showimage showimagename ;
    showimage           -> @icon;
    showimagename       -> @text;
    
  batchoptionframe:beside            -> batchframeleft  batchframeright;
    batchframeleft:framed              -> batchblock1 batchblock2 specialframe;
    batchframeright:framed             -> batchblock3 runbatchframe showresultframe;
    
  topleftbottomframe -> dirframe deleteframe ;
    
  dirframe:beside -> choosedirguibutton choosedirbutton choosedir opendirbutton refreshbutton;
    choosedirguibutton  -> @button="X" ;
    choosedirbutton     -> @button="Choose stackshot directory:" ;
    choosedir           -> @string="'$Projecthome'" ;
    opendirbutton       -> @button="Open in file manager";
    refreshbutton       -> @button="refresh" ;
    
  deleteframe -> deletedir;
    deletedir:beside "Delete intermediate results" -> deletecache deleteevaluate deletecompose deletefuse deletemagick deleteall;
      deletecache       -> @button="-" ;
      deletemagick      -> @button="-" ;
      deletecompose     -> @button="-" ;
      deleteevaluate    -> @button="-" ;
      deletefuse        -> @button="-" ;
      deleteall         -> @button="Delete all";
    
  statusframe -> wizardstatusline wizardlog wizardlog;
    wizardstatusline:beside -> cmdpercent cmdbreak ;
      cmdpercent        -> @icon ;
      cmdbreak          -> @button="break" ;
    wizardlog           -> @text="" ;
      
    
      batchblock1 "batch block 1: prepare stackshot images in directory magick" -> cropline @text="convert options" contrastline sharpenline kuwaharaline brightnessline gammaline levelline stretchline wizardline applyallline;
        gammaline:beside                                      -> gamma gammamagick gammafuse gammaevaluate;
          gammacombo                                            -> @combow("auto","0.2","0.3","0.4","0.5","0.6","0.7","0.8","0.9","1.2","1.5","2.0","3.0","4.0")="auto" ;
          gammamagick                                           -> @button="magick" ;
          gammaevaluate                                         -> @button="evaluate" ;
          gammafuse                                             -> @button="fuse" ;
          gamma:beside                "gamma"                   -> gammacombo | "";
        levelline:beside                                      -> level levelmagick levelfuse levelevaluate;
          levelcombo                                            -> @combow("auto","5%","10%","15%","20%","25%","30%")="auto" ;
          levelmagick                                           -> @button="magick" ;
          levelevaluate                                         -> @button="evaluate" ;
          levelfuse                                             -> @button="fuse" ;
          level:beside                "level"                   -> levelcombo | ! "";
        contrastline:beside                                   -> contrast contrastmagick contrastfuse contrastevaluate;
          contrastcombo                                         -> @combow("1x50%","2x50%","3x50%","4x50%","5x50%","6x50%")="6x50%" ;
          contrastmagick                                        -> @button="magick" ;
          contrastevaluate                                      -> @button="evaluate" ;
          contrastfuse                                          -> @button="fuse" ;
          contrast:beside             "sigmoidal-contrast"      -> contrastcombo | "";
        kuwaharaline:beside                                   -> kuwahara kuwaharamagick kuwaharafuse kuwaharaevaluate;
          kuwaharacombo                                         -> @combow("1.0","1.5","2.0","2.5","3.0","4.0","5.0")="1" ;
          kuwaharamagick                                        -> @button="magick" ;
          kuwaharaevaluate                                      -> @button="evaluate" ;
          kuwaharafuse                                          -> @button="fuse" ;
          kuwahara:beside             "kuwahara"                -> kuwaharacombo | ! "";
        sharpenline:beside                                    -> sharpen sharpenmagick sharpenfuse sharpenevaluate;
          sharpencombo                                          -> @combow("3x1","6x2","8x4")="6x2" ;
          sharpenmagick                                         -> @button="magick" ;
          sharpenevaluate                                       -> @button="evaluate" ;
          sharpenfuse                                           -> @button="fuse" ;
          sharpen:beside              "adaptive-sharpen"        -> sharpencombo | "";
        brightnessline:beside                                 -> brightness brightnessmagick brightnessfuse brightnessevaluate;
          brightnesscombo                                       -> @combow("0x5","0x10","0x15","5x0","5x5","5x10","5x15","10x0","10x5","10x10","15x15","20x20")="10x10" ;
          brightnessmagick                                      -> @button="magick" ;
          brightnessevaluate                                    -> @button="evaluate" ;
          brightnessfuse                                        -> @button="fuse" ;
          brightness:beside           "brightness-contrast"     -> brightnesscombo | ! "";
        stretchline:beside                                    -> stretch stretchmagick stretchfuse stretchevaluate;
          stretchcombo                                          -> @combow("0%","1%","2%","3%","4%","5%","10%","15%","20%")="0%" ;
          stretchmagick                                         -> @button="magick" ;
          stretchevaluate                                       -> @button="evaluate" ;
          stretchfuse                                           -> @button="fuse" ;
          stretch:beside              "stretch-contrast"        -> stretchcombo | ! "";
        wizardline:beside                                     -> wizard wizardmagick wizardfuse wizardevaluate;
          wizardcombo                                           -> @combow("","-negate","-despeckle","-edge 3","-emboss 3","-enhance","-equalize","-canny 3","-charcoal 3")="" ;
          wizardmagick                                          -> @button="magick" ;
          wizardevaluate                                        -> @button="evaluate" ;
          wizardfuse                                            -> @button="fuse" ;
          wizard:beside               "convert"                 -> wizardcombo | ! "" ;
        applyallline:beside                                   -> applyall applyallmagick applyallfuse applyallevaluate;
          applyallmagick                                        -> @button="magick" ;
          applyallevaluate                                      -> @button="evaluate" ;
          applyallfuse                                          -> @button="fuse" ;
          applyall:beside             "Apply all convert options"  -> "" ;
          
      batchblock2 "batch block 2: post processing directory magick" -> meanbalanceline whitebalanceline align_aisline align_huginline align_vidstab1line align_vidstab2line align_vidstab3line ;
        meanbalanceline:beside                               -> meanbalance meanbalancemodecombo meanbalancemagick meanbalancefuse meanbalanceevaluate;
          meanbalancemodecombo                                 -> @combo("interactive","topleft","topright","bottomleft","bottomright","full")="full" ;
          meanbalancemagick                                    -> @button="magick" ;
          meanbalanceevaluate                                  -> @button="evaluate" ;
          meanbalancefuse                                      -> @button="fuse" ;
          meanbalance:beside         "meanbalance"            ->  "on"  | "";
        whitebalanceline:beside                               -> whitebalance whitebalancemodecombo whitebalancecombo whitebalancemagick whitebalancefuse whitebalanceevaluate;
          whitebalancemodecombo                                 -> @combo("interactive","topleft","topright","bottomleft","bottomright","full")="interactive" ;
          whitebalancecombo                                     -> @combow("mean","#777777","#888888","#999988","#999999","#AAAA99","#AAAAAA","#BBBBAA","#BBBBBB","#CCCCBB","#CCCCCC","#DDDDCC","#DDDDDD","#EEEEEE","#FFFFFF")="#CCCCCC" ;
          whitebalancemagick                                    -> @button="magick" ;
          whitebalanceevaluate                                  -> @button="evaluate" ;
          whitebalancefuse                                      -> @button="fuse" ;
          whitebalance:beside         "whitebalance"            ->  "on"  | ! "";
        cropline:beside                                       -> crop cropmodecombo cropcombo cropmagick cropfuse cropevaluate;
          cropmodecombo                                         -> @combo("interactive","shrink","even","geometry")="interactive" ;
          cropcombo                                             -> @combow("","1","2","5","10","200x200+15+15")="" ;
          cropmagick                                            -> @button="magick" ;
          cropevaluate                                          -> @button="evaluate" ;
          cropfuse                                              -> @button="fuse" ;
          crop:beside                 "crop + rotate"           -> "on" | ! "";
        align_aisline:beside                                  -> align_ais align_aisbutton ;
          align_aisbutton                                       -> @button="magick" ;
          align_ais:beside            "align with ais"          -> "on" | ! "";
        align_huginline:beside                                -> align_hugin align_huginbutton ;
          align_huginbutton                                     -> @button="magick" ;
          align_hugin:beside          "align with hugin"        -> "on" | ! "";
        align_vidstab1line:beside                             -> align_vidstab1 align_vidstab1combo align_vidstab1button ;
          align_vidstab1modecombo:beside    "Shakiness:"        -> @combo("1","2","3","4","5","6","7","8","9","10")="10" ;
          align_vidstab1combo         "crop interactive"        -> "on" | "";
          align_vidstab1button                                  -> @button="magick" ;
          align_vidstab1:beside       "align with vidstab:"     -> align_vidstab1modecombo | "";
        align_vidstab2line:beside                             -> align_vidstab2 align_vidstab2combo align_vidstab2button ;
          align_vidstab2modecombo:beside    "Shakiness:"        -> @combo("1","2","3","4","5","6","7","8","9","10")="5" ;
          align_vidstab2combo         "crop interactive"        -> "on" | ! "";
          align_vidstab2button                                  -> @button="magick" ;
          align_vidstab2:beside       "align with vidstab:"     -> align_vidstab2modecombo | "";
        align_vidstab3line:beside                             -> align_vidstab3 align_vidstab3combo align_vidstab3button ;
          align_vidstab3modecombo:beside    "Shakiness:"        -> @combo("1","2","3","4","5","6","7","8","9","10")="1" ;
          align_vidstab3combo         "crop interactive"        -> "on" | ! "";
          align_vidstab3button                                  -> @button="magick" ;
          align_vidstab3:beside       "align with vidstab:"     -> align_vidstab3modecombo | "";
        
      batchblock3 "batch block 3: combine stackshot images" -> fuse evaluateline sharpen_evaluate kuwahara_evaluate compose;
        fuse:beside                   "fuse"                    -> @button="magick" "on" | "";
        evaluateline:beside                                     -> evaluate evaluatemagick evaluatefuse;
          evaluatemagick                                        -> @button="magick" ;
          evaluatefuse                                          -> @button="fuse" ;
          evaluate:beside             "evaluate"                -> "on" | "";
        sharpen_evaluate:beside       "sharpen 3x1"             -> @button="evaluate" "on" | "";
        kuwahara_evaluate:beside      "kuwahara 1.0"            -> @button="evaluate" "on" | ! "";
        compose:beside                "compose"                 -> @button="evaluate" "on" | "";

      runbatchframe "Batch processing" -> runbatch1 runbatch2 runbatch3 runbatchprocessing;
        runbatch1:beside              "batch block 1"           -> "batchblock1" | "" @button="run";
        runbatch2:beside              "batch block 2"           -> "batchblock2" | "" @button="run";
        runbatch3:beside              "batch block 3"           -> "batchblock3" | "" @button="run";
        runbatchprocessing                                      -> @button="Run batch";
        
      specialframe "Special operations" -> rulerline undoline ;
        rulerline:beside                                      -> ruler rulermagick rulerfuse rulerevaluate;
          rulermodecombo                                        -> @combo("100c","100p","100z","40c","40p","40z","20c","20p","20z","10c","10p","10z")="100z" ;
          rulercombo:beside           "Title:"                  -> @string ;
          rulermagick                                           -> @button="magick" ;
          rulerevaluate                                         -> @button="evaluate" ;
          rulerfuse                                             -> @button="fuse" ;
          ruler:beside                "micrometer"              -> "" rulermodecombo rulercombo;
        undoline:beside                                       -> undo undomagick undofuse undoevaluate;
          undomagick                                            -> @button="magick" ;
          undoevaluate                                          -> @button="evaluate" ;
          undofuse                                              -> @button="fuse" ;
          undo                        "undo last step"          -> "" ;
          
      showresultframe "Show results" -> showimagebuttons showresultline @fill killviewnior;
        showimagebuttons:beside  -> showimageeval showimagefuse ;
          showimageeval            -> show_magick_max show_magick_mean show_magick_median show_magick_min ;
            show_magick_max          -> @button="magick.max";
            show_magick_mean         -> @button="magick.mean";
            show_magick_median       -> @button="magick.median";
            show_magick_min          -> @button="magick.min";
          showimagefuse            -> show_fuse_max   show_fuse_mean   show_fuse_median   show_fuse_min ;
            show_fuse_max            -> @button="fuse.max";
            show_fuse_mean           -> @button="fuse.mean";
            show_fuse_median         -> @button="fuse.median";
            show_fuse_min            -> @button="fuse.min";
      
          showresultline           -> @text="Directories" showresultline1 showresultline2 ;
            showresultline1:beside   -> showstackshot showmagick ;
              showstackshot            -> @button="stackshot";
              showmagick               -> @button="magick";
            showresultline2:beside   -> showfuse showcompose showevaluate;
              showfuse                 -> @button="fuse";
              showcompose              -> @button="compose";
              showevaluate             -> @button="evaluate";
        killviewnior:beside          -> @fill @action("killall viewnior")="killall viewnior" @fill;
'
}

sendkaptain() {
  # send messages to kaptain over its stdin
  echo "$1" >&${Kaptainstdin}
#  echo "sent to kaptain: $1"
}

askkaptain() {
  # ask kaptain for value of $1
  local Answer
  kaptaingrammar | grep -q "${1:-}" || return 1
  sendkaptain "${1:-}?"
  read Answer <&${Kaptainstdout}
  [ -z "$Answer" ] && return 1
  echo "$Answer"
  return 0
}

kaptain_update() {
  local Stackdir Pwdvalid Historyfile Cmdstatus
  Stackdir="$(storeinfo dump pwd)"
  
  # update working directory
  sendkaptain "choosedir='$Stackdir'"
    
  [ -d "$Stackdir/stackshot" ] && Pwdvalid="yes" || Pwdvalid="no"
  
  case $Pwdvalid in
    yes)
      storeinfo "pwd_valid=yes"
      storeinfo "history=$Stackdir/wizard.history"
      # update delete buttons
      [ -d "$Stackdir/magick" ]                       && sendkaptain "deletemagick='Delete magick'"         || sendkaptain "deletemagick='-'"
      [ -d "$Stackdir/evaluate" ]                     && sendkaptain "deleteevaluate='Delete evaluate'"     || sendkaptain "deleteevaluate='-'"
      [ -d "$Stackdir/compose" ]                      && sendkaptain "deletecompose='Delete compose'"       || sendkaptain "deletecompose='-'"
      [ -d "$Stackdir/fuse" ]                         && sendkaptain "deletefuse='Delete fuse'"             || sendkaptain "deletefuse='-'"
      check_dirglob "$Stackdir/*.bak $Stackdir/cache" && sendkaptain "deletecache='Delete cache + backups'" || sendkaptain "deletecache='-'"

    ;;
    no)
      storeinfo drop pwd_valid
      failure "Directory does not contain ./stackshot: $Stackdir"
      storeinfo drop history
      
      # update delete buttons
      sendkaptain "deletemagick='-'"
      sendkaptain "deleteevaluate='-'"
      sendkaptain "deletecompose='-'"
      sendkaptain "deletefuse='-'"
      sendkaptain "deletecache='-'"
    ;;
  esac
  
  Cmdstatus="$(storeinfo dump status)"
  case $Cmdstatus in
    error|idle) showpercent $Cmdstatus ;;
  esac
  
  # update preview
  kaptain_update_preview
}

kaptain_update_preview() {
  local Stackdir Currentimage Image Cachedir Imagelist Imagenumber
  
  # check if currently in valid dir, otherwise clear display
  storeinfo test pwd_valid || {
    #sendkaptain "showimage('')=x"
    storeinfo drop preview_md5
    storeinfo drop showimage
    return 0
  }
  
  Stackdir="$(storeinfo dump pwd)"
  
  # check if an image of current stackdir is shown
  Currentimage="$(storeinfo dump showimage)"
  grep -q "$Stackdir" <<< "$Currentimage" && [ -e "$Currentimage" ] && showimage "$Currentimage" && return 0
  
  # check for results
  Image="$(fileglob "$Stackdir/evaluate/*fuse.median*")"
  [ -e "$Image" ] && showimage "$Image" && return 0
  
  Image="$(fileglob "$Stackdir/evaluate/*magick.max*")"
  [ -e "$Image" ] && showimage "$Image" && return 0
  
  Image="$(fileglob "$Stackdir/*fuse.median*" | head -n1)"
  [ -e "$Image" ] && showimage "$Image" && return 0

  Cachedir="$(storeinfo dump cache)"
  Image="$Cachedir/preview.jpg"

  Imagelist="$(fileglob "$Stackdir/magick/*")"
  [ "$Imagelist" ] &&{
    Imagenumber="$(grep -c . <<< "$Imagelist")"
    Image="$(head -n$((Imagenumber/3)) <<< "$Imagelist" | tail -n1)"
    showimage "$Image"
    return 0
  }
  
  Imagelist="$(fileglob "$Stackdir/stackshot/*")"
  [ "$Imagelist" ] &&{
    Imagenumber="$(grep -c . <<< "$Imagelist")"
    Image="$(head -n$((Imagenumber/2)) <<< "$Imagelist" | tail -n1)"
    showimage "$Image"
    return 0
  }
  
  return 1

  ######### disabled
  # Generate max from magick
  check_fileglob "$Stackdir/magick/*" && {
    convert "$Stackdir/magick/*" -evaluate-sequence max "$Image"
    showimage "$Image"
    return 0
  }
  
  # Generate max from stackshot
  convert "$Stackdir/stackshot/*" -evaluate-sequence max "$Image"
  showimage "$Image"
  return 0
}

showpercent() {
  local Percent Part Full Percentimage
  
  Percentimage="$Wizardcache/percent.png"
  Part="${1:-}"
  Full="${2:-1}"
  
  case "$Part" in
    idle) Percentimage="p_idle.png" ;;
    ERROR) Percentimage="p_error.png" ;;
    *)
      Percent="$(( 100 * Part / Full ))"
      Percentimage="p_$Percent.png" 
    ;;
  esac
  Percentimage="$Percentcachedir/$Percentimage"

  [ -e "$Percentimage" ] || case "$Part" in
    idle)  convert -size 200x20 xc:transparent -fill black -pointsize 20 -draw "text 80,18 'idle'"   "$Percentimage" ;;
    error) convert -size 200x20 xc:transparent -fill red   -pointsize 20 -draw "text 80,18 'ERROR'"  "$Percentimage" ;;
    *)     convert -size 200x20 xc:transparent -fill green1 -draw "rectangle 0,0,$((Percent * 2)),20" -fill black -pointsize 20  -draw "text 80,18 '${Percent}%'" "$Percentimage" ;;
  esac
  sendkaptain "cmdpercent('$Percentimage')=''"
}

parse_kaptainsignal() {
  local Kaptainsignal
  local Command Argument Functionmode Functionoption Stackdir Newstackdir
  local Image
  local Iterate
  
  Kaptainsignal="${1:-}"
  Stackdir="$(storeinfo dump pwd)"
  
  case $Kaptainsignal in
    refreshbutton) ;;
    cmdbreak) 
      storeinfo "cmdbreak=yes"
      #Cmdpid=$(storeinfo dump cmdpid)
    ;;
    choosedirguibutton)
      worknote "Generating GUI"
      Newstackdir="$(choose_stackshot "$Stackdir")"
      [ "$Newstackdir" ] && {
        Stackdir="$Newstackdir"
        storeinfo "pwd=$Stackdir"
      }
      kaptain_update
    ;;
    choosedirbutton)
      Newstackdir="$(kdialog --getexistingdirectory "$Stackdir")"
      [ "$Newstackdir" ] && {
        Stackdir="$Newstackdir" 
        storeinfo "pwd=$Stackdir"
      }
      kaptain_update
    ;;
    opendirbutton)
      thunar "$Stackdir" &
    ;;
    previewrefresh)
      kaptain_update
    ;;
    delete*) 
      cmd -f $Kaptainsignal -t "$Stackdir"
    ;;
    showmagickbackup) ### FIXME
      cmd -f showcompare -m magick -t "$Stackdir"
    ;;
    show_*)
      Image="$(echo "$Kaptainsignal" | cut -d_ -f2- | tr _ . )"
      Image="$Stackdir/evaluate/*.$Image.*"
      showimage "$(fileglob "$Image")"
    ;;
    show*)
      showimage "$Stackdir/${Kaptainsignal#show}/*"
    ;;
    
    evaluate*|compose|fuse)
      cmd -f $Kaptainsignal -t $Stackdir
    ;;
    sharpen_evaluate)
      cmd -f sharpenevaluate -o 3x1 -t "$Stackdir"
    ;;
    kuwahara_evaluate)
      cmd -f kuwaharaevaluate -o 1.0 -t "$Stackdir"
    ;;
    
    *magick|*compose|*evaluate|*fuse)
      Command="$Kaptainsignal"
      Command="${Command%magick}"
      Command="${Command%evaluate}"
      Command="${Command%evaluate}"
      Command="${Command%fuse}"
      Functionmode="$(askkaptain "${Command}modecombo")"
      Functionoption="$(askkaptain "${Command}combo")"
      case "$Command" in
        applyall) 
          Functionoption="$(getbatch1)"
          Kaptainsignal="wizard${Kaptainsignal#applyall}"
        ;;
        meanbalance)
          Functionoption="mean"
          Kaptainsignal="whitebalance${Kaptainsignal#meanbalance}"
        ;;
      esac
      
      cmd -f "$Kaptainsignal" -m "$Functionmode" -o "$Functionoption" -t "$Stackdir"
    ;;
    
    align_aisbutton)
      cmd -f align_ais -t "$Stackdir"
    ;;
    align_huginbutton)
      cmd -f align_hugin -t "$Stackdir"
    ;;
    align_vidstab?button)
      Iterate=$(echo $Kaptainsignal | tr -d -c "0-9")
      Functionmode="$(askkaptain "align_vidstab${Iterate}modecombo")"
      Functionoption="$(askkaptain "align_vidstab${Iterate}combo")"
      cmd -f align_vidstab -m "$Functionmode" -o "$Functionoption" -t "$Stackdir"
    ;;
    
    runbatch1) 
      runbatch1 
      note "Batch 1 is ready."
    ;;
    runbatch2) 
      runbatch2 
      note "Batch 2 is ready."
    ;;
    runbatch3) 
      runbatch3 
      note "Batch 3 is ready."
    ;;
    runbatchprocessing)
      askkaptain "runbatch1" >/dev/null && runbatch1
      askkaptain "runbatch2" >/dev/null && runbatch2
      askkaptain "runbatch3" >/dev/null && runbatch3
      note "Batch all is ready."
    ;;
    *)
      failure "Unknown signal: $Kaptainsignal"
    ;;
  esac
}

## sub GUIs

choose_stackshot() {
  # GUI to choose stackshot. Preview of median images. Sorted by project dirs.
  local Dirlist Imagelist
  local Allprojects Entrylist Projectimages Projectline
  local Projectdir Oldprojectdir
  local Count Dircount Dir Image
  local FDin FDout
  
  cd "$Projecthome"
  # generate empty X image for unfused stackshots
  Emptyimage=$Thumbnaildir/empty.png
  [ -e "$Emptyimage" ] || convert caption:X $Emptyimage
  
  # get list of stackshot dirs and median images
  Dirlist="$(find -name stackshot -type d | sed s%/stackshot%% | sort -V)"
  for Dir in $Dirlist; do
    Image="$(find $Dir/*fuse.median* 2>/dev/null | head -n1)"
    Imagelist="$Imagelist
$Image"
  done
  Imagelist="$(tail -n+2 <<< "$Imagelist")"
  Dircount="$(grep -c . <<< "$Dirlist")"

  Count=0
  for Dir in $Dirlist EOL ; do
    Count=$((Count +1))
    showpercent "$Count" "$Dircount"
    
    # generate thumbnail. Check existing thumbnail with md5
    Image="$(sed "${Count}q;d" <<< "$Imagelist")"
    Image="${Image:-$Emptyimage}"
    Md5="$(md5sum "$Image" | cut -d' ' -f1)"
    Destinationfile=$Thumbnaildir/$(basename "$Image").$Md5.png
    [ -e "$Destinationfile" ] || convert "$Image" -resize 256x256 "$Destinationfile"
    
    # Check current project dir
    Projectdir="$(dirname $Dir)"

    # Checking a project dir is ready
    [ "$Projectdir" != "$Oldprojectdir" ] && {
      [ "$Projectline" ] && {
        # montage of all stackshot images in a project dir
        #Projectimages="$(sort <<< "$Projectimages")"
        Md5="$(cat $Projectimages | md5sum | cut -d' ' -f1)"
        Montagefile="$Thumbnaildir/$(basename $Projectdir).$Md5.png"
        [ -e "$Montagefile" ] || montage $Projectimages -tile x1 -geometry 100x100+5+5 $Montagefile
        
        # entry of subtree: montageimage + pjoject directory. Childs are stackshots.        
        Projectline="project$Count:tree '{$Montagefile}$Oldprojectdir' -> $Projectline"
        Allprojects="$Allprojects project$Count"
        Entrylist="$Entrylist
$Projectline ;"
      }
      
      [ "$Dir" = "EOL" ] && break
      
      Oldprojectdir="$Projectdir"
      Projectline=""
      Projectimages=""
      Montagefile=""
    }
    
    # add stackshot to subtree list
    Projectline="$Projectline stackshot$Count"
    
    # add stackshot
    Entrylist="$Entrylist
  stackshot$Count:beside '{$Destinationfile}$Dir' -> @dump('$Dir')='Choose this stackshot' @close='Cancel';"
  
    # add image to montage list
    Projectimages="$Projectimages
$Image"
  done

  echo "#! /usr/bin/kaptain
start 'Choose a stackshot' -> frame1;
  frame1:tree -> $Allprojects ;
$Entrylist
" > $Thumbnaildir/choose_stackshot.kaptain
  Dir="$(kaptain $Thumbnaildir/choose_stackshot.kaptain)"
  realpath "$Dir"
}

choose_fuseimages() {

  Wizardcache=/tmp
  Imagelist=""
  Entrylist=""
  Entryline=""
  Sourcedir=/home/lauscher/Bilder/ardustack/test/fuse
  Count=0
  for Image in $Sourcedir/*; do
    Count=$((Count+1))
    Imagelist="$Imagelist
$Image"
    Entryline="$Entryline image$Count"
    Entrylist="$Entrylist
    image$Count:beside '$Count' -> @button('$Image')='$(basename $Image)' '$(basename $Image)' | '' ;"
  done
  echo "#! /usr/bin/kaptain
start -> frameset;
  frameset:beside:framed -> framelist framepreview frameexiv;
    framelist    -> list;
    framepreview -> @icon('/home/lauscher/Bilder/ardustack/test/fuse/np.test.fuse06.jpg');
    frameexiv     -> exiv;
  exiv -> @text='' ;
  list -> $Entryline ;
$Entrylist" > $Wizardcache/test.kaptn
  cat $Wizardcache/test.kaptn
  
  rm $Wizardcache/test.fifo
  rm $Wizardcache/test11.fifo
  mkfifo $Wizardcache/test.fifo
  mkfifo $Wizardcache/test11.fifo
  exec {FDin}<>$Wizardcache/test.fifo
  exec {FDout}<>$Wizardcache/test11.fifo
  
  kaptain --stdio $Wizardcache/test.kaptn <&${FDin} >&${FDout} &
  Kaptainpid=$!
  
  while ps -p $Kaptainpid >/dev/null; do
    read -t1 Kaptainsignal <&${FDout}
    echo "Signal: $Kaptainsignal"
    Exiftext=""
    for Exifline in enfuse --exposure-weight=0.0  --saturation-weight=0.0  --contrast-weight=1.0  --hard-mask  --contrast-edge-scale=0  --contrast-window-size=3 --gray-projector=luminance ;do
      Exiftext="$Exiftext \n $Exifline"
    done
    echo "exiv=\"$Exiftext\"" >&${FDin}
  done 

}

cropgeometry_interactive() {
  # Interactive dialog to choose a crop geometry
  #   $1   Image to crop.
  #   $2   Cache folder to store files. Clean up yourself.
  #   $3   Preset crop geometry (optional). Default: entire image
  # Result:
  #   return 0 : echo crop geometry WxH+X+Y
  #   return 1 : no output
  # Dependencies:
  #   imagemagick
  #   kaptain (https://github.com/mviereck/kaptain)

  local Kaptaingrammar Kaptainpid Kaptainstdinfifo Kaptainstdoutfifo Kaptainsignal Kaptainstdin Kaptainstdout
  local Image Imagempc Imagewidth Imageheight
  local CropX CropY CropW CropH Cropgeometry
  local Rotate
  local Refresh Stepsize Return
  local Cachedir Cropgeometryimage Cropimagempc
  
  Image="${1:-}"
  Cachedir="${2:-}"
  Cropgeometry="${3:-}"
  
  checkvar -e crop_interactive Image    "$Image"    || return 1
  checkvar -d crop_interactive Cachedir "$Cachedir" || return 1
  
  worknote "Interactive choice of crop geometry of $Image"
  
  Cropgeometryimage="$Cachedir/cropgeometry.gui.tif"
  Cropimagempc="$Cachedir/crop.mpc"
  
  # check source for mpc format, convert if not
  [ "$Image" = "${Image%.mpc}" ] && {
    Imagempc="$Cachedir/cropgeometry.source.mpc"
    convert "$Image" "$Imagempc"
  } || {
    Imagempc="$Image"
  }
  
  Stepsize=50
  Rotate=0
  Refresh="yes"

  Imagewidth=$(convert  -format '%w'  $Imagempc info:)
  Imageheight=$(convert -format '%h'  $Imagempc info:)
    
  grep -q "x" <<< "$Cropgeometry" && grep -q "+" <<< "$Cropgeometry" && {
    CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
    CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
    CropW=$(cut -dx -f1 <<< "$Cropgeometry")
    CropH=$(cut -dx -f2 <<< "$Cropgeometry")
    CropH=$(cut -d+ -f1 <<< "$CropH")
  } || {
    CropX=0
    CropY=0
    CropW=$((Imagewidth-1))
    CropH=$((Imageheight-1))
  }
  
  Kaptaingrammar="$Cachedir/crop.kaptain.grammar"
  Kaptainstdinfifo="$Cachedir/crop.kaptain.stdin"
  Kaptainstdoutfifo="$Cachedir/crop.kaptain.stdout"
  mkfifo   $Kaptainstdinfifo
  mkfifo   $Kaptainstdoutfifo
  exec  {Kaptainstdin}<>$Kaptainstdinfifo
  exec  {Kaptainstdout}<>$Kaptainstdoutfifo
  
  echo "#! /usr/bin/kaptain
start 'Choose geometry' -> frameset ;
  frameset:beside -> frameleft ;
    frameleft:framed  -> arrowline stepsizeframe rotateline geometryline buttonline cmdpercent;
    
  cmdpercent    -> @icon;
  
  arrowline:beside:framed -> arrowposframe arrowsizeframe ;
    arrowposframe 'Position:' -> arrowpos1 arrowpos2 arrowpos3;
      arrowpos1:beside -> @fill   postop    @fill;
      arrowpos2:beside -> posleft @fill     posright ;
      arrowpos3:beside -> @fill   posbottom @fill;
        posleft          -> @button=' < ';
        posright         -> @button=' > ';
        postop           -> @button=' ^ ';
        posbottom        -> @button=' v ';
    arrowsizeframe 'Size:' -> size1 size2 size3;
      size1:beside     -> @fill    sizetop    @fill;
      size2:beside     -> sizeleft @fill      sizeright ;
      size3:beside     -> @fill    sizebottom @fill;
        sizeleft         -> @button=' < ';
        sizeright        -> @button=' > ';
        sizetop          -> @button=' ^ ';
        sizebottom       -> @button=' v ';
    rotateline:beside 'Rotate:'  -> rotatecombo rotateapply trim;
      rotatecombo       -> @combow('0','0.5','-0.5','1','-1','1.5','-1.5','2','-2','2.5','-2.5','3','-3','5','-5','10','-10','45','-45','90','180','270')='0';
      rotateapply       -> @button='apply';
      trim              -> @button='trim';
  stepsizeframe 'Step size' -> stepsize1 stepsize2;
  stepsize1:beside  -> ss1 ss2 ss5 ss10 ;
  stepsize2:beside  -> ss25 ss50 ss100 ss250;
    ss1           -> @button='1';
    ss2           -> @button='2';
    ss5           -> @button='5';
    ss10          -> @button='10';
    ss25          -> @button='25';
    ss50          -> @button='50';
    ss100         -> @button='100';
    ss250         -> @button='250';
  geometryline:beside -> geometry geometryapply;
    geometry:beside  'Crop geometry:'      -> @string='$Cropgeometry';
    geometryapply                          -> @button='apply';
  buttonline:beside -> ok cancel ;
    ok                                     -> @button=' OK' ;
    cancel                                 -> @close='Cancel';
" >> $Kaptaingrammar
  kaptain --stdio $Kaptaingrammar <&${Kaptainstdin} >&${Kaptainstdout} & Kaptainpid=$!

  Refresh="yes"
  while ps -p $Kaptainpid >/dev/null; do

    [ "$Refresh" = "yes" ] && {
      Cropgeometry="${CropW}x${CropH}+$CropX+$CropY"
      showpercent 10 100
      convert $Imagempc -background '#00000000' -rotate $Rotate +repage -fill none -stroke red -strokewidth 1 -draw "rectangle $CropX,$CropY $((CropX+CropW-1)),$((CropY+CropH-1))" "$Cropgeometryimage"
      showpercent 60 100
      showimage "$Cropgeometryimage"
      echo "geometry='$Cropgeometry'" >&${Kaptainstdin}
      Refresh="no"
      showpercent 100 100
    }

    Imagewidth=$(convert  -format '%w'  $Cropgeometryimage info:)
    Imageheight=$(convert -format '%h'  $Cropgeometryimage info:)
    
    read -t1 Kaptainsignal <&${Kaptainstdout}
    
    ifcmdbreak && Return=1 && break
    
    [ "$Kaptainsignal" ] && {
      Kaptainsignal="${Kaptainsignal%:pressed}"
      case $Kaptainsignal in
        posleft)    CropX=$((CropX-$Stepsize)) ;;
        posright)   CropX=$((CropX+$Stepsize)) ;;
        postop)     CropY=$((CropY-$Stepsize)) ;;
        posbottom)  CropY=$((CropY+$Stepsize)) ;;
        sizeleft)   CropW=$((CropW-$Stepsize)) ;;
        sizeright)  CropW=$((CropW+$Stepsize)) ;;
        sizetop)    CropH=$((CropH-$Stepsize)) ;;
        sizebottom) CropH=$((CropH+$Stepsize)) ;;
        ss*)        Stepsize="$(cut -c3- <<< "$Kaptainsignal")" ;;
        rotatecombo*) Rotate="$(cut -d: -f2 <<< "$Kaptainsignal")" ;;
        rotateapply) 
          echo "rotatecombo?" >&${Kaptainstdin}
          read Rotate <&${Kaptainstdout}
        ;;
        geometryapply)
          echo "geometry?" >&${Kaptainstdin}
          read Cropgeometry <&${Kaptainstdout}
          [ "$Cropgeometry" ] && {
            CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
            CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
            CropW=$(cut -dx -f1 <<< "$Cropgeometry")
            CropH=$(cut -dx -f2 <<< "$Cropgeometry")
            CropH=$(cut -d+ -f1 <<< "$CropH")
          }
        ;;
        trim)
          convert "$Imagempc" -background '#00000000' -rotate $Rotate +repage "$Cropimagempc"
          Cropgeometry="$(trim_hard "$Cropimagempc" "$Cropgeometry" )"
          [ "$Cropgeometry" ] && {
            CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
            CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
            CropW=$(cut -dx -f1 <<< "$Cropgeometry")
            CropH=$(cut -dx -f2 <<< "$Cropgeometry")
            CropH=$(cut -d+ -f1 <<< "$CropH")
          }
        ;;
        ok)         Return=0; break ;;
      esac
      [ "$CropX" -lt "0" ] && CropX=0
      [ "$CropY" -lt "0" ] && CropY=0
      [ "$CropW" -lt "1" ] && CropW=1
      [ "$CropH" -lt "1" ] && CropH=1
      [ "$CropX" -gt "$Imagewidth" ]  && CropX=$Imagewidth
      [ "$CropY" -gt "$Imageheight" ] && CropY=$Imageheight
      [ "$((CropX+CropW-1))" -gt "$Imagewidth" ]  && CropW=$((Imagewidth-CropX))
      [ "$((CropY+CropH-1))" -gt "$Imageheight" ] && CropH=$((Imageheight-CropY))
      Refresh="yes"
    }
  done 
  
  worknote "trim_hard(): final check"
  convert "$Imagempc" -background '#00000000' -rotate $Rotate +repage "$Cropimagempc"
  Cropgeometry="$(trim_hard "$Cropimagempc" "$Cropgeometry")" # final check
          
  exec {Kaptainstdin}>&- {Kaptainstdout}>&-
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
  [ "$Return" = "0" ] && {
    [ "$Rotate" = "0" ] && echo "$Cropgeometry" || echo "$Cropgeometry:$Rotate"
    return 0
  }
  return 1
}

#### run commands on all CPUs

multicore() {
  # Run multiple processes in parallel, but not more than $Wizardthreads
  # $1 Command
  # $2 Image to show if $1 is finished
  # Run multicore_wait afterwards to wait for the last processes to finish.
  
  local Process
    
  [ "$Multicoreprocesscount" = $Wizardthreads ] && {
    for Process in $(seq $Wizardthreads); do
      [ "${Multicoreprocess[$Process]}" ] && {
        multicore_waitprocess "${Multicoreprocess[$Process]}" || {
          multicore_break
          return 1
        }
        [ "${Multicoreimage[$Process]}" ] && showimage "${Multicoreimage[$Process]}"
      }
      Multicoreprocess[$Process]=""
      Multicoreimage[$Process]=""
    done
    Multicoreprocesscount=0
  }
  
  ifcmdbreak && {
    multicore_break
    return 1
  }
        
  Multicoreprocesscount=$((Multicoreprocesscount +1))

  #echo "${1:-} "
  eval "${1:-} &"
  
  Multicoreprocess[Multicoreprocesscount]=$!
  Multicoreimage[Multicoreprocesscount]="${2:-}"
  
  return 0
}

multicore_wait() {
  local Process
  for Process in $(seq $Wizardthreads); do
    [ "${Multicoreprocess[$Process]}" ] && {
      multicore_waitprocess "${Multicoreprocess[$Process]}" || {
        multicore_break
        return 1
      }
      [ "${Multicoreimage[$Process]}" ] && showimage "${Multicoreimage[$Process]}"
    }
    Multicoreprocess[$Process]=""
    Multicoreimage[$Process]=""
  done
  Multicoreprocesscount=0
  return 0
}

multicore_waitprocess() {
  while sleep 0.05 ; do
    ps -p "${1:-}" >/dev/null || break
    ifcmdbreak && return 1
  done
  wait "${1:-}"
  return $?
}

multicore_break() {
  local Process
  for Process in $(seq $Wizardthreads); do
    [ "${Multicoreprocess[$Process]}" ] && {
      kill "${Multicoreprocess[$Process]}"
      wait "${Multicoreprocess[$Process]}"
    }
  done
}

#### headquarter

cmd() {
  local Arg Command
  
  #parse_cmd "$@"

  for Arg in "$@"; do
    Command="$Command '$Arg'"
  done
#  echo "$Command" >> $Commandstackfile
  echo "$Command" >&${FDcmd}
}

ifcmdbreak() {
  storeinfo test cmdbreak && return 0
  return 1
}

stack_cmd() {
  local Command Commandpid Return
  while :; do
    read -t1 Command <&${FDcmd}
    eval set -- $Command 
    storeinfo test cmdbreak && {
      [ "$Command" ] || storeinfo drop cmdbreak
      Command=""
    }
    [ "$Command" ] && {
      eval set -- $Command 
      
      #sendkaptain "wizardcmd=' $*'"
      showpercent "0" "100"
      storeinfo "status=work"
      
      parse_cmd "$@" &
      Commandpid=$!
      storeinfo "cmdpid=$Commandpid"
      wait $Commandpid
      Return=$?
      storeinfo drop cmdpid
      
      case $Return in
        0)
          storeinfo "status=idle"
          showpercent idle
          #sendkaptain "wizardcmd=''"
        ;;
        *)
          storeinfo "status=error"
          showpercent error
          storeinfo "cmdbreak=yes"
        ;;
      esac
    }
  done
}

parse_cmd() {
  local $Batchlocal
  local Commandline Return= Historyfile=

  parse_batchoptions "$@" || return 1
  Commandline="$@"
  
  Historyfile="$(storeinfo dump history)"
  
  case "$Function" in
    deleteall)   myrm "$Targetdir"/*.bak "$Targetdir/cache" "$Targetdir/magick" "$Targetdir/compose" "$Targetdir/evaluate" "$Targetdir/fuse" ; Return=0 ;;
    deletecache) myrm "$Targetdir/cache" "$Targetdir"/*.bak ; Return=0 ;;
    delete*)     myrm "$Targetdir/${Function#delete}" "$Targetdir/${Function#delete}.bak" ; Return=0 ;;
    
    align_hugin)
      batch_function -f align_hugin -t "$Targetdir"
      Return=$?
    ;;
    align_ais)
      batch_function -f align_ais -t "$Targetdir"
      Return=$?
    ;;
    align_vidstab)
      batch_function -f align_vidstab -m "$Functionmode" -o "$Functionoption" -t "$Targetdir"
      Return=$?
    ;;
    brightness*|contrast*|crop*|gamma*|kuwahara*|level*|prepare*|sharpen*|stretch*|undo*|whitebalance*|ruler*|wizard*)
      Function="${Function%magick}"
      batch_function -f $Function -m "$Functionmode" -o "$Functionoption" -t "$Targetdir"
      Return=$?
    ;;
    evaluate*|compose*|fuse)
      batch_function -f $Function -m "${Functionmode:-all}" -t "$Targetdir"
      Return=$?
    ;;
    showimage)
      showimage "$Sourcedir/$Sourcefileglob"
      Return=0
    ;;
  esac
 
  kaptain_update

  case $Return in
    0) 
      echo "$Commandline" >> "$Historyfile"
      return 0
    ;;
    *) return ${Return:-1} ;;
  esac
}

#### main

declare_variables() {
  Projecthome="$HOME/Bilder/ardustack"
  Gallerydir="$HOME/Gallery"

  Wizardcache="$HOME/.cache/fusewizard"
  Wizardlocalshare="$HOME/.local/share/fusewizard"
  Percentcachedir="$Wizardlocalshare/percent"
  Thumbnaildir="$Wizardlocalshare/thumbnails"
  
#  Wizardthreads="$(nproc)"
  Wizardthreads="3"
  Wizardthreads="${Wizardthreads:-1}"
  for i in $Wizardthreads; do
    Multicoreprocess[$i]=""
    Multicoreimage[$i]=""
  done
  Multicoreprocesscount=0
  
  Batchlocal="Targetdir Sourcedir Sourcefileglob Destinationdir Destinationfile Cachedir Function Functionmode Functionoption"
  Convert="convert -quality 100%"

  Commandstackfile=$Wizardcache/commandstack
  
  Wizardlogfile=$Wizardcache/wizard.log
  Wizardlogfifo=$Wizardcache/wizard.log.fifo
  
  Wizardmessagefifo=$Wizardcache/wizard.message.fifo
  Wizardmessagefile=$Wizardcache/wizard.message.log
  
  Kaptaingrammar=$Wizardcache/kaptain.grammar
  Kaptainstdinfifo=$Wizardcache/kaptain.stdin 
  Kaptainstdoutfifo=$Wizardcache/kaptain.stdout
  Kaptainstdin=""
  Kaptainstdout=""
  
  Storeinfofile=$Wizardcache/store.info
  Storepidfile=$Wizardcache/store.pid
  
    
  Historyfile=""
  
  Imgruler="$(dirname $0)/imgruler"
}

create_cachefiles() {
  mkdir -p $Wizardcache
  mkdir -p $Thumbnaildir
  mkdir -p $Percentcachedir
  
  mkfifo   $Kaptainstdinfifo
  exec  {Kaptainstdin}<>$Kaptainstdinfifo
  mkfifo   $Kaptainstdoutfifo
  exec  {Kaptainstdout}<>$Kaptainstdoutfifo

  mkfifo   $Wizardlogfifo
  
  mkfifo   $Wizardmessagefifo
  exec  {FDmessage}<>$Wizardmessagefifo
  :>       $Wizardmessagefile
  
  mkfifo   $Commandstackfile
  exec  {FDcmd}<>$Commandstackfile
  :>       $Storeinfofile
  :>       $Storepidfile
}

finish() {
  trap - EXIT
  while read Pid; do
    kill $Pid
  done <$Storepidfile
  exec {Kaptainstdin}>&-
  exec {Kaptainstdout}>&-
  rm -R $Wizardcache
}

main() {
  trap finish EXIT
  
  # init
  declare_variables
  create_cachefiles
  storeinfo "cache=$Wizardcache"
  
  # start kaptain
  kaptaingrammar > $Kaptaingrammar
  #nl -ba $Kaptaingrammar
  kaptain --stdio $Kaptaingrammar <&${Kaptainstdin} >&${Kaptainstdout} & Kaptainpid=$!
  echo $Kaptainpid >> $Storepidfile
  
  showlog &
  echo $! >> $Storepidfile
  showmessages &
  echo $! >> $Storepidfile
  
  exec 1>$Wizardlogfifo 2>&1
  
  stack_cmd &
  echo $! >> $Storepidfile
  
  storeinfo "status=idle"

  # watch signals of kaptain
  while ps -p $Kaptainpid >/dev/null; do
    read -t1 Kaptainsignal <&${Kaptainstdout}
    [ "$Kaptainsignal" ] && {
      echo "Signal from kaptain: $Kaptainsignal"
      grep -q ":on"      <<< "$Kaptainsignal" && Kaptainsignal=""
      grep -q ":off"     <<< "$Kaptainsignal" && Kaptainsignal=""
      grep -q ":pressed" <<< "$Kaptainsignal" && {
        Stackdir="$(askkaptain choosedir)"
        [ "$Stackdir" != "$Oldstackdir" ] && {
          storeinfo "pwd=$Stackdir"
          kaptain_update
        }
        Oldstackdir="$Stackdir"
      }
      Kaptainsignal="${Kaptainsignal%:pressed}"
    }
    [ "$Kaptainsignal" ] && parse_kaptainsignal "$Kaptainsignal"
  done
}

main "$@"
finish

######### legacy

compose_independent() {
  local $Batchlocal
  local Minfile Maxfile Destinationfilebasename
  
  parse_batchoptions "$@" || return 1
  
  Destinationfilebasename="${Destinationfile:-compose}"
  Functionmode="${Functionmode:-all}"
  Functionmode="$(tr '[:upper:]' '[:lower:]' <<< "$Functionmode")"
  
  Maxfile="$Cachedir/evaluate.max.jpg"
  Minfile="$Cachedir/evaluate.min.jpg"
  [ -e "$Maxfile" ] && [ -e "$Minfile" ] || {
    evaluate -s "$Sourcedir" -g "$Sourcefileglob" -d "$Cachedir" -m "max"
    evaluate -s "$Sourcedir" -g "$Sourcefileglob" -d "$Cachedir" -m "min"
  }

  [ -e "$Maxfile" ] && [ -e "$Minfile" ] || {
    failure "compose $Functionmode: Failed to create min and max files."
    return 1
  }
  
  [ "$Functionmode" = "all" ] && {
    for Functionmode in bumpmap colorburn difference linearburn linearlight modulate multiply overlay pegtoplight; do
      compose -s "$Sourcedir" -g "$Sourcefileglob" -d "$Destinationdir" -b "$Destinationfilebasename" -m "$Functionmode" -c "$Cachedir" || return 1
    done
    return 0
  }
  
  Destinationfile="$Destinationdir/$Destinationfilebasename.${Functionmode}1.jpg"
  $Convert "$Minfile" "$Maxfile" -compose "$Functionmode" -composite "$Destinationfile"
  echo "$Destinationfile"
  showimage "$Destinationfile"
  
  case $Functionmode in
    linearburn|multiply) ;;  # skip second compose for modes with identical result
    difference)
      $Convert "$Destinationfile" -negate "$Destinationdir/$Destinationfilebasename.${Functionmode}-negate.jpg"
    ;;
    *)
      Destinationfile="$Destinationdir/$Destinationfilebasename.${Functionmode}2.jpg"
      $Convert "$Maxfile" "$Minfile" -compose "$Functionmode" -composite "$Destinationfile"
      echo "$Destinationfile"
      showimage "$Destinationfile"
    ;;
  esac
}

align_ffmpeg_rotatemagick(){
  local $Batchlocal
  local Sourcefilelist Imagelist Destinationfile Sourcefile
  local Image Imagewidth Imageheight Count Imagecount
  local CropW CropH CropX CropY Cropgeometry Zoom
  local Shakiness Blackborder Rotate Stepsize
  local Xoffset Xoffsetrelative Xoffsetlist Yoffset Yoffsetrelative Yoffsetlist Radians Radiansrelative Radianslist Degree 
  local Cropevendir Motionsfile Rotatedir Rotateminimage 

  parse_batchoptions "$@" || return 1
  
  cd $Cachedir
  
  Functionmode="${Functionmode:-vidstab}"
  Shakiness="$( cut -d: -f1 <<< "$Functionoption")"
  Shakiness="${Shakiness:-1}"
  Rotate=""
  Blackborder="crop=black:"
  Stepsize=6
  
  Cropevendir="$Cachedir/cropeven"
  mkdir -p "$Cropevendir"
  crop -m even -s "$Sourcedir" -g "$Sourcefileglob" -d "$Cropevendir"

  Sourcefilelist=$Cachedir/align.source.list
  :> $Sourcefilelist
  
  Imagelist="$(fileglob "$Cropevendir/$Sourcefileglob")"
  for Image in $Imagelist; do
    echo "file $Image" >>$Sourcefilelist
  done
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagecount="$(grep -c . <<< "$Imagelist")"

  worknote "align_ffmpeg: generating video from images"
  ffmpeg -y -hide_banner -nostdin -safe "0" -f "concat" -i "$Sourcefilelist" \
         -vcodec "libx264" -profile:v "high444" -refs "16" -crf "0" -preset "ultrafast" \
         "$Cachedir/align.source.mp4" || return 1
  ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.source.mp4"
  
  showpercent "1" "100"

  case $Functionmode in
    vidstab)
      worknote "align_ffmpeg: Analyzing video with shakiness=$Shakiness"
      ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.source.mp4" \
             -vf "vidstabdetect=shakiness=$Shakiness:accuracy=15:mincontrast=0.1:stepsize=$Stepsize:show=1:result=$Cachedir/transforms$Shakiness.trf" \
             "$Cachedir/align.vidstab-show.mp4" || return 1
      ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.vidstab-show.mp4"
      showpercent "2" "100"

      Transformoptions="smoothing=0:interpol=no:relative=1:${Blackborder}${Rotate}"

      worknote "align_ffmpeg: Transforming video with $Transformoptions"
      ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.source.mp4" \
             -vf "vidstabtransform=optzoom=0:${Transformoptions}debug=1:input=$Cachedir/transforms$Shakiness.trf,unsharp=5:5:0.8:3:3:0.4" \
             "$Cachedir/align.result.mp4" || return 1
      ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.result.mp4"
      showpercent "3" "100"
      
      worknote "align_ffmpeg: Splitting aligned video into images"
      ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.result.mp4" "$Cachedir/alignimg%04d.tif" || return 1
      
      Image="$(head -n1 <<< "$Imagelist")"
      Imagewidth=$(convert  -format '%w'  $Image info:)
      Imageheight=$(convert -format '%h'  $Image info:)
      
      Motionsfile="$Cachedir/global_motions.trf"

      Xoffsetlist="$(cat $Motionsfile | grep -v '#' | awk '{print $2}')"
      Yoffsetlist="$(cat $Motionsfile | grep -v '#' | awk '{print $3}')"
      Radianslist="$(cat $Motionsfile | grep -v '#' | awk '{print $4}')"
      
      Rotatedir="$Cachedir/rotate"
      mkdir -p "$Rotatedir"
      
      worknote "align_ffmpeg: Distorting images"
      Count=0
      for Image in $Imagelist; do
        Count="$((Count + 1))"
        
        Xoffsetrelative="$(sed "${Count}q;d" <<<"$Xoffsetlist")"
        Xoffset="$(awk "BEGIN { print $Xoffset + $Xoffsetrelative }")"
        Yoffsetrelative="$(sed "${Count}q;d" <<<"$Yoffsetlist")"
        Yoffset="$(awk "BEGIN { print $Yoffset + $Yoffsetrelative }")"
        Radiansrelative="$(sed "${Count}q;d" <<<"$Radianslist")"
        Radians="$(awk "BEGIN { print $Radians - $Radiansrelative }")"
        Degree="$(awk  "BEGIN { print $Radians * 180 / 3.141592652}")"
                 
        Destinationimage="$Rotatedir/$(basename $Image).png"
        
        multicore "$Convert -size ${Imagewidth}x${Imageheight} xc:transparent \
                            -draw 'translate  $(awk "BEGIN {print $Imagewidth/2}"),$(awk "BEGIN {print $Imageheight/2 }") \
                                   rotate $Degree image over $(awk "BEGIN {print -$Imagewidth/2 + $Xoffset}"),$(awk "BEGIN {print -$Imageheight/2 + $Yoffset}") 0,0 \"$Image\"' \
                            $Destinationimage" \
                  "$Destinationimage" || return 1
        
        showpercent "$Count" "$Imagecount"
      done
      multicore_wait
          
      Rotateminimage="$Cachedir/rotate.min.mpc"
      $Convert $(fileglob "$Cachedir/rotate/*") -evaluate-sequence min "$Rotateminimage" || return 1
      Cropgeometry="$(trim_hard "$Rotateminimage")"
      
      worknote "align_ffmpeg: cropping inner rectangle"
      Count=0
      for Image in $(fileglob "$Rotatedir/*"); do
        Count="$((Count + 1))"
        Destinationfile="$Destinationdir/$(basename "$Image")"
        Destinationfile="${Destinationfile%.png}"
        multicore "$Convert $Image -crop $Cropgeometry $Destinationfile" "$Destinationfile" || return 1
        showpercent "$Count" "$Imagecount"
      done
      multicore_wait
            
      showimage "$Rotateminimage.trim_hard.png"
      
    ;;
    deshake)
      worknote "align_ffmpeg: Deshaking video"
      ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.source.mp4" \
             -vf "deshake=edge=blank:contrast=16:rx=64:ry=64:blocksize=32:filename=$Cachedir/align.ffmpeg.log" \
             "$Cachedir/align.result.mp4" || return 1
             
      worknote "align_ffmpeg: Splitting aligned video into images"
      ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.result.mp4" "$Cachedir/alignimg%04d.tif" || return 1
      
      Count=0
      for Image in $(fileglob "$Cachedir/*.tif"); do
        Count="$((Count+1))"
        Sourcefile="$(sed "s/file // ; ${Count}q;d" $Sourcefilelist)"
        Destinationfile="$Destinationdir/$(basename $Sourcefile)"
        $Convert "$Image" "$Destinationfile" || return 1
        showimage "$Destinationfile"
        showpercent "$Count" "$Imagecount"
      done
    ;;
  esac
}
