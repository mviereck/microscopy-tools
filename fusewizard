#! /bin/bash
#
# fusewizard - generate sharp aligned images from stackshots
#

Version="0.1"

#### Messages, Log

note() {
  echo "note: $(shortpath "$*")"    >> $Wizardmessagefifo
}

verbose() {
  echo "$*" >&2
}

worknote() {
  echo "@work: $(shortpath "$*")"   >> $Wizardmessagefifo
}

warning() {
  echo "WARNING: $(shortpath "$*")" >> $Wizardmessagefifo
}

failure() {
  echo "Failure: $(shortpath "$*")" >> $Wizardmessagefifo
}

error() {
  echo "ERROR: $(shortpath "$*")"   >> $Wizardmessagefifo
}

historyentry() {
  local Historyfile
  Historyfile="$(storeinfo dump history)"
  [ "$Historyfile" ] && echo "$*" >> "$Historyfile"
}

storeinfo() {
  # store and provide pieces of information
  # replace entry if codeword is already present
  # Store as codeword=string:
  #   $1 codeword=string
  # Dump stored string:
  #   $1 dump
  #   #2 codeword
  # Drop stored string:
  #   $1 drop
  #   #2 codeword
  # Test for codeword: (return 1 if not found)
  #   $1 test
  #   $2 codeword
  #
  # note: sed -i causes file permission issues if called in container in Cygwin, compare ticket #187
  #       chmod 666 for $Sharefolder could probably fix that. (FIXME)
  #
  [ -e "$Storeinfofile" ] || return 1
  case "${1:-}" in
    dump) grep     "^${2:-}="   $Storeinfofile | sed "s/^${2:-}=//" ;;      # dump entry
    drop) sed -i  "/^${2:-}=/d" $Storeinfofile ;;                           # drop entry
    test) grep -q  "^${2:-}="   $Storeinfofile ;;                           # test for entry
    *)                                                                      # store entry
      sed -i "/^$(echo "${1:-}" | cut -d= -f1)=/d"     $Storeinfofile       # drop possible old entry
      echo "${1:-}"                                 >> $Storeinfofile
    ;;
  esac
}

storepid() {
  echo "${1:-}" >> $Storepidfile
  ### FIXME store command
}

showlog() {
  local Line
  while read Line; do
    echo "$Line"
    echo "$Line" >> $Wizardlogfile
  done < $Wizardlogfifo
}

showmessages() {
  local Line
  while read Line; do
    echo "$Line"
    echo "$Line" >> $Wizardmessagefile
#    sendkaptain 'wizardlog=`tail -n1 '$Wizardmessagefile'`'
    Line="${Line#note: }"
    Line="${Line#@work: }"
    sendkaptain "wizardlog='${Line}'"
  done <&${FDmessage}
}

shortpath() {
  LC_ALL=C sed "s!$Projecthome!.!g" <<< "${1:-}"
#  echo "${1:-}"
}

#### misc

checkvar() {
  local Arg

  Arg="${1:-}"
  [ "$(cut -c1 <<< "$Arg")" = "-" ] && shift || Arg=""

  [ -z "${3:-}" ] && {
    failure "${1:-}: Variable ${2:-} is empty."
    return 1
  }
  
  case "$Arg" in
    -d) 
      [ -d "${3:-}" ] || {
        failure "${1:-}: ${2:-} is not a directory: ${3:-}"
        return 1
      }
    ;;
    -e) 
      [ -e "${3:-}" ] || {
        failure "${1:-}: ${2:-} does not exist: ${3:-}"
        return 1
      }
    ;;
  esac
  case "$Arg" in
    -D) 
      check_fileglob "${3:-}/*" || {
        failure "${1:-}: ${2:-}: directory is empty: ${3:-}"
        return 1
      }
    ;;
    -E) 
      [ -s "${3:-}" ] || {
        failure "${1:-}: ${2:-}: file is empty: ${3:-}"
        return 1
      }
    ;;
  esac
  return 0
}

printnum(){
  # print number $1 with leading zeroes.
  # $1 number
  # $2 digits. Default: 3
  printf %0${2:-3}d "${1:-0}"
}

#### file operations

myrm() {
  # remove files
  # $@ quoted globs
  local Line
  for Line in "$@" ; do
    check_fileglob "$Line" && {
      verbose "rm: Deleting $Line"
      rm $(fileglob "$Line")
    }
  done
}

myrmdir() {
  # remove directories and their content
  # $@ quoted globs
  local Line
  for Line in "$@" ; do
    check_dirglob "$Line"  && {
      verbose "rmdir: Deleting $Line"
      rm -rf $Line
    }
  done
}

mymv() {
  # move quoted glob $1 to directory $2
  check_fileglob "${1:-}" || {
    verbose "mv: Source is empty: ${1:-}"
    return 1
  }
  [ -d "${2:-}" ] || {
    failure "mv: Target is not a directory: ${2:-}"
    return 1
  }
  verbose "mv: moving ${1:-} to ${2:-}"
  mv -f $(fileglob "${1:-}") "${2:-}"
}

mycp() {
  # copy quoted glob $1 to directory $2
  check_fileglob "${1:-}" || {
    verbose "cp: Source is empty: ${1:-}"
    return 1
  }
  [ -d "${2:-}" ] || {
    failure "cp: Target is not a directory: ${2:-}"
    return 1
  }
  verbose "cp: copy ${1:-} to ${2:-}"
  cp $(fileglob "${1:-}") "${2:-}"
}

check_fileglob() {
  # check whether files exist for quoted glob $1
  [ -n "$(eval find ${1:-} -maxdepth 0 -type f -print -quit 2>/dev/null)" ]
}

check_dirglob() {
  # check whether directories exist for quoted glob $1
  [ -f "${1:-}" ] && return 1
  [ -n "$(eval find ${1:-} -maxdepth 0 -type d -print -quit 2>/dev/null)" ]
}

fileglob() {
  # echos files only for glob $1
  #local Path Glob 
  local Filelist
  
  #[ -d "${1:-}" ] && {
  #  Path="${1:-}"
  #  Glob="*"
  #} || {
  #  Path="$(dirname  "${1:-}")"
  #  Glob="$(basename "${1:-}")"
  #}
  #Path="$(realpath "$Path")"
  
  Filelist="$(eval find ${1:-} -maxdepth 0 -type f 2>/dev/null)"
  Filelist="$(sort -V <<< "$Filelist")"
  
  [ "$Filelist" ] && echo "$Filelist" || return 1
}

check_stackdir() {
  # Check $1 if it is a valid directory containing a subfolder stackshot
  local Stackdir Newstackdir Stackdirvalid Projectname Projecthome
  
  Stackdir="$(storeinfo dump stackshotdir)"
  Newstackdir="${1:-}"
  Newstackdir="${Newstackdir:-$Stackdir}"
  Newstackdir="${Newstackdir%/}"
  
  Projecthome="$(storeinfo dump projecthome)"
  
  [ -z "$Newstackdir" ]   && failure "No stackshot directory given." && return 1
  [ ! -d "$Newstackdir" ] && failure "Not a directory: $Newstackdir" && return 1
  
  [ -d "$Newstackdir/stackshot" ] && Stackdirvalid="yes" || Stackdirvalid="no"

  [ "$Stackdirvalid" = "no" ] && [ "${Newstackdir%/stackshot}" != "$Newstackdir" ] && {
    Newstackdir="${Newstackdir%/stackshot}"
    Stackdirvalid="yes"
  }
  
  storeinfo "stackshotdir=$Newstackdir"
  case "$Stackdirvalid" in
    yes)
      storeinfo "stackshotdir_valid=yes"
      storeinfo "history=$Newstackdir/wizard.history"

      grep -q "$Projecthome" <<< "$Newstackdir" && {
        Projectname="${Newstackdir#$Projecthome/}"
        Projectname="$(dirname "$Projectname")"
        [ "$Projectname" = "$(basename "$Newstackdir")" ] && Projectname=""
        [ "$Projectname" = "." ]                          && Projectname=""
      }
      [ "$Projectname" ] && storeinfo "projectdir=$Projecthome/$Projectname" || storeinfo drop projectdir
      [ -z "$Projecthome" ] && Projectname="np"
      [ -z "$Projectname" ] && Projectname="np"
      storeinfo "projectname=$Projectname"
      return 0
    ;;
    no)
      storeinfo drop stackshotdir_valid
      storeinfo drop history
      storeinfo "projectname=np"
      return 1
    ;;
  esac
}

setup_workdir() {
  # Detect possible source directories in $2 for function $1
  # Set up variables that can be used to call function $1
  # Usage:
  #   setup_workdir Function Targetdir
  # Args:
  #   Function       One of align, sharpen, fuse, median, min, max, mean, set
  #   Targetdir      Target directory [+glob] to check.
  #                  Can already be in an ardustack-structure or an arbitrary one.
  #                  Location of $Destinationdir depends on detected directory structure.
  #   Functionoption   Mode of Function
  # Sets variables:
  #   Sourcedir                 Source directory within $Targetdir
  #   Sourcefileglob            Glob to get files. Mostly just "*"
  #   Destinationdir            Recommended directory to store resulting images.
  #                             Often serves as source dir for following functions.
  #   Destinationfile   Possible prefix of destination file(s). Can be "", though.
  #   Targetcachedir            Cache folder
  #
  # Run in a loop to check for next possible source dir in Targetdir.
  # Returns 0 on success and 1 if nothing more is to do.
  #
  # Stores already checked source dirs of $Targetdir in $Sourcedirchecklist. 
  # -> Set Sourcedirchecklist="" before running a loop with setup_workdir().
  # Use local in calling function:
  #   local Sourcedir Sourcefileglob Destinationdir Destinationfile Targetptofile Targetcachedir Sourcedirchecklist

  local Targetstackshotdir Targetnewdir Targetprevdir 
  local Targetmagickdir Targetfusedir Targetevaluatedir Targetcomposedir Targetcachedir
  local Projectname

  Function="${1:-}"
  Targetdir="${2:-}"
  Sourcefileglob="${3:-*}"
  
  Function="${Function%magick}"
  Destinationdir=""
  Destinationfile=""

  Targetdir="$(realpath "$Targetdir")"
  [ -d "$Targetdir" ] || {
    failure "No target directory found. Please specify a target directory or make a stackshot.
  Wrong Target: $Targetdir"
    return 1
  }
  Projectname="$(storeinfo dump projectname)"
  
  [ -d "$Targetdir/stackshot" ]          && Targetstackshotdir="$Targetdir/stackshot" || Targetstackshotdir="$Targetdir"
  [ -d "$Targetdir/stackshot-median" ]   && Targetstackshotdir="$Targetdir/stackshot-median"
  Targetmagickdir="$Targetdir/magick"
  Targetfusedir="$Targetdir/fuse"
  Targetcomposedir="$Targetdir/compose"
  Targetevaluatedir="$Targetdir/evaluate"
  Targetvideodir="$Targetdir/video"
  
  Targetcachedir="$Targetdir/cache"
  myrmdir     "$Targetcachedir"
  mkdir -p "$Targetcachedir"
  Cachedir="$Targetcachedir"
  
  grep -q -- "fuse" <<< "$Function"      && Targetnewdir="$Targetfusedir"
  grep -q -- "compose" <<< "$Function"   && Targetnewdir="$Targetcomposedir"
  grep -q -- "evaluate" <<< "$Function"  && Targetnewdir="$Targetevaluatedir" 
  grep -q -- "animation" <<< "$Function" && Targetnewdir="$Targetvideodir" 
  grep -q -- "video" <<< "$Function"     && Targetnewdir="$Targetvideodir" 
  [ "$Targetnewdir" ] || Targetnewdir="$Targetmagickdir"
  
  [ "$Targetnewdir" = "$Targetmagickdir" ] && {
    mkdir -p $Targetnewdir
    check_fileglob "$Targetmagickdir/$Sourcefileglob" || mycp "$Targetstackshotdir/$Sourcefileglob" "$Targetmagickdir"
  }
  
  Targetprevdir="$Targetnewdir.bak"

  # backup for undo, serving also as source for batch operations
  case $Function in
    undo*) ;;
    evaluate*|animation*|video*|fuse*)
      mkdir -p $Targetprevdir
      check_fileglob "$Targetnewdir/*" && mycp "$Targetnewdir/*" "$Targetprevdir/" 
    ;;
    *)
      mkdir -p $Targetprevdir
      myrm "$Targetprevdir/*"
      check_fileglob "$Targetnewdir/*" && mymv "$Targetnewdir/*" "$Targetprevdir/"
    ;;
  esac

  case $Function in
    fuse)
      Sourcedir="$Targetmagickdir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir")"
    ;;
      
    evaluate)
      Sourcedir="$Targetmagickdir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir").$(basename "$Sourcedir")"
    ;;
    evaluatefuse)
      Sourcedir="$Targetfusedir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir").$(basename "$Sourcedir")"
    ;;
    compose)
      Sourcedir="$Targetevaluatedir"
      Destinationdir="$Targetnewdir"
      #Destinationfile="$Projectname.$(basename "$Targetdir").$(basename "$Sourcedir")"
    ;;
    
    align*|brightness*|cuberotate*|sharpen*|level*|contrast*|crop*|gamma*|stretch*|kuwahara*|prepare*|ruler*|wizard*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
      
    whitebalance*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
    
    animation|video)
      Sourcedir="$Targetmagickdir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir")"
    ;;
    
    undo*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
    
    *)
      failure "setup_workdir(): Function not defined: $Function"
      return 1
  esac
  
  [ "$Sourcedir" = "$Targetmagickdir" ] && {
    mkdir -p $Targetmagickdir
    check_fileglob "$Targetmagickdir/$Sourcefileglob" || mycp "$Targetstackshotdir/$Sourcefileglob" "$Targetmagickdir"
  }
  check_fileglob "$Sourcedir/$Sourcefileglob" || {
    failure "setup_workdir(): No source found: $Sourcedir/$Sourcefileglob"
    return 1
  }
  
  [ "$Destinationdir" ] || {
    failure "setup_workdir(): Destinationdir not specified"
    return 1
  }
  mkdir -p "$Destinationdir"
  
  return 0
}

#### show images

showimage() {
  local Imagelist Image Shrinkimage
  Imagelist="$(fileglob "${1:-}")" >&2
  case $(grep -c . <<< "$Imagelist") in
    0) 
      failure "showimage: Not found: ${1:-}"
      Image="$(storeinfo dump notfoundimage)"
      [ -e "$Image" ] || convert -size 300x200 xc:red -fill black -pointsize 20 -gravity center -draw "text 0,0 'image not found'" "$Image"
      geeqie -t -r File:"$Image"
      #sendkaptain "showimage('')=''" 
      #sendkaptain "showimagename=''"
      storeinfo drop showimage
      return 1
    ;;
    1) 
      Image="$Imagelist"
      #Shrinkimage="$Wizardcache/showimage.png"
      #convert "$Image" -scale 800x800\> "$Shrinkimage" 
      #sendkaptain "showimage('$Shrinkimage')=''" 
      #sendkaptain "showimagename='$(shortpath "$Image")'"
      case "$(rev <<< "$Image" | cut -d. -f1 | rev)" in
        gif|mp4|webm) 
          showvideo "$Image" 
        ;;
        *)       
          geeqie -t -r File:"$Image" 
          storeinfo   "showimage=$Image"
        ;;
      esac
    ;;
#    1) geeqie -t -r File:"$Imagelist" ;;
    *) viewnior           $Imagelist & ;;
  esac
  return 0
}

showvideo() {
  ffplay -window_title "$(basename "${1:-}")" -loglevel error -loop 0 "${1:-}" & storepid $!
}

#### image batch processing

batch_function() {
  # Apply image processing function $1 on all possible source dirs in target directory $2, options in $3

  local $Batchlocal
  local Sourcedirchecklist Return=0
  local Gallerydir

  parse_batchoptions "$@"                  || return 1
  storeinfo test stackshotdir_valid        || {
    failure "batch_function(): Invalid directory: $(storeinfo dump stackshotdir)"  
    return 1
  }

  checkvar -d batch Targetdir "$Targetdir" || return 1
  checkvar    batch Function  "$Function"  || return 1
  
  ifcmdbreak && return 1
  
  setup_workdir "$Function" "$Targetdir" "$Sourcefileglob" || {
    failure "batch $Function: no source found in $Targetdir
    $@"
    return 1
  }
  cd "$Targetdir"
  
  case $Function in
    compose|fuse|evaluate) ;;
    *)
      Function="${Function%magick}"
      Function="${Function%compose}"
      Function="${Function%evaluate}"
      Function="${Function%fuse}"
    ;;
  esac
  Function="${Function%_}"
  
  case "$Function" in
    brightness|contrast|gamma|kuwahara|level|prepare|sharpen|stretch|wizard)
      Functionmode="$Function"
      Function="wizard"
    ;;
  esac
  
  checkvar           -D "$Function" Sourcedir      "$Sourcedir"        || return 1
  checkvar           -d "$Function" Destinationdir "$Destinationdir"   || return 1
  case $Function in
    undo|compose) ;;
    *) checkvar         $Function Sourcefileglob "$Sourcefileglob"   || return 1 ;;
  esac
  case $Function in
    wizard) checkvar    $Function Functionmode   "$Functionmode"     || return 1 ;;
  esac
  case $Function in
    align*|crop|undo|whitebalance)
      checkvar       -d $Function Cachedir       "$Cachedir"         || return 1 ;;
  esac
  
  [ -z "$Functionmode" ] && case "$Function" in
    compose|evaluate|fuse) Functionmode="all" ;;
  esac
  
  note "$Function $Functionmode $Functionoption"
  storeinfo "cmd=$@"
  storeinfo "cmd_source=$Sourcedir"
  storeinfo "cmd_destination=$Destinationdir"
  storeinfo "cmd_cache=$Cachedir"
  cd "$Cachedir"
  verbose "batch_function(): $Function -m '$Functionmode' -o '$Functionoption' -s '$Sourcedir' -g '$Sourcefileglob' -d '$Destinationdir' -b '$Destinationfile' -c '$Cachedir'"
  $Function -m "$Functionmode" -o "$Functionoption" -s "$Sourcedir" -g "$Sourcefileglob" -d "$Destinationdir" -b "$Destinationfile" -c "$Cachedir"
  Return=$?
  cd "$Targetdir"
  storeinfo drop cmd
  storeinfo drop cmd_source
  storeinfo drop cmd_destination
  storeinfo drop cmd_cache
  
  [ "$Return" = "0" ] && {
    note "Ready: $Function $Functionmode $Functionoption"
  } || {
    failure "ERROR in $Function $Functionmode $Functionoption: $(basename "$Sourcedir") -> $(basename "$Destinationdir")"
    case $Function in
      animation) ;;
      compose|evaluate|fuse) undo -s "$Destinationdir.bak" -d "$Destinationdir" -c "$Cachedir" ;;
      *)                     undo -s "$Sourcedir"          -d "$Destinationdir" -c "$Cachedir" ;;
    esac
  }
  
  storeinfo test rmcache && rm -R "$Cachedir"
  
  [ "$Return" = "0" ] && [ "$(basename "$Destinationdir")" = "evaluate" ] && {
    storeinfo "refreshgui_selector=yes"
    ls $Destinationdir/*fuse.median* >/dev/null 2>&1 && {
      [ -d "$Destinationdir/../stackshot" ] && {
        # link fuse.median result into parent directory
        ln -f $(fileglob "$Destinationdir/*fuse.median*") "$Destinationdir/../"
        # link into project dir
        ln -f $(fileglob "$Destinationdir/*fuse.median*") "$Destinationdir/../../"
      }
      # link fuse.median result into $Gallerydir directory
      Gallerydir="$(storeinfo dump gallerydir)"
      [ -d "$Gallerydir" ] && ln -f $(fileglob "$Destinationdir/*fuse.median*") "$Gallerydir"
    }
  }
  verbose "batch_function: $Function: return $Return"
  [ "$Return" = "0" ] && [ "$(basename "$Destinationdir")" = "fuse" ] && storeinfo "refreshgui_fuse=yes"

  return $Return
}

parse_batchoptions() {
  # To be called by batch functions to parse options.
  # Include this local line in the calling function:
  #   local Targetdir Sourcedir Sourcefileglob Destinationdir Destinationfile Cachedir Function Functionmode Functionoption

  local Shortoptions Longoptions Parsedoptions
  Shortoptions="b:c:d:f:g:m:o:s:t:"
  Longoptions=""

  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@" )"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ] ; do
    case "${1:-}" in
      -t) Targetdir="${2:-}" ;;
      -s) Sourcedir="${2:-}" ;;
      -g) Sourcefileglob="${2:-}" ;;
      -d) Destinationdir="${2:-}" ;;
      -b) Destinationfile="${2:-}" ;;
      -c) Cachedir="${2:-}" ;;
      -f) Function="${2:-}" ;;
      -m) Functionmode="${2:-}" ;;
      -o) Functionoption="${2:-}" ;;
      --) ;;
      *) 
        failure "Unbekannte Option ${1:-} ($Function)" 
        return 1
      ;;
    esac
    shift
    shift
  done

  [ "$Sourcefileglob" ] || Sourcefileglob="*"
  #[ ! -d "$Sourcedir" ]      && failure "$Function: source dir not found: $Sourcedir" && return 1
  #[ ! -d "$Destinationdir" ] && failure "$Function: destination dir not found: $Destinationdir"&& return 1
  #! check_fileglob "$Sourcedir/$Sourcefileglob" && failure "$Function: No source files found: $Sourcedir/$Sourcefileglob"  && return 1
  return 0
}

getbatch1() {
  local Command= Line Argument
  for Line in contrast sharpen kuwahara brightness gamma level stretch wizard; do
    Argument="$(askkaptain "$Line")"
    case $Line in
      brightness) Line="-brightness-contrast" ;;
      contrast)   Line="-sigmoidal-contrast" ;;
      sharpen)    Line="-adaptive-sharpen" ;;
      stretch)    Line="-contrast-stretch" ;;
      wizard)     Line="" ;;
      *)          Line="-$Line" ;;
    esac
    case $Argument in
      "") ;;
      auto) Command="$Command -auto$Line" ;;
      *)    Command="$Command $Line $Argument" ;;
    esac
  done
  echo "$Command"
}

getfunctionsettings() {
  Functionmode="$(askkaptain -c ${Function}modecombo)"
  Functionoption="$(askkaptain -c ${Function}combo)"
}

runbatch1() {
  local Function Functionmode Functionoption Stackdir
  Stackdir="${1:-}"
  askkaptain crop > /dev/null && {
    Function="crop"
    getfunctionsettings
    cmd -f "$Function" -m "$Functionmode" -o "$Functionoption" -t "$Stackdir"
  }
  cmd -f wizard -o "$(getbatch1)" -t "$Stackdir"
}

runbatch2() {
  local Function Functionmode Functionoption
  local Iterate
  for Function in whitebalance align_vidstab gamma_ ; do
    askkaptain -c $Function > /dev/null && {
      getfunctionsettings
      case $Function in
        align_vidstab)
          cmd -f "$Function" -m "10"            -o "$Functionoption" -t "$Stackdir"
          cmd -f "$Function" -m "5"             -o ""                -t "$Stackdir"
          cmd -f "$Function" -m "1"             -o ""                -t "$Stackdir"
        ;;
        *)
          cmd -f "$Function" -m "$Functionmode" -o "$Functionoption" -t "$Stackdir"
        ;;
      esac
    }
  done
  return 0
}

runbatch3() {
  askkaptain evaluate1 >/dev/null        && cmd -f evaluate -m all -t "$Stackdir"
  askkaptain fuse >/dev/null             && cmd -f fuse -m $(askkaptain fusemodecombo) -t "$Stackdir"
  askkaptain evaluate2 >/dev/null &&  {
    Functionoption=$(askkaptain evaluatecombo)
    cmd -f evaluatefuse -m all -t "$Stackdir" -g "$(fuse_glob $Functionoption)"
  }
  askkaptain sharpen_evaluate >/dev/null && cmd -f sharpenevaluate -o 3x1 -t "$Stackdir"
  askkaptain compose >/dev/null          && cmd -f compose -t "$Stackdir"
  
  cmd -f showimage -s "$Stackdir/evaluate" -g "*fuse.median*"
}

setup_imagelist() {
  # Set up often needed image variables
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagenumber="$(grep -c . <<< "$Imagelist")"
  Imagewidth=$($Convert  -format '%w'  "$(head -n1 <<< "$Imagelist")" info:)
  Imageheight=$($Convert -format '%h'  "$(head -n1 <<< "$Imagelist")" info:)
  Imagecount=0
  Image=""
  Cropgeometry=""
  [ -n "$Imagelist" ] && return 0 || {
    failure "No images found"
    return 1
  }
}

#### image sequence operations

align_vidstab() {
  # Align images with ffmpeg/vidstab
  # -m  Shakiness 1-10 (low to high)
  # -o  crop interactive yes/""
  
  local $Batchlocal
  local $Imagelocal
  local Sourcefilelist Sourcefile
  local CropW CropH CropX CropY Cropgeometry Zoom
  local Cropinteractive Shakiness Stepsize
  local Xoffset Xoffsetrelative Xoffsetlist Yoffset Yoffsetrelative Yoffsetlist Radians Radiansrelative Radianslist Degree 
  local Framedir Motionsfile Distortdir Cropminimage 

  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  cd $Cachedir
  
  # settings
  Shakiness="$Functionmode"
  Shakiness="${Shakiness:-1}"
  Cropinteractive="$Functionoption"
  [ "$Cropinteractive" ] && Cropinteractive="yes"
  Stepsize=6
  
  # cache setup
  Framedir="$Cachedir/frames"
  mkdir -p "$Framedir"
  Distortdir="$Cachedir/distort"
  mkdir -p "$Distortdir"
  
  Sourcefilelist=$Cachedir/align.source.list
  :> $Sourcefilelist
  Motionsfile="$Cachedir/global_motions.trf"
  
  # ffmpeg needs even image size
  crop -m even -s "$Sourcedir" -g "$Sourcefileglob" -d "$Framedir"

  # Set up ffmpeg input images list
  Imagelist="$(fileglob "$Framedir/$Sourcefileglob")"
  :> $Sourcefilelist
  for Image in $Imagelist; do
    echo "file $Image" >>$Sourcefilelist
  done

  # Workaround to get video of png images. vidstab fails with videos generated from gphoto2 jpg for unknown reasons.
  worknote "align_vidstab: generating 1. video from images"
  ffmpeg -y -hide_banner -nostdin -safe "0" -f "concat" -i "$Sourcefilelist" \
         -vcodec "libx264" -profile:v "high444" -refs "16" -crf "0" -preset "ultrafast" \
         "$Cachedir/align.orig.mp4" || return 1
  ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.orig.mp4"
  showpercent 1 100
  ifcmdbreak && return 1
  
  worknote "align_vidstab: Splitting generated 1. video into .png images"
  myrm "$Framedir/*"
  ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.orig.mp4" "$Framedir/sourceimg%04d.png" || return 1
  showpercent 2 100
  ifcmdbreak && return 1

  # Set up ffmpeg input images list with generated png images
  :> $Sourcefilelist
  Imagelist="$(fileglob "$Framedir/*")"
  for Image in $Imagelist; do
    echo "file $Image" >>$Sourcefilelist
  done
  
  worknote "align_vidstab: generating 2. video from .png images"
  ffmpeg -y -hide_banner -nostdin -f image2 -start_number 1 -i $Framedir/sourceimg%04d.png -safe "0" -vframes 1000 -vcodec libx264 -crf 25  -pix_fmt yuv420p "$Cachedir/align.source.mp4" || return 1
  showpercent 3 100
  ifcmdbreak && return 1

  worknote "align_vidstab: Analyzing video with shakiness=$Shakiness"
  ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.source.mp4" \
         -vf "vidstabdetect=shakiness=$Shakiness:accuracy=15:mincontrast=0.1:stepsize=$Stepsize:show=1:result=$Cachedir/transforms$Shakiness.trf" \
         "$Cachedir/align.vidstab-show.mp4" || return 1
  ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.vidstab-show.mp4"
  showpercent 4 100
  ifcmdbreak && return 1
            
  worknote "align_vidstab: Transforming video with shakiness=$Shakiness"
  ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.source.mp4" \
         -vf "vidstabtransform=optzoom=0:smoothing=0:interpol=bicubic:relative=1:crop=black:debug=1:input=$Cachedir/transforms$Shakiness.trf,unsharp=5:5:0.8:3:3:0.4" \
         "$Cachedir/align.result.mp4" || return 1
  ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.result.mp4"
  showpercent 5 100
  ifcmdbreak && return 1

  worknote "align_vidstab: Splitting aligned video into images (shakiness=$Shakiness)"
  myrm $Framedir/*
  ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.result.mp4" "$Framedir/alignimg%04d.tif" || return 1
  showpercent 6 100
  ifcmdbreak && return 1
      
  Imagelist="$(fileglob "$Framedir/*")"
  Image="$(head -n1 <<< "$Imagelist")"
  Imagewidth=$(convert  -format '%w'  $Image info:)
  Imageheight=$(convert -format '%h'  $Image info:)
      

  Xoffsetlist="$(cat $Motionsfile | grep -v '#' | awk '{print $2}')"
  Yoffsetlist="$(cat $Motionsfile | grep -v '#' | awk '{print $3}')"
  Radianslist="$(cat $Motionsfile | grep -v '#' | awk '{print $4}')"
  
      
  worknote "align_vidstab: Cutting of black border (shakiness=$Shakiness)"
  Imagecount=0
  for Image in $Imagelist; do
    Imagecount="$((Imagecount + 1))"
    Xoffsetrelative="$(sed "${Imagecount}q;d" <<<"$Xoffsetlist")"
    Xoffset="$(awk "BEGIN { print $Xoffset + $Xoffsetrelative }")"
    Yoffsetrelative="$(sed "${Imagecount}q;d" <<<"$Yoffsetlist")"
    Yoffset="$(awk "BEGIN { print $Yoffset + $Yoffsetrelative }")"
    Radiansrelative="$(sed "${Imagecount}q;d" <<<"$Radianslist")"
    Radians="$(awk "BEGIN { print $Radians - $Radiansrelative }")"
    Degree="$(awk  "BEGIN { print $Radians * 180 / 3.141592652}")"
        
    Destinationfile="$Distortdir/distorted$Imagecount.png"
    multicore "$Convert -size ${Imagewidth}x${Imageheight} xc:transparent -fill white -stroke white \
               -draw 'translate $((Imagewidth/2)),$((Imageheight/2)) \
                      rotate $Degree \
                      polygon $(awk "BEGIN {print -$Imagewidth/2  +$Xoffset}"),$(awk "BEGIN {print -$Imageheight/2 +$Yoffset}") \
                              $(awk "BEGIN {print +$Imagewidth/2  +$Xoffset}"),$(awk "BEGIN {print -$Imageheight/2 +$Yoffset}") \
                              $(awk "BEGIN {print +$Imagewidth/2  +$Xoffset}"),$(awk "BEGIN {print +$Imageheight/2 +$Yoffset}") \
                              $(awk "BEGIN {print -$Imagewidth/2  +$Xoffset}"),$(awk "BEGIN {print +$Imageheight/2 +$Yoffset}") \
                              $(awk "BEGIN {print -$Imagewidth/2  +$Xoffset}"),$(awk "BEGIN {print -$Imageheight/2 +$Yoffset}") '\
               $Image -evaluate-sequence min $Destinationfile" "$Destinationfile" || return 1
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
      
  # crop greatest common inner rectangle of distorted images
  Cropminimage="$Cachedir/distorted.min.mpc"
  convert $(fileglob "$Distortdir/*") -evaluate-sequence min "$Cropminimage" || return 1
  case $Cropinteractive in
    yes) notify-send "align_vidstab(): Ready for interactive crop"
         Cropgeometry="$(cropgeometry_interactive "$Cropminimage" "$Cachedir")" || return 1 ;;
    *)   Cropgeometry="$(trim_hard "$Cropminimage" "$Cropgeometry")" || return 1 ;;
  esac
  
  Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
  Rotate="${Rotate:-0}"
  Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
  Cropgeometry="$(calc_evengeometry "$Cropgeometry")"
      
  [ "$Cropgeometry" ] || {
    failure "align_vidstab: crop geometry is empty"
    return 1
  }
      
  worknote "align_vidstab: Cropping aligned images to $Cropgeometry (shakiness=$Shakiness)"
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagecount=0
  for Image in $(fileglob "$Distortdir/*"); do
    Imagecount="$((Imagecount+1))"
    Destinationfile="$(sed "${Imagecount}q;d" <<< "$Imagelist")"
    Destinationfile="$Destinationdir/$(basename "$Destinationfile")"
    multicore "$Convert $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || return 1
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
            
  showimage "$Cropminimage.trim_hard.png"
  return 0    
}

animation() {
  # Generate animated GIF from stackshot.
  # Helps to visualize diferent layers and gives some 3D effect
  #
  # -m  Rendermode:Fusemode
  # -o  Distortion
  #
  # Rendermode     quick or smooth
  # Distortion     Distortion between lowest and highest layer.
  # Fusemode       See fuse()
  # Framerate      Framerate between frames
  # Staticlayer    Relative position of static layer that won't move. 0 means lowest layer, 1/2 means middle layer, 1 means top layer
  # Format         File format
  
  local $Batchlocal
  local $Imagelocal
  local Fusemode Distortion Framerate Sequence Staticlayer Format Appendfirstframe
  local Distortdir Distortimage Fusedir Mpcdir Destinationfilebasename Imagebasename
  local Xpos Ypos Offset Border
  local Count Iteration=0 Iterationnumber
  local Imagelistfile
  local Position Positionlist Positionnumber
  local Sequence Sequencename Sequencenumber
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  # settings
  Rendermode="$(cut -d: -f1  <<<"$Functionmode")"
  Fusemode="$(cut -s -d: -f2 <<<"$Functionmode")"
  Rendermode="${Rendermode:-quick}"
  Fusemode="${Fusemode:-4}"
  Distortion="${Functionoption:-25}"
  Staticlayer="1/4"
  Format="webm"
  Appendfirstframe="no"
  Destinationfilebasename="${Destinationfile:-animation}"
  
  # cache setup
  Mpcdir=$Cachedir/mpc
  mkdir -p "$Mpcdir"
  
  # Position raster
  #
  # -5x-5 -5x-4 -5x-3 -5x-2 -5x-1  -5x0   -5x1  -5x2  -5x3  -5x4  -5x5
  #
  # -4x-5 -4x-4 -4x-3 -4x-2 -4x-1  -4x0   -4x1  -4x2  -4x3  -4x4  -4x5
  #
  # -3x-5 -3x-4 -3x-3 -3x-2 -3x-1  -3x0   -3x1  -3x2  -3x3  -3x4  -3x5
  #
  # -2x-5 -2x-4 -2x-3 -2x-2 -2x-1  -2x0   -2x1  -2x2  -2x3  -2x4  -2x5
  #
  # -1x-5 -1x-4 -1x-3 -1x-2 -1x-1  -1x0   -1x1  -1x2  -1x3  -1x4  -1x5
  #
  #  0x-5  0x-4  0x-3  0x-2  0x-1   0x0    0x1   0x2   0x3   0x4   0x5
  #
  #  1x-5  1x-4  1x-3  1x-2  1x-1   1x0    1x1   1x2   1x3   1x4   1x5
  #
  #  2x-5  2x-4  2x-3  2x-2  2x-1   2x0    2x1   2x2   2x3   2x4   2x5
  #
  #  3x-5  3x-4  3x-3  3x-2  3x-1   3x0    3x1   3x2   3x3   3x4   3x5
  #
  #  4x-5  4x-4  4x-3  4x-2  4x-1   4x0    4x1   4x2   4x3   4x4   4x5
  #
  #  5x-5  5x-4  5x-3  5x-2  5x-1   5x0    5x1   5x2   5x3   5x4   5x5

  case $Rendermode in
    smooth)
      Raster="3"
      Framerate="8"
      Sequencenumber="3"
                   
      Sequencename[1]="dagaz"
      Sequence[1]="0x0  -1x1 -2x2 -3x3
                  -2x3  -1x3  0x3  1x3   2x3   3x3
                   2x2   1x1  0x0 -1x-1 -2x-2 -3x-3
                  -2x-3 -1x-3 0x-3 1x-3  2x-3  3x-3
                   2x-2  1x-1"
            
      Sequencename[2]="circle_left"
      Sequence[2]="-3x0 -3x1  -2x2  -1x3  0x3  1x3  2x2  3x1  3x0 3x-1 2x-2 1x-3 0x-3 -1x-3 -2x-2 -3x-1"
            
      Sequencename[3]="circle_right"
      Sequence[3]="-3x0 -3x-1 -2x-2 -1x-3 0x-3 1x-3 2x-2 3x-1 3x0 3x1  2x2  1x3  0x3  -1x3  -2x2  -3x1"
      
      #disabled
      Sequencename[4]="eight_small"
      Sequence[4]="0x0  -1x0  -1x-1  0x-1  1x-1  1x0
                   0x0  -1x0  -1x1   0x1   1x1   1x0"
      
      Sequencename[5]="eight"
      Sequence[5]="0x0  -1x0  -2x0  -3x-1  -3x-2  -2x-3  -1x-3  0x-3  1x-3  2x-3  3x-2  3x-1  2x0  1x0
                   0x0  -1x0  -2x0  -3x1   -3x2   -2x3   -1x3   0x3   1x3   2x3   3x2   3x1   2x0  1x0"
            
      Sequencename[6]="knot"
      Sequence[6]="0x0 -1x0 -2x0 -3x-1 -3x-2 -2x-3 -1x-3 0x-2 0x-1
                   0x0  0x1  0x2  1x3   2x3   3x2   3x1  2x0  1x0
                   0x0 -1x0 -2x0 -3x1  -3x2  -2x3  -1x3  0x2  0x1
                   0x0  0x-1 0x-2 1x-3  2x-3  3x-2  3x-1 2x0  1x0"
  
      Sequencename[7]="knot_small"
      Sequence[7]="0x0  0x-1 -1x-1 -1x0  
                   0x0  1x0   1x1   0x1
                   0x0  0x-1  1x-1  1x0
                   0x0 -1x0  -1x1   0x1"
    ;;
    quick)
      Raster="1"
      Framerate="4"
      Sequencenumber="3"

      Sequencename[1]="eight_quick"
      Sequence[1]="0x0  -1x0  -1x-1  0x-1  1x-1  1x0
                   0x0  -1x0  -1x1   0x1   1x1   1x0"
                   
      Sequencename[2]="dagaz_quick"
      Sequence[2]="0x0  -1x-1 -1x0 -1x1 0x0 1x-1 1x0 1x1"
      
      Sequencename[3]="square_quick"
      Sequence[3]="-1x-1  -1x0  -1x1  0x1  1x1  1x0  1x-1  0x-1"
      
      #disabled
      Sequencename[4]="knot_quick"
      Sequence[4]="0x0  0x-1 -1x-1 -1x0  
                   0x0  1x0   1x1   0x1
                   0x0  0x-1  1x-1  1x0
                   0x0 -1x0  -1x1   0x1"
    ;;
  esac
    
  # convert to mpc for faster access
  worknote "animation: Converting images to mpc format"
  showpercent 1 100
  for Image in $Imagelist; do
    multicore "convert $Image $Mpcdir/$(basename $Image).mpc" || return 1
  done
  multicore_wait || return 1

  # Revert image list to work from bottom to top
  Imagelist="$(fileglob "$Mpcdir/*.mpc")"
  Imagelist="$(sort -V -r <<< "$Imagelist")"
  
  # calculate lost borders
  Border="$((Distortion - Distortion * $Staticlayer))"  # wrong result if Staticlayer>1/2 ?
  Cropgeometry="$((Imagewidth - Border * 2 - 1))x$((Imageheight - Border * 2 - 1))"
  
  # offset factor, distortion between neighboured layers
  Offset="$(awk "BEGIN {print $Distortion / ( $Imagenumber * $Raster ) }")"
  
  # get list of needed positions
  for Sequencecount in $(seq $Sequencenumber); do
    for Position in ${Sequence[$Sequencecount]}; do
      Positionlist="$Positionlist
$Position"
    done
  done
  Positionlist="$(grep x <<< "$Positionlist")"
  Positionlist="$(sort <<< "$Positionlist" | uniq)"
  Positionnumber="$(grep -c . <<< "$Positionlist")"
  
  Iterationnumber=$((Positionnumber*3 + Sequencenumber))
    
  # Distort images
  for Position in $Positionlist; do
    Xpos="$(cut -dx -f1 <<< "$Position")"
    Ypos="$(cut -dx -f2 <<< "$Position")"
    worknote "animation: Distorting images for position ${Xpos}x${Ypos}."
    Distortdir="$Cachedir/distort.$Position"
    [ -d "$Distortdir" ] || {
      mkdir -p "$Distortdir"
      
      Count=-$((Imagenumber * $Staticlayer))  # negative start value causes movement of lowest layer
      
      for Image in $Imagelist; do
        Count="$((Count +1))"
        Distortimage="$Distortdir/$(basename $Image)"
        Distortimage="${Distortimage%.mpc}"
        multicore "convert $Image -gravity center -crop $Cropgeometry+$(awk "BEGIN {print $Count * $Xpos * $Offset}")+$(awk "BEGIN {print $Count * $Ypos * $Offset}") $Distortimage" "$Distortimage" || return 1
      done

      Iteration=$((Iteration + 1))
      showpercent $Iteration $Iterationnumber
    }
  done
  multicore_wait || return 1

  # fuse distorted images
  Showpercentfunc="$(declare -f showpercent)"
  for Position in $Positionlist; do
    Iteration=$((Iteration + 1))
    Distortdir="$Cachedir/distort.$Position"
    Distortcachedir="$Cachedir/distort.$Position/layered"
    mkdir -p $Distortcachedir
    Fusedir="$Distortdir/fuse"
    mkdir -p "$Fusedir"
    Imagebasename="animation.$Position"
    case $Fusemode in
      all|set*) ( showpercent() { : ; } ; fuse -s $Distortdir -g '*' -d $Fusedir -b $Imagebasename -m $Fusemode -c $Distortcachedir ) || return 1 ;; 
      *)                       multicore "fuse -s $Distortdir -g '*' -d $Fusedir -b $Imagebasename -m $Fusemode -c $Distortcachedir"  || return 1 ;;
    esac
    showpercent $Iteration $Iterationnumber
  done
  multicore_wait || return 1

  # Calculate median of fuse images
  for Position in $Positionlist; do
    Iteration=$((Iteration + 1))
    Distortdir="$Cachedir/distort.$Position"
    Fusedir="$Distortdir/fuse"
    Destinationfile="$Cachedir/animation.$Position.median.jpg"
    worknote "animation: Generating $(basename $Destinationfile)"
    #multicore "convert $Fusedir/* -evaluate-sequence median -gravity center -stroke black -fill black -pointsize 24 -draw 'text 0,0 \"$Position\"' $Destinationfile" "$Destinationfile" || return 1
    multicore "convert $Fusedir/* -evaluate-sequence median $Destinationfile" "$Destinationfile" || return 1
    showpercent $Iteration $Iterationnumber
  done
  multicore_wait || return 1

  # Generate videos
  for Count in $(seq $Sequencenumber); do
    Iteration=$((Iteration + 1))
    Imagelistfile="$Cachedir/imagelist.${Sequencename[$Count]}"
    :> $Imagelistfile
    [ "$Appendfirstframe" = "yes" ] && Sequence[$Count]="${Sequence[$Count]} $(cut -d' ' -f1 <<< "${Sequence[$Count]}")"
    
    for Position in ${Sequence[$Count]}; do
      Image="$(fileglob "$Cachedir/*.$Position.median.*")"
      echo "file '$Image'" >> "$Imagelistfile"
    done
    Destinationfile="$Destinationdir/$Destinationfilebasename.${Sequencename[$Count]}.$(fuse_getname $Fusemode shortcut).$Distortion.$Format"

    worknote "animation: Generating $(basename $Destinationfile)."
    multicore "ffmpeg -y -safe 0 -r $Framerate -f concat -i $Imagelistfile -c:v libvpx-vp9 -crf 30 -b:v 0 $Destinationfile" "$Destinationfile"  || return 1
    
    showpercent $Iteration $Iterationnumber
  done
  multicore_wait || return 1
}

calc_autogamma() {
  # calculate -auto-gamma value for sequence of images
  # based on https://stackoverflow.com/questions/24396024/in-imagemagick-is-it-possible-to-auto-gamma-based-on-a-region
  # -s
  # -g
  # -c
  
  local $Batchlocal
  local Meanimage Mean Quantumrange Gamma
  
  parse_batchoptions "$@" || return 1
  
  Meanimage="$Cachedir/autogamma.mean"
  
  worknote "calc_autogamma: Generating mean image"
  convert $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence mean "$Meanimage" || return 1
  showimage "$Meanimage"
  
  Mean="$(convert         "$Meanimage" -format "%[mean]"            info:)"
  Quantumrange="$(convert "$Meanimage" -format "%[fx:quantumrange]" info:)"
  
  # calculate gamma
  Gamma="$(awk "BEGIN{print log($Mean/$Quantumrange)/log(0.5)}")"
  verbose "calc_autogamma: Calculated gamma: $Gamma"
  
  echo "$Gamma"
}

compose() {
  local $Batchlocal
  local Evalmaxfile Evalminfile Minfile Maxfile 
  local Destinationfilebasename
  local i Count
  
  parse_batchoptions "$@" || return 1
  
  Evalmaxfile[0]="$(fileglob "$Sourcedir/*magick.max*")"
  Evalminfile[0]="$(fileglob "$Sourcedir/*magick.min*")"
  Evalmaxfile[1]="$(fileglob "$Sourcedir/*fuse.max*")"
  Evalminfile[1]="$(fileglob "$Sourcedir/*fuse.min*")"
  
  [ -z "${Evalmaxfile[0]}${Evalmaxfile[1]}" ] && {
    failure "compose: No source found. Please run evaluate first."
    return 1
  }

  Count=0
  for i in 0 1 ; do
    Maxfile="${Evalmaxfile[$i]}"
    Minfile="${Evalminfile[$i]}"
    [ -z "$Maxfile" ] && break
    Destinationfilebasename="$(sed 's/.max.*//' <<< "$Maxfile")"
    Destinationfilebasename="$(basename "$Destinationfilebasename")"
    
    for Functionmode in bumpmap colorburn difference linearburn linearlight modulate multiply overlay pegtoplight; do
      Count="$((Count + 1))"
      
      ifcmdbreak && return 1
    
      Destinationfile="$Destinationdir/$Destinationfilebasename.${Functionmode}1.jpg"
      $Convert "$Minfile" "$Maxfile" -compose "$Functionmode" -composite "$Destinationfile"
      worknote "compose $Functionmode: $Destinationfile"
      showimage "$Destinationfile"
  
      case $Functionmode in
        linearburn|multiply) ;;  # skip second compose for modes with identical result
        difference)
          $Convert "$Destinationfile" -negate "$Destinationdir/$Destinationfilebasename.${Functionmode}1-negate.jpg"
          showimage "$Destinationdir/$Destinationfilebasename.${Functionmode}1-negate.jpg"
        ;;
        *)
          Destinationfile="$Destinationdir/$Destinationfilebasename.${Functionmode}2.jpg"
          $Convert "$Maxfile" "$Minfile" -compose "$Functionmode" -composite "$Destinationfile"
          echo "$Destinationfile"
          showimage "$Destinationfile"
        ;;
      esac
      
      showpercent "$Count" "18"
    done
  done
  return 0
}

crop() {
  # crop area of image sequence
  # -m  even|shrink|geometry|interactive
  # -o   -  |pixel |geometry|geometry
  local $Batchlocal
  local $Imagelocal
  local Newwidth Newheight Shrink
  local Rotate Rotatedir
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1

  # cache setup
  Rotatedir="$Cachedir/rotate"
  mkdir -p $Rotatedir
  
  case $Functionmode in
    even)
      Newwidth=$((Imagewidth/2))
      Newwidth=$((Newwidth*2))
      Newheight=$((Imageheight/2))
      Newheight=$((Newheight*2))
      Cropgeometry="${Newwidth}x${Newheight}+0+0"
    ;;
    shrink) 
      Shrink="$Functionoption"
      Cropgeometry="$((Imagewidth - $((Shrink * 2))))x$((Imageheight - $((Shrink * 2))))+$Shrink+$Shrink"
    ;;
    geometry)
      Cropgeometry="$Functionoption"
    ;;
    interactive) 
#      Image="$Cachedir/crop.min.jpg"
      Image="$Cachedir/crop.min.mpc"
      showpercent 1 100
      worknote "crop $Functionmode: Generating min image"
      convert $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence min "$Image"
      Cropgeometry="$(cropgeometry_interactive "$Image" "$Cachedir" "$Functionoption")"
      Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
      Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
    ;;
  esac
  
  Rotate="${Rotate:-0}"
  [ "$Cropgeometry" ] || {
    failure "crop $Functionmode: crop geometry is empty"
    return 1
  }
  
  [ "$Cropgeometry" = "${Imagewidth}x${Imageheight}+0+0" ] && [ "$Rotate" = "0" ] && {
    worknote "crop $Functionmode: Images already have desired geometry: $Cropgeometry"
    mycp "$Sourcedir/$Sourcefileglob" "$Destinationdir"
    return
  }
  
  worknote "crop $Functionmode: Cropping images with rotation $Rotate and geometry $Cropgeometry"
  Imagecount="0"
  for Image in $Imagelist; do
    Imagecount="$((Imagecount+1))"
    Destinationfile="$Destinationdir/$(basename "$Image")"
    multicore "$Convert $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || return 1
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
  Imagelist="$(fileglob "$Rotatedir/*")"
  
  historyentry "# crop geometry: $Cropgeometry rotation: $Rotate"
  return 0
}

cuberotate() {
  local $Batchlocal
  local $Imagelocal
  local Linecount Linenumber
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
    
  case $Functionmode in
    top|bottom) Linenumber="$Imageheight" ;;
    left|right) Linenumber="$Imagewidth" ;;
  esac
  
  case $Functionmode in
    top|bottom|left|right)
      worknote "cuberotate $Functionmode: Splitting images into rows or columns"
      Imagecount=0
      for Image in $Imagelist; do
        Imagecount="$((Imagecount+1))"
        mkdir $Cachedir/split$Imagecount
        case $Functionmode in
          top|bottom) Cropgeometry="0x1" ;;
          left|right) Cropgeometry="1x0" ;;
        esac
        multicore "convert $Image -crop $Cropgeometry $Cachedir/split$Imagecount/line%d.mpc" || return 1
        showpercent $Imagecount $((Imagenumber*2))
      done
      multicore_wait
      
      worknote "cuberotate $Functionmode: Appending lines to rotated image"
      for Linecount in $(seq $Linenumber); do
        Linelist=""
        for Imagecount in $(seq $Imagenumber); do
          case $Functionmode in
            left|top)     Linelist="$Linelist $Cachedir/split$((Imagenumber-Imagecount+1))/line$((Linecount-1)).mpc" ;;
            right|bottom) Linelist="$Linelist $Cachedir/split${Imagecount}/line$((Linenumber-Linecount)).mpc" ;;
          esac
        done
        Destinationfile="$Destinationdir/cube${Functionmode}$(printnum $Linecount 4).jpg"
        
        case $Functionmode in
          top|bottom) multicore "$Convert $Linelist -append $Destinationfile" "$Destinationfile" || return 1 ;;
          left|right) multicore "$Convert $Linelist +append $Destinationfile" "$Destinationfile" || return 1 ;;
        esac
        showpercent $((Linenumber+Linecount)) $((Linenumber*2))
      done
      multicore_wait
    ;;
    back-left|back-top|reverse-order)
      Imagecount=0
      for Image in $Imagelist; do
        Destinationfile="$(head -n $((Imagenumber - Imagecount)) <<< "$Imagelist" | tail -1)"
        Destinationfile="$(basename "$Destinationfile")"
        worknote "cuberotate $Functionmode: Generating $Destinationfile"
        Destinationfile="$Destinationdir/$Destinationfile"
        case $Functionmode in
          reverse-order)
            multicore "cp -T    $Image       $Destinationfile" "$Destinationfile" 16 || return 1
          ;;
          back-left)
            multicore "$Convert $Image -flop $Destinationfile" "$Destinationfile" || return 1
          ;;
          back-top)
            multicore "$Convert $Image -flip $Destinationfile" "$Destinationfile" || return 1
          ;;
        esac
        Imagecount="$((Imagecount+1))"
        showpercent $Imagecount $Imagenumber
      done
      multicore_wait || return 1
    ;;
    90|180|270)
      Imagecount=0
      for Image in $Imagelist; do
        Imagecount="$((Imagecount+1))"
        Destinationfile="$(basename $Image)"
        worknote "cuberotate $Functionmode: Generating $Destinationfile"
        Destinationfile="$Destinationdir/$Destinationfile"
        multicore "$Convert $Image -rotate $Functionmode $Destinationfile" "$Destinationfile" || return 1
        showpercent $Imagecount $Imagenumber
      done
      multicore_wait || return 1
    ;;
  esac
}

evaluate() {
  # Evaluate image stack.
  
  local $Batchlocal
  local Destinationfilebasename Fileformat Count
  
  parse_batchoptions "$@" || return 1
  
  Destinationfilebasename="${Destinationfile:-evaluate}"  
  Fileformat="${Functionoption:-jpg}"
  Functionmode="${Functionmode:-all}"
  
  case "$Functionmode" in
    all)
      Count=0
      for Functionmode in min mean max median; do
        Count="$((Count + 1))"
        multicore "evaluate -s '$Sourcedir' -g '$Sourcefileglob' -d '$Destinationdir' -b '$Destinationfilebasename' -m '$Functionmode' -o '$Fileformat'" || return 1
        showpercent "$Count" "4"
      done
      multicore_wait || return 1
    ;;
    min|max|mean|median) ;;
    *) failure "evaluate: Unknown function mode $Functionmode" ; return 1 ;;
  esac
  
  Destinationfile="$Destinationdir/$Destinationfilebasename.$Functionmode.$Fileformat"
  $Convert $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence $Functionmode "$Destinationfile" || {
    failure "evaluate $Functionmode: ERROR in excuting convert. Please check policy restrictions of ImageMagick. Note that all source images must be of same size."
    return 1
  }
  showimage "$Destinationfile"
  return 0
}

fuse() {
  # fuse stackshot of images with enfuse
  
  local $Batchlocal 
  local Destinationfilebasename
  local Fusemode Fuseoption Modelist Modenumber Count
  local Layertif Filesize
  
  parse_batchoptions "$@" || return 1
  
  Destinationfilebasename="${Destinationfile:-fuse}"
  Fusemode="${Functionmode:-1}"
  Fuseoption="${Functionoption:-}"
  
  case $Fusemode in
    all|set*)
      Layertif="$Cachedir/layer.tif"
      worknote "fuse $Fusemode: Generating layered tif image"
      convert $(fileglob "$Sourcedir/$Sourcefileglob") "$Layertif" || return 1
      Filesize="$(du -k "$Layertif" | awk '{print $1}')"
      case $Fusemode in
        all) 
          Modelist="$(seq $Fusemodenumber)" 
        ;;
        set*)  
          for Count in $(seq $Fusemodenumber); do
            [ "$(fuse_getvalue $Count $Fusemode value)" ] && Modelist="$Modelist $Count"
          done
        ;;
      esac
      Modenumber="$(wc -w <<< "$Modelist")"
      Count=0
      for Fusemode in $Modelist; do
        Count="$((Count+1))"
        multicore "fuse -s '$(dirname "$Layertif")' -g '$(basename "$Layertif")' -d '$Destinationdir' -b '$Destinationfilebasename' -m '$Fusemode' -o '$Fuseoption'" "" "$((Filesize*3))"|| return 1
        showpercent "$Count" "$Modenumber"
      done
      multicore_wait || return 1
      return 0
    ;;
    fuse*)
      Fusemode="${Fusemode#fuse}"
      Fusemode="${Fusemode#0}"
    ;;
  esac
  
  Destinationfile="$Destinationdir/$Destinationfilebasename.$(fuse_getname $Fusemode shortcut).jpg"
  case $Fuseoption in
    skip)
      [ -e "$Destinationfile" ] && {
        note "fuse: Skipping $Fusemode: already exists: $(basename $Destinationfile)"
        showimage "$Destinationfile"
        return 0
      }
    ;;
  esac
  worknote "fuse $Fusemode: Creating $(basename "$Destinationfile")"

  # Collect options
  Enfuseoptions=""
  for Line in $Fuseoptions; do
    Enfuseoptions="$Enfuseoptions $(fuse_getvalue $Fusemode $Line option)"
  done
  verbose "fuse $Fusemode: $Enfuseoptions"
  
  # Fuse
  { enfuse $Enfuseoptions \
           --output="$Destinationfile" \
           $(fileglob "$Sourcedir/$Sourcefileglob") 2>&1 || {
      failure "fuse $Fusemode failed"
      return 1
    } 
  } | grep -v -E 'assuming all pixels should contribute|alpha channel|loading next image|no usable resolution found'
        
  # Write enfuse options into EXIF data of image
  exiv2 -M"set Exif.Photo.UserComment Comment charset=Ascii enfuse $(echo $Enfuseoptions)" "$Destinationfile" 

  #note "fuse $Fusemode is ready: ${Destinationfile}"
  showimage "$Destinationfile"
  return 0
}

ruler() {
  local $Batchlocal
  local $Imagelocal
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  Imagecount="0"
  for Image in $Imagelist; do
    Imagecount="$((Imagecount+1))"
    Destinationfile="$Destinationdir/$(basename $Image)"
    multicore "$Imgruler -m $Functionmode -t '$Functionoption' -o $Destinationfile $Image" "$Destinationfile" || return 1
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
  return 0
}

undo() {
  local $Batchlocal
  local Undocache
  
  parse_batchoptions "$@" || return 1

  Undocache="$Cachedir/undo"
  mkdir -p "$Undocache"
  
  mymv "$Sourcedir/*"      "$Undocache"      || return 1
  mymv "$Destinationdir/*" "$Sourcedir" 
  mymv "$Undocache/*"      "$Destinationdir"
  
  myrmdir "$Undocache"
}

video() {
  # Generate video of stackshot showing focus changes
  local $Batchlocal
  local $Imagelocal
  local Imagelistfile
  local Framerate Format
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1

  Functionmode="${Functionmode:-in_and_out}"
  Framerate="${Functionoption:-10}"
  Format="mp4"
  
  Destinationfile="$Destinationdir/$Destinationfile.focus.$Functionmode.$Framerate.$Format"
  Imagelistfile="$Cachedir/imagelist"
  
  case $Functionmode in
    in) Imagelist="$(tac <<< "$Imagelist")";;
    out) ;;
    in_and_out) Imagelist="$Imagelist
$(tac <<< "$Imagelist")"
    ;;
  esac
  
  :> "$Imagelistfile"
  for Image in $Imagelist; do
    echo "file '$Image'" >> $Imagelistfile
  done
  
  showpercent 20 100
  ffmpeg -y -hide_banner -nostdin -safe "0" -r $Framerate -f concat -i $Imagelistfile $Destinationfile || return 1
  showpercent 100 100
  showimage $Destinationfile
}

whitebalance() {
  # whitebalance sequence of images
  # -m  reference geometry
  # -o  reference color or "mean"
  
  local $Batchlocal
  local $Imagelocal
  local Referencecolor Referencecolorimage Meancolorimage 
  local Refred  Refgreen  Refblue
  local Meanred Meangreen Meanblue
  local Partred Partgreen Partblue
  
  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
    
  Functionmode="${Functionmode:-topleft}"
  Referencecolor="${Functionoption:-#BBBBBB}"
  
  Meancolorimage="$Cachedir/meancolor.mpc"
  Referencecolorimage="$Cachedir/referencecolor.mpc"
  
  case $Functionmode in
    topleft)     Cropgeometry="10x10+5+5" ;;
    topright)    Cropgeometry="10x10+$((Imagewidth-15))+5" ;;
    bottomleft)  Cropgeometry="10x10+5+$((Imageheight-15))" ;;
    bottomright) Cropgeometry="10x10+$((Imagewidth-15))+$((Imageheight-15))" ;;
    full)        Cropgeometry="${Imagewidth}x${Imageheight}+0+0" ;;
    interactive) 
#      Image="$Cachedir/whitebalance.min.jpg"
      Image="$Cachedir/whitebalance.min.mpc"
      worknote "whitebalance: Generating min image"
      $Convert $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence min "$Image"
      Cropgeometry="$(cropgeometry_interactive "$Image" "$Cachedir" "50x50+10+10")"  ### FIXME rotate
      Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")" 
      [ "$Cropgeometry" ] || {
        failure "whitebalance: Got no crop geometry"
        return 1
      }
    ;;
    *)           Cropgeometry="$Functionmode" ;;
  esac
  
  [ "$Referencecolor" = "mean" ] && {
    Image="$Cachedir/whitebalance.mean.mpc"
    worknote "whitebalance: Generating mean image"
    convert $(fileglob "$Sourcedir/$Sourcefileglob") -crop "$Cropgeometry" -evaluate-sequence mean "$Image"
    Referencecolor=$($Convert "$Image" -filter box -resize 1x1! -format "%[pixel:u]" info:)
  }
  
  convert -size 1x1 xc:"$Referencecolor" $Referencecolorimage
  Refred="$(convert   $Referencecolorimage -format "%[fx:255*u.p{0,0}.r]" info:)"
  Refgreen="$(convert $Referencecolorimage -format "%[fx:255*u.p{0,0}.g]" info:)"
  Refblue="$(convert  $Referencecolorimage -format "%[fx:255*u.p{0,0}.b]" info:)"

  historyentry "# whitebalance geometry: $Cropgeometry"

  worknote "whitebalance: Balancing with reference color $Referencecolor"
  Imagecount=0
  for Image in $Imagelist; do
    Imagecount="$((Imagecount + 1))"
    Destinationfile="$Destinationdir/$(basename "$Image")"
    
    convert $Image -crop $Cropgeometry -resize 1x1! "$Meancolorimage"
    
    Meanred="$(convert   $Meancolorimage -format "%[fx:255*u.p{0,0}.r]" info:)"
    Meangreen="$(convert $Meancolorimage -format "%[fx:255*u.p{0,0}.g]" info:)"
    Meanblue="$(convert  $Meancolorimage -format "%[fx:255*u.p{0,0}.b]" info:)"
    
    [ "$Meanred"   = "0" ] && Partred=255   || Partred="$(awk   "BEGIN { print $Refred   / $Meanred }")"
    [ "$Meangreen" = "0" ] && Partgreen=255 || Partgreen="$(awk "BEGIN { print $Refgreen / $Meangreen }")"
    [ "$Meanblue"  = "0" ] && Partblue=255  || Partblue="$(awk  "BEGIN { print $Refblue  / $Meanblue }")"
    
    multicore "$Convert $Image -color-matrix '$Partred 0 0 0 $Partgreen 0 0 0 $Partblue' $Destinationfile" "$Destinationfile" || return 1
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
  return 0
}

wizard() {
  # Wrapper for ImageMagick convert to work on folders
  # Args:
  #  mandatory:
  #   -m Functionmode
  #   -s Sourcedir
  #   -d Destinationdir
  #  optional:
  #   -g Sourcefileglob
  #   -o Functionoption
  
  local $Batchlocal
  local $Imagelocal
  local Gamma

  parse_batchoptions "$@" || return 1
  setup_imagelist         || return 1
  
  [ "$Functionoption" ] || case "$Function" in
    brightness) Functionoption="10x10" ;;
    contrast)   Functionoption="3x50%" ;;
    gamma)      Functionoption="auto" ;;
    kuwahara)   Functionoption="1.5" ;;
    level)      Functionoption="auto" ;;
    sharpen)    Functionoption="6x2" ;;
    stretch)    Functionoption="0%" ;;
  esac

  case "$Functionmode" in
    level|gamma) 
      case "$Functionoption" in
        auto|"") Functionmode="-auto-$Functionmode" ; Functionoption="" ;;
        *)       Functionmode="-$Functionmode" ;;
      esac
    ;;
    brightness)  Functionmode="-brightness-contrast" ;;
    contrast)    Functionmode="-sigmoidal-contrast" ;;
    kuwahara)    Functionmode="-kuwahara" ;;
    sharpen)     Functionmode="-adaptive-sharpen" ;;
    stretch)     Functionmode="-contrast-stretch" ;;
    wizard)      Functionmode="" ;;
  esac
  
  grep -q "auto-gamma" <<< "$Functionmode $Functionoption" && {
    Gamma="$(calc_autogamma -s "$Sourcedir" -g "$Sourcefileglob" -c "$Cachedir")"
    Functionmode="$(sed   "s/auto-gamma/gamma $Gamma/" <<< "$Functionmode")"
    Functionoption="$(sed "s/auto-gamma/gamma $Gamma/" <<< "$Functionoption")"
  }
  
  worknote "wizard: $Functionmode $Functionoption"
  
  Imagecount=0
  for Image in $Imagelist; do
    Imagecount="$((Imagecount + 1 ))"
    Destinationfile="$Destinationdir/$(basename "$Image")"
    multicore "$Convert $Image $Functionmode $Functionoption $Destinationfile" "$Destinationfile" || return 1
    showpercent "$Imagecount" "$Imagenumber"
  done
  multicore_wait || return 1
  
  return 0
}

#### single image operations

calc_evengeometry() {
  local Geometry XY W H
  Geometry="${1:-}"
  W=$(cut -dx -f1 <<< "$Geometry")
  H=$(cut -dx -f2 <<< "$Geometry" | cut -d+ -f1)
  XY="$(cut -d+ -f2- <<< "$Geometry")"
  W=$((W/2))
  W=$((W*2))
  H=$((H/2))
  H=$((H*2))
  Geometry="${W}x${H}+${XY}"
  echo $Geometry
}

trim_hard() {
  # Function: Trim all border with transparency from image $1
  # Results in a maximal inner rectangle without border color.
  # $1  $Image      image
  # $2  $Trimcolor  color to trim. Default: transparent
  # $3  Geometry seed value (optional)
  # $4  additional command to run on each iteration (optional, special use case for cropgeometry_interactive() )
  # Output: crop geometry
  
  local Imagemask Trimcolor Cropgeometry Addcommand
  local Sourceimage Sourceimagempc Cropgeometryimage Imagewidth Imageheight
  local Left         Right         Top         Bottom
  local Skipleft     Skipright     Skiptop     Skipbottom
  local Permilleleft Permilleright Permilletop Permillebottom Permillemax
  local Return
  local Debugmode Loopcount
  local pid1 pid2 pid3 pid4
  
  Sourceimage="${1:-}"
  Cropgeometry="${2:-}"
  Addcommand="${3:-}"
  
  Trimcolor="#00000000" # to support other colors, creating mask must be fixed FIXME
  
  # check source for mpc format, convert if not
  [ "$Sourceimage" = "${Sourceimage%.mpc}" ] && {
    Sourceimagempc="$Sourceimage.mpc"
    convert "$Sourceimage" "$Sourceimagempc"
  } || {
    Sourceimagempc="$Sourceimage"
  }
  Cropgeometryimage="$Sourceimage.trim_hard.png"
  
  # Generate alpha mask image in imagemagick memory format for fastest possible access
  Imagemask="$Sourceimage.mask.mpc"
  convert "$Sourceimagempc" -alpha extract "$Imagemask"
  
  worknote "trim_hard(): Searching for inner rectangle of $(basename $Image)"
  
  Imagewidth=$(convert  -format '%w'  $Imagemask info:)
  Imageheight=$(convert -format '%h'  $Imagemask info:)
  Left=0
  Top=0
  Right=$((Imagewidth-1))
  Bottom=$((Imageheight-1))
  
  # First cut with regular trim to save some time.
  # Add a colored border so trim uses the desired color. Afterward remove border from canvas to get correct geometry values. 
  Line="$(convert "$Sourceimagempc" -bordercolor "$Trimcolor" -border 1x1  -trim -set page '%[fx:page.width-2]x%[fx:page.height-2]+%[fx:page.x-1]+%[fx:page.y-1]' info:)"
  Left="$(awk '{print $4}' <<< "$Line" | cut -d+ -f2)"
  Top="$(awk '{print $4}' <<< "$Line" | cut -d+ -f3)"
  Right="$(awk '{print $3}' <<< "$Line" | cut -dx -f1)"
  Right="$((Left+Right-1))"
  Bottom="$(awk '{print $3}' <<< "$Line" | cut -dx -f2)"
  Bottom="$((Top+Bottom-1))"
  
  [ "$Cropgeometry" ] && {
    Left=$(cut -d+ -f2 <<< "$Cropgeometry")
    Top=$(cut -d+ -f3 <<< "$Cropgeometry")
    Right=$(cut -dx -f1 <<< "$Cropgeometry")
    Right=$((Left+Right-1))
    Bottom=$(cut -dx -f2 <<< "$Cropgeometry")
    Bottom=$(cut -d+ -f1 <<< "$Bottom")
    Bottom=$((Top+Bottom-1))
  }
  
  # Workflow:
  # - Get permille amount of $Trimcolor from all sides.
  # - Remove side with greatest permille amount of $Trimcolor.
  # - Repeat check with new geometry
  while :; do
    # Get part of non-$Trimcolor at each side
    [ "$Skipleft" ]   || convert $Imagemask -crop 1x$((Bottom-Top+1))+$Left+$Top    +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permilleleft    & pid1=$!
    [ "$Skipright" ]  || convert $Imagemask -crop 1x$((Bottom-Top+1))+$Right+$Top   +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permilleright   & pid2=$!
    [ "$Skiptop" ]    || convert $Imagemask -crop $((Right-Left+1))x1+$Left+$Top    +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permilletop     & pid3=$!
    [ "$Skipbottom" ] || convert $Imagemask -crop $((Right-Left+1))x1+$Left+$Bottom +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permillebottom  & pid4=$!
    wait $pid1
    wait $pid2
    wait $pid3
    wait $pid4
    Permilleleft=$(  LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permilleleft)
    Permilleright=$( LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permilleright)
    Permilletop=$(   LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permilletop)
    Permillebottom=$(LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permillebottom )
    
    # Determine maximal permille value
    Permillemax=$(echo "$Permilleleft
$Permilleright
$Permilletop
$Permillebottom" | sort -n | head -n1)
    showpercent "$(awk "BEGIN {print 1000*$Permillemax}" | cut -d. -f1)" "1000"
    [ "$Permillemax" = "1.0000" ] && break # Ready
    
    # Remove side with maximal permille of $Trimcolor.
    [ "$Permillemax" = "$Permilleleft" ]   && Left=$((Left+1))
    [ "$Permillemax" = "$Permilleright" ]  && Right=$((Right-1))
    [ "$Permillemax" = "$Permilletop" ]    && Top=$((Top+1))
    [ "$Permillemax" = "$Permillebottom" ] && Bottom=$((Bottom-1))
    Cropgeometry="$((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top"
    
    # Skip check for sides without $Trimcolor in future to save some time
    [ "1.0000" = "$Permilleleft" ]   && Skipleft=yes
    [ "1.0000" = "$Permilleright" ]  && Skipright=yes
    [ "1.0000" = "$Permilletop" ]    && Skiptop=yes
    [ "1.0000" = "$Permillebottom" ] && Skipbottom=yes
    
    # break signal of fusewizard
    ifcmdbreak && return 1

    # Out-of-range error
    { [ "$Left" -gt "$Right" ] || [ "$Top" -gt "$Bottom" ] ; } && {
#      echo "Error: Failed to find an inner rectangle. Unuseable result: $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top" >&2
      failure "trim_hard(): Failed to find an inner rectangle. Unuseable result: $Cropgeometry" 
      Return=1
      Left=0
      Top=0
      Right=$((Imagewidth-1))
      Bottom=$((Imageheight-1))
      break
    }
    
    # Debugging: show intermediate results
    Debugmode=yes
    [ "$Debugmode" ] && {
      Loopcount=$((Loopcount+1))
      [ "$Loopcount" = "10" ] && {
        Loopcount=0
        convert $Sourceimagempc -fill none -stroke red -strokewidth 1 -pointsize 18 -undercolor white -gravity center -draw "rectangle $Left,$Top $Right,$Bottom  text 0,0 '$Cropgeometry'" $Cropgeometryimage
        showimage $Cropgeometryimage
        eval "$Addcommand"
      }
    }
  done

  # show result
  showpercent 100 100
  convert $Sourceimagempc -fill none -stroke red -strokewidth 1 -pointsize 18 -undercolor white -gravity center -draw "rectangle $Left,$Top $Right,$Bottom  text 0,0 '$Cropgeometry'" $Cropgeometryimage
  showimage $Cropgeometryimage
  
  # Output of result
  #echo "$Left,$Top $Right,$Bottom"                     # "-draw rectangle" geometry
  #echo $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top  # "-crop" geometry
  echo "$Cropgeometry"

  return ${Return:-0}
}

#### fuse helpers

fuse_declare() {
  # declare default fuse mode values
  local Count
  
  Fusemodenumber=25
  Fusesetnumber=5
  
  Fuseoptions="exposureweight saturationweight contrastweight entropyweight blendmask grayprojector levels contrastwindowsize contrastmincurvature contrastedgescale"
  Fusearguments="$Fuseoptions lcescale lcefactor"
#  Fusemodecombo="'all','set$(seq -s "','set" $Fusesetnumber)','$(seq -s "','" $Fusemodenumber)'"
  Fusemodecombo="'all','set$(seq -s "','set" $Fusesetnumber)'"
  for Count in $(seq $Fusemodenumber); do
    Fusemodecombo="$Fusemodecombo,'$(fuse_getname $Count shortcut)'"
  done
  
  # set1
  for Count in 1 2 3 4 5 6 7 8 9 15 16 17 20 ; do
    fuse_storevalue $Count set1 !
  done
  # set2
  for Count in 1 2 3 ; do
    fuse_storevalue $Count set2 !
  done
  # set3
  for Count in 4 5 6 ; do
    fuse_storevalue $Count set3 !
  done
  
  # Default Fuse modes
  # 1)
  # 2)
  fuse_storevalue 2 saturationweight 0.1
  # 3)
  fuse_storevalue 3 contrastwindowsize 7
  # 4)
  fuse_storevalue 4 contrastwindowsize 7
  fuse_storevalue 4 saturationweight 0.1
  # 5) 
  fuse_storevalue 5 contrastwindowsize 15
  # 6)
  fuse_storevalue 6 contrastwindowsize 15
  fuse_storevalue 6 saturationweight 0.1
  # 7) 
  fuse_storevalue 7 contrastwindowsize 23
  # 8)
  fuse_storevalue 8 contrastwindowsize 23
  fuse_storevalue 8 saturationweight 0.1
  # 9)
  fuse_storevalue 9 contrastedgescale 0.8
  fuse_storevalue 9 lcescale 16
  fuse_storevalue 9 lcefactor 7
  # Contrastedgescale="0.8:2000%:300%"
  ##Contrastmincurvature="+8.0%"
  # 10)
  fuse_storevalue 10 contrastedgescale 0.8
  fuse_storevalue 10 lcescale 4
  fuse_storevalue 10 lcefactor 25
  #Contrastedgescale="0.8:500%:500%"
  ##Contrastmincurvature="+8.0%"
  # 11)
  fuse_storevalue 11 contrastedgescale 1.2
  fuse_storevalue 11 lcescale 16
  fuse_storevalue 11 lcefactor 4
  ##Contrastmincurvature="+5.0%"
  # 12)
  fuse_storevalue 12 contrastedgescale 1.2
  fuse_storevalue 12 lcescale 8
  fuse_storevalue 12 lcefactor 4
  ##Contrastmincurvature="+5.0%"
  ##Saturationweight="0.1"
  # 13)
  fuse_storevalue 13 contrastedgescale 1.6
  fuse_storevalue 13 lcescale 16
  fuse_storevalue 13 lcefactor 4
  ##Contrastmincurvature="+3.0%"
  # 14)
  fuse_storevalue 14 contrastedgescale 1.6
  fuse_storevalue 14 lcescale 8
  fuse_storevalue 14 lcefactor 4
  ##Contrastmincurvature="+3.0%"
  ##Saturationweight="0.1"
  # 15)
  fuse_storevalue 15 contrastedgescale 1.6
  fuse_storevalue 15 lcescale 16
  fuse_storevalue 15 lcefactor 10
  ##Contrastmincurvature="+6.0%"
  # 16)
  fuse_storevalue 16 contrastedgescale 1.6
  fuse_storevalue 16 lcescale 8
  fuse_storevalue 16 lcefactor 10
  ##Contrastmincurvature="+8.0%"
  ##Saturationweight="0.1"
  # 17)
  fuse_storevalue 17 contrastedgescale 2.0
  fuse_storevalue 17 lcescale 10
  fuse_storevalue 17 lcefactor 25
  ##Contrastedgescale="2.0:500%:500%"
  ##Contrastmincurvature="+2.0%"
  # 18)
  fuse_storevalue 18 contrastedgescale 1.2
  fuse_storevalue 18 lcescale 16
  fuse_storevalue 18 lcefactor 4
  fuse_storevalue 18 contrastwindowsize 9
  fuse_storevalue 18 contrastmincurvature 8
  # 19)
  fuse_storevalue 19 contrastedgescale 1.2
  fuse_storevalue 19 lcescale 16
  fuse_storevalue 19 lcefactor 4
  fuse_storevalue 19 contrastwindowsize 23
  fuse_storevalue 19 contrastmincurvature 8
  # 20)
  fuse_storevalue 20 contrastedgescale 3.0
  fuse_storevalue 20 lcescale 4
  fuse_storevalue 20 lcefactor 4
}

fuse_getname() {
  local Number Mode
  local Line Value Name

  Number="${1:-}"
  Mode="${2:-}"
  
  case $Mode in
    option)
      for Line in $Fuseoptions; do
        Value="$(fuse_getvalue $Number $Line value)"
        [ "$Value" = "$(fuse_defaultvalue $Line)" ] || {
          case $Line in
            exposureweight)       Name="$Name exp$Value" ;;
            saturationweight)     Name="$Name sat$Value" ;;
            contrastweight)       Name="$Name cont$Value" ;;
            entropyweight)        Name="$Name ent$Value" ;;
            blendmask)            Name="$Name $(tr -d "-" <<< ${Value%mask})" ;;
            grayprojector)        Name="$Name $Value" ;;
            levels)               Name="$Name lev$Value" ;;
            contrastwindowsize)   Name="$Name cws$Value" ;;
            contrastmincurvature) Name="$Name curv$Value" ;;
            contrastedgescale)    Name="$Name edge$(fuse_getvalue $Number $Line option | cut -d= -f2)" ;;
          esac
        }
      done
      [ -z "$Name" ] && Name="default"
    ;;
    shortcut|"")
      case $Number in
        all|set*) echo "$Number" ;;
        *)
          Number="${Number#fuse}"
          Number="${Number#0}"
          echo "fuse$(printf %02d "$Number")" 
        ;;
      esac
    ;;
  esac
  echo  "$Name"
}

fuse_defaultvalue() {
  # define default enfuse settings
  local Entry
  Entry="${1:-}"
  Entry="$(tr -d "-" <<< "$Entry")"
  case "${1:-}" in
    exposureweight)       echo "0" ;;
    saturationweight)     echo "0" ;;
    contrastweight)       echo "1" ;;
    entropyweight)        echo "0" ;;
    blendmask)            echo "--hard-mask" ;;
    grayprojector)        echo "luminance" ;;
    levels)               echo "" ;;
    contrastwindowsize)   echo "5" ;;
    contrastmincurvature) echo "" ;;
    contrastedgescale)    echo "" ;;
    lcescale)             echo "" ;;
    lcefactor)            echo "" ;;
    set*)                 echo "" ;;
  esac
}

fuse_getvalue() {
  local Number Entry Mode Entryoption Value Combovalues Combo
  Number="${1:-}"
  Entry="${2:-}"
  Mode="${3:-}"
  
  Entry="$(tr -d "-" <<< "$Entry")"
  case $Entry in
    exposureweight)       Entryoption="--exposure-weight" ;;
    saturationweight)     Entryoption="--saturation-weight" ;;
    contrastweight)       Entryoption="--contrast-weight" ;;
    entropyweight)        Entryoption="--entropy-weight" ;;
    grayprojector)        Entryoption="--gray-projector" ;;
    levels)               Entryoption="--levels" ;;
    contrastwindowsize)   Entryoption="--contrast-window-size" ;;
    contrastmincurvature) Entryoption="--contrast-min-curvature" ;;
    contrastedgescale)    Entryoption="--contrast-edge-scale" ;;
  esac
  
  case $Entry in
    exposureweight|saturationweight|contrastweight|entropyweight) Combovalues="empty 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1" ;;
    blendmask)            Combovalues="--hard-mask --soft-mask" ;;
    grayprojector)        Combovalues="anti-value average l-star lightness luminance pl-star value" ;;
    levels)               Combovalues="empty $(seq 29)" ;;
    contrastwindowsize)   Combovalues="empty 3 5 7 9 11 13 15 17 19 21 23 25 27 29" ;;
    contrastmincurvature) Combovalues="empty 0 0.1 0.5 1 2 3 5 7.5 8 10" ;;
    contrastedgescale)    Combovalues="empty 0 0.1 0.2 0.3 0.4 0.5 0.8 1.0 1.2 1.4 1.6 1.8 2.0 2.5 3.0" ;;
    lcescale)             Combovalues="empty 0 2 4 6 8 10 15 16 20 25" ;;
    lcefactor)            Combovalues="empty 0 2 4 6 7 8 10 12 25" ;;
  esac
  
  
  Value="$(grep "^$Number:$Entry:" $Storefusefile | cut -d: -f3)"
  [ -z "$Value" ] && Value="$(fuse_defaultvalue "$Entry")"
  
  case $Mode in
    value)     
      echo "$Value" 
    ;;
    
    option)
      [ -z "$Value" ] && echo "" && return 0
      case $Entry in
        blendmask)
          echo "$Value"
        ;;
        contrastedgescale)
          Lcescale=$(fuse_getvalue  $Number lcescale value)
          Lcefactor=$(fuse_getvalue $Number lcefactor value)
          case $Lcescale in
            "") 
              echo "$Entryoption=$Value" 
            ;;
            *)
              case $Lcefactor in
                "") echo "$Entryoption=$Value:$Lcescale" ;;
                *)  echo "$Entryoption=$Value:$Lcescale:$Lcefactor" ;;
              esac
            ;;
          esac
        ;;
        lcescale|lcefactor) echo "" ;;
        *) 
          echo "$Entryoption=$Value" 
        ;;
      esac
    ;;
    
    kaptain)
      for Line in $Combovalues; do
        Combo="$Combo,'$Line'"
      done
      Combo="${Combo#,}"
      Combo="$(sed 's/empty//' <<< "$Combo")"
      echo "${Entry}(${Combo})='${Value}'"
    ;;
  esac
}

fuse_storevalue() {
  local Number Entry Value Content
  
  Number="${1:-}"
  Entry="${2:-}"
  Value="${3:-}"
  
  Entry="$(tr -d "-" <<< "$Entry")"
  Content="$(sed "/^$Number:$Entry:/d" $Storefusefile)"
  [ "$Value" = "$(fuse_defaultvalue "$Entry")" ] && Line="" || Line="$Number:$Entry:$Value"
  [ "$Line" ] && Content="$(sort -V <<< "$Content
$Line")"
  echo "$Content" > $Storefusefile
  return 0
}

fuse_glob() {
  local Count Glob
  case "${1:-}" in
    all) echo "*" ;;
    set*) 
      for Count in $(seq $Fusemodenumber); do
        [ "$(fuse_getvalue $Count ${1:-} value)" ] && Glob="${Glob},*$(fuse_getname $Count shortcut)*"
      done
      echo "{${Glob}}"
    ;;
    *) echo "*$(fuse_getname ${1:-} shortcut)*"
  esac
}

#### run commands on all CPUs

multicore() {
  # Run multiple processes in parallel, but not more than $Multicore_maxprocesses
  # $1 Command
  # $2 Image to show if $1 is finished
  # Run multicore_wait afterwards to wait for the last processes to finish.
  
  local Process
  local Mem_needed
  
  [ "$Multicore_processcount" = "$Multicore_maxprocesses" ] && {
    multicore_wait || return 1
  }
  
  [ "$Multicore_processcount" = "0" ] && Multicore_memorymax="$(LC_ALL=C free | grep "Mem:" | awk '{print $7}')"
  
  Mem_needed=0
  for Process in $(seq $Multicore_maxprocesses); do
    Mem_needed="$(awk "BEGIN {print $Mem_needed + ${Multicore_memory[$Process]:-0} }" )"
  done
  Mem_needed="$((Mem_needed+${3:-0}))"
  [ "$Mem_needed" -gt "$Multicore_memorymax" ] && {
    note "multicore: Low memory. Waiting for $Multicore_processcount running processes to finish. Need: $Mem_needed, Available: $Multicore_memorymax"
    multicore_wait || return 1
  }

  Multicore_processcount=$((Multicore_processcount +1))

  #verbose "multicore: ${1:-}"
  eval "${1:-} &"
  
  Multicore_process[Multicore_processcount]=$!
  Multicore_image[Multicore_processcount]="${2:-}"
  Multicore_memory[Multicore_processcount]="${3:-0}"
  
  return 0
}

multicore_wait() {
  local Process
  for Process in $(seq $Multicore_maxprocesses); do
    [ "${Multicore_process[$Process]}" ] && {
      multicore_waitprocess "${Multicore_process[$Process]}" || {
        multicore_break
        return 1
      }
      [ "${Multicore_image[$Process]}" ] && showimage "${Multicore_image[$Process]}"
    }
    Multicore_process[$Process]=""
    Multicore_image[$Process]=""
    Multicore_memory[$Process]="0"
  done
  Multicore_processcount=0
  return 0
}

multicore_waitprocess() {
  while sleep 0.2 ; do
    ps -p "${1:-}" >/dev/null || break
    ifcmdbreak && return 1
  done
  wait "${1:-}"
  return $?
}

multicore_break() {
  local Process
  for Process in $(seq $Multicore_maxprocesses); do
    [ "${Multicore_process[$Process]}" ] && {
      kill "${Multicore_process[$Process]}"
      wait "${Multicore_process[$Process]}"
      Multicore_process[$Process]=""
      Multicore_image[$Process]=""
      Multicore_memory[$Process]="0"
    }
  done
}

#### GUI

kaptaingrammar() {
  echo '#! /usr/bin/kaptain

start "fusewizard '$Version'" -> frameset;
  frameset:framed                    -> topframe bottomframe;
    topframe                           -> batchoptionframe ;
      batchoptionframe:beside            -> batchframeleft  batchframeright;
        batchframeleft:framed              -> batchblock1 batchblock2 specialframe;
        batchframeright:framed             -> batchblock3 runbatchframe showresultframe @fill deleteframe;
    bottomframe                        -> dirframe statusframe ;
    
      dirframe:beside                    -> choosedirguibutton choosedir refreshbutton;
        choosedirguibutton                 -> @button="Stackshot directory:" ;
        choosedir                          -> @directory="'$Projecthome'" ;
        refreshbutton                      -> @button="refresh" ;
    
      statusframe                        -> wizardstatusline ;
        wizardstatusline:beside            -> cmdpercent wizardlog;
          cmdpercent                         -> @icon ;
          wizardlog                          -> @text="" ;
      
      batchblock1 "batch block 1: prepare stackshot images in directory magick" -> cropline @text="convert options" contrastline sharpenline kuwaharaline brightnessline gammaline levelline stretchline wizardline applyallline;
        gammaline:beside                                      -> gamma gammamagick gammafuse gammaevaluate;
          gammacombo                                            -> @combow("auto","0.2","0.3","0.4","0.5","0.6","0.7","0.8","0.9","1.2","1.5","2.0","3.0","4.0")="auto" ;
          gammamagick                                           -> @button="magick" ;
          gammaevaluate                                         -> @button="evaluate" ;
          gammafuse                                             -> @button="fuse" ;
          gamma:beside                "gamma"                   -> gammacombo | "";
        levelline:beside                                      -> level levelmagick levelfuse levelevaluate;
          levelcombo                                            -> @combow("auto","5%","10%","15%","20%","25%","30%")="auto" ;
          levelmagick                                           -> @button="magick" ;
          levelevaluate                                         -> @button="evaluate" ;
          levelfuse                                             -> @button="fuse" ;
          level:beside                "level"                   -> levelcombo | ! "";
        contrastline:beside                                   -> contrast contrastmagick contrastfuse contrastevaluate;
          contrastcombo                                         -> @combow("1x50%","2x50%","3x50%","4x50%","5x50%","6x50%")="6x50%" ;
          contrastmagick                                        -> @button="magick" ;
          contrastevaluate                                      -> @button="evaluate" ;
          contrastfuse                                          -> @button="fuse" ;
          contrast:beside             "sigmoidal-contrast"      -> contrastcombo | "";
        kuwaharaline:beside                                   -> kuwahara kuwaharamagick kuwaharafuse kuwaharaevaluate;
          kuwaharacombo                                         -> @combow("1.2","1.5","2.0","2.5","3.0","4.0","5.0")="1.5" ;
          kuwaharamagick                                        -> @button="magick" ;
          kuwaharaevaluate                                      -> @button="evaluate" ;
          kuwaharafuse                                          -> @button="fuse" ;
          kuwahara:beside             "kuwahara"                -> kuwaharacombo | ! "";
        sharpenline:beside                                    -> sharpen sharpenmagick sharpenfuse sharpenevaluate;
          sharpencombo                                          -> @combow("3x1","6x2","6x4","8x4")="6x4" ;
          sharpenmagick                                         -> @button="magick" ;
          sharpenevaluate                                       -> @button="evaluate" ;
          sharpenfuse                                           -> @button="fuse" ;
          sharpen:beside              "adaptive-sharpen"        -> sharpencombo | "";
        brightnessline:beside                                 -> brightness brightnessmagick brightnessfuse brightnessevaluate;
          brightnesscombo                                       -> @combow("0x5","0x10","0x15","5x0","5x5","5x10","5x15","10x0","10x5","10x10","15x15","20x20")="10x10" ;
          brightnessmagick                                      -> @button="magick" ;
          brightnessevaluate                                    -> @button="evaluate" ;
          brightnessfuse                                        -> @button="fuse" ;
          brightness:beside           "brightness-contrast"     -> brightnesscombo | ! "";
        stretchline:beside                                    -> stretch stretchmagick stretchfuse stretchevaluate;
          stretchcombo                                          -> @combow("0%","1%","2%","3%","4%","5%","10%","15%","20%")="0%" ;
          stretchmagick                                         -> @button="magick" ;
          stretchevaluate                                       -> @button="evaluate" ;
          stretchfuse                                           -> @button="fuse" ;
          stretch:beside              "stretch-contrast"        -> stretchcombo | ! "";
        wizardline:beside                                     -> wizard wizardmagick wizardfuse wizardevaluate;
          wizardcombo                                           -> @combow("","-negate","-despeckle","-edge 3","-emboss 3","-enhance","-equalize","-canny 3","-charcoal 3")="" ;
          wizardmagick                                          -> @button="magick" ;
          wizardevaluate                                        -> @button="evaluate" ;
          wizardfuse                                            -> @button="fuse" ;
          wizard:beside               "convert"                 -> wizardcombo | ! "" ;
        applyallline:beside                                   -> applyall applyallmagick applyallfuse applyallevaluate;
          applyallmagick                                        -> @button="magick" ;
          applyallevaluate                                      -> @button="evaluate" ;
          applyallfuse                                          -> @button="fuse" ;
          applyall:beside             "Apply all convert options"  -> "" ;
          
      batchblock2 "batch block 2: post processing directory magick" -> meanbalanceline whitebalanceline align_vidstabline gamma_line;
        meanbalanceline:beside                                -> meanbalance meanbalancemodecombo meanbalancemagick meanbalancefuse meanbalanceevaluate;
          meanbalancemodecombo                                  -> @combo("interactive","topleft","topright","bottomleft","bottomright","full")="full" ;
          meanbalancemagick                                     -> @button="magick" ;
          meanbalanceevaluate                                   -> @button="evaluate" ;
          meanbalancefuse                                       -> @button="fuse" ;
          meanbalance:beside          "meanbalance"             ->  "on"  | ! "";
        whitebalanceline:beside                               -> whitebalance whitebalancemodecombo whitebalancecombo whitebalancemagick whitebalancefuse whitebalanceevaluate;
          whitebalancemodecombo                                 -> @combo("interactive","topleft","topright","bottomleft","bottomright","full")="topleft" ;
          whitebalancecombo                                     -> @combow("mean","#777777","#888888","#999999","#AAAAAA","#BBBBBB","#CCCCCC","#DDDDDD","#EEEEEE","#FFFFFF")="#999999" ;
          whitebalancemagick                                    -> @button="magick" ;
          whitebalanceevaluate                                  -> @button="evaluate" ;
          whitebalancefuse                                      -> @button="fuse" ;
          whitebalance:beside         "whitebalance"            ->  "on"  | ! "";
        cropline:beside                                       -> crop cropmodecombo cropcombo cropmagick cropfuse cropevaluate;
          cropmodecombo                                         -> @combo("interactive","shrink","even","geometry")="interactive" ;
          cropcombo                                             -> @combow("","1","2","5","10","200x200+15+15")="" ;
          cropmagick                                            -> @button="magick" ;
          cropevaluate                                          -> @button="evaluate" ;
          cropfuse                                              -> @button="fuse" ;
          crop:beside                 "crop + rotate"           -> "on" | ! "";
        align_vidstabline:beside                              -> align_vidstab align_vidstabcombo align_vidstabbutton ;
          align_vidstabcombo          "crop interactive"        -> "on" | ! "";
          align_vidstabbutton                                   -> @button="magick" ;
          align_vidstab:beside        "align"                   -> "on" | "";
        gamma_line:beside                                     -> gamma_ gamma_magick gamma_fuse gamma_evaluate;
          gamma_combo                                           -> @combow("auto","0.2","0.3","0.4","0.5","0.6","0.7","0.8","0.9","1.2","1.3","1.4","1.5","2.0","3.0","4.0")="1.4" ;
          gamma_magick                                          -> @button="magick" ;
          gamma_evaluate                                        -> @button="evaluate" ;
          gamma_fuse                                            -> @button="fuse" ;
          gamma_:beside                "gamma"                  -> gamma_combo | ! "";
        
      batchblock3 "batch block 3: combine stackshot images" -> evaluateline1 fuseline evaluateline2 sharpen_evaluate compose;
        fuseline:beside                                       -> fuse fuseconfig @fill fusemodecombo fusemagick;
          fuseconfig                                            -> @button="fuse" ;
          fusemodecombo                                         -> @combo('$Fusemodecombo')="set1" ;
          fusemagick                                            -> @button="magick";
          fuse:beside                                           -> "on" | "" ;
        evaluateline1:beside                                    -> evaluate1 evaluatemagick ;
          evaluatemagick                                        -> @button="magick" ;
          evaluate1:beside            "evaluate"                -> "on" | "";
        evaluateline2:beside                                    -> evaluate2 evaluatecombo evaluatefuse;
          evaluatefuse                                          -> @button="fuse" ;
          evaluatecombo                                         -> @combo('$Fusemodecombo')="all" ;
          evaluate2:beside            "evaluate"                -> "on" | "";
        sharpen_evaluate:beside       "sharpen 3x1"             -> @button="evaluate" "on" | "";
        compose:beside                "compose"                 -> @button="evaluate" "on" | "";

      runbatchframe "Batch processing" -> batchblockline batchallline;
        batchblockline -> runbatch1 runbatch2 runbatch3;
          runbatch1:beside            "batch block 1"           -> "batchblock1" | "" @button="run";
          runbatch2:beside            "batch block 2"           -> "batchblock2" | "" @button="run";
          runbatch3:beside            "batch block 3"           -> "batchblock3" | "" @button="run";
        batchallline:beside -> runbatchprocessing cmdbreak ;
          runbatchprocessing                                    -> @button="Run selected batch blocks";
          cmdbreak                                              -> @button="break" ;
        
      specialframe "Special operations" -> rulerline videoline animationline cuberotateline undoline ;
        rulerline:beside                                      -> ruler rulermagick rulerfuse rulerevaluate;
          rulermodecombo                                        -> @combo("100c","100p","100z","40c","40p","40z","20c","20p","20z","10c","10p","10z")="100z" ;
          rulercombo:beside           "Title:"                  -> @string ;
          rulermagick                                           -> @button="magick" ;
          rulerevaluate                                         -> @button="evaluate" ;
          rulerfuse                                             -> @button="fuse" ;
          ruler:beside                "micrometer"              -> "" rulermodecombo rulercombo;
        animationline:beside                                  -> animation animationmodecombo animationfusecombo animationcombo animationmagick;
          animationmodecombo:beside                             -> @combo("quick","smooth")="quick";
          animationcombo:beside       "Distortion:"             -> @combow("15","20","25","30","40","50","75","100","150")="30";
          animationfusecombo:beside   "fuse:"                   -> @combow('$Fusemodecombo')="fuse18";
          animationmagick                                       -> @button="magick" ;
          animation:beside            "animated video"          -> "" ;
        videoline:beside                                      -> video videomodecombo videocombo videomagick;
          videomodecombo:beside                                 -> @combo("in","out","in_and_out")="in_and_out";
          videocombo:beside           "Framerate:"              -> @combow("2","3","4","5","7","10","15","20","25","30")="10";
          videomagick                                           -> @button="magick" ;
          video:beside                "focus video"             -> "" ;
        cuberotateline:beside                                 -> cuberotate cuberotatemodecombo cuberotatemagick;
          cuberotatemodecombo:beside                            -> @combo("90","180","270","reverse-order","back-left","back-top","left","right","top","bottom")="reverse-order";
          cuberotatemagick                                      -> @button="magick" ;
          cuberotate:beside           "cuberotate"              -> "" ;
        undoline:beside                                       -> undo undomagick undofuse undoevaluate;
          undomagick                                            -> @button="magick" ;
          undoevaluate                                          -> @button="evaluate" ;
          undofuse                                              -> @button="fuse" ;
          undo                        "undo last step"          -> "" ;
          
      showresultframe "Show results"                        -> showimagebuttons show_video showdirline;
        showimagebuttons:beside                               -> showimagemagickeval showimagefuseeval ;
          showimagemagickeval                                 -> @combo("magick.max","magick.mean","magick.median","magick.min")="magick.max" ;
          showimagefuseeval                                   -> @combo("fuse.max","fuse.mean","fuse.median","fuse.min")="fuse.median" ;
        show_video                                          -> @combo("-");
        showdirline                                         -> @text="Directories" showdirline1 showdirline2 ;
          showdirline1:beside                                 -> opendirbutton showstackshot showmagick ;
            opendirbutton                                       -> @button="FM";
            showstackshot                                       -> @button="stackshot";
            showmagick                                          -> @button="magick";
          showdirline2:beside                                 -> showfuse showcompose showevaluate;
            showfuse                                            -> @button="fuse";
            showcompose                                         -> @button="compose";
            showevaluate                                        -> @button="evaluate";
    
      deleteframe                  "Delete results"         -> delete killviewnior ;
        delete:beside                 "DELETE"                -> @combo("backups","evaluate","magick","compose","video","fuse","all")="cache" ;
        killviewnior                                          -> @action("killall viewnior ffplay")="killall viewnior ffplay";
  '
}

sendkaptain() {
  # send messages to kaptain over its stdin
  echo "$1" >&${Kaptainstdin}
#  echo "sent to kaptain: $1"
}

askkaptain() {
  # ask kaptain for value of $1
  local Answer
  [ "${1:-}" = "-c" ] && {
    # check if entry if present at all
    shift
    kaptaingrammar | grep -q "${1:-}" || return 1
  }
  sendkaptain "${1:-}?"
  read Answer <&${Kaptainstdout}
  [ -z "$Answer" ] && return 1
  echo "$Answer"
  return 0
}

## GUI helpers

kaptain_update() {
  local Stackdir Cmdstatus
  local Line Shortcut Comboline
  Stackdir="$(storeinfo dump stackshotdir)"
  
  # update working directory
  sendkaptain "choosedir='$Stackdir'"
  
  # show directory buttons
  [ -d "$Stackdir/stackshot" ]                    && sendkaptain "showstackshot='stackshot'"      || sendkaptain "showstackshot='-'"
  [ -d "$Stackdir/magick" ]                       && sendkaptain "showmagick='magick'"            || sendkaptain "showmagick='-'"
  [ -d "$Stackdir/evaluate" ]                     && sendkaptain "showevaluate='evaluate'"        || sendkaptain "showevaluate='-'"
  [ -d "$Stackdir/compose" ]                      && sendkaptain "showcompose='compose'"          || sendkaptain "showcompose='-'"
  [ -d "$Stackdir/fuse" ]                         && sendkaptain "showfuse='fuse'"                || sendkaptain "showfuse='-'"
  
  # videos
  Comboline=""
  for Line in $(fileglob "$Stackdir/video/*.mp4") $(fileglob "$Stackdir/video/*.gif") $(fileglob "$Stackdir/video/*.webm"); do
    Shortcut="$(rev <<< "$Line" | cut -d. -f1-4 | rev)"
    Comboline="$Comboline,'$Shortcut'"
  done
  Comboline="${Comboline#,}"
  [ -z "$Comboline" ] && Comboline="'-'"
  sendkaptain "show_video($Comboline)=''"
  
  # evaluate reults
  check_fileglob "$Stackdir/evaluate/*.magick.*" && {
    sendkaptain 'showimagemagickeval("magick.max","magick.mean","magick.median","magick.min")="magick.max"'
  } || {
    sendkaptain 'showimagemagickeval("-")="-"'
  }
  check_fileglob "$Stackdir/evaluate/*.fuse.*" && {
    sendkaptain 'showimagefuseeval("fuse.max","fuse.mean","fuse.median","fuse.min")="fuse.median"'
  } || {
    sendkaptain 'showimagefuseeval("-")="-"'
  }
  
  Cmdstatus="$(storeinfo dump status)"
  case $Cmdstatus in
    error|idle) showpercent $Cmdstatus ;;
  esac
  
  # update preview
  kaptain_update_preview
}

kaptain_update_preview() {
  local Stackdir Currentimage Image Cachedir Imagelist Imagenumber
  
  # check if currently in valid dir, otherwise clear display
  storeinfo test stackshotdir_valid || {
    storeinfo drop showimage
    return 0
  }

  Stackdir="$(storeinfo dump stackshotdir)"
  
  # check if an image of current stackdir is shown
  Currentimage="$(storeinfo dump showimage)"
  grep -q "$Stackdir" <<< "$Currentimage" && [ -e "$Currentimage" ] && showimage "$Currentimage" && return 0
  
  # check for results
  Image="$(fileglob "$Stackdir/evaluate/*fuse.median*")"
  [ -e "$Image" ] && showimage "$Image" && return 0
  
  Image="$(fileglob "$Stackdir/evaluate/*magick.max*")"
  [ -e "$Image" ] && showimage "$Image" && return 0
  
  Image="$(fileglob "$Stackdir/*fuse.median*" | head -n1)"
  [ -e "$Image" ] && showimage "$Image" && return 0

  Imagelist="$(fileglob "$Stackdir/magick/*")"
  [ "$Imagelist" ] &&{
    Imagenumber="$(grep -c . <<< "$Imagelist")"
    Image="$(head -n$((Imagenumber/2)) <<< "$Imagelist" | tail -n1)"
    showimage "$Image"
    return 0
  }
  
  Imagelist="$(fileglob "$Stackdir/stackshot/*")"
  [ "$Imagelist" ] &&{
    Imagenumber="$(grep -c . <<< "$Imagelist")"
    Image="$(head -n$((Imagenumber/2)) <<< "$Imagelist" | tail -n1)"
    showimage "$Image"
    return 0
  }
  
  return 1
}

showpercent() {
  local Percent Part Full Percentimage
  
  Percentimage="$Wizardcache/percent.png"
  Part="${1:-}"
  Full="${2:-1}"
  
  case "$Part" in
    idle) Percentimage="p_idle.png" ;;
    error) Percentimage="p_error.png" ;;
    *)
      Percent="$(( 100 * Part / Full ))"
      Percentimage="p_$Percent.png" 
    ;;
  esac
  Percentimage="$Percentcachedir/$Percentimage"

  [ -e "$Percentimage" ] || case "$Part" in
    idle)  convert -size 100x20 xc:transparent -fill black -pointsize 20 -gravity center -draw "text 0,0 'idle'"   "$Percentimage" ;;
    error) convert -size 100x20 xc:transparent -fill red   -pointsize 20 -gravity center -draw "text 0,0 'ERROR'"  "$Percentimage" ;;
    *)     convert -size 100x20 xc:transparent -fill green1 -draw "rectangle 0,0,$((Percent * 1)),20" -fill black -pointsize 20 -gravity center -draw "text 0,0 '${Percent}%'" "$Percentimage" ;;
  esac
  sendkaptain "cmdpercent('$Percentimage')=''"
}

parse_kaptainsignal() {
  local Kaptainsignal
  local Command Argument Functionmode Functionoption Stackdir Newstackdir Projecthome
  local Image
  
  Kaptainsignal="${1:-}"
  Stackdir="$(storeinfo dump stackshotdir)"
  Projecthome="$(storeinfo dump projecthome)"
  
  case $Kaptainsignal in
    refreshbutton) 
      #kaptain_update
      storeinfo drop showimage
      storeinfo "refreshgui_main=yes"
    ;;
    cmdbreak)
      worknote "Sending BREAK to current action"
      storeinfo "cmdbreak=yes"
    ;;
    choosedirguibutton)
      stackshot_selector &
    ;;
    opendirbutton)
      xdg-open "${Stackdir:-$Projecthome}" &
    ;;
    delete*) 
      cmd -f $(tr -d ":" <<< "$Kaptainsignal") -t "$Stackdir"
    ;;
    show_video*)
      Image="$(echo "$Kaptainsignal" | cut -d: -f2-)"
      Image="$Stackdir/video/*.$Image*"
      showimage "$(fileglob "$Image")"
    ;;
    showimage*)
      Image="$(cut -d: -f2 <<< "$Kaptainsignal")"
      showimage "$(fileglob "$Stackdir/evaluate/*$Image*")"
    ;;
    show*)
      showimage "$Stackdir/${Kaptainsignal#show}/*"
    ;;
    
    fuseconfig)
      fuse_config &
    ;;
    fuse*)
      Functionmode=$(askkaptain fusemodecombo)
      cmd -f $Kaptainsignal -t $Stackdir -m $Functionmode    
    ;;
    evaluatemagick|compose)
      cmd -f $Kaptainsignal -t $Stackdir
    ;;
    evaluatefuse)
      Functionoption=$(askkaptain evaluatecombo)
      cmd -f $Kaptainsignal -t "$Stackdir" -g "$(fuse_glob $Functionoption)"
    ;;
    sharpen_evaluate)
      cmd -f sharpenevaluate -o 3x1 -t "$Stackdir"
    ;;
    
    *magick|*compose|*evaluate|*fuse)
      Command="$Kaptainsignal"
      Command="${Command%magick}"
      Command="${Command%evaluate}"
      Command="${Command%evaluate}"
      Command="${Command%fuse}"
      Functionmode="$(askkaptain -c "${Command}modecombo")"
      Functionoption="$(askkaptain -c "${Command}combo")"
      case "$Command" in
        applyall) 
          Functionoption="$(getbatch1)"
          Kaptainsignal="wizard${Kaptainsignal#applyall}"
        ;;
        meanbalance)
          Functionoption="mean"
          Kaptainsignal="whitebalance${Kaptainsignal#meanbalance}"
        ;;
        animation)
          Functionmode="${Functionmode}:$(askkaptain "animationfusecombo")"
      esac
      Command="${Command%_}"
      
      cmd -f "$Kaptainsignal" -m "$Functionmode" -o "$Functionoption" -t "$Stackdir"
    ;;
    
    align_vidstabbutton)
      Functionoption="$(askkaptain "align_vidstabcombo")"
      cmd -f align_vidstab -m "10" -o "$Functionoption" -t "$Stackdir"
      cmd -f align_vidstab -m "5"  -o ""                -t "$Stackdir"
      cmd -f align_vidstab -m "1"  -o ""                -t "$Stackdir"
    ;;
    
    runbatch1) 
      runbatch1 "$Stackdir"
      note "Batch 1 is ready."
    ;;
    runbatch2) 
      runbatch2 "$Stackdir"
      note "Batch 2 is ready."
    ;;
    runbatch3) 
      runbatch3 "$Stackdir"
      note "Batch 3 is ready."
    ;;
    runbatchprocessing)
      askkaptain "runbatch1" >/dev/null && runbatch1 "$Stackdir"
      askkaptain "runbatch2" >/dev/null && runbatch2 "$Stackdir"
      askkaptain "runbatch3" >/dev/null && runbatch3 "$Stackdir"
      note "Batch all is ready."
    ;;
    *)
      failure "Unknown signal: $Kaptainsignal"
    ;;
  esac
}

## sub GUIs

stackshot_selector() {
  # GUI to choose stackshot. Preview of median images. Sorted by project dirs.
  local Button Argument
  local Dirlist Imagelist Dirarray
  local Allprojects Entrylist Projectimages Projectline
  local Projecthome Projectdir Oldprojectdir Cachedir
  local Count Dircount Dir Image
  local Refresh 
  local Windowwidth Windowheight Windowxpos Windowypos
  
  Cachedir="$(storeinfo dump cache)"

  Projecthome="$(storeinfo dump projecthome)"
  Projecthome="${1:-$Projecthome}"
  cd "$Projecthome"
  
  # check for running instance, raise window if yes
  storeinfo test stackshot_selector && {
    note "stackshot_selector is already running."
    xdotool search --name "stackshot selector" windowraise
    return
  }
  storeinfo "stackshot_selector=running"
  
  # generate empty X image for unfused stackshots
  Emptyimage=$Thumbnaildir/empty.png
  [ -e "$Emptyimage" ] || convert caption:X $Emptyimage
  
  # get list of stackshot dirs and median images
  Dirlist="$(find -name stackshot -type d | sed s%/stackshot%% | sort -V)"
  for Dir in $Dirlist; do
    Image="$(find $Dir/*fuse.median* 2>/dev/null | head -n1)"
    Imagelist="$Imagelist
$Image"
  done
  Imagelist="$(tail -n+2 <<< "$Imagelist")"
  Dircount="$(grep -c . <<< "$Dirlist")"

  Count=0
  for Dir in $Dirlist EOL ; do
    Count=$((Count +1))
    showpercent "$Count" "$Dircount"
    Dirarray[$Count]="$Projecthome/$(cut -d/ -f2- <<< "$Dir")"
    
    # generate thumbnail. Check existing thumbnail with md5
    Image="$(sed "${Count}q;d" <<< "$Imagelist")"
    Image="${Image:-$Emptyimage}"
    #Md5="$(md5sum "$Image" | cut -d' ' -f1)"
    Md5="$(md5sum <<< "$(ls --full-time "$Image")" | cut -d' ' -f1)"
    Destinationfile=$Thumbnaildir/$(basename "$Image").$Md5.png
    #[ -e "$Destinationfile" ] || convert "$Image" -resize 256x256 "$Destinationfile"
    [ -e "$Destinationfile" ] || {
      convert "$Image" -scale 256x256 "$Destinationfile"
      ### FIXME delete old thumbnail
    }
    
    # Check current project dir
    Projectdir="$(dirname $Dir)"

    # Checking a project dir is ready
    [ "$Projectdir" != "$Oldprojectdir" ] && {
      [ "$Projectline" ] && {
        # montage of all stackshot images in a project dir
        #Projectimages="$(sort <<< "$Projectimages")"
        Md5="$(cat $Projectimages | md5sum | cut -d' ' -f1)"
        Montagefile="$Thumbnaildir/$(basename $Projectdir).$Md5.png"
        [ -e "$Montagefile" ] || montage $Projectimages -tile x1 -geometry 100x100+5+5 $Montagefile
        
        # entry of subtree: montageimage + pjoject directory. Childs are stackshots.        
        Projectline="project$Count:tree '{$Montagefile}$Oldprojectdir' -> $Projectline"
        Allprojects="$Allprojects project$Count"
        Entrylist="$Entrylist
$Projectline ;"
      }
      
      [ "$Dir" = "EOL" ] && break
      
      Oldprojectdir="$Projectdir"
      Projectline=""
      Projectimages=""
      Montagefile=""
    }
    
    # add stackshot to subtree list
    Projectline="$Projectline stackshot$Count"
    
    # add stackshot
    Entrylist="$Entrylist
  stackshot$Count:beside '{$Destinationfile}$Dir' -> @button='Choose this stackshot';"
  
    # add image to montage list
    Projectimages="$Projectimages
$Image"
  done
  showpercent idle
 
  local Kaptaingrammarfile Kaptainpid Kaptainstdinfifo Kaptainstdoutfifo Kaptainsignal Kaptainstdin Kaptainstdout
  # prepare kaptain files and fifos
  Kaptaingrammarfile="$Cachedir/selector.kaptain.grammar"
  Kaptainstdinfifo="$Cachedir/selector.kaptain.stdin"
  Kaptainstdoutfifo="$Cachedir/selector.kaptain.stdout"
  mkfifo   $Kaptainstdinfifo
  mkfifo   $Kaptainstdoutfifo
  exec  {Kaptainstdin}<>$Kaptainstdinfifo
  exec  {Kaptainstdout}<>$Kaptainstdoutfifo
  
  echo "#! /usr/bin/kaptain
start 'fusewizard stackshot selector' -> frame1 frame2;
  frame1:tree -> $Allprojects ;
$Entrylist
  frame2:beside -> refresh windowpos close ;
    refresh     -> @button='Reload GUI' ;
    windowpos   -> @button='Reset window geometry' ;
    close       -> @button='Close' ;

" > $Kaptaingrammarfile

  kaptain --stdio $Kaptaingrammarfile <&${Kaptainstdin} >&${Kaptainstdout} & Kaptainpid=$!
  storepid $Kaptainpid
  for Count in $(seq 50); do
    read -t1 Line <&${Kaptainstdout}
    [ -z "$Line" ] && break
  done
    
  while ps -p $Kaptainpid >/dev/null; do
    read -t1 Kaptainsignal <&${Kaptainstdout}
    [ "$Kaptainsignal" ] && {
      echo $Kaptainsignal
      Button="$(cut -d: -f1 <<< "$Kaptainsignal")"
      Argument="$(cut -s -d: -f2- <<< "$Kaptainsignal")"
      case $Button in
        stackshot*)
          Count="${Button#stackshot}"
          Dir="${Dirarray[$Count]}"
          storeinfo "stackshotdir=$Dir"
          check_stackdir
          storeinfo "refreshgui_main=yes"
          storeinfo "refreshgui_fuse=yes"
        ;;
        windowpos)
          # check width of main window
          Windowgeometry="$(xdotool search --name "fusewizard $Version" getwindowgeometry)"
          Windowwidth="$(grep  Geometry <<< "$Windowgeometry" | rev | cut -d' ' -f1 | rev | cut -dx -f1)"
          Windowheight="$(grep Geometry <<< "$Windowgeometry"  | rev | cut -d' ' -f1 | rev | cut -dx -f2)"
          Windowxpos="$(grep   Position <<< "$Windowgeometry"| cut -d: -f2 | cut -d' ' -f2 | cut -d, -f1)"
          Windowypos="$(grep   Position <<< "$Windowgeometry"| cut -d: -f2 | cut -d' ' -f2 | cut -d, -f2)"
          xdotool search --sync --name "stackshot selector" windowsize $Windowwidth $Windowheight windowmove $Windowxpos $Windowypos
        ;;
        close) 
          break 
        ;;
        refresh) 
          Refresh="yes" 
          break
        ;;
      esac
    }
  done
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
  rm $Kaptainstdinfifo $Kaptainstdoutfifo
  storeinfo drop stackshot_selector
  [ "$Refresh" = "yes" ] && stackshot_selector
}

fuse_config() {
  
  local Kaptaingrammarfile Kaptainpid Kaptainstdinfifo Kaptainstdoutfifo Kaptainsignal Kaptainstdin Kaptainstdout
  local Cachedir Stackdir
  local Count Setcount Line Image Imagelist Commentfile Button Argument Currentfuse=1 Fusemode Fuseskip
  local Comment Commentfile
  local Formatline Formatlist Fusetoworkonlist Fusetoworkonline Setline Setlist Setcount
  
  Cachedir="$(storeinfo dump cache)"
  Commentfile="$Cachedir/exivcomment"
  
  storeinfo test fuse_config && {
    note "fuse_config is already running."
    xdotool search --name "enfuse settings" windowraise
    return 1
  }
  storeinfo "fuse_config=running"

  # prepare kaptain files and fifos
  Kaptaingrammarfile="$Cachedir/fuse.kaptain.grammar"
  Kaptainstdinfifo="$Cachedir/fuse.kaptain.stdin"
  Kaptainstdoutfifo="$Cachedir/fuse.kaptain.stdout"
  mkfifo   $Kaptainstdinfifo
  mkfifo   $Kaptainstdoutfifo
  exec  {Kaptainstdin}<>$Kaptainstdinfifo
  exec  {Kaptainstdout}<>$Kaptainstdoutfifo
  
  worknote "Preparing fuse GUI"
  
  # Prepare left columns of GUI
  Formatline="formatline ' ' -> "
  Fusetoworkonline="fusetoworkon 'all' -> "
  for Setcount in $(seq $Fusesetnumber); do
    Setline[$Setcount]="set${Setcount} 'set${Setcount}' -> "
  done
  for Count in $(seq $Fusemodenumber); do
    Formatline="$Formatline format$Count"
    Formatlist="$Formatlist
      format$Count -> @text=''; "
    
    Fusetoworkonline="$Fusetoworkonline fuse${Count} |"
    Fusetoworkonlist="$Fusetoworkonlist
      fuse${Count}:beside '$(fuse_getname $Count shortcut)' -> @string='$(fuse_getname $Count option)' ;"
    
    for Setcount in $(seq $Fusesetnumber); do
      Setline[$Setcount]="${Setline[$Setcount]} set${Setcount}_${Count}"
      Setlist[$Setcount]="${Setlist[$Setcount]}
        set${Setcount}_${Count}:beside -> @ | $(fuse_getvalue $Count set${Setcount} value) '' ;"
    done
  done
  Formatline="$Formatline ;"
  Fusetoworkonline="${Fusetoworkonline%"|"} ;"
  for Setcount in $(seq $Fusesetnumber); do
    Setline[$Setcount]="${Setline[$Setcount]} ;"
  done
  
  # grammar
  echo "#! /usr/bin/kaptain
start 'fusewizard enfuse settings' -> frameset;
  frameset:beside     -> leftframe rightframe ;
    leftframe:framed:beside    -> formatline fusetoworkon $(for Setcount in $(seq $Fusesetnumber); do echo set$Setcount; done) ;
    rightframe:framed   -> fusesettings @fill runfuseframe;
    
    $Formatline
      $Formatlist
    
    $Fusetoworkonline
      $Fusetoworkonlist
      
    $(for Setcount in $(seq $Fusesetnumber); do echo "
    ${Setline[$Setcount]}
      ${Setlist[$Setcount]}"
      done)
      
    fusesettings 'enfuse options' -> exposureweight saturationweight contrastweight entropyweight blendmask grayprojector text2 levels contrastwindowsize contrastmincurvature contrastedgescaleline exivcomment;
    
      exposureweight:beside        '--exposure-weight'            -> @combo('')='';
      saturationweight:beside      '--saturation-weight'          -> @combo('')='';
      contrastweight:beside        '--contrast-weight'            -> @combo('')='';
      entropyweight:beside         '--entropy-weight'             -> @combo('')='';

      blendmask:beside                                            -> @combo('')='' ;
      grayprojector:beside         '--gray-projector'             -> @combo('')='';
      levels:beside                '--levels'                     -> @combo('')='';
      
      text2 -> @text='Following options are most of interest to change.' ;
      contrastwindowsize:beside    '--contrast-window-size'       -> @combow('')='';
      contrastmincurvature:beside  '--contrast-min-curvature (%)' -> @combow('')='' ;
      contrastedgescaleline:beside '--contrast-edge-scale'        -> contrastedgescale lcescale lcefactor ;
        contrastedgescale                                           -> @combow('')='';
        lcescale                                                    -> @combow('')='';
        lcefactor                                                   -> @combow('')='';
      exivcomment                                                 -> @text='' ;
        
    runfuseframe 'fuse'  -> runfuseline ;
      runfuseline:beside -> runcombo runskip runbutton ;
        runcombo                                                    -> @combo('current',$Fusemodecombo)='current' ;
        runskip                    'fuse only missing'              -> 'skip' | ! '' ;
        runbutton                                                   -> @button='Run enfuse' ;
      
        
" > $Kaptaingrammarfile
  
  nl -ba $Kaptaingrammarfile
  
  kaptain --stdio $Kaptaingrammarfile <&${Kaptainstdin} >&${Kaptainstdout} & Kaptainpid=$!
  storepid $Kaptainpid
  for Count in $(seq 50); do
    read -t1 Line <&${Kaptainstdout}
    [ -z "$Line" ] && break
  done

  storeinfo "refreshgui_fuse=yes"
  while ps -p $Kaptainpid >/dev/null; do
    storeinfo test refreshgui_fuse && {
      storeinfo drop refreshgui_fuse
      Projectname="$(storeinfo dump projectname)"
      Stackdir="$(storeinfo dump stackshotdir)"
      Fusebasename="$Projectname.$(basename $Stackdir)"
      
      # Read and show exiv comment (contains enfuse options)
      Image="$(fileglob "$Stackdir/fuse/*$(fuse_getname $Currentfuse shortcut)*")"
      showimage "$Image" && Comment="$(exiv2 "$Image" | grep comment | cut -d: -f2-)" || Comment=""
      :> $Commentfile
      [ -e "$Image" ] && echo "$(basename $Image) was generated with:
        " >> "$Commentfile"
      for Line in $Comment; do
        echo "$Line" >> $Commentfile
      done
      sendkaptain "exivcomment=\`tail -n+1 $Commentfile\`"
      
      # mark existing images
      Imagelist="$(fileglob "$Stackdir/fuse/*fuse*")"
      for Count in $(seq $Fusemodenumber); do
        grep -q "\.$(fuse_getname $Count shortcut)\." <<< "$Imagelist" && sendkaptain "format$Count='x'" || sendkaptain "format$Count=' '"
      done
      
      # show current settings
      for Line in $Fusearguments; do
        sendkaptain "$(fuse_getvalue $Currentfuse $Line kaptain)"
      done
    }
    
    read -t1 Kaptainsignal <&${Kaptainstdout}
    
    [ "$Kaptainsignal" ] && {
      echo $Kaptainsignal
      
      Button="$(cut -d: -f1 <<< "$Kaptainsignal")"
      Argument="$(cut -d: -f2 <<< "$Kaptainsignal")"
      case $Button in
        fuse*)
          Currentfuse="${Kaptainsignal#fuse}"
          Currentfuse="${Currentfuse%:selected}"
          storeinfo "refreshgui_fuse=yes"
        ;;
        runbutton)
          Fusemode="$(askkaptain runcombo)"
          [ "$Fusemode" = "current" ] && Fusemode="$Currentfuse"
          Fuseskip="$(askkaptain runskip)"

          sendkaptain "runbutton='*** BUSY ***'"
          parse_cmd -f fuse -m "$Fusemode" -o "$Fuseskip" -t "$Stackdir"
          sendkaptain "runbutton='Run enfuse'"
          storeinfo "refreshgui_fuse=yes"
        ;;
        set*)
          case $Argument in
            on)  fuse_storevalue $(cut -d_ -f2 <<< "$Button") $(cut -d_ -f1 <<< "$Button") "!" ;;
            off) fuse_storevalue $(cut -d_ -f2 <<< "$Button") $(cut -d_ -f1 <<< "$Button") ""  ;;
          esac
        ;;
        *)
          fuse_storevalue $Currentfuse $Button $Argument
          sendkaptain "fuse$Currentfuse='$(fuse_getname $Currentfuse option)'"
        ;;
      esac
    }
  done
  
  exec {Kaptainstdin}>&- {Kaptainstdout}>&-
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
  storeinfo drop fuse_config
}

cropgeometry_interactive() {
  # Interactive dialog to choose a crop geometry
  #   $1   Image to crop.
  #   $2   Cache folder to store files. Clean up yourself.
  #   $3   Preset crop geometry (optional). Default: entire image
  # Result:
  #   return 0 : echo crop geometry WxH+X+Y
  #   return 1 : no output
  # Dependencies:
  #   imagemagick
  #   kaptain (https://github.com/mviereck/kaptain)

  local Kaptaingrammarfile Kaptainpid Kaptainstdinfifo Kaptainstdoutfifo Kaptainsignal Kaptainstdin Kaptainstdout
  local Image Imagempc Imagewidth Imageheight
  local CropX CropY CropW CropH Cropgeometry
  local Rotate
  local Refresh Stepsize Return
  local Cachedir Cropgeometryimage Cropimagempc
  
  Image="${1:-}"
  Cachedir="${2:-}"
  Cropgeometry="${3:-}"
  
  checkvar -e crop_interactive Image    "$Image"    || return 1
  checkvar -d crop_interactive Cachedir "$Cachedir" || return 1
  
  worknote "Interactive choice of crop geometry of $Image"
  
  Cropgeometryimage="$Cachedir/cropgeometry.gui.tif"
  Cropimagempc="$Cachedir/crop.mpc"
  
  # check source for mpc format, convert if not
  [ "$Image" = "${Image%.mpc}" ] && {
    Imagempc="$Cachedir/cropgeometry.source.mpc"
    convert "$Image" "$Imagempc"
  } || {
    Imagempc="$Image"
  }
  
  Stepsize=50
  Rotate=0
  Refresh="yes"

  Imagewidth=$(convert  -format '%w'  $Imagempc info:)
  Imageheight=$(convert -format '%h'  $Imagempc info:)
    
  grep -q "x" <<< "$Cropgeometry" && grep -q "+" <<< "$Cropgeometry" && {
    CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
    CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
    CropW=$(cut -dx -f1 <<< "$Cropgeometry")
    CropH=$(cut -dx -f2 <<< "$Cropgeometry")
    CropH=$(cut -d+ -f1 <<< "$CropH")
  } || {
    CropX=0
    CropY=0
    CropW=$((Imagewidth-1))
    CropH=$((Imageheight-1))
  }
  
  Kaptaingrammarfile="$Cachedir/crop.kaptain.grammar"
  Kaptainstdinfifo="$Cachedir/crop.kaptain.stdin"
  Kaptainstdoutfifo="$Cachedir/crop.kaptain.stdout"
  mkfifo   $Kaptainstdinfifo
  mkfifo   $Kaptainstdoutfifo
  exec  {Kaptainstdin}<>$Kaptainstdinfifo
  exec  {Kaptainstdout}<>$Kaptainstdoutfifo
  
  echo "#! /usr/bin/kaptain
start 'Choose geometry' -> frameset ;
  frameset:beside -> frameleft ;
    frameleft:framed  -> arrowline stepsizeframe rotateline geometryline buttonline cmdpercent;
    
  cmdpercent    -> @icon;
  
  arrowline:beside:framed -> arrowposframe arrowsizeframe ;
    arrowposframe 'Position:' -> arrowpos1 arrowpos2 arrowpos3;
      arrowpos1:beside -> @fill   postop    @fill;
      arrowpos2:beside -> posleft @fill     posright ;
      arrowpos3:beside -> @fill   posbottom @fill;
        posleft          -> @button=' < ';
        posright         -> @button=' > ';
        postop           -> @button=' ^ ';
        posbottom        -> @button=' v ';
    arrowsizeframe 'Size:' -> size1 size2 size3;
      size1:beside     -> @fill    sizetop    @fill;
      size2:beside     -> sizeleft @fill      sizeright ;
      size3:beside     -> @fill    sizebottom @fill;
        sizeleft         -> @button=' < ';
        sizeright        -> @button=' > ';
        sizetop          -> @button=' ^ ';
        sizebottom       -> @button=' v ';
    rotateline:beside 'Rotate:'  -> rotatecombo rotateapply trim;
      rotatecombo       -> @combow('0','0.5','-0.5','1','-1','1.5','-1.5','2','-2','2.5','-2.5','3','-3','5','-5','10','-10','45','-45','90','180','270')='0';
      rotateapply       -> @button='apply';
      trim              -> @button='trim';
  stepsizeframe 'Step size' -> stepsize1 stepsize2;
  stepsize1:beside  -> ss1  ss2   ss5   ss10  ss25 ;
  stepsize2:beside  -> ss50 ss100 ss250 ss500 ss1000 ;
    ss1           -> @button='1';
    ss2           -> @button='2';
    ss5           -> @button='5';
    ss10          -> @button='10';
    ss25          -> @button='25';
    ss50          -> @button='50';
    ss100         -> @button='100';
    ss250         -> @button='250';
    ss500         -> @button='500';
    ss1000        -> @button='1000';
  geometryline:beside -> geometry geometryapply;
    geometry:beside  'Crop geometry:'      -> @string='$Cropgeometry';
    geometryapply                          -> @button='apply';
  buttonline:beside -> ok cancel ;
    ok                                     -> @button=' OK' ;
    cancel                                 -> @close='Cancel';
" >> $Kaptaingrammarfile
  kaptain --stdio $Kaptaingrammarfile <&${Kaptainstdin} >&${Kaptainstdout} & Kaptainpid=$!

  Refresh="yes"
  while ps -p $Kaptainpid >/dev/null; do

    [ "$Refresh" = "yes" ] && {
      Cropgeometry="${CropW}x${CropH}+$CropX+$CropY"
      showpercent 10 100
      convert $Imagempc -background '#00000000' -rotate $Rotate +repage -fill none -stroke red -strokewidth 1 -draw "rectangle $CropX,$CropY $((CropX+CropW-1)),$((CropY+CropH-1))" "$Cropgeometryimage"
      showpercent 60 100
      showimage "$Cropgeometryimage"
      echo "geometry='$Cropgeometry'" >&${Kaptainstdin}
      Refresh="no"
      showpercent 100 100
    }

    Imagewidth=$(convert  -format '%w'  $Cropgeometryimage info:)
    Imageheight=$(convert -format '%h'  $Cropgeometryimage info:)
    
    read -t1 Kaptainsignal <&${Kaptainstdout}
    
    ifcmdbreak && Return=1 && break
    
    [ "$Kaptainsignal" ] && {
      Kaptainsignal="${Kaptainsignal%:pressed}"
      case $Kaptainsignal in
        posleft)    CropX=$((CropX-$Stepsize)) ;;
        posright)   CropX=$((CropX+$Stepsize)) ;;
        postop)     CropY=$((CropY-$Stepsize)) ;;
        posbottom)  CropY=$((CropY+$Stepsize)) ;;
        sizeleft)   CropW=$((CropW-$Stepsize)) ;;
        sizeright)  CropW=$((CropW+$Stepsize)) ;;
        sizetop)    CropH=$((CropH-$Stepsize)) ;;
        sizebottom) CropH=$((CropH+$Stepsize)) ;;
        ss*)        Stepsize="$(cut -c3- <<< "$Kaptainsignal")" ;;
        rotatecombo*) Rotate="$(cut -d: -f2 <<< "$Kaptainsignal")" ;;
        rotateapply) 
          echo "rotatecombo?" >&${Kaptainstdin}
          read Rotate <&${Kaptainstdout}
        ;;
        geometryapply)
          echo "geometry?" >&${Kaptainstdin}
          read Cropgeometry <&${Kaptainstdout}
          [ "$Cropgeometry" ] && {
            CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
            CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
            CropW=$(cut -dx -f1 <<< "$Cropgeometry")
            CropH=$(cut -dx -f2 <<< "$Cropgeometry")
            CropH=$(cut -d+ -f1 <<< "$CropH")
          }
        ;;
        trim)
          convert "$Imagempc" -background '#00000000' -rotate $Rotate +repage "$Cropimagempc"
          Cropgeometry="$(trim_hard "$Cropimagempc" "$Cropgeometry" )"
          [ "$Cropgeometry" ] && {
            CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
            CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
            CropW=$(cut -dx -f1 <<< "$Cropgeometry")
            CropH=$(cut -dx -f2 <<< "$Cropgeometry")
            CropH=$(cut -d+ -f1 <<< "$CropH")
          }
        ;;
        ok)         Return=0; break ;;
      esac
      [ "$CropX" -lt "0" ] && CropX=0
      [ "$CropY" -lt "0" ] && CropY=0
      [ "$CropW" -lt "1" ] && CropW=1
      [ "$CropH" -lt "1" ] && CropH=1
      [ "$CropX" -gt "$Imagewidth" ]  && CropX=$Imagewidth
      [ "$CropY" -gt "$Imageheight" ] && CropY=$Imageheight
      [ "$((CropX+CropW-1))" -gt "$Imagewidth" ]  && CropW=$((Imagewidth-CropX))
      [ "$((CropY+CropH-1))" -gt "$Imageheight" ] && CropH=$((Imageheight-CropY))
      Refresh="yes"
    }
  done 
  
  worknote "trim_hard(): final check"
  convert "$Imagempc" -background '#00000000' -rotate $Rotate +repage "$Cropimagempc"
  Cropgeometry="$(trim_hard "$Cropimagempc" "$Cropgeometry")" # final check
          
  exec {Kaptainstdin}>&- {Kaptainstdout}>&-
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
  [ "$Return" = "0" ] && {
    [ "$Rotate" = "0" ] && echo "$Cropgeometry" || echo "$Cropgeometry:$Rotate"
    return 0
  }
  return 1
}

#### headquarter

cmd() {
  local Arg Command
  
  #parse_cmd "$@"

  for Arg in "$@"; do
    Command="$Command '$Arg'"
  done
#  echo "$Command" >> $Commandstackfifo
  echo "$Command" >&${FDcmd}
}

ifcmdbreak() {
  storeinfo test cmdbreak && return 0 || return 1
}

stack_cmd() {
  local Command Commandpid Return
  while :; do
    read -t1 Command <&${FDcmd}
    eval set -- $Command 
    storeinfo test cmdbreak && {
      [ "$Command" ] || storeinfo drop cmdbreak
      Command=""
    }
    [ "$Command" ] && {
      eval set -- $Command 
      
      #sendkaptain "wizardcmd=' $*'"
      showpercent "0" "100"
      storeinfo "status=work"
      
      parse_cmd "$@"
      Return=$?
      
      case $Return in
        0)
          storeinfo "status=idle"
          showpercent idle
          #sendkaptain "wizardcmd=''"
        ;;
        *)
          storeinfo "status=error"
          showpercent error
          storeinfo "cmdbreak=yes"
        ;;
      esac
    }
  done
}

parse_cmd() {
  local $Batchlocal
  local Commandline Return= 

  verbose "parse_cmd(): $*"
  parse_batchoptions "$@" || return 1
  Commandline="$@"
    
  case "$Function" in
    deleteall)     myrmdir "$Targetdir"/*.bak "$Targetdir/cache" "$Targetdir/magick" "$Targetdir/compose" "$Targetdir/evaluate" "$Targetdir/fuse" "$Targetdir/video" ; Return=0 ;;
    #deletebackups) myrmdir "$Targetdir/cache" "$Targetdir"/*.bak ; Return=0 ;;
    deletebackups) myrmdir "$Targetdir"/*.bak ; Return=0 ;;
    delete*)       myrmdir "$Targetdir/${Function#delete}" "$Targetdir/${Function#delete}.bak" ; Return=0 ;;
   
    align_vidstab)
      batch_function -f align_vidstab -m "$Functionmode" -o "$Functionoption" -t "$Targetdir"
      Return=$?
    ;;
    animation*|brightness*|contrast*|crop*|cuberotate*|gamma*|kuwahara*|level*|prepare*|sharpen*|stretch*|undo*|whitebalance*|ruler*|video*|wizard*)
      Function="${Function%magick}"
      batch_function -f $Function -m "$Functionmode" -o "$Functionoption" -t "$Targetdir"
      Return=$?
    ;;
    evaluate*|compose*|fuse*)
      batch_function -f $Function -m "${Functionmode:-all}" -o "$Functionoption" -t "$Targetdir" -g "$Sourcefileglob"
      Return=$?
    ;;
    showimage)
      showimage "$Sourcedir/$Sourcefileglob"
      Return=0
    ;;
    *)
      failure "parse_cmd(): Unknown function: $Function"
    ;;
  esac
 
  #kaptain_update
  storeinfo "refreshgui_main=yes"

  case $Return in
    0) 
      historyentry "$Commandline"
      return 0
    ;;
    *) return ${Return:-1} ;;
  esac
}

#### main

declare_variables() {

  Wizardcache="$HOME/.cache/fusewizard"
  Wizardlocalshare="$HOME/.local/share/fusewizard"
  Percentcachedir="$Wizardlocalshare/percent"
  Thumbnaildir="$Wizardlocalshare/thumbnails"
  
  Configfile="$HOME/.config/fusewizardrc"
  
  Projecthome="$HOME/Bilder/ardustack"
  Gallerydir="$HOME/Gallery"
  
  Multicore_maxprocesses="$(nproc)"
  Multicore_maxprocesses="${Multicore_maxprocesses:-1}"
  for i in $Multicore_maxprocesses; do
    Multicore_process[$i]=""
    Multicore_image[$i]=""
    Multicore_memory[$i]="0"
  done
  Multicore_processcount=0
  Multicore_minram=250000
  Multicore_maxprocesses=$Multicore_maxprocesses
  
  Batchlocal="Targetdir Sourcedir Sourcefileglob Destinationdir Destinationfile Cachedir Function Functionmode Functionoption"
  Imagelocal="Image Imagelist Imagewidth Imageheight Imagecount Imagenumber Cropgeometry"

  Convert="convert -quality 100%"

  Commandstackfifo=$Wizardcache/commandstack
  
  Wizardlogfile=$Wizardcache/fusewizard.log
  Wizardlogfifo=$Wizardcache/fusewizard.log.fifo
  
  Wizardmessagefile=$Wizardcache/fusewizard.message.log
  Wizardmessagefifo=$Wizardcache/fusewizard.message.fifo
  
  Kaptaingrammarfile=$Wizardcache/kaptain.grammar
  Kaptainstdinfifo=$Wizardcache/kaptain.stdin 
  Kaptainstdoutfifo=$Wizardcache/kaptain.stdout
  Kaptainstdin=""
  Kaptainstdout=""
  
  Storeinfofile=$Wizardcache/store.info
  Storepidfile=$Wizardcache/store.pid
  Storefusefile=$Wizardlocalshare/fuse_storevalue
    
  Imgruler="$(command -v imgruler)"
  [ -z "$Imgruler" ] && Imgruler="$(dirname $0)/imgruler"
}

create_cachefiles() {
  mkdir -p $Wizardcache
  mkdir -p $Thumbnaildir
  mkdir -p $Percentcachedir
  
  mkfifo   $Wizardlogfifo
  :>       $Wizardlogfile

  mkfifo   $Kaptainstdinfifo
  exec  {Kaptainstdin}<>$Kaptainstdinfifo
  mkfifo   $Kaptainstdoutfifo
  exec  {Kaptainstdout}<>$Kaptainstdoutfifo

  mkfifo   $Wizardmessagefifo
  exec  {FDmessage}<>$Wizardmessagefifo
  :>       $Wizardmessagefile
  
  mkfifo   $Commandstackfifo
  exec  {FDcmd}<>$Commandstackfifo
  
  :>       $Storeinfofile
  :>       $Storepidfile
  
  touch    $Storefusefile
}

check_dependencies() {
  local Dependency
  for Dependency in kaptain convert enfuse ffmpeg geeqie viewnior $Imgruler; do
    command -v $Dependency >/dev/null || failure "Dependency $Dependency not found. Please install $Dependency."
  done
  ffmpeg 2>&1 | grep -q libvidstab || failure "Dependency libvidstab in ffmpeg not found. Please install ffmpeg with vidstab."
}

finish() {
  trap - EXIT
  while read Pid; do ### FIXME check command
    kill $Pid
  done <$Storepidfile
  exec {Kaptainstdin}>&-
  exec {Kaptainstdout}>&-
  rm -R $Wizardcache
  exit 0
}

main() {
  local Kaptainpid Kaptainsignal
  trap finish EXIT
  
  # init
  declare_variables
  create_cachefiles
  
  storeinfo "cache=$Wizardcache"
  storeinfo "projecthome=$Projecthome"
  storeinfo "stackshotdir=$Projecthome"
  storeinfo "gallerydir=$Gallerydir"
  storeinfo "status=idle"
  storeinfo "notfoundimage=$Thumbnaildir/notfound.jpg"
  storeinfo "rmcache=yes"
  
  [ -e "$Configfile" ] && source "$Configfile"
  
  fuse_declare

  # start kaptain
  kaptaingrammar > $Kaptaingrammarfile
  #nl -ba $Kaptaingrammarfile
  kaptain --stdio $Kaptaingrammarfile <&${Kaptainstdin} >&${Kaptainstdout} & Kaptainpid=$!
  storepid $Kaptainpid
  
  # messages
  showlog      & storepid $!
  showmessages & storepid $!
  exec 1>$Wizardlogfifo 2>&1
  stack_cmd    & storepid $!
  
  check_dependencies
  
#  kaptain_update
  storeinfo "refreshgui_main=yes"

  # watch signals of kaptain
  while ps -p $Kaptainpid >/dev/null; do
    storeinfo test refreshgui_main && {
      storeinfo drop refreshgui_main
      kaptain_update
    }
    read -t1 Kaptainsignal <&${Kaptainstdout}
    [ "$Kaptainsignal" ] && {
      echo "Signal from kaptain: $Kaptainsignal"
      grep -q ":on"      <<< "$Kaptainsignal" && Kaptainsignal=""
      grep -q ":off"     <<< "$Kaptainsignal" && Kaptainsignal=""
      grep -q "combo"    <<< "$Kaptainsignal" && Kaptainsignal=""
      grep -q ":pressed" <<< "$Kaptainsignal" && {
        Stackdir="$(askkaptain choosedir)"
        [ "$Stackdir" != "$(storeinfo dump stackshotdir)" ] && {
          check_stackdir "$Stackdir"
          storeinfo "refreshgui_main=yes"
          storeinfo "refreshgui_fuse=yes"
          #kaptain_update
        }
      }
      Kaptainsignal="${Kaptainsignal%:pressed}"
    }
    [ "$Kaptainsignal" ] && parse_kaptainsignal "$Kaptainsignal"
  done
}

main "$@"
finish

##### ToDo ####
# gamma=auto: apply mean gamma
# crop: Do not crop if geometry is same as image
# memory check for multicore fuse
# configuration dialog:
#  - project directory
#  - gallery directory
#  - number of threads
#  - checkbutton: "allow invalid directory structure"
# storepid(): store name, too, check in finish()
# cli support
# documentation in all functions
# Features:
#  - clean entire project home: cache, backup, magick (note in history)
# Fix:
#  ardustack - replace align_image_stack for median with vidstab
