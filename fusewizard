#! /bin/bash

#### Messages, Log

note() {
  echo "note: $(shortpath "$*")"    >> $Wizardmessagefifo
}

worknote() {
  echo "@work: $(shortpath "$*")"   >> $Wizardmessagefifo
}

warning() {
  echo "WARNING: $(shortpath "$*")" >> $Wizardmessagefifo
}

failure() {
  echo "Failure: $(shortpath "$*")" >> $Wizardmessagefifo
}

error() {
  echo "ERROR: $(shortpath "$*")"   >> $Wizardmessagefifo
}

historyentry() {
  local Historyfile
  Historyfile="$(storeinfo dump history)"
  [ "$Historyfile" ] && echo "$*" >> "$Historyfile"
}

storeinfo() {
  # store and provide pieces of information
  # replace entry if codeword is already present
  # Store as codeword=string:
  #   $1 codeword=string
  # Dump stored string:
  #   $1 dump
  #   #2 codeword
  # Drop stored string:
  #   $1 drop
  #   #2 codeword
  # Test for codeword: (return 1 if not found)
  #   $1 test
  #   $2 codeword
  #
  # note: sed -i causes file permission issues if called in container in Cygwin, compare ticket #187
  #       chmod 666 for $Sharefolder could probably fix that. (FIXME)
  #
  [ -e "$Storeinfofile" ] || return 1
  case "${1:-}" in
    dump) grep     "^${2:-}="   $Storeinfofile | sed "s/^${2:-}=//" ;;      # dump entry
    drop) sed -i  "/^${2:-}=/d" $Storeinfofile ;;                           # drop entry
    test) grep -q  "^${2:-}="   $Storeinfofile ;;                           # test for entry
    *)                                                                      # store entry
      sed -i "/^$(echo "${1:-}" | cut -d= -f1)=/d"     $Storeinfofile       # drop possible old entry
      echo "${1:-}"                                 >> $Storeinfofile
    ;;
  esac
}

storepid() {
  echo "${1:-}" >> $Storepidfile
  ### FIXME store command
}

showlog() {
  local Line
  while read Line; do
    echo "$Line"
    echo "$Line" >> $Wizardlogfile
  done < $Wizardlogfifo
}

showmessages() {
  local Line
  while read Line; do
    echo "$Line"
    echo "$Line" >> $Wizardmessagefile
#    sendkaptain 'wizardlog=`tail -n1 '$Wizardmessagefile'`'
    Line="${Line#note: }"
    Line="${Line#@work: }"
    sendkaptain "wizardlog='${Line}'"
  done <&${FDmessage}
}

shortpath() {
  LC_ALL=C sed "s!$Projecthome!.!g" <<< "${1:-}"
#  echo "${1:-}"
}

#### file operations

checkvar() {
  local Arg
  
  Arg="${1:-}"
  [ "$(cut -c1 <<< "$Arg")" = "-" ] && shift || Arg=""
  
  [ -z "${3:-}" ] && {
    failure "${1:-}: Variable ${2:-} is empty."
    return 1
  }
  
  case "$Arg" in
    -d) 
      [ -d "${3:-}" ] || {
        failure "${1:-}: ${2:-} is not a directory: ${3:-}"
        return 1
      }
    ;;
    -e) 
      [ -e "${3:-}" ] || {
        failure "${1:-}: ${2:-} does not exist: ${3:-}"
        return 1
      }
    ;;
  esac
  case "$Arg" in
    -D) 
      check_fileglob "${3:-}/*" || {
        failure "${1:-}: ${2:-}: directory is empty: ${3:-}"
        return 1
      }
    ;;
    -E) 
      [ -s "${3:-}" ] || {
        failure "${1:-}: ${2:-}: file is empty: ${3:-}"
        return 1
      }
    ;;
  esac
  return 0
}

myrm() {
  local Line
  for Line in "$@" ; do
    [ -e "$Line" ] && {
      worknote "rm: deleting $Line"
      rm -rf $Line
    }
  done
}

mymv() {
  check_fileglob "${1:-}" || {
    failure "mv: Source is empty: ${1:-}"
    return 1
  }
  [ -d "${2:-}" ] || {
    failure "mv: Target is not a directory: ${2:-}"
    return 1
  }
  worknote "mv: moving ${1:-} to ${2:-}"
  mv -f $(fileglob "${1:-}") "${2:-}"
}

mycp() {
  check_fileglob "${1:-}" || {
    failure "cp: Source is empty: ${1:-}"
    return 1
  }
  [ -d "${2:-}" ] || {
    failure "cp: Target is not a directory: ${2:-}"
    return 1
  }
  worknote "cp: copy ${1:-} to ${2:-}"
  cp $(fileglob "${1:-}") "${2:-}"
}

check_fileglob() {
  # check whether files exist for glob $1
  #[ -d "$1" ] && return 1
  [ -n "$(find ${1:-} -maxdepth 0 -type f -print -quit 2>/dev/null)" ]
}

check_dirglob() {
  # check whether directories exist for glob $1
  [ -f "${1:-}" ] && return 1
  [ -n "$(find ${1:-} -maxdepth 0 -type d -print -quit 2>/dev/null)" ]
}

fileglob() {
  # echos files only for glob $1
  local Path Glob Filelist
  
  [ -d "${1:-}" ] && {
    Path="${1:-}"
    Glob="*"
  } || {
    Path="$(dirname  "${1:-}")"
    Glob="$(basename "${1:-}")"
  }
  Path="$(realpath "$Path")"
  
  Filelist="$(find ${1:-} -maxdepth 0 -type f 2>/dev/null)"
  Filelist="$(sort -V <<< "$Filelist")"
  
  [ "$Filelist" ] && echo "$Filelist" || return 1
}

check_destinationfile() {
  local Destinationfile Function
  Destinationfile="${1:-}"
  Function="${2:-}"
  [ -e "$Destinationfile" ] && {
    #failure "$Function: Destination file already exists: $Destinationfile"
    failure "$Function: Destination file already exists: $(basename "$Destinationfile")"
    return 1
  }
  return 0
}

check_stackdir() {
  # Check $1 if it is a valid directory containing a subfolder stackshot
  local Stackdir Newstackdir Stackdirvalid Projectname Projecthome
  
  Stackdir="$(storeinfo dump stackshotdir)"
  Newstackdir="${1:-}"
  Newstackdir="${Newstackdir:-$Stackdir}"
  Newstackdir="${Newstackdir%/}"
  
  Projecthome="$(storeinfo dump projecthome)"
  
  [ -z "$Newstackdir" ]   && failure "No stackshot directory given." && return 1
  [ ! -d "$Newstackdir" ] && failure "Not a directory: $Newstackdir" && return 1
  
  [ -d "$Newstackdir/stackshot" ] && Stackdirvalid="yes" || Stackdirvalid="no"

  [ "$Stackdirvalid" = "no" ] && [ "${Newstackdir%/stackshot}" != "$Newstackdir" ] && {
    Newstackdir="${Newstackdir%/stackshot}"
    Stackdirvalid="yes"
  }
  
  storeinfo "stackshotdir=$Newstackdir"
  case "$Stackdirvalid" in
    yes)
      storeinfo "stackshotdir_valid=yes"
      storeinfo "history=$Newstackdir/wizard.history"

      grep -q "$Projecthome" <<< "$Newstackdir" && {
        Projectname="${Newstackdir#$Projecthome/}"
        Projectname="$(dirname "$Projectname")"
        [ "$Projectname" = "$(basename "$Newstackdir")" ] && Projectname=""
        [ "$Projectname" = "." ]                          && Projectname=""
      }
      [ "$Projectname" ] && storeinfo "projectdir=$Projecthome/$Projectname" || storeinfo drop projectdir
      [ -z "$Projecthome" ] && Projectname="np"
      [ -z "$Projectname" ] && Projectname="np"
      storeinfo "projectname=$Projectname"
      return 0
    ;;
    no)
      storeinfo drop stackshotdir_valid
      storeinfo drop history
      storeinfo "projectname=np"
      return 1
    ;;
  esac
}

setup_workdir() {
  # Detect possible source directories in $2 for function $1
  # Set up variables that can be used to call function $1
  # Usage:
  #   setup_workdir Function Targetdir
  # Args:
  #   Function       One of align, sharpen, fuse, median, min, max, mean, set
  #   Targetdir      Target directory [+glob] to check.
  #                  Can already be in an ardustack-structure or an arbitrary one.
  #                  Location of $Destinationdir depends on detected directory structure.
  #   Functionoption   Mode of Function
  # Sets variables:
  #   Sourcedir                 Source directory within $Targetdir
  #   Sourcefileglob            Glob to get files. Mostly just "*"
  #   Destinationdir            Recommended directory to store resulting images.
  #                             Often serves as source dir for following functions.
  #   Destinationfile   Possible prefix of destination file(s). Can be "", though.
  #   Targetcachedir            Cache folder
  #
  # Run in a loop to check for next possible source dir in Targetdir.
  # Returns 0 on success and 1 if nothing more is to do.
  #
  # Stores already checked source dirs of $Targetdir in $Sourcedirchecklist. 
  # -> Set Sourcedirchecklist="" before running a loop with setup_workdir().
  # Use local in calling function:
  #   local Sourcedir Sourcefileglob Destinationdir Destinationfile Targetptofile Targetcachedir Sourcedirchecklist

  local Targetdir Targetstackshotdir Targetnewdir Targetprevdir 
  local Targetmagickdir Targetfusedir Targetevaluatedir Targetcomposedir Targetcachedir
  local Projectname
  
  Function="${1:-}"
  Targetdir="${2:-}"
  Function="${Function%magick}"

  # Check if a glob like * is given
  check_fileglob "$Targetdir" && {
    Sourcefileglob="$(basename "$Targetdir")"
    Targetdir="$(dirname "$Targetdir")"
  }
  Sourcefileglob="${Sourcefileglob:-"*"}"
  Destinationdir=""
  Destinationfile=""

  Targetdir="$(realpath "$Targetdir")"
  [ -d "$Targetdir" ] || {
    failure "No target directory found. Please specify a target directory or make a stackshot.
  Wrong Target: $Targetdir"
    return 1
  }
  
  Projectname="$(storeinfo dump projectname)"
  
  [ -d "$Targetdir/stackshot" ]          && Targetstackshotdir="$Targetdir/stackshot" || Targetstackshotdir="$Targetdir"
  [ -d "$Targetdir/stackshot-median" ]   && Targetstackshotdir="$Targetdir/stackshot-median"
  Targetmagickdir="$Targetdir/magick"
  Targetfusedir="$Targetdir/fuse"
  Targetcomposedir="$Targetdir/compose"
  Targetevaluatedir="$Targetdir/evaluate"
  Targetvideodir="$Targetdir/video"
  
  Targetcachedir="$Targetdir/cache"
  myrm     "$Targetcachedir"
  mkdir -p "$Targetcachedir"
  Cachedir="$Targetcachedir"
  
  grep -q -- "fuse" <<< "$Function"      && Targetnewdir="$Targetfusedir"
  grep -q -- "compose" <<< "$Function"   && Targetnewdir="$Targetcomposedir"
  grep -q -- "evaluate" <<< "$Function"  && Targetnewdir="$Targetevaluatedir" 
  grep -q -- "animatedgif" <<< "$Function"  && Targetnewdir="$Targetvideodir" 
  [ "$Targetnewdir" ] || Targetnewdir="$Targetmagickdir"
  
  [ "$Targetnewdir" = "$Targetmagickdir" ] && {
    mkdir -p $Targetnewdir
    check_fileglob "$Targetmagickdir/$Sourcefileglob" || mycp "$Targetstackshotdir/$Sourcefileglob" "$Targetmagickdir"
  }
  
  Targetprevdir="$Targetnewdir.bak"

  # backup for undo, serving also as source for batch operations
  case $Function in
    undo*) ;;
    evaluate*) ;;
    animatedgif*) ;;
    *)
      mkdir -p $Targetprevdir
      check_fileglob "$Targetnewdir/*" && mymv "$Targetnewdir/*" "$Targetprevdir/"
    ;;
    
    #align*|brightness*|sharpen*|level*|contrast*|crop*|gamma*|stretch*|kuwahara*|prepare*|wizard*|whitebalance*)
    #  mkdir -p $Targetprevdir
    #  mymv "$Targetnewdir/*" "$Targetprevdir/"
    #;;
    #evaluate*|compose*|fuse)
    #  [ -e "$Targetnewdir" ] && {
    #    mkdir -p $Targetprevdir
    #    mymv "$Targetnewdir/*" "$Targetprevdir/"
    #  }
    #;;
  esac

  case $Function in
    fuse)
      Sourcedir="$Targetmagickdir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir")"
    ;;
      
    evaluate)
      Sourcedir="$Targetmagickdir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir").$(basename "$Sourcedir")"
    ;;
    evaluatefuse)
      Sourcedir="$Targetfusedir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir").$(basename "$Sourcedir")"
    ;;
    compose)
      Sourcedir="$Targetevaluatedir"
      Destinationdir="$Targetnewdir"
      #Destinationfile="$Projectname.$(basename "$Targetdir").$(basename "$Sourcedir")"
    ;;
    
    align*|brightness*|sharpen*|level*|contrast*|crop*|gamma*|stretch*|kuwahara*|prepare*|ruler*|wizard*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
      
    whitebalance*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
    
    animatedgif)
      Sourcedir="$Targetmagickdir"
      Destinationdir="$Targetnewdir"
      Destinationfile="$Projectname.$(basename "$Targetdir")"
    ;;
    
    undo*)
      Sourcedir="$Targetprevdir"
      Destinationdir="$Targetnewdir"
    ;;
    
    *)
      failure "setup_workdir(): Function not defined: $Function"
      return 1
  esac
  
  [ "$Sourcedir" = "$Targetmagickdir" ] && {
    mkdir -p $Targetmagickdir
    check_fileglob "$Targetmagickdir/$Sourcefileglob" || mycp "$Targetstackshotdir/$Sourcefileglob" "$Targetmagickdir"
  }
  check_fileglob "$Sourcedir/$Sourcefileglob" || {
    failure "setup_workdir(): No source found: $Sourcedir/$Sourcefileglob"
    return 1
  }
  
  [ "$Destinationdir" ] || {
    failure "setup_workdir(): Destinationdir not specified"
    return 1
  }
  mkdir -p "$Destinationdir"
  
  return 0
}

#### show images

generate_doubleimage() {
  local Leftimage Rightimage Destinationfile Commentleft Commentright
  
  Leftimage="${1:-}"
  Rightimage="${2:-}"
  Destinationfile="${3:-}"
  Commentleft="${4:-previous}"
  Commentright="${5:-new}"
  
#  montage -geometry +0+0 -label "$Commentleft" "$Leftimage" -label "$Commentright" -flop "$Rightimage" "$Destinationfile"
  montage -geometry +0+0 -label "$Commentleft" "$Leftimage" -label "$Commentright" "$Rightimage" "$Destinationfile"
}

showimage() {
  local Imagelist Image Shrinkimage
  Imagelist="$(fileglob "${1:-}")" >&2
  case $(grep -c . <<< "$Imagelist") in
    0) 
      failure "showimage: Not found: ${1:-}" 
      #sendkaptain "showimage('')=''" 
      #sendkaptain "showimagename=''"
      storeinfo drop showimage
    ;;
    1) 
      Image="$Imagelist"
      #Shrinkimage="$Wizardcache/showimage.png"
      #convert "$Image" -scale 800x800\> "$Shrinkimage" 
      #sendkaptain "showimage('$Shrinkimage')=''" 
      #sendkaptain "showimagename='$(shortpath "$Image")'"
      #storeinfo   "showimage=$Image"
      case "$(rev <<< "$Image" | cut -d. -f1)" in
        fig|4pm) showvideo "$Image" ;;
        *)       geeqie -t -r File:"$Image" ;;
      esac
    ;;
#    1) geeqie -t -r File:"$Imagelist" ;;
    *) viewnior           $Imagelist & ;;
  esac
}

showvideo() {
  ffplay -window_title "$(basename "${1:-}")" -loglevel error -loop 0 "${1:-}" & storepid $!
}

showimagehalf() {
  local Sourceimage Destinationimage
  local Cacheimage
  Sourceimage="${1:-}"
  Destinationimage="${2:-}"
  Cacheimage=$Wizardcache/diff.jpg
  $Convert $Sourceimage -crop 50%x100%+0+0 $Cacheimage.half.jpg
  composite -geometry +0+0 $Cacheimage.half.jpg $Destinationimage $Cacheimage
  showimage $Cacheimage
}

showimagediff() {
  local Leftimage Rightimage Commentleft Commentright
  local Cacheimage
  
  Leftimage="${1:-}"
  Rightimage="${2:-}"
  Commentleft="${3:-previous}"
  Commentright="${4:-new}"
  
  Cacheimage="$Wizardcache/diff.jpg"
  
  generate_doubleimage "$Leftimage" "$Rightimage" "$Cacheimage" "$Commentleft" "$Commentright"
  showimage "$Cacheimage"
}

showimage_gui() {

  local Kaptaingrammarfile Kaptainpid Kaptainstdinfifo Kaptainstdoutfifo Kaptainsignal
  local Image
  
  Image="$Wizardcache/showimage.tif"
  
  Kaptaingrammarfile="$Cachedir/crop.kaptain.grammar"
  Kaptainstdinfifo="$Cachedir/crop.kaptain.stdin"
  Kaptainstdoutfifo="$Cachedir/crop.kaptain.stdout"
  mkfifo   $Kaptainstdinfifo
  mkfifo   $Kaptainstdoutfifo
  exec {FDin}<>$Kaptainstdinfifo
  exec {FDout}<>$kaptainstdoutfifo
  
#  kaptain --stdio $Wizardcache/test.kaptn <&${FDin} >&${FDout} &
  
  echo "#! /usr/bin/kaptain
start 'View image stack' -> image directoryline resultline;
  image -> @icon('$Cropimage');
  directoryline -> stackshot magick;
    stackshot     -> @button='stackshot';
    magick        -> @button='magick';
  resultline    -> fusemedian fusemean fusemin fusemax;
    fusemedian    -> @button='fuse.median';
    fusemean      -> @button='fuse.median';
    fusemin       -> @button='fuse.median';
    fusemax       -> @button='fuse.median';
" >> "$Kaptaingrammarfile"
  kaptain --stdio "$Kaptaingrammarfile" <&${FDin} >&${FDout} & Kaptainpid=$!

  while ps -p $Kaptainpid >/dev/null; do
    [ "$Refresh" = "yes" ] && {
      echo "image('$Image')='x'" >${FDin}
      Refresh="no"
    }

    read -t1 Kaptainsignal <&${FDout}
    
    [ "$Kaptainsignal" ] && {
      Kaptainsignal="${Kaptainsignal%:pressed}"
      case $Kaptainsignal in
        ok)         Return=0; break ;;
      esac
      Refresh="yes"
    }
  done 
  
  exec ${FDin}>&- ${FDout}>&-
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
  return 0
}

#### image batch processing

batch_function() {
  # Apply image processing function $1 on all possible source dirs in target directory $2, options in $3
  
  local $Batchlocal
  local Sourcedirchecklist Return=0
  local Gallerydir
    
  parse_batchoptions "$@"  || return 1
  storeinfo test stackshotdir_valid || return 1
  
  checkvar -d batch Targetdir "$Targetdir" || return 1
  checkvar    batch Function  "$Function"  || return 1
  
  ifcmdbreak && return 1
  
  setup_workdir "$Function" "$Targetdir" || {
    failure "batch $Function: no source found in $Targetdir
    $@"
    return 1
  }
  cd "$Targetdir"
  
  case $Function in
    compose|evaluate|fuse) ;;
    *)
      Function="${Function%magick}"
      Function="${Function%compose}"
      Function="${Function%evaluate}"
      Function="${Function%fuse}"
    ;;
  esac
  Function="${Function%_}"
  
  case "$Function" in
    brightness|contrast|gamma|kuwahara|level|prepare|sharpen|stretch|wizard)
      Functionmode="$Function"
      Function="wizard"
    ;;
  esac
  
  checkvar           -D $Function Sourcedir      "$Sourcedir"        || return 1
  checkvar           -d $Function Destinationdir "$Destinationdir"   || return 1
  case $Function in
    undo|compose) ;;
    *) checkvar         $Function Sourcefileglob "$Sourcefileglob"   || return 1 ;;
  esac
  case $Function in
    wizard) checkvar    $Function Functionmode   "$Functionmode"     || return 1 ;;
  esac
  case $Function in
    align*|crop|undo|whitebalance)
      checkvar       -d $Function Cachedir       "$Cachedir"         || return 1 ;;
  esac
  
  [ -z "$Functionmode" ] && case "$Function" in
    compose|evaluate|fuse) Functionmode="all" ;;
  esac
  
  note "$Function $Functionmode $Functionoption"
  storeinfo "cmd=$@"
  storeinfo "cmd_source=$Sourcedir"
  storeinfo "cmd_destination=$Destinationdir"
  storeinfo "cmd_cache=$Cachedir"
  cd "$Cachedir"
  $Function -m "$Functionmode" -o "$Functionoption" -s "$Sourcedir" -g "$Sourcefileglob" -d "$Destinationdir" -b "$Destinationfile" -c "$Cachedir"
  Return=$?
  cd "$Targetdir"
  storeinfo drop cmd
  storeinfo drop cmd_source
  storeinfo drop cmd_destination
  storeinfo drop cmd_cache
  
  [ "$Return" = "0" ] && {
    note "Ready: $Function $Functionmode $Functionoption"
  } || {
    failure "ERROR in $Function $Functionmode $Functionoption: $(basename "$Sourcedir") -> $(basename "$Destinationdir")"
    case $Function in
      animatedgif) ;;
      compose|evaluate|fuse) undo -s "$Destinationdir.bak" -d "$Destinationdir" -c "$Cachedir" ;;
      *)                     undo -s "$Sourcedir"          -d "$Destinationdir" -c "$Cachedir" ;;
    esac
  }
  
  [ "$Return" = "0" ] && [ "$(basename "$Destinationdir")" = "evaluate" ] && {
    ls $Destinationdir/*fuse.median* >/dev/null 2>&1 && {
      [ -d "$Destinationdir/../stackshot" ] && {
        # link fuse.median result into parent directory
        ln -f $(fileglob "$Destinationdir/*fuse.median*") "$Destinationdir/../"
        # link into project dir
        ln -f $(fileglob "$Destinationdir/*fuse.median*") "$Destinationdir/../../"
      }
      # link fuse.median result into $Gallerydir directory
      Gallerydir="$(storeinfo dump gallerydir)"
      [ -d "$Gallerydir" ] && ln -f $(fileglob "$Destinationdir/*fuse.median*") "$Gallerydir"
    }
  }
  
  return $Return
}

parse_batchoptions() {
  # To be called by batch functions to parse options.
  # Include this local line in the calling function:
  #   local Targetdir Sourcedir Sourcefileglob Destinationdir Destinationfile Cachedir Function Functionmode Functionoption

  local Shortoptions Longoptions Parsedoptions
  Shortoptions="b:c:d:f:g:m:o:s:t:"
  Longoptions=""

  Parsedoptions="$(getopt --options "$Shortoptions" --longoptions "$Longoptions" --name "$0" -- "$@" )"
  eval set -- "$Parsedoptions"

  while [ $# -gt 0 ] ; do
    case "${1:-}" in
      -t) Targetdir="${2:-}" ;;
      -s) Sourcedir="${2:-}" ;;
      -g) Sourcefileglob="${2:-}" ;;
      -d) Destinationdir="${2:-}" ;;
      -b) Destinationfile="${2:-}" ;;
      -c) Cachedir="${2:-}" ;;
      -f) Function="${2:-}" ;;
      -m) Functionmode="${2:-}" ;;
      -o) Functionoption="${2:-}" ;;
      --) ;;
      *) failure "Unbekannte Option ${1:-} ($Function)" ;;
    esac
    #[ "${1:-}" != "--" ] && [ -z "${2:-}" ] && failure "Option ${1:-} has no argument ($Function)" && return 1
    shift
    shift
  done

  [ "$Sourcefileglob" ] || Sourcefileglob="*"
  #[ ! -d "$Sourcedir" ]      && failure "$Function: source dir not found: $Sourcedir" && return 1
  #[ ! -d "$Destinationdir" ] && failure "$Function: destination dir not found: $Destinationdir"&& return 1
  #! check_fileglob "$Sourcedir/$Sourcefileglob" && failure "$Function: No source files found: $Sourcedir/$Sourcefileglob"  && return 1
  return 0
}

getbatch1() {
  local Command= Line Argument
  for Line in contrast sharpen kuwahara brightness gamma level stretch wizard; do
    Argument="$(askkaptain "$Line")"
    case $Line in
      brightness) Line="-brightness-contrast" ;;
      contrast)   Line="-sigmoidal-contrast" ;;
      sharpen)    Line="-adaptive-sharpen" ;;
      stretch)    Line="-contrast-stretch" ;;
      wizard)     Line="" ;;
      *)          Line="-$Line" ;;
    esac
    case $Argument in
      "") ;;
      auto) Command="$Command -auto$Line" ;;
      *)    Command="$Command $Line $Argument" ;;
    esac
  done
  echo "$Command"
}

getfunctionsettings() {
  Functionmode="$(askkaptain ${Function}modecombo)"
  Functionoption="$(askkaptain ${Function}combo)"
}

runbatch1() {
  local Function Functionmode Functionoption Stackdir
  Stackdir="${1:-}"
  askkaptain crop > /dev/null && {
    Function="crop"
    getfunctionsettings
    cmd -f "$Function" -m "$Functionmode" -o "$Functionoption" -t "$Stackdir"
  }
  cmd -f wizard -o "$(getbatch1)" -t "$Stackdir"
}

runbatch2() {
  local Function Functionmode Functionoption
  local Iterate
  for Function in whitebalance gamma_ align_vidstab1 align_vidstab2 align_vidstab3 ; do
    askkaptain $Function > /dev/null && {
      getfunctionsettings
      Function="$(tr -c -d "a-z_" <<< "$Function")"  # remove 1 2 3 from align_vidstab
      cmd -f "$Function" -m "$Functionmode" -o "$Functionoption" -t "$Stackdir"
    }
  done
  return 0
}

runbatch3() {
  askkaptain fuse >/dev/null             && cmd -f fuse -m all -t "$Stackdir"
  askkaptain evaluate >/dev/null         && {
    cmd -f evaluate     -m all -t "$Stackdir"
    cmd -f evaluatefuse -m all -t "$Stackdir"
  }  
  askkaptain sharpen_evaluate >/dev/null && cmd -f sharpenevaluate -o 3x1 -t "$Stackdir"
  askkaptain compose >/dev/null          && cmd -f compose -t "$Stackdir"
  
  cmd -f showimage -s "$Stackdir/evaluate" -g "*fuse.median*"
}

#### image sequence operations

align_vidstab() {
  local $Batchlocal
  local Sourcefilelist Imagelist Destinationfile Sourcefile
  local Image Imagewidth Imageheight
  local CropW CropH CropX CropY Cropgeometry Zoom
  local Cropinteractive 
  local Shakiness Stepsize
  local Xoffset Xoffsetrelative Xoffsetlist Yoffset Yoffsetrelative Yoffsetlist Radians Radiansrelative Radianslist Degree 
  local Framedir Motionsfile Rotatedir Rotateminimage 
  local Count Imagecount

  parse_batchoptions "$@" || return 1
  
  cd $Cachedir
  
  Shakiness="$Functionmode"
  Shakiness="${Shakiness:-1}"
  Cropinteractive="$Functionoption"
  [ "$Cropinteractive" ] && Cropinteractive="yes"
  Stepsize=6
  
  Framedir="$Cachedir/frames"
  mkdir -p "$Framedir"
  
  crop -m even -s "$Sourcedir" -g "$Sourcefileglob" -d "$Framedir"

  Sourcefilelist=$Cachedir/align.source.list
  :> $Sourcefilelist
  
  Imagelist="$(fileglob "$Framedir/$Sourcefileglob")"
  for Image in $Imagelist; do
    echo "file $Image" >>$Sourcefilelist
  done
  Imagecount="$(grep -c . <<< "$Imagelist")"

  worknote "align_vidstab: generating 1. video from images"
  ffmpeg -y -hide_banner -nostdin -safe "0" -f "concat" -i "$Sourcefilelist" \
         -vcodec "libx264" -profile:v "high444" -refs "16" -crf "0" -preset "ultrafast" \
         "$Cachedir/align.orig.mp4" || return 1
  ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.orig.mp4"
  showpercent 1 100
  ifcmdbreak && return 1
  
  worknote "align_vidstab: Splitting generated 1. video into .png images"
  rm $Framedir/*
  ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.orig.mp4" "$Framedir/sourceimg%04d.png" || return 1
  showpercent 2 100
  ifcmdbreak && return 1

  :> $Sourcefilelist
  Imagelist="$(fileglob "$Framedir/*")"
  for Image in $Imagelist; do
    echo "file $Image" >>$Sourcefilelist
  done
  
  worknote "align_vidstab: generating 2. video from .png images"
  ffmpeg -y -hide_banner -nostdin -f image2 -start_number 1 -i $Framedir/sourceimg%04d.png -safe "0" -vframes 1000 -vcodec libx264 -crf 25  -pix_fmt yuv420p "$Cachedir/align.source.mp4" || return 1
  showpercent 3 100
  ifcmdbreak && return 1

  worknote "align_vidstab: Analyzing video with shakiness=$Shakiness"
  ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.source.mp4" \
         -vf "vidstabdetect=shakiness=$Shakiness:accuracy=15:mincontrast=0.1:stepsize=$Stepsize:show=1:result=$Cachedir/transforms$Shakiness.trf" \
         "$Cachedir/align.vidstab-show.mp4" || return 1
  ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.vidstab-show.mp4"
  showpercent 4 100
  ifcmdbreak && return 1
            
  worknote "align_vidstab: Transforming video with shakiness=$Shakiness"
  ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.source.mp4" \
         -vf "vidstabtransform=optzoom=0:smoothing=0:interpol=bicubic:relative=1:crop=black:debug=1:input=$Cachedir/transforms$Shakiness.trf,unsharp=5:5:0.8:3:3:0.4" \
         "$Cachedir/align.result.mp4" || return 1
  ffplay -autoexit -exitonkeydown -exitonmousedown -loglevel quiet "$Cachedir/align.result.mp4"
  showpercent 5 100
  ifcmdbreak && return 1

  worknote "align_vidstab: Splitting aligned video into images (shakiness=$Shakiness)"
  rm $Framedir/*
  ffmpeg -y -hide_banner -nostdin -i "$Cachedir/align.result.mp4" "$Framedir/alignimg%04d.tif" || return 1
  showpercent 6 100
  ifcmdbreak && return 1
      
  Imagelist="$(fileglob "$Framedir/*")"
  Image="$(head -n1 <<< "$Imagelist")"
  Imagewidth=$(convert  -format '%w'  $Image info:)
  Imageheight=$(convert -format '%h'  $Image info:)
      
  Motionsfile="$Cachedir/global_motions.trf"

  Xoffsetlist="$(cat $Motionsfile | grep -v '#' | awk '{print $2}')"
  Yoffsetlist="$(cat $Motionsfile | grep -v '#' | awk '{print $3}')"
  Radianslist="$(cat $Motionsfile | grep -v '#' | awk '{print $4}')"
      
  Rotatedir="$Cachedir/rotate"
  mkdir -p "$Rotatedir"
      
  worknote "align_vidstab: Cutting of black border (shakiness=$Shakiness)"
  Count=0
  for Image in $Imagelist; do
    Count="$((Count + 1))"
    Xoffsetrelative="$(sed "${Count}q;d" <<<"$Xoffsetlist")"
    Xoffset="$(awk "BEGIN { print $Xoffset + $Xoffsetrelative }")"
    Yoffsetrelative="$(sed "${Count}q;d" <<<"$Yoffsetlist")"
    Yoffset="$(awk "BEGIN { print $Yoffset + $Yoffsetrelative }")"
    Radiansrelative="$(sed "${Count}q;d" <<<"$Radianslist")"
    Radians="$(awk "BEGIN { print $Radians - $Radiansrelative }")"
    Degree="$(awk  "BEGIN { print $Radians * 180 / 3.141592652}")"
        
    Destinationfile="$Rotatedir/rotate$Count.png"
    multicore "$Convert -size ${Imagewidth}x${Imageheight} xc:transparent -fill white -stroke white \
               -draw 'translate $((Imagewidth/2)),$((Imageheight/2)) \
                      rotate $Degree \
                      polygon $(awk "BEGIN {print -$Imagewidth/2  +$Xoffset}"),$(awk "BEGIN {print -$Imageheight/2 +$Yoffset}") \
                              $(awk "BEGIN {print +$Imagewidth/2  +$Xoffset}"),$(awk "BEGIN {print -$Imageheight/2 +$Yoffset}") \
                              $(awk "BEGIN {print +$Imagewidth/2  +$Xoffset}"),$(awk "BEGIN {print +$Imageheight/2 +$Yoffset}") \
                              $(awk "BEGIN {print -$Imagewidth/2  +$Xoffset}"),$(awk "BEGIN {print +$Imageheight/2 +$Yoffset}") \
                              $(awk "BEGIN {print -$Imagewidth/2  +$Xoffset}"),$(awk "BEGIN {print -$Imageheight/2 +$Yoffset}") '\
               $Image -evaluate-sequence min $Destinationfile" "$Destinationfile" || return 1
    showpercent "$Count" "$Imagecount"
  done
  multicore_wait || return 1
      
#  Rotateminimage="$Cachedir/rotate.min.png"
  Rotateminimage="$Cachedir/rotate.min.mpc"
  convert $(fileglob "$Cachedir/rotate/*") -evaluate-sequence min "$Rotateminimage" || return 1
  case $Cropinteractive in
    yes) notify-send "align_vidstab(): Ready for interactive crop"
         Cropgeometry="$(cropgeometry_interactive "$Rotateminimage" "$Cachedir")" || return 1 ;;
    *)   Cropgeometry="$(trim_hard "$Rotateminimage" "$Cropgeometry")" || return 1 ;;
  esac
      
  Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
  Rotate="${Rotate:-0}"
  Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
  Cropgeometry="$(calc_evengeometry "$Cropgeometry")"
      
  [ "$Cropgeometry" ] || {
    failure "align_vidstab: crop geometry is empty"
    return 1
  }
      
  worknote "align_vidstab: Cropping aligned images to $Cropgeometry (shakiness=$Shakiness)"
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Count=0
  for Image in $(fileglob "$Rotatedir/*"); do
    Count="$((Count+1))"
    Destinationfile="$(sed "${Count}q;d" <<< "$Imagelist")"
    Destinationfile="$Destinationdir/$(basename "$Destinationfile")"
    multicore "$Convert $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || return 1
    showpercent "$Count" "$Imagecount"
  done
  multicore_wait || return 1
            
  showimage "$Rotateminimage.trim_hard.png"
  return 0    
}

animatedgif() {
  # Generate animated GIF from stackshot.
  # Helps to visualize diferent layers and gives some 3D effect
  #
  # Fusemode       See fuse(). ($Functionmode)
  # Distortion     Distortion between lowest and highest layer. ($Functionoption)
  # Delay          Delay between frames
  # Staticlayer    Relative position of static layer that won't move. 0 means lowest layer, 1/2 means middle layer, 1 means top layer
  #
  local $Batchlocal
  local Fusemode Distortion Delay Sequence Staticlayer
  local Distortdir Distortimage Destinationfile Destinationfilebasename Imagebasename
  local Imagewidth Imageheight Cropgeometry
  local Count Iteration Xpos Ypos
  local Image Imagelist
  local Xpos Ypos Offset Border 
  local Position Positionlist Positionnumber
  local Sequence Sequencename Sequencenumber
  
  parse_batchoptions "$@" || return 1
  
  Fusemode="${Functionmode:-1}"
  Distortion="${Functionoption:-10}"
  Delay="10"
  Staticlayer="1/4"
  
  # Position raster
  #
  # -3x-3 -3x-2 -3x-1  -3x0   -3x1  -3x2  -3x3
  #
  # -2x-3 -2x-2 -2x-1  -2x0   -2x1  -2x2  -2x3
  #
  # -1x-3 -1x-2 -1x-1  -1x0   -1x1  -1x2  -1x3
  #
  #  0x-3  0x-2  0x-1   0x0    0x1   0x2   0x3
  #
  #  1x-3  1x-2  1x-1   1x0    1x1   1x2   1x3
  #
  #  2x-3  2x-2  2x-1   2x0    2x1   2x2   2x3
  #
  #  3x-3  3x-2  3x-1   3x0    3x1   3x2   3x3

  Rendermode=smooth
  case $Rendermode in
    smooth)
      Sequencenumber="5"
      Raster="3"
  
      Sequencename[1]="knot_small"
      Sequence[1]="0x0  0x-1 -1x-1 -1x0  
                   0x0  1x0   1x1   0x1
                   0x0  0x-1  1x-1  1x0
                   0x0 -1x0  -1x1   0x1"
            
      Sequencename[2]="dagaz"
      Sequence[2]="0x0  -1x1 -2x2 -3x3
                  -2x3  -1x3  0x3  1x3   2x3   3x3
                   2x2   1x1  0x0 -1x-1 -2x-2 -3x-3
                  -2x-3 -1x-3 0x-3 1x-3  2x-3  3x-3
                   2x-2  1x-1"
            
      Sequencename[3]="knot"
      Sequence[3]="0x0 -1x0 -2x0 -3x-1 -3x-2 -2x-3 -1x-3 0x-2 0x-1
                   0x0  0x1  0x2  1x3   2x3   3x2   3x1  2x0  1x0
                   0x0 -1x0 -2x0 -3x1  -3x2  -2x3  -1x3  0x2  0x1
                   0x0  0x-1 0x-2 1x-3  2x-3  3x-2  3x-1 2x0  1x0"
            
      Sequencename[4]="circle_left"
      Sequence[4]="-3x0 -3x1  -2x2  -1x3  0x3  1x3  2x2  3x1  3x0 3x-1 2x-2 1x-3 0x-3 -1x-3 -2x-2 -3x-1"
            
      Sequencename[5]="circle_right"
      Sequence[5]="-3x0 -3x-1 -2x-2 -1x-3 0x-3 1x-3 2x-2 3x-1 3x0 3x1  2x2  1x3  0x3  -1x3  -2x2  -3x1"
    ;;
    quick)
      Sequencenumber="3"
      Raster="1"
    
      Sequencename[1]="knot_quick"
      Sequence[1]="0x0  0x-1 -1x-1 -1x0  
                   0x0  1x0   1x1   0x1
                   0x0  0x-1  1x-1  1x0
                   0x0 -1x0  -1x1   0x1"
                   
      Sequencename[2]="dagaz_quick"
      Sequence[2]="0x0  -1x-1 -1x0 -1x1 0x0 1x-1 1x0 1x1"
      
      Sequencename[3]="circle_quick"
      Sequence[3]="-1x-1 -1x0 -1x1 0x1 1x1 1x0 1x-1 0x-1"
    ;;
  esac
  
  
  
  # Revert image list to work from bottom to top
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagelist="$(sort -V -r <<< "$Imagelist")"
  Imagenumber="$(grep -c . <<< "$Imagelist")"
  
  # crop lost borders
  Imagewidth=$($Convert  -format '%w'  "$(head -n1 <<< "$Imagelist")" info:)
  Imageheight=$($Convert -format '%h'  "$(head -n1 <<< "$Imagelist")" info:)
  Border="$((Distortion - Distortion * $Staticlayer))"  # wrong result if Staticlayer>1/2 ?
#  Cropgeometry="$((Imagewidth - Border * 2 - 1))x$((Imageheight - Border * 2 - 1))+$Border+$Border"
  Cropgeometry="$((Imagewidth - Border * 2 - 1))x$((Imageheight - Border * 2 - 1))"

  Destinationfilebasename="${Destinationfile:-animated}"
  
  # offset factor, distortion between neighboured layers
  Offset="$(awk "BEGIN {print $Distortion / ( $Imagenumber * $Raster ) }")"
  
  
  for Sequencecount in $(seq $Sequencenumber); do
    for Position in ${Sequence[$Sequencecount]}; do
      Positionlist="$Positionlist
$Position"
    done
  done
  Positionlist="$(grep x <<< "$Positionlist")"
  Positionlist="$(sort <<< "$Positionlist" | uniq)"
  Positionnumber="$(grep -c . <<< "$Positionlist")"
    
  # Distort images
  Iteration=0
  for Position in $Positionlist; do
    Xpos="$(cut -dx -f1 <<< "$Position")"
    Ypos="$(cut -dx -f2 <<< "$Position")"
    worknote "animatedgif: Distorting images for position ${Xpos}x${Ypos}."
      
    Distortdir="$Cachedir/distort.$Position"
    [ -d "$Distortdir" ] || {
      mkdir -p "$Distortdir"
      
      Count=-$((Imagenumber * $Staticlayer))  # negative start value causes movement of lowest layer
      
      for Image in $Imagelist; do
        Count="$((Count +1))"
        Distortimage="$Distortdir/$(basename $Image)"
        multicore "convert $Image -gravity center -crop $Cropgeometry+$(awk "BEGIN {print $Count * $Xpos * $Offset}")+$(awk "BEGIN {print $Count * $Ypos * $Offset}") $Distortimage" "$Distortimage" || return 1
      done

      Iteration=$((Iteration + 1))
      showpercent $Iteration $((Positionnumber*2 +5))
    }
  done
  multicore_wait || return 1
  
  # fuse distorted images
  for Position in $Positionlist; do
    Iteration=$((Iteration + 1))
    Distortdir="$Cachedir/distort.$Position"
    Imagebasename="animate.$Position"
    multicore "fuse -s $Distortdir -g '*' -d $Cachedir -b $Imagebasename -m $Fusemode" || return 1
    showpercent $Iteration $((Positionnumber*2 +5))
  done
  multicore_wait || return 1
  
  for Count in $(seq $Sequencenumber); do
    Iteration=$((Iteration + 1))
    Imagelist=""
    for Position in ${Sequence[$Count]}; do
      Image="$(fileglob "$Cachedir/*.$Position.*")"
      Imagelist="$Imagelist $Image"
    done
    Destinationfile="$Destinationdir/$Destinationfilebasename.${Sequencename[$Count]}.$Fusemode.$Distortion.gif"

    worknote "Generating $(basename $Destinationfile)."
    multicore "convert -delay $Delay -loop 0 $Imagelist $Destinationfile" "$Destinationfile" || return 1
    showpercent $Iteration $((Positionnumber*2 +5))
  done
  multicore_wait || return 1
}

compose() {
  local $Batchlocal
  local Evalmaxfile Evalminfile Minfile Maxfile 
  local Destinationfilebasename
  local i Count
  
  parse_batchoptions "$@" || return 1
  
  Evalmaxfile[0]="$(fileglob "$Sourcedir/*magick.max*")"
  Evalminfile[0]="$(fileglob "$Sourcedir/*magick.min*")"
  Evalmaxfile[1]="$(fileglob "$Sourcedir/*fuse.max*")"
  Evalminfile[1]="$(fileglob "$Sourcedir/*fuse.min*")"
  
  [ -z "${Evalmaxfile[0]}${Evalmaxfile[1]}" ] && {
    failure "compose: No source found. Please run evaluate first."
    return 1
  }

  Count=0
  for i in 0 1 ; do
    Maxfile="${Evalmaxfile[$i]}"
    Minfile="${Evalminfile[$i]}"
    [ -z "$Maxfile" ] && break
    Destinationfilebasename="$(sed 's/.max.*//' <<< "$Maxfile")"
    Destinationfilebasename="$(basename "$Destinationfilebasename")"
    
    for Functionmode in bumpmap colorburn difference linearburn linearlight modulate multiply overlay pegtoplight; do
      Count="$((Count + 1))"
      
      ifcmdbreak && return 1
    
      Destinationfile="$Destinationdir/$Destinationfilebasename.${Functionmode}1.jpg"
      $Convert "$Minfile" "$Maxfile" -compose "$Functionmode" -composite "$Destinationfile"
      worknote "compose $Functionmode: $Destinationfile"
      showimage "$Destinationfile"
  
      case $Functionmode in
        linearburn|multiply) ;;  # skip second compose for modes with identical result
        difference)
          $Convert "$Destinationfile" -negate "$Destinationdir/$Destinationfilebasename.${Functionmode}1-negate.jpg"
          showimage "$Destinationdir/$Destinationfilebasename.${Functionmode}1-negate.jpg"
        ;;
        *)
          Destinationfile="$Destinationdir/$Destinationfilebasename.${Functionmode}2.jpg"
          $Convert "$Maxfile" "$Minfile" -compose "$Functionmode" -composite "$Destinationfile"
          echo "$Destinationfile"
          showimage "$Destinationfile"
        ;;
      esac
      
      showpercent "$Count" "18"
    done
  done
  return 0
}

crop() {
  local $Batchlocal
  local Image Imagelist Cropgeometry Destinationfile
  local Imagewidth Imageheight Newwidth Newheight Shrink
  local Count Imagecount
  local Rotate Rotatedir
  
  parse_batchoptions "$@" || return 1
  
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagecount="$(grep -c . <<< "$Imagelist")"
  Imagewidth=$($Convert  -format '%w'  "$(head -n1 <<< "$Imagelist")" info:)
  Imageheight=$($Convert -format '%h'  "$(head -n1 <<< "$Imagelist")" info:)

  case $Functionmode in
    even)
      Newwidth=$((Imagewidth/2))
      Newwidth=$((Newwidth*2))
      Newheight=$((Imageheight/2))
      Newheight=$((Newheight*2))
      Cropgeometry="${Newwidth}x${Newheight}+0+0"
    ;;
    shrink) 
      Shrink="$Functionoption"
      Cropgeometry="$((Imagewidth - $((Shrink * 2))))x$((Imageheight - $((Shrink * 2))))+$Shrink+$Shrink"
    ;;
    geometry)
      Cropgeometry="$Functionoption"
    ;;
    interactive) 
#      Image="$Cachedir/crop.min.jpg"
      Image="$Cachedir/crop.min.mpc"
      showpercent 1 100
      convert $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence min "$Image"
      Cropgeometry="$(cropgeometry_interactive "$Image" "$Cachedir" "$Functionoption")"
      Rotate="$(cut -s -d: -f2 <<< "$Cropgeometry")"
      Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")"
    ;;
  esac
  
  Rotate="${Rotate:-0}"

  [ "$Cropgeometry" ] || {
    failure "crop $Functionmode: crop geometry is empty"
    return 1
  }
  
  [ "$Cropgeometry" = "${Imagewidth}x${Imageheight}+0+0" ] && [ "$Rotate" = "0" ] && {
    worknote "crop $Functionmode: Images already have desired geometry: $Cropgeometry"
    cp $Imagelist "$Destinationdir" ### FIXME mycp()
    return
  }
  
  worknote "crop $Functionmode: Cropping images with rotation $Rotate and geometry $Cropgeometry"
  Rotatedir="$Cachedir/rotate"
  mkdir -p $Rotatedir
  Count="0"
  for Image in $Imagelist; do
    Count="$((Count+1))"
    Destinationfile="$Destinationdir/$(basename "$Image")"
    multicore "$Convert $Image -rotate $Rotate +repage -crop $Cropgeometry $Destinationfile" "$Destinationfile" || return 1
    showpercent "$Count" "$Imagecount"
  done
  multicore_wait || return 1
  Imagelist="$(fileglob "$Rotatedir/*")"
  
  historyentry "# crop geometry: $Cropgeometry rotation: $Rotate"
  return 0
}

evaluate() {
  # Evaluate image stack.
  
  local $Batchlocal
  local Destinationfilebasename Fileformat Count
  
  parse_batchoptions "$@" || return 1
  
  Destinationfilebasename="${Destinationfile:-evaluate}"  
  Fileformat="${Functionoption:-jpg}"
  Functionmode="${Functionmode:-all}"
  
  case "$Functionmode" in
    all)
      Count=0
      for Functionmode in min mean max median; do
        Count="$((Count + 1))"
        multicore "evaluate -s '$Sourcedir' -g '$Sourcefileglob' -d '$Destinationdir' -b '$Destinationfilebasename' -m '$Functionmode' -o '$Fileformat'" || return 1
        showpercent "$Count" "4"
      done
      multicore_wait || return 1
    ;;
    min|max|mean|median) ;;
    *) failure "evaluate: Unknown function mode $Functionmode" ; return 1 ;;
  esac
  
  Destinationfile="$Destinationdir/$Destinationfilebasename.$Functionmode.$Fileformat"
  $Convert $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence $Functionmode "$Destinationfile" || {
    failure "evaluate $Functionmode: ERROR in excuting convert. Please check policy restrictions of ImageMagick. Note that all input images have to be the same size."
    return 1
  }
  showimage "$Destinationfile"
  return 0
}

fuse() {
  # fuse stackshot of images with enfuse
  
  local $Batchlocal
  local Destinationfilebasename
  local Exposureweight Saturationweight Contrastweight
  local Contrastedgescale Contrastmincurvature Contrastwindowsize
  local Grayprojector
  
  parse_batchoptions "$@" || return 1
  
  Destinationfilebasename="${Destinationfile:-fuse}"
  Functionmode="${Functionmode:-1}"
 
  # Predefined parameter sets
  Exposureweight=0.0
  Saturationweight=0.0
  Contrastweight=1.0
  Contrastedgescale=0
  Contrastmincurvature=""
  Contrastwindowsize="3"
  Grayprojector="luminance"
  
  case $Functionmode in
    all)
      for Functionmode in $(seq 50); do
        multicore "fuse -s '$Sourcedir' -g '$Sourcefileglob' -d '$Destinationdir' -b '$Destinationfilebasename' -m '$Functionmode'" || return 1
        showpercent "$Functionmode" "50"
      done
      multicore_wait || return 1
      return 0
    ;;
    1)
    ;;
    2)
      Saturationweight="0.1"
    ;;
    3)
      Contrastwindowsize="7"
    ;;
    4)
      Contrastwindowsize="7"
      Saturationweight="0.1"
    ;;
    5) 
      Contrastwindowsize="15"
    ;;
    6) 
      Contrastwindowsize="15"
      Saturationweight="0.1"
    ;;
    7) 
      Contrastwindowsize="23"
    ;;
    8) 
      Contrastwindowsize="23"
      Saturationweight="0.1"
    ;;
   x9)
      Contrastedgescale="0.8:2000%:300%"
      #Contrastmincurvature="+8.0%"
    ;;
   x10)
      Contrastedgescale="0.8:500%:500%"
      #Contrastmincurvature="+8.0%"
    ;;
   x11)
      Contrastedgescale="1.2:16:4"
      #Contrastmincurvature="+5.0%"
    ;;
   x12)
      Contrastedgescale="1.2:8:4"
      #Contrastmincurvature="+5.0%"
      #Saturationweight="0.1"
    ;;
   x13)
      Contrastedgescale="1.6:16:4"
      #Contrastmincurvature="+3.0%"
    ;;
   x14)
      Contrastedgescale="1.6:8:4"
      #Contrastmincurvature="+3.0%"
      #Saturationweight="0.1"
    ;;
    15)
      Contrastedgescale="1.6:16:10"
      #Contrastmincurvature="+6.0%"
    ;;
    16)
      Contrastedgescale="1.6:8:10"
      #Contrastmincurvature="+8.0%"
      #Saturationweight="0.1"
    ;;
    17)
      Contrastedgescale="2.0:500%:500%"
      #Contrastmincurvature="+2.0%"
    ;;
   x18)
      Contrastwindowsize="15"
      Contrastedgescale="1.2:16:4"
      Contrastmincurvature="+8.01%"
    ;;
   x19)
      Contrastwindowsize="23"
      Contrastedgescale="1.2:16:4"
      Contrastmincurvature="+8.01%"
    ;;
    20)
      Contrastedgescale="3.0:4:4"
    ;;
    
    
    ###############
    22x) #*
      Contrastwindowsize="23"
      Contrastedgescale="2.5:8:4"
      Contrastmincurvature="+8.01%"
    ;;
    
    23x) #*
      Contrastwindowsize="23"
      Contrastedgescale="2.5:4:2"
      Contrastmincurvature="+8.01%"
    ;;
    
    
    
    20x)
      Contrastwindowsize="23"
      Contrastedgescale="1.2:24:8"
    ;;
    21x)
      Contrastwindowsize="23"
      Contrastedgescale="0.5:36:24"
      Contrastmincurvature="+8.01%"
    ;;
    27x) #*
      Contrastwindowsize="15"
      Contrastedgescale="2.5:4:2"
      Contrastmincurvature="+8.01%"
    ;;
    
    
    xxx7)
      Contrastedgescale="0.3:1000%:300%"
      Contrastmincurvature="+0.3%"
    ;;
    xxx8)
      Contrastedgescale="0.3:1000%:300%"
      Contrastmincurvature="+0.3%"
      Saturationweight="0.1"
    ;;
    
    
    
    
    x11)
      Grayprojector="l-star"
    ;;
    x12) 
      Contrastwindowsize="7"
      Grayprojector="l-star"
    ;;
    x13)
      Grayprojector="l-star"
      Contrastedgescale="0.3:1000%:300%"
      Contrastmincurvature="+0.3%"
      Grayprojector="l-star"
    ;;
    x14)
      Contrastedgescale="0.8:2000%:300%"
      Grayprojector="l-star"
    ;;
    x15)
      Contrastedgescale="1.2:16:4"
      Contrastmincurvature="+8.0%"
      Grayprojector="l-star"
    ;;
    x16)
      Contrastedgescale="1.6:16:4"
      Contrastmincurvature="+4.0%"
      Grayprojector="l-star"
    ;;
    x17)
      Contrastedgescale="1.6:16:4"
      Saturationweight="0.1"
      Contrastmincurvature="+5.0%"
      Grayprojector="l-star"
    ;;
    x18)
      Contrastedgescale="1.6:16:10"
      Saturationweight="0.1"
      Contrastmincurvature="+10.0%"
      Grayprojector="l-star"
    ;;
    *) return 0 ;;
  esac

  Destinationfile="$Destinationdir/$Destinationfilebasename.fuse$(printf %02d $Functionmode).jpg"
  #check_destinationfile "$Destinationfile" "fuse" || return 1
  worknote "fuse $Functionmode: Creating $(basename "$Destinationfile")"
  
  Enfuseoptions="
      --exposure-weight=$Exposureweight \
      --saturation-weight=$Saturationweight \
      --contrast-weight=$Contrastweight \
      --hard-mask \
      \
      --contrast-edge-scale=$Contrastedgescale \
      --contrast-window-size=$Contrastwindowsize \
      \
      --gray-projector=$Grayprojector"
  [ "$Contrastmincurvature" ] && Enfuseoptions="$Enfuseoptions \
      --contrast-min-curvature=$Contrastmincurvature"
  
  # Fusing here
  enfuse $Enfuseoptions \
         --output="$Destinationfile" \
         $(fileglob "$Sourcedir/$Sourcefileglob") \
         2>&1 | grep -v "does not have an alpha channel" | grep -v "assuming all pixels should contribute" | grep -v "loading next image" || {
    failure "fuse $Functionmode failed"
    return 1
  }
        
  # Write enfuse options into EXIF data of image
  exiv2 -M"set Exif.Photo.UserComment Comment charset=Ascii enfuse $(echo $Enfuseoptions)" "$Destinationfile" 

  #note "fuse $Functionmode is ready: ${Destinationfile}"
  showimage "$Destinationfile"
  return 0
}

ruler() {
  local $Batchlocal
  local Destinationfile
  local Count Imagecount Imagelist
  
  parse_batchoptions "$@" || return 1
  
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagecount="$(grep -c . <<< "$Imagelist")"
  
  Count="0"
  for Image in $Imagelist; do
    Count="$((Count+1))"
    Destinationfile="$Destinationdir/$(basename $Image)"
    multicore "$Imgruler -m $Functionmode -t '$Functionoption' -o $Destinationfile $Image" "$Destinationfile" || return 1
    showpercent "$Count" "$Imagecount"
  done
  multicore_wait || return 1
  return 0
}

undo() {
  local $Batchlocal
  local Undocache
  
  parse_batchoptions "$@" || return 1

  Undocache="$Cachedir/undo"
  mkdir -p "$Undocache"
  
  mymv "$Sourcedir/*"      "$Undocache"      || return 1
  mymv "$Destinationdir/*" "$Sourcedir" 
  mymv "$Undocache/*"      "$Destinationdir"
  
  myrm "$Undocache"
}

whitebalance() {
  local $Batchlocal
  local Image Cropgeometry Imagewidth Imageheight
  local Referencecolor Referencecolorimage Meancolorimage 
  local Destinationfile Imagelist Imagecount Count
  local Refred  Refgreen  Refblue
  local Meanred Meangreen Meanblue
  local Partred Partgreen Partblue
  
  parse_batchoptions "$@" || return 1
    
  Functionmode="${Functionmode:-topleft}"
  Referencecolor="${Functionoption:-#BBBBBB}"
  
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagecount="$(grep -c . <<< "$Imagelist")"
  Imagewidth=$($Convert  -format '%w'  "$(head -n1 <<< "$Imagelist")" info:)
  Imageheight=$($Convert -format '%h'  "$(head -n1 <<< "$Imagelist")" info:)
  
  Meancolorimage="$Cachedir/meancolor.mpc"
  Referencecolorimage="$Cachedir/referencecolor.mpc"
  
  case $Functionmode in
    topleft)     Cropgeometry="10x10+5+5" ;;
    topright)    Cropgeometry="10x10+$((Imagewidth-15))+5" ;;
    bottomleft)  Cropgeometry="10x10+5+$((Imageheight-15))" ;;
    bottomright) Cropgeometry="10x10+$((Imagewidth-15))+$((Imageheight-15))" ;;
    full)        Cropgeometry="${Imagewidth}x${Imageheight}+0+0" ;;
    interactive) 
#      Image="$Cachedir/whitebalance.min.jpg"
      Image="$Cachedir/whitebalance.min.mpc"
      $Convert $(fileglob "$Sourcedir/$Sourcefileglob") -evaluate-sequence min "$Image"
      Cropgeometry="$(cropgeometry_interactive "$Image" "$Cachedir" "50x50+10+10")"  ### FIXME rotate
      Cropgeometry="$(cut -d: -f1 <<< "$Cropgeometry")" 
      [ "$Cropgeometry" ] || {
        failure "whitebalance: Got no crop geometry"
        return 1
      }
    ;;
  esac
  
  [ "$Referencecolor" = "mean" ] && {
    Image="$Cachedir/whitebalance.mean.mpc"
    convert $(fileglob "$Sourcedir/$Sourcefileglob") -crop "$Cropgeometry" -evaluate-sequence mean "$Image"
    Referencecolor=$($Convert "$Image" -filter box -resize 1x1! -format "%[pixel:u]" info:)
  }
  
  convert -size 1x1 xc:"$Referencecolor" $Referencecolorimage
  Refred="$(convert   $Referencecolorimage -format "%[fx:255*u.p{0,0}.r]" info:)"
  Refgreen="$(convert $Referencecolorimage -format "%[fx:255*u.p{0,0}.g]" info:)"
  Refblue="$(convert  $Referencecolorimage -format "%[fx:255*u.p{0,0}.b]" info:)"

  historyentry "# whitebalance geometry: $Cropgeometry"

  Count=0
  for Image in $Imagelist; do
    Count="$((Count + 1))"
    Destinationfile="$Destinationdir/$(basename "$Image")"
    
    convert $Image -crop $Cropgeometry -resize 1x1! "$Meancolorimage"
    
    Meanred="$(convert   $Meancolorimage -format "%[fx:255*u.p{0,0}.r]" info:)"
    Meangreen="$(convert $Meancolorimage -format "%[fx:255*u.p{0,0}.g]" info:)"
    Meanblue="$(convert  $Meancolorimage -format "%[fx:255*u.p{0,0}.b]" info:)"
    
    [ "$Meanred"   = "0" ] && Partred=255   || Partred="$(awk   "BEGIN { print $Refred   / $Meanred }")"
    [ "$Meangreen" = "0" ] && Partgreen=255 || Partgreen="$(awk "BEGIN { print $Refgreen / $Meangreen }")"
    [ "$Meanblue"  = "0" ] && Partblue=255  || Partblue="$(awk  "BEGIN { print $Refblue  / $Meanblue }")"
    
    multicore "convert $Image -color-matrix '$Partred 0 0 0 $Partgreen 0 0 0 $Partblue' $Destinationfile" "$Destinationfile" || return 1
    showpercent "$Count" "$Imagecount"
  done
  multicore_wait || return 1
  return 0
}

wizard() {
  # Wrapper for ImageMagick convert to work on folders
  # Args:
  #  mandatory:
  #   -m Functionmode
  #   -s Sourcedir
  #   -d Destinationdir
  #  optional:
  #   -g Sourcefileglob
  #   -o Functionoption
  
  local $Batchlocal
  local Image Destinationfile Imagelist
  
  parse_batchoptions "$@" || return 1
  
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagecount="$(grep -c . <<< "$Imagelist")"
  
  [ "$Functionoption" ] || case "$Function" in
    brightness) Functionoption="10x10" ;;
    contrast)   Functionoption="3x50%" ;;
    gamma)      Functionoption="auto" ;;
    kuwahara)   Functionoption="1.5" ;;
    level)      Functionoption="auto" ;;
    sharpen)    Functionoption="6x2" ;;
    stretch)    Functionoption="0%" ;;
  esac

  case "$Functionmode" in
    gamma|level) 
      case "$Functionoption" in
        auto|"") Functionmode="-auto-$Functionmode" ; Functionoption="" ;;
        *)       Functionmode="-$Functionmode" ;;
      esac
    ;;
    brightness)  Functionmode="-brightness-contrast" ;;
    contrast)    Functionmode="-sigmoidal-contrast" ;;
    kuwahara)    Functionmode="-kuwahara" ;;
    sharpen)     Functionmode="-adaptive-sharpen" ;;
    stretch)     Functionmode="-contrast-stretch" ;;
    wizard)      Functionmode="" ;;
  esac
  
  Count=0
  for Image in $Imagelist; do
    Count="$((Count + 1 ))"
    Destinationfile="$Destinationdir/$(basename "$Image")"
    multicore "$Convert $Image $Functionmode $Functionoption $Destinationfile" "$Destinationfile" || return 1
    showpercent "$Count" "$Imagecount"
  done
  multicore_wait || return 1
  
  return 0
}

#### single image operations

calc_evengeometry() {
  local Geometry XY W H
  Geometry="${1:-}"
  W=$(cut -dx -f1 <<< "$Geometry")
  H=$(cut -dx -f2 <<< "$Geometry" | cut -d+ -f1)
  XY="$(cut -d+ -f2- <<< "$Geometry")"
  W=$((W/2))
  W=$((W*2))
  H=$((H/2))
  H=$((H*2))
  Geometry="${W}x${H}+${XY}"
  echo $Geometry
}

trim_hard() {
  # Function: Trim all border with transparency from image $1
  # Results in a maximal inner rectangle without border color.
  # $1  $Image      image
  # $2  $Trimcolor  color to trim. Default: transparent
  # $3  Geometry seed value (optional)
  # $4  additional command to run on each iteration (optional, special use case for cropgeometry_interactive() )
  # Output: crop geometry
  
  local Imagemask Trimcolor Cropgeometry Addcommand
  local Sourceimage Sourceimagempc Cropgeometryimage Imagewidth Imageheight
  local Left         Right         Top         Bottom
  local Skipleft     Skipright     Skiptop     Skipbottom
  local Permilleleft Permilleright Permilletop Permillebottom Permillemax
  local Return
  local Debugmode Loopcount
  local pid1 pid2 pid3 pid4
  
  Sourceimage="${1:-}"
  Cropgeometry="${2:-}"
  Addcommand="${3:-}"
  
  Trimcolor="#00000000" # to support other colors, creating mask must be fixed FIXME
  
  # check source for mpc format, convert if not
  [ "$Sourceimage" = "${Sourceimage%.mpc}" ] && {
    Sourceimagempc="$Sourceimage.mpc"
    convert "$Sourceimage" "$Sourceimagempc"
  } || {
    Sourceimagempc="$Sourceimage"
  }
  Cropgeometryimage="$Sourceimage.trim_hard.png"
  
  # Generate alpha mask image in imagemagick memory format for fastest possible access
  Imagemask="$Sourceimage.mask.mpc"
  convert "$Sourceimagempc" -alpha extract "$Imagemask"
  
  worknote "trim_hard(): Searching for inner rectangle of $(basename $Image)"
  
  Imagewidth=$(convert  -format '%w'  $Imagemask info:)
  Imageheight=$(convert -format '%h'  $Imagemask info:)
  Left=0
  Top=0
  Right=$((Imagewidth-1))
  Bottom=$((Imageheight-1))
  
  # First cut with regular trim to save some time.
  # Add a colored border so trim uses the desired color. Afterward remove border from canvas to get correct geometry values. 
  Line="$(convert "$Sourceimagempc" -bordercolor "$Trimcolor" -border 1x1  -trim -set page '%[fx:page.width-2]x%[fx:page.height-2]+%[fx:page.x-1]+%[fx:page.y-1]' info:)"
  Left="$(awk '{print $4}' <<< "$Line" | cut -d+ -f2)"
  Top="$(awk '{print $4}' <<< "$Line" | cut -d+ -f3)"
  Right="$(awk '{print $3}' <<< "$Line" | cut -dx -f1)"
  Right="$((Left+Right-1))"
  Bottom="$(awk '{print $3}' <<< "$Line" | cut -dx -f2)"
  Bottom="$((Top+Bottom-1))"
  
  [ "$Cropgeometry" ] && {
    Left=$(cut -d+ -f2 <<< "$Cropgeometry")
    Top=$(cut -d+ -f3 <<< "$Cropgeometry")
    Right=$(cut -dx -f1 <<< "$Cropgeometry")
    Right=$((Left+Right-1))
    Bottom=$(cut -dx -f2 <<< "$Cropgeometry")
    Bottom=$(cut -d+ -f1 <<< "$Bottom")
    Bottom=$((Top+Bottom-1))
  }
  
  # Workflow:
  # - Get permille amount of $Trimcolor from all sides.
  # - Remove side with greatest permille amount of $Trimcolor.
  # - Repeat check with new geometry
  while :; do
    # Get part of non-$Trimcolor at each side
    [ "$Skipleft" ]   || convert $Imagemask -crop 1x$((Bottom-Top+1))+$Left+$Top    +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permilleleft    & pid1=$!
    [ "$Skipright" ]  || convert $Imagemask -crop 1x$((Bottom-Top+1))+$Right+$Top   +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permilleright   & pid2=$!
    [ "$Skiptop" ]    || convert $Imagemask -crop $((Right-Left+1))x1+$Left+$Top    +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permilletop     & pid3=$!
    [ "$Skipbottom" ] || convert $Imagemask -crop $((Right-Left+1))x1+$Left+$Bottom +repage -scale 1x1! -precision 4 -format "%[fx:mean]" info:  >/tmp/permillebottom  & pid4=$!
    wait $pid1
    wait $pid2
    wait $pid3
    wait $pid4
    Permilleleft=$(  LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permilleleft)
    Permilleright=$( LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permilleright)
    Permilletop=$(   LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permilletop)
    Permillebottom=$(LC_ALL=C xargs /usr/bin/printf "%.4f" < /tmp/permillebottom )
    
    # Determine maximal permille value
    Permillemax=$(echo "$Permilleleft
$Permilleright
$Permilletop
$Permillebottom" | sort -n | head -n1)
    showpercent "$(awk "BEGIN {print 1000*$Permillemax}" | cut -d. -f1)" "1000"
    [ "$Permillemax" = "1.0000" ] && break # Ready
    
    # Remove side with maximal permille of $Trimcolor.
    [ "$Permillemax" = "$Permilleleft" ]   && Left=$((Left+1))
    [ "$Permillemax" = "$Permilleright" ]  && Right=$((Right-1))
    [ "$Permillemax" = "$Permilletop" ]    && Top=$((Top+1))
    [ "$Permillemax" = "$Permillebottom" ] && Bottom=$((Bottom-1))
    Cropgeometry="$((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top"
    
    # Skip check for sides without $Trimcolor in future to save some time
    [ "1.0000" = "$Permilleleft" ]   && Skipleft=yes
    [ "1.0000" = "$Permilleright" ]  && Skipright=yes
    [ "1.0000" = "$Permilletop" ]    && Skiptop=yes
    [ "1.0000" = "$Permillebottom" ] && Skipbottom=yes
    
    # break signal of fusewizard
    ifcmdbreak && return 1

    # Out-of-range error
    { [ "$Left" -gt "$Right" ] || [ "$Top" -gt "$Bottom" ] ; } && {
#      echo "Error: Failed to find an inner rectangle. Unuseable result: $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top" >&2
      failure "trim_hard(): Failed to find an inner rectangle. Unuseable result: $Cropgeometry" 
      Return=1
      Left=0
      Top=0
      Right=$((Imagewidth-1))
      Bottom=$((Imageheight-1))
      break
    }
    
    # Debugging: show intermediate results
    Debugmode=yes
    [ "$Debugmode" ] && {
      Loopcount=$((Loopcount+1))
      [ "$Loopcount" = "10" ] && {
        Loopcount=0
        convert $Sourceimagempc -fill none -stroke red -strokewidth 1 -pointsize 18 -undercolor white -gravity center -draw "rectangle $Left,$Top $Right,$Bottom  text 0,0 '$Cropgeometry'" $Cropgeometryimage
        showimage $Cropgeometryimage
        eval "$Addcommand"
      }
    }
  done

  # show result
  showpercent 100 100
  convert $Sourceimagempc -fill none -stroke red -strokewidth 1 -pointsize 18 -undercolor white -gravity center -draw "rectangle $Left,$Top $Right,$Bottom  text 0,0 '$Cropgeometry'" $Cropgeometryimage
  showimage $Cropgeometryimage
  
  # Output of result
  #echo "$Left,$Top $Right,$Bottom"                     # "-draw rectangle" geometry
  #echo $((Right-Left+1))x$((Bottom-Top+1))+$Left+$Top  # "-crop" geometry
  echo "$Cropgeometry"

  return ${Return:-0}
}

#### run commands on all CPUs

multicore() {
  # Run multiple processes in parallel, but not more than $Wizardthreads
  # $1 Command
  # $2 Image to show if $1 is finished
  # Run multicore_wait afterwards to wait for the last processes to finish.
  
  local Process
    
  [ "$Multicoreprocesscount" = $Wizardthreads ] && {
    for Process in $(seq $Wizardthreads); do
      [ "${Multicoreprocess[$Process]}" ] && {
        multicore_waitprocess "${Multicoreprocess[$Process]}" || {
          multicore_break
          return 1
        }
        [ "${Multicoreimage[$Process]}" ] && showimage "${Multicoreimage[$Process]}"
      }
      Multicoreprocess[$Process]=""
      Multicoreimage[$Process]=""
    done
    Multicoreprocesscount=0
  }
  
  ifcmdbreak && {
    multicore_break
    return 1
  }
        
  Multicoreprocesscount=$((Multicoreprocesscount +1))

  #echo "${1:-} "
  eval "${1:-} &"
  
  Multicoreprocess[Multicoreprocesscount]=$!
  Multicoreimage[Multicoreprocesscount]="${2:-}"
  
  return 0
}

multicore_wait() {
  local Process
  for Process in $(seq $Wizardthreads); do
    [ "${Multicoreprocess[$Process]}" ] && {
      multicore_waitprocess "${Multicoreprocess[$Process]}" || {
        multicore_break
        return 1
      }
      [ "${Multicoreimage[$Process]}" ] && showimage "${Multicoreimage[$Process]}"
    }
    Multicoreprocess[$Process]=""
    Multicoreimage[$Process]=""
  done
  Multicoreprocesscount=0
  return 0
}

multicore_waitprocess() {
  while sleep 0.05 ; do
    ps -p "${1:-}" >/dev/null || break
    ifcmdbreak && return 1
  done
  wait "${1:-}"
  return $?
}

multicore_break() {
  local Process
  for Process in $(seq $Wizardthreads); do
    [ "${Multicoreprocess[$Process]}" ] && {
      kill "${Multicoreprocess[$Process]}"
      wait "${Multicoreprocess[$Process]}"
    }
  done
}

#### GUI

kaptaingrammar() {
  echo '#! /usr/bin/kaptain

start "fusewizard" -> frameset;
  frameset:framed                    -> topframe bottomframe;
    topframe                           -> batchoptionframe ;
      batchoptionframe:beside            -> batchframeleft  batchframeright;
        batchframeleft:framed              -> batchblock1 batchblock2 specialframe;
        batchframeright:framed             -> batchblock3 runbatchframe showresultframe deleteframe;
    bottomframe                        -> dirframe statusframe ;
    
      dirframe:beside                    -> choosedirguibutton choosedir refreshbutton ;
        choosedirguibutton                 -> @button="Stackshot directory:" ;
        choosedir                          -> @directory="'$Projecthome'" ;
        refreshbutton                      -> @button="refresh" ;
    
      statusframe                        -> wizardstatusline ;
        wizardstatusline:beside            -> cmdpercent wizardlog;
          cmdpercent                         -> @icon ;
          wizardlog                          -> @text="" ;
      
      batchblock1 "batch block 1: prepare stackshot images in directory magick" -> cropline @text="convert options" contrastline sharpenline kuwaharaline brightnessline gammaline levelline stretchline wizardline applyallline;
        gammaline:beside                                      -> gamma gammamagick gammafuse gammaevaluate;
          gammacombo                                            -> @combow("auto","0.2","0.3","0.4","0.5","0.6","0.7","0.8","0.9","1.2","1.5","2.0","3.0","4.0")="auto" ;
          gammamagick                                           -> @button="magick" ;
          gammaevaluate                                         -> @button="evaluate" ;
          gammafuse                                             -> @button="fuse" ;
          gamma:beside                "gamma"                   -> gammacombo | "";
        levelline:beside                                      -> level levelmagick levelfuse levelevaluate;
          levelcombo                                            -> @combow("auto","5%","10%","15%","20%","25%","30%")="auto" ;
          levelmagick                                           -> @button="magick" ;
          levelevaluate                                         -> @button="evaluate" ;
          levelfuse                                             -> @button="fuse" ;
          level:beside                "level"                   -> levelcombo | ! "";
        contrastline:beside                                   -> contrast contrastmagick contrastfuse contrastevaluate;
          contrastcombo                                         -> @combow("1x50%","2x50%","3x50%","4x50%","5x50%","6x50%")="6x50%" ;
          contrastmagick                                        -> @button="magick" ;
          contrastevaluate                                      -> @button="evaluate" ;
          contrastfuse                                          -> @button="fuse" ;
          contrast:beside             "sigmoidal-contrast"      -> contrastcombo | "";
        kuwaharaline:beside                                   -> kuwahara kuwaharamagick kuwaharafuse kuwaharaevaluate;
          kuwaharacombo                                         -> @combow("1.2","1.5","2.0","2.5","3.0","4.0","5.0")="1.5" ;
          kuwaharamagick                                        -> @button="magick" ;
          kuwaharaevaluate                                      -> @button="evaluate" ;
          kuwaharafuse                                          -> @button="fuse" ;
          kuwahara:beside             "kuwahara"                -> kuwaharacombo | ! "";
        sharpenline:beside                                    -> sharpen sharpenmagick sharpenfuse sharpenevaluate;
          sharpencombo                                          -> @combow("3x1","6x2","6x4","8x4")="6x4" ;
          sharpenmagick                                         -> @button="magick" ;
          sharpenevaluate                                       -> @button="evaluate" ;
          sharpenfuse                                           -> @button="fuse" ;
          sharpen:beside              "adaptive-sharpen"        -> sharpencombo | "";
        brightnessline:beside                                 -> brightness brightnessmagick brightnessfuse brightnessevaluate;
          brightnesscombo                                       -> @combow("0x5","0x10","0x15","5x0","5x5","5x10","5x15","10x0","10x5","10x10","15x15","20x20")="10x10" ;
          brightnessmagick                                      -> @button="magick" ;
          brightnessevaluate                                    -> @button="evaluate" ;
          brightnessfuse                                        -> @button="fuse" ;
          brightness:beside           "brightness-contrast"     -> brightnesscombo | ! "";
        stretchline:beside                                    -> stretch stretchmagick stretchfuse stretchevaluate;
          stretchcombo                                          -> @combow("0%","1%","2%","3%","4%","5%","10%","15%","20%")="0%" ;
          stretchmagick                                         -> @button="magick" ;
          stretchevaluate                                       -> @button="evaluate" ;
          stretchfuse                                           -> @button="fuse" ;
          stretch:beside              "stretch-contrast"        -> stretchcombo | ! "";
        wizardline:beside                                     -> wizard wizardmagick wizardfuse wizardevaluate;
          wizardcombo                                           -> @combow("","-negate","-despeckle","-edge 3","-emboss 3","-enhance","-equalize","-canny 3","-charcoal 3")="" ;
          wizardmagick                                          -> @button="magick" ;
          wizardevaluate                                        -> @button="evaluate" ;
          wizardfuse                                            -> @button="fuse" ;
          wizard:beside               "convert"                 -> wizardcombo | ! "" ;
        applyallline:beside                                   -> applyall applyallmagick applyallfuse applyallevaluate;
          applyallmagick                                        -> @button="magick" ;
          applyallevaluate                                      -> @button="evaluate" ;
          applyallfuse                                          -> @button="fuse" ;
          applyall:beside             "Apply all convert options"  -> "" ;
          
      batchblock2 "batch block 2: post processing directory magick" -> meanbalanceline whitebalanceline gamma_line align_vidstab1line align_vidstab2line align_vidstab3line ;
        meanbalanceline:beside                               -> meanbalance meanbalancemodecombo meanbalancemagick meanbalancefuse meanbalanceevaluate;
          meanbalancemodecombo                                 -> @combo("interactive","topleft","topright","bottomleft","bottomright","full")="full" ;
          meanbalancemagick                                    -> @button="magick" ;
          meanbalanceevaluate                                  -> @button="evaluate" ;
          meanbalancefuse                                      -> @button="fuse" ;
          meanbalance:beside         "meanbalance"            ->  "on"  | "";
        whitebalanceline:beside                               -> whitebalance whitebalancemodecombo whitebalancecombo whitebalancemagick whitebalancefuse whitebalanceevaluate;
          whitebalancemodecombo                                 -> @combo("interactive","topleft","topright","bottomleft","bottomright","full")="topleft" ;
          whitebalancecombo                                     -> @combow("mean","#777777","#888888","#999999","#AAAAAA","#BBBBBB","#CCCCCC","#DDDDDD","#EEEEEE","#FFFFFF")="#999999" ;
          whitebalancemagick                                    -> @button="magick" ;
          whitebalanceevaluate                                  -> @button="evaluate" ;
          whitebalancefuse                                      -> @button="fuse" ;
          whitebalance:beside         "whitebalance"            ->  "on"  | ! "";
        cropline:beside                                       -> crop cropmodecombo cropcombo cropmagick cropfuse cropevaluate;
          cropmodecombo                                         -> @combo("interactive","shrink","even","geometry")="interactive" ;
          cropcombo                                             -> @combow("","1","2","5","10","200x200+15+15")="" ;
          cropmagick                                            -> @button="magick" ;
          cropevaluate                                          -> @button="evaluate" ;
          cropfuse                                              -> @button="fuse" ;
          crop:beside                 "crop + rotate"           -> "on" | ! "";
        gamma_line:beside                                     -> gamma_ gamma_magick gamma_fuse gamma_evaluate;
          gamma_combo                                           -> @combow("auto","0.2","0.3","0.4","0.5","0.6","0.7","0.8","0.9","1.2","1.3","1.4","1.5","2.0","3.0","4.0")="1.4" ;
          gamma_magick                                          -> @button="magick" ;
          gamma_evaluate                                        -> @button="evaluate" ;
          gamma_fuse                                            -> @button="fuse" ;
          gamma_:beside                "gamma"                  -> gamma_combo | "";
        align_vidstab1line:beside                             -> align_vidstab1 align_vidstab1combo align_vidstab1button ;
          align_vidstab1modecombo:beside    "Shakiness:"        -> @combo("1","2","3","4","5","6","7","8","9","10")="10" ;
          align_vidstab1combo         "crop interactive"        -> "on" | "";
          align_vidstab1button                                  -> @button="magick" ;
          align_vidstab1:beside       "align with vidstab:"     -> align_vidstab1modecombo | "";
        align_vidstab2line:beside                             -> align_vidstab2 align_vidstab2combo align_vidstab2button ;
          align_vidstab2modecombo:beside    "Shakiness:"        -> @combo("1","2","3","4","5","6","7","8","9","10")="5" ;
          align_vidstab2combo         "crop interactive"        -> "on" | ! "";
          align_vidstab2button                                  -> @button="magick" ;
          align_vidstab2:beside       "align with vidstab:"     -> align_vidstab2modecombo | "";
        align_vidstab3line:beside                             -> align_vidstab3 align_vidstab3combo align_vidstab3button ;
          align_vidstab3modecombo:beside    "Shakiness:"        -> @combo("1","2","3","4","5","6","7","8","9","10")="1" ;
          align_vidstab3combo         "crop interactive"        -> "on" | ! "";
          align_vidstab3button                                  -> @button="magick" ;
          align_vidstab3:beside       "align with vidstab:"     -> align_vidstab3modecombo | "";
        
      batchblock3 "batch block 3: combine stackshot images" -> fuse evaluateline sharpen_evaluate compose;
        fuse:beside                   "fuse"                    -> @button="magick" "on" | "";
        evaluateline:beside                                     -> evaluate evaluatemagick evaluatefuse;
          evaluatemagick                                        -> @button="magick" ;
          evaluatefuse                                          -> @button="fuse" ;
          evaluate:beside             "evaluate"                -> "on" | "";
        sharpen_evaluate:beside       "sharpen 3x1"             -> @button="evaluate" "on" | "";
        compose:beside                "compose"                 -> @button="evaluate" "on" | "";

      runbatchframe "Batch processing" -> batchblockline batchallline;
        batchblockline -> runbatch1 runbatch2 runbatch3;
          runbatch1:beside            "batch block 1"           -> "batchblock1" | "" @button="run";
          runbatch2:beside            "batch block 2"           -> "batchblock2" | "" @button="run";
          runbatch3:beside            "batch block 3"           -> "batchblock3" | "" @button="run";
        batchallline:beside -> runbatchprocessing cmdbreak ;
          runbatchprocessing                                    -> @button="Run selected batch blocks";
          cmdbreak                                              -> @button="break" ;
        
      specialframe "Special operations" -> rulerline animatedgifline undoline ;
        rulerline:beside                                      -> ruler rulermagick rulerfuse rulerevaluate;
          rulermodecombo                                        -> @combo("100c","100p","100z","40c","40p","40z","20c","20p","20z","10c","10p","10z")="100z" ;
          rulercombo:beside           "Title:"                  -> @string ;
          rulermagick                                           -> @button="magick" ;
          rulerevaluate                                         -> @button="evaluate" ;
          rulerfuse                                             -> @button="fuse" ;
          ruler:beside                "micrometer"              -> "" rulermodecombo rulercombo;
        animatedgifline:beside                                -> animatedgif animatedgifmagick;
          animatedgifmodecombo:beside "Fuse mode:"              -> @combow("1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20")="4";
          animatedgifcombo:beside     "Distortion:"             -> @combow("20","30","40","50","60")="30";
          animatedgifmagick                                     -> @button="magick" ;
          animatedgif:beside          "animated gif:"           -> "" animatedgifmodecombo animatedgifcombo @fill ;
        undoline:beside                                       -> undo undomagick undofuse undoevaluate;
          undomagick                                            -> @button="magick" ;
          undoevaluate                                          -> @button="evaluate" ;
          undofuse                                              -> @button="fuse" ;
          undo                        "undo last step"          -> "" ;
          
      showresultframe "Show results" -> showimagebuttons showresultline @fill showresultbottomline;
        showimagebuttons:beside    -> showimageeval showimagefuse ;
          showimageeval              -> show_magick_max show_magick_mean show_magick_median show_magick_min show_video;
            show_magick_max            -> @button="magick.max";
            show_magick_mean           -> @button="magick.mean";
            show_magick_median         -> @button="magick.median";
            show_magick_min            -> @button="magick.min";
            show_video                 -> @combo("-");
          showimagefuse              -> show_fuse_max   show_fuse_mean   show_fuse_median   show_fuse_min show_animatedgif;
            show_fuse_max              -> @button="fuse.max";
            show_fuse_mean             -> @button="fuse.mean";
            show_fuse_median           -> @button="fuse.median";
            show_fuse_min              -> @button="fuse.min";
            show_animatedgif           -> @combo("-");
        showresultline             -> @text="Directories" showresultline1 showresultline2 ;
          showresultline1:beside     -> showstackshot showmagick ;
            showstackshot              -> @button="stackshot";
            showmagick                 -> @button="magick";
          showresultline2:beside     -> showfuse showcompose showevaluate;
            showfuse                   -> @button="fuse";
            showcompose                -> @button="compose";
            showevaluate               -> @button="evaluate";
        showresultbottomline:beside  -> killviewnior opendirbutton;
          killviewnior                 -> @action("killall viewnior")="killall viewnior";
          opendirbutton                -> @button="Open in file manager";
    
      deleteframe "Delete results" -> deleteline1 deleteline2 deleteall ;
        deleteline1:beside -> deletevideo deletemagick deletecache ;
        deleteline2:beside -> deletefuse deletecompose deleteevaluate ;
          deletecache        -> @button="cache" ;
          deletemagick       -> @button="magick" ;
          deletevideo        -> @button="video" ;
          deletecompose      -> @button="compose" ;
          deleteevaluate     -> @button="evaluate" ;
          deletefuse         -> @button="fuse" ;
          deleteall          -> @button="Delete all";
'
}

sendkaptain() {
  # send messages to kaptain over its stdin
  echo "$1" >&${Kaptainstdin}
#  echo "sent to kaptain: $1"
}

askkaptain() {
  # ask kaptain for value of $1
  local Answer
  kaptaingrammar | grep -q "${1:-}" || return 1
  sendkaptain "${1:-}?"
  read Answer <&${Kaptainstdout}
  [ -z "$Answer" ] && return 1
  echo "$Answer"
  return 0
}

kaptain_update() {
  local Stackdir Cmdstatus
  local Line Shortcut Comboline
  Stackdir="$(storeinfo dump stackshotdir)"
  
  # update working directory
  sendkaptain "choosedir='$Stackdir'"
  
  # update delete buttons
  [ -d "$Stackdir/magick" ]                       && sendkaptain "deletemagick='magick'"         || sendkaptain "deletemagick='-'"
  [ -d "$Stackdir/evaluate" ]                     && sendkaptain "deleteevaluate='evaluate'"     || sendkaptain "deleteevaluate='-'"
  [ -d "$Stackdir/compose" ]                      && sendkaptain "deletecompose='compose'"       || sendkaptain "deletecompose='-'"
  [ -d "$Stackdir/fuse" ]                         && sendkaptain "deletefuse='fuse'"             || sendkaptain "deletefuse='-'"
  [ -d "$Stackdir/video" ]                        && sendkaptain "deletevideo='video'"           || sendkaptain "deletevideo='-'"
  check_dirglob "$Stackdir/*.bak $Stackdir/cache" && sendkaptain "deletecache='cache'"           || sendkaptain "deletecache='-'"
      
  [ -d "$Stackdir/stackshot" ]                    && sendkaptain "showstackshot='stackshot'"     || sendkaptain "showstackshot='-'"
  [ -d "$Stackdir/magick" ]                       && sendkaptain "showmagick='magick'"           || sendkaptain "showmagick='-'"
  [ -d "$Stackdir/evaluate" ]                     && sendkaptain "showevaluate='evaluate'"       || sendkaptain "showevaluate='-'"
  [ -d "$Stackdir/compose" ]                      && sendkaptain "showcompose='compose'"         || sendkaptain "showcompose='-'"
  [ -d "$Stackdir/fuse" ]                         && sendkaptain "showfuse='fuse'"               || sendkaptain "showfuse='-'"
  
  # animated gifs 
  for Line in $(fileglob "$Stackdir/video/*.gif"); do
    Shortcut="$(rev <<< "$Line" | cut -d. -f1-4 | rev)"
    Comboline="$Comboline,'$Shortcut'"
  done
  Comboline="${Comboline#,}"
  [ -z "$Comboline" ] && Comboline="'-'"
  sendkaptain "show_animatedgif($Comboline)=''"
  
  # videos
  for Line in $(fileglob "$Stackdir/video/*.mp*"); do
    Shortcut="$(rev <<< "$Line" | cut -d. -f1-3 | rev)"
    Comboline="$Comboline,'$Shortcut'"
  done
  Comboline="${Comboline#,}"
  [ -z "$Comboline" ] && Comboline="'-'"
  sendkaptain "show_animatedgif($Comboline)=''"
      
  check_fileglob "$Stackdir/evaluate/*.magick.*" && {
    sendkaptain "show_magick_max='magick.max'" 
    sendkaptain "show_magick_mean='magick.mean'" 
    sendkaptain "show_magick_median='magick.median'" 
    sendkaptain "show_magick_min='magick.min'" 
  } || {
    sendkaptain "show_magick_max='-'"
    sendkaptain "show_magick_mean='-'"
    sendkaptain "show_magick_median='-'"
    sendkaptain "show_magick_min='-'"
  }
      
  check_fileglob "$Stackdir/evaluate/*.fuse.*" && {
    sendkaptain "show_fuse_max='fuse.max'" 
    sendkaptain "show_fuse_mean='fuse.mean'" 
    sendkaptain "show_fuse_median='fuse.median'" 
    sendkaptain "show_fuse_min='fuse.min'" 
  } || {
    sendkaptain "show_fuse_max='-'"
    sendkaptain "show_fuse_mean='-'"
    sendkaptain "show_fuse_median='-'"
    sendkaptain "show_fuse_min='-'"
  }
  
  Cmdstatus="$(storeinfo dump status)"
  case $Cmdstatus in
    error|idle) showpercent $Cmdstatus ;;
  esac
  
  # update preview
  kaptain_update_preview
}

kaptain_update_preview() {
  local Stackdir Currentimage Image Cachedir Imagelist Imagenumber
  
  # check if currently in valid dir, otherwise clear display
  storeinfo test stackshotdir_valid || {
    storeinfo drop showimage
    return 0
  }
  
  Stackdir="$(storeinfo dump stackshotdir)"
  
  # check if an image of current stackdir is shown
  Currentimage="$(storeinfo dump showimage)"
  grep -q "$Stackdir" <<< "$Currentimage" && [ -e "$Currentimage" ] && showimage "$Currentimage" && return 0
  
  # check for results
  Image="$(fileglob "$Stackdir/evaluate/*fuse.median*")"
  [ -e "$Image" ] && showimage "$Image" && return 0
  
  Image="$(fileglob "$Stackdir/evaluate/*magick.max*")"
  [ -e "$Image" ] && showimage "$Image" && return 0
  
  Image="$(fileglob "$Stackdir/*fuse.median*" | head -n1)"
  [ -e "$Image" ] && showimage "$Image" && return 0

  Imagelist="$(fileglob "$Stackdir/magick/*")"
  [ "$Imagelist" ] &&{
    Imagenumber="$(grep -c . <<< "$Imagelist")"
    Image="$(head -n$((Imagenumber/3)) <<< "$Imagelist" | tail -n1)"
    showimage "$Image"
    return 0
  }
  
  Imagelist="$(fileglob "$Stackdir/stackshot/*")"
  [ "$Imagelist" ] &&{
    Imagenumber="$(grep -c . <<< "$Imagelist")"
    Image="$(head -n$((Imagenumber/2)) <<< "$Imagelist" | tail -n1)"
    showimage "$Image"
    return 0
  }
  
  return 1
}

showpercent() {
  local Percent Part Full Percentimage
  
  Percentimage="$Wizardcache/percent.png"
  Part="${1:-}"
  Full="${2:-1}"
  
  case "$Part" in
    idle) Percentimage="p_idle.png" ;;
    ERROR) Percentimage="p_error.png" ;;
    *)
      Percent="$(( 100 * Part / Full ))"
      Percentimage="p_$Percent.png" 
    ;;
  esac
  Percentimage="$Percentcachedir/$Percentimage"

  [ -e "$Percentimage" ] || case "$Part" in
    idle)  convert -size 100x20 xc:transparent -fill black -pointsize 20 -draw "text 40,18 'idle'"   "$Percentimage" ;;
    error) convert -size 100x20 xc:transparent -fill red   -pointsize 20 -draw "text 40,18 'ERROR'"  "$Percentimage" ;;
    *)     convert -size 100x20 xc:transparent -fill green1 -draw "rectangle 0,0,$((Percent * 1)),20" -fill black -pointsize 20 -gravity center -draw "text 0,0 '${Percent}%'" "$Percentimage" ;;
  esac
  sendkaptain "cmdpercent('$Percentimage')=''"
}

parse_kaptainsignal() {
  local Kaptainsignal
  local Command Argument Functionmode Functionoption Stackdir Newstackdir Projecthome
  local Image
  local Iterate
  
  Kaptainsignal="${1:-}"
  Stackdir="$(storeinfo dump stackshotdir)"
  Projecthome="$(storeinfo dump projecthome)"
  
  case $Kaptainsignal in
    refreshbutton) 
      kaptain_update
    ;;
    cmdbreak)
      worknote "Sending BREAK to current action"
      storeinfo "cmdbreak=yes"
    ;;
    choosedirguibutton)
      worknote "Generating GUI"
      Newstackdir="$(choose_stackshot "$Projecthome")"
      check_stackdir "$Newstackdir"
      kaptain_update
    ;;
    opendirbutton)
      thunar "${Stackdir:-$Projecthome}" &
    ;;
    delete*) 
      cmd -f $Kaptainsignal -t "$Stackdir"
    ;;
    show_animatedgif*|show_video*)
      Image="$(echo "$Kaptainsignal" | cut -d: -f2-)"
      Image="$Stackdir/video/*.$Image"
      showvideo "$(fileglob "$Image")"
    ;;
    show_*)
      Image="$(echo "$Kaptainsignal" | cut -d_ -f2- | tr _ . )"
      Image="$Stackdir/evaluate/*.$Image.*"
      showimage "$(fileglob "$Image")"
    ;;
    show*)
      showimage "$Stackdir/${Kaptainsignal#show}/*"
    ;;
    
    evaluate*|compose|fuse)
      cmd -f $Kaptainsignal -t $Stackdir
    ;;
    sharpen_evaluate)
      cmd -f sharpenevaluate -o 3x1 -t "$Stackdir"
    ;;
    
    *magick|*compose|*evaluate|*fuse)
      Command="$Kaptainsignal"
      Command="${Command%magick}"
      Command="${Command%evaluate}"
      Command="${Command%evaluate}"
      Command="${Command%fuse}"
      Functionmode="$(askkaptain "${Command}modecombo")"
      Functionoption="$(askkaptain "${Command}combo")"
      case "$Command" in
        applyall) 
          Functionoption="$(getbatch1)"
          Kaptainsignal="wizard${Kaptainsignal#applyall}"
        ;;
        meanbalance)
          Functionoption="mean"
          Kaptainsignal="whitebalance${Kaptainsignal#meanbalance}"
        ;;
      esac
      Command="${Command%_}"
      
      cmd -f "$Kaptainsignal" -m "$Functionmode" -o "$Functionoption" -t "$Stackdir"
    ;;
    
    align_vidstab?button)
      Iterate=$(echo $Kaptainsignal | tr -d -c "0-9")
      Functionmode="$(askkaptain "align_vidstab${Iterate}modecombo")"
      Functionoption="$(askkaptain "align_vidstab${Iterate}combo")"
      cmd -f align_vidstab -m "$Functionmode" -o "$Functionoption" -t "$Stackdir"
    ;;
    
    runbatch1) 
      runbatch1 "$Stackdir"
      note "Batch 1 is ready."
    ;;
    runbatch2) 
      runbatch2 "$Stackdir"
      note "Batch 2 is ready."
    ;;
    runbatch3) 
      runbatch3 "$Stackdir"
      note "Batch 3 is ready."
    ;;
    runbatchprocessing)
      askkaptain "runbatch1" >/dev/null && runbatch1 "$Stackdir"
      askkaptain "runbatch2" >/dev/null && runbatch2 "$Stackdir"
      askkaptain "runbatch3" >/dev/null && runbatch3 "$Stackdir"
      note "Batch all is ready."
    ;;
    *)
      failure "Unknown signal: $Kaptainsignal"
    ;;
  esac
}

## sub GUIs

choose_stackshot() {
  # GUI to choose stackshot. Preview of median images. Sorted by project dirs.
  local Dirlist Imagelist
  local Allprojects Entrylist Projectimages Projectline
  local Projecthome Projectdir Oldprojectdir
  local Count Dircount Dir Image
  local FDin FDout
  
  Projecthome="$(storeinfo dump projecthome)"
  Projecthome="${1:-$Projecthome}"
  cd "$Projecthome"
  
  # generate empty X image for unfused stackshots
  Emptyimage=$Thumbnaildir/empty.png
  [ -e "$Emptyimage" ] || convert caption:X $Emptyimage
  
  # get list of stackshot dirs and median images
  Dirlist="$(find -name stackshot -type d | sed s%/stackshot%% | sort -V)"
  for Dir in $Dirlist; do
    Image="$(find $Dir/*fuse.median* 2>/dev/null | head -n1)"
    Imagelist="$Imagelist
$Image"
  done
  Imagelist="$(tail -n+2 <<< "$Imagelist")"
  Dircount="$(grep -c . <<< "$Dirlist")"

  Count=0
  for Dir in $Dirlist EOL ; do
    Count=$((Count +1))
    showpercent "$Count" "$Dircount"
    
    # generate thumbnail. Check existing thumbnail with md5
    Image="$(sed "${Count}q;d" <<< "$Imagelist")"
    Image="${Image:-$Emptyimage}"
    Md5="$(md5sum "$Image" | cut -d' ' -f1)"
    Destinationfile=$Thumbnaildir/$(basename "$Image").$Md5.png
    [ -e "$Destinationfile" ] || convert "$Image" -resize 256x256 "$Destinationfile"
    
    # Check current project dir
    Projectdir="$(dirname $Dir)"

    # Checking a project dir is ready
    [ "$Projectdir" != "$Oldprojectdir" ] && {
      [ "$Projectline" ] && {
        # montage of all stackshot images in a project dir
        #Projectimages="$(sort <<< "$Projectimages")"
        Md5="$(cat $Projectimages | md5sum | cut -d' ' -f1)"
        Montagefile="$Thumbnaildir/$(basename $Projectdir).$Md5.png"
        [ -e "$Montagefile" ] || montage $Projectimages -tile x1 -geometry 100x100+5+5 $Montagefile
        
        # entry of subtree: montageimage + pjoject directory. Childs are stackshots.        
        Projectline="project$Count:tree '{$Montagefile}$Oldprojectdir' -> $Projectline"
        Allprojects="$Allprojects project$Count"
        Entrylist="$Entrylist
$Projectline ;"
      }
      
      [ "$Dir" = "EOL" ] && break
      
      Oldprojectdir="$Projectdir"
      Projectline=""
      Projectimages=""
      Montagefile=""
    }
    
    # add stackshot to subtree list
    Projectline="$Projectline stackshot$Count"
    
    # add stackshot
    Entrylist="$Entrylist
  stackshot$Count:beside '{$Destinationfile}$Dir' -> @dump('$Dir')='Choose this stackshot' @close='Cancel';"
  
    # add image to montage list
    Projectimages="$Projectimages
$Image"
  done

  echo "#! /usr/bin/kaptain
start 'Choose a stackshot' -> frame1;
  frame1:tree -> $Allprojects ;
$Entrylist
" > $Thumbnaildir/choose_stackshot.kaptain
  Dir="$(kaptain $Thumbnaildir/choose_stackshot.kaptain)"
  realpath "$Dir"
}

choose_fuseimages() {

  Wizardcache=/tmp
  Imagelist=""
  Entrylist=""
  Entryline=""
  Sourcedir=/home/lauscher/Bilder/ardustack/test/fuse
  Count=0
  for Image in $Sourcedir/*; do
    Count=$((Count+1))
    Imagelist="$Imagelist
$Image"
    Entryline="$Entryline image$Count"
    Entrylist="$Entrylist
    image$Count:beside '$Count' -> @button('$Image')='$(basename $Image)' '$(basename $Image)' | '' ;"
  done
  echo "#! /usr/bin/kaptain
start -> frameset;
  frameset:beside:framed -> framelist framepreview frameexiv;
    framelist    -> list;
    framepreview -> @icon('/home/lauscher/Bilder/ardustack/test/fuse/np.test.fuse06.jpg');
    frameexiv     -> exiv;
  exiv -> @text='' ;
  list -> $Entryline ;
$Entrylist" > $Wizardcache/test.kaptn
  cat $Wizardcache/test.kaptn
  
  rm $Wizardcache/test.fifo
  rm $Wizardcache/test11.fifo
  mkfifo $Wizardcache/test.fifo
  mkfifo $Wizardcache/test11.fifo
  exec {FDin}<>$Wizardcache/test.fifo
  exec {FDout}<>$Wizardcache/test11.fifo
  
  kaptain --stdio $Wizardcache/test.kaptn <&${FDin} >&${FDout} &
  Kaptainpid=$!
  
  while ps -p $Kaptainpid >/dev/null; do
    read -t1 Kaptainsignal <&${FDout}
    echo "Signal: $Kaptainsignal"
    Exiftext=""
    for Exifline in enfuse --exposure-weight=0.0  --saturation-weight=0.0  --contrast-weight=1.0  --hard-mask  --contrast-edge-scale=0  --contrast-window-size=3 --gray-projector=luminance ;do
      Exiftext="$Exiftext \n $Exifline"
    done
    echo "exiv=\"$Exiftext\"" >&${FDin}
  done 

}

cropgeometry_interactive() {
  # Interactive dialog to choose a crop geometry
  #   $1   Image to crop.
  #   $2   Cache folder to store files. Clean up yourself.
  #   $3   Preset crop geometry (optional). Default: entire image
  # Result:
  #   return 0 : echo crop geometry WxH+X+Y
  #   return 1 : no output
  # Dependencies:
  #   imagemagick
  #   kaptain (https://github.com/mviereck/kaptain)

  local Kaptaingrammarfile Kaptainpid Kaptainstdinfifo Kaptainstdoutfifo Kaptainsignal Kaptainstdin Kaptainstdout
  local Image Imagempc Imagewidth Imageheight
  local CropX CropY CropW CropH Cropgeometry
  local Rotate
  local Refresh Stepsize Return
  local Cachedir Cropgeometryimage Cropimagempc
  
  Image="${1:-}"
  Cachedir="${2:-}"
  Cropgeometry="${3:-}"
  
  checkvar -e crop_interactive Image    "$Image"    || return 1
  checkvar -d crop_interactive Cachedir "$Cachedir" || return 1
  
  worknote "Interactive choice of crop geometry of $Image"
  
  Cropgeometryimage="$Cachedir/cropgeometry.gui.tif"
  Cropimagempc="$Cachedir/crop.mpc"
  
  # check source for mpc format, convert if not
  [ "$Image" = "${Image%.mpc}" ] && {
    Imagempc="$Cachedir/cropgeometry.source.mpc"
    convert "$Image" "$Imagempc"
  } || {
    Imagempc="$Image"
  }
  
  Stepsize=50
  Rotate=0
  Refresh="yes"

  Imagewidth=$(convert  -format '%w'  $Imagempc info:)
  Imageheight=$(convert -format '%h'  $Imagempc info:)
    
  grep -q "x" <<< "$Cropgeometry" && grep -q "+" <<< "$Cropgeometry" && {
    CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
    CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
    CropW=$(cut -dx -f1 <<< "$Cropgeometry")
    CropH=$(cut -dx -f2 <<< "$Cropgeometry")
    CropH=$(cut -d+ -f1 <<< "$CropH")
  } || {
    CropX=0
    CropY=0
    CropW=$((Imagewidth-1))
    CropH=$((Imageheight-1))
  }
  
  Kaptaingrammarfile="$Cachedir/crop.kaptain.grammar"
  Kaptainstdinfifo="$Cachedir/crop.kaptain.stdin"
  Kaptainstdoutfifo="$Cachedir/crop.kaptain.stdout"
  mkfifo   $Kaptainstdinfifo
  mkfifo   $Kaptainstdoutfifo
  exec  {Kaptainstdin}<>$Kaptainstdinfifo
  exec  {Kaptainstdout}<>$Kaptainstdoutfifo
  
  echo "#! /usr/bin/kaptain
start 'Choose geometry' -> frameset ;
  frameset:beside -> frameleft ;
    frameleft:framed  -> arrowline stepsizeframe rotateline geometryline buttonline cmdpercent;
    
  cmdpercent    -> @icon;
  
  arrowline:beside:framed -> arrowposframe arrowsizeframe ;
    arrowposframe 'Position:' -> arrowpos1 arrowpos2 arrowpos3;
      arrowpos1:beside -> @fill   postop    @fill;
      arrowpos2:beside -> posleft @fill     posright ;
      arrowpos3:beside -> @fill   posbottom @fill;
        posleft          -> @button=' < ';
        posright         -> @button=' > ';
        postop           -> @button=' ^ ';
        posbottom        -> @button=' v ';
    arrowsizeframe 'Size:' -> size1 size2 size3;
      size1:beside     -> @fill    sizetop    @fill;
      size2:beside     -> sizeleft @fill      sizeright ;
      size3:beside     -> @fill    sizebottom @fill;
        sizeleft         -> @button=' < ';
        sizeright        -> @button=' > ';
        sizetop          -> @button=' ^ ';
        sizebottom       -> @button=' v ';
    rotateline:beside 'Rotate:'  -> rotatecombo rotateapply trim;
      rotatecombo       -> @combow('0','0.5','-0.5','1','-1','1.5','-1.5','2','-2','2.5','-2.5','3','-3','5','-5','10','-10','45','-45','90','180','270')='0';
      rotateapply       -> @button='apply';
      trim              -> @button='trim';
  stepsizeframe 'Step size' -> stepsize1 stepsize2;
  stepsize1:beside  -> ss1  ss2   ss5   ss10  ss25 ;
  stepsize2:beside  -> ss50 ss100 ss250 ss500 ss1000 ;
    ss1           -> @button='1';
    ss2           -> @button='2';
    ss5           -> @button='5';
    ss10          -> @button='10';
    ss25          -> @button='25';
    ss50          -> @button='50';
    ss100         -> @button='100';
    ss250         -> @button='250';
    ss500         -> @button='500';
    ss1000        -> @button='1000';
  geometryline:beside -> geometry geometryapply;
    geometry:beside  'Crop geometry:'      -> @string='$Cropgeometry';
    geometryapply                          -> @button='apply';
  buttonline:beside -> ok cancel ;
    ok                                     -> @button=' OK' ;
    cancel                                 -> @close='Cancel';
" >> $Kaptaingrammarfile
  kaptain --stdio $Kaptaingrammarfile <&${Kaptainstdin} >&${Kaptainstdout} & Kaptainpid=$!

  Refresh="yes"
  while ps -p $Kaptainpid >/dev/null; do

    [ "$Refresh" = "yes" ] && {
      Cropgeometry="${CropW}x${CropH}+$CropX+$CropY"
      showpercent 10 100
      convert $Imagempc -background '#00000000' -rotate $Rotate +repage -fill none -stroke red -strokewidth 1 -draw "rectangle $CropX,$CropY $((CropX+CropW-1)),$((CropY+CropH-1))" "$Cropgeometryimage"
      showpercent 60 100
      showimage "$Cropgeometryimage"
      echo "geometry='$Cropgeometry'" >&${Kaptainstdin}
      Refresh="no"
      showpercent 100 100
    }

    Imagewidth=$(convert  -format '%w'  $Cropgeometryimage info:)
    Imageheight=$(convert -format '%h'  $Cropgeometryimage info:)
    
    read -t1 Kaptainsignal <&${Kaptainstdout}
    
    ifcmdbreak && Return=1 && break
    
    [ "$Kaptainsignal" ] && {
      Kaptainsignal="${Kaptainsignal%:pressed}"
      case $Kaptainsignal in
        posleft)    CropX=$((CropX-$Stepsize)) ;;
        posright)   CropX=$((CropX+$Stepsize)) ;;
        postop)     CropY=$((CropY-$Stepsize)) ;;
        posbottom)  CropY=$((CropY+$Stepsize)) ;;
        sizeleft)   CropW=$((CropW-$Stepsize)) ;;
        sizeright)  CropW=$((CropW+$Stepsize)) ;;
        sizetop)    CropH=$((CropH-$Stepsize)) ;;
        sizebottom) CropH=$((CropH+$Stepsize)) ;;
        ss*)        Stepsize="$(cut -c3- <<< "$Kaptainsignal")" ;;
        rotatecombo*) Rotate="$(cut -d: -f2 <<< "$Kaptainsignal")" ;;
        rotateapply) 
          echo "rotatecombo?" >&${Kaptainstdin}
          read Rotate <&${Kaptainstdout}
        ;;
        geometryapply)
          echo "geometry?" >&${Kaptainstdin}
          read Cropgeometry <&${Kaptainstdout}
          [ "$Cropgeometry" ] && {
            CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
            CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
            CropW=$(cut -dx -f1 <<< "$Cropgeometry")
            CropH=$(cut -dx -f2 <<< "$Cropgeometry")
            CropH=$(cut -d+ -f1 <<< "$CropH")
          }
        ;;
        trim)
          convert "$Imagempc" -background '#00000000' -rotate $Rotate +repage "$Cropimagempc"
          Cropgeometry="$(trim_hard "$Cropimagempc" "$Cropgeometry" )"
          [ "$Cropgeometry" ] && {
            CropX=$(cut -d+ -f2 <<< "$Cropgeometry")
            CropY=$(cut -d+ -f3 <<< "$Cropgeometry")
            CropW=$(cut -dx -f1 <<< "$Cropgeometry")
            CropH=$(cut -dx -f2 <<< "$Cropgeometry")
            CropH=$(cut -d+ -f1 <<< "$CropH")
          }
        ;;
        ok)         Return=0; break ;;
      esac
      [ "$CropX" -lt "0" ] && CropX=0
      [ "$CropY" -lt "0" ] && CropY=0
      [ "$CropW" -lt "1" ] && CropW=1
      [ "$CropH" -lt "1" ] && CropH=1
      [ "$CropX" -gt "$Imagewidth" ]  && CropX=$Imagewidth
      [ "$CropY" -gt "$Imageheight" ] && CropY=$Imageheight
      [ "$((CropX+CropW-1))" -gt "$Imagewidth" ]  && CropW=$((Imagewidth-CropX))
      [ "$((CropY+CropH-1))" -gt "$Imageheight" ] && CropH=$((Imageheight-CropY))
      Refresh="yes"
    }
  done 
  
  worknote "trim_hard(): final check"
  convert "$Imagempc" -background '#00000000' -rotate $Rotate +repage "$Cropimagempc"
  Cropgeometry="$(trim_hard "$Cropimagempc" "$Cropgeometry")" # final check
          
  exec {Kaptainstdin}>&- {Kaptainstdout}>&-
  ps -p $Kaptainpid >/dev/null && kill $Kaptainpid
  [ "$Return" = "0" ] && {
    [ "$Rotate" = "0" ] && echo "$Cropgeometry" || echo "$Cropgeometry:$Rotate"
    return 0
  }
  return 1
}

#### headquarter

cmd() {
  local Arg Command
  
  #parse_cmd "$@"

  for Arg in "$@"; do
    Command="$Command '$Arg'"
  done
#  echo "$Command" >> $Commandstackfifo
  echo "$Command" >&${FDcmd}
}

ifcmdbreak() {
  storeinfo test cmdbreak && return 0
  return 1
}

stack_cmd() {
  local Command Commandpid Return
  while :; do
    read -t1 Command <&${FDcmd}
    eval set -- $Command 
    storeinfo test cmdbreak && {
      [ "$Command" ] || storeinfo drop cmdbreak
      Command=""
    }
    [ "$Command" ] && {
      eval set -- $Command 
      
      #sendkaptain "wizardcmd=' $*'"
      showpercent "0" "100"
      storeinfo "status=work"
      
      parse_cmd "$@" &
      Commandpid=$!
      storeinfo "cmdpid=$Commandpid"
      wait $Commandpid
      Return=$?
      storeinfo drop cmdpid
      
      case $Return in
        0)
          storeinfo "status=idle"
          showpercent idle
          #sendkaptain "wizardcmd=''"
        ;;
        *)
          storeinfo "status=error"
          showpercent error
          storeinfo "cmdbreak=yes"
        ;;
      esac
    }
  done
}

parse_cmd() {
  local $Batchlocal
  local Commandline Return= 

  parse_batchoptions "$@" || return 1
  Commandline="$@"
    
  case "$Function" in
    deleteall)   myrm "$Targetdir"/*.bak "$Targetdir/cache" "$Targetdir/magick" "$Targetdir/compose" "$Targetdir/evaluate" "$Targetdir/fuse" "$Targetdir/video" ; Return=0 ;;
    deletecache) myrm "$Targetdir/cache" "$Targetdir"/*.bak ; Return=0 ;;
    delete*)     myrm "$Targetdir/${Function#delete}" "$Targetdir/${Function#delete}.bak" ; Return=0 ;;
   
    align_vidstab)
      batch_function -f align_vidstab -m "$Functionmode" -o "$Functionoption" -t "$Targetdir"
      Return=$?
    ;;
    animatedgif*|brightness*|contrast*|crop*|gamma*|kuwahara*|level*|prepare*|sharpen*|stretch*|undo*|whitebalance*|ruler*|wizard*)
      Function="${Function%magick}"
      batch_function -f $Function -m "$Functionmode" -o "$Functionoption" -t "$Targetdir"
      Return=$?
    ;;
    evaluate*|compose*|fuse)
      batch_function -f $Function -m "${Functionmode:-all}" -t "$Targetdir"
      Return=$?
    ;;
    showimage)
      showimage "$Sourcedir/$Sourcefileglob"
      Return=0
    ;;
  esac
 
  kaptain_update

  case $Return in
    0) 
      historyentry "$Commandline"
      return 0
    ;;
    *) return ${Return:-1} ;;
  esac
}

#### main

declare_variables() {

  Wizardcache="$HOME/.cache/fusewizard"
  Wizardlocalshare="$HOME/.local/share/fusewizard"
  Percentcachedir="$Wizardlocalshare/percent"
  Thumbnaildir="$Wizardlocalshare/thumbnails"
  
  Configfile="$HOME/.config/fusewizardrc"
  
  Projecthome="$HOME/Bilder/ardustack"
  Gallerydir="$HOME/Gallery"
  
  Wizardthreads="$(nproc)"
#  Wizardthreads="3"
  Wizardthreads="${Wizardthreads:-1}"
  for i in $Wizardthreads; do
    Multicoreprocess[$i]=""
    Multicoreimage[$i]=""
  done
  Multicoreprocesscount=0
  
  Batchlocal="Targetdir Sourcedir Sourcefileglob Destinationdir Destinationfile Cachedir Function Functionmode Functionoption"
  Convert="convert -quality 100%"

  Commandstackfifo=$Wizardcache/commandstack
  
  Wizardlogfile=$Wizardcache/fusewizard.log
  Wizardlogfifo=$Wizardcache/fusewizard.log.fifo
  
  Wizardmessagefile=$Wizardcache/fusewizard.message.log
  Wizardmessagefifo=$Wizardcache/fusewizard.message.fifo
  
  Kaptaingrammarfile=$Wizardcache/kaptain.grammar
  Kaptainstdinfifo=$Wizardcache/kaptain.stdin 
  Kaptainstdoutfifo=$Wizardcache/kaptain.stdout
  Kaptainstdin=""
  Kaptainstdout=""
  
  Storeinfofile=$Wizardcache/store.info
  Storepidfile=$Wizardcache/store.pid
    
  Imgruler="$(command -v imgruler)"
  [ -z "$Imgruler" ] && Imgruler="$(dirname $0)/imgruler"
}

create_cachefiles() {
  mkdir -p $Wizardcache
  mkdir -p $Thumbnaildir
  mkdir -p $Percentcachedir
  
  mkfifo   $Wizardlogfifo
  :>       $Wizardlogfile

  mkfifo   $Kaptainstdinfifo
  exec  {Kaptainstdin}<>$Kaptainstdinfifo
  mkfifo   $Kaptainstdoutfifo
  exec  {Kaptainstdout}<>$Kaptainstdoutfifo

  mkfifo   $Wizardmessagefifo
  exec  {FDmessage}<>$Wizardmessagefifo
  :>       $Wizardmessagefile
  
  mkfifo   $Commandstackfifo
  exec  {FDcmd}<>$Commandstackfifo
  
  :>       $Storeinfofile
  :>       $Storepidfile
}

check_dependencies() {
  local Dependency
  for Dependency in kaptain convert enfuse ffmpeg geeqie viewnior $Imgruler; do
    command -v $Dependency >/dev/null || failure "Dependency $Dependency not found. Please install $Dependency."
  done
  ffmpeg 2>&1 | grep -q libvidstab || failure "Dependency libvidstab in ffmpeg not found. Please install ffmpeg with vidstab."
}

finish() {
  trap - EXIT
  while read Pid; do ### FIXME check command
    kill $Pid
  done <$Storepidfile
  exec {Kaptainstdin}>&-
  exec {Kaptainstdout}>&-
  rm -R $Wizardcache
}

main() {
  local Kaptainpid Kaptainsignal
  trap finish EXIT
  
  # init
  declare_variables
  create_cachefiles
  
  [ -e "$Configfile" ] && source "$Configfile"
  
  storeinfo "cache=$Wizardcache"
  storeinfo "projecthome=$Projecthome"
  storeinfo "stackshotdir=$Projecthome"
  storeinfo "gallerydir=$Gallerydir"
  storeinfo "status=idle"
  
  # start kaptain
  kaptaingrammar > $Kaptaingrammarfile
  #nl -ba $Kaptaingrammarfile
  kaptain --stdio $Kaptaingrammarfile <&${Kaptainstdin} >&${Kaptainstdout} & Kaptainpid=$!
  storepid $Kaptainpid
  
  # messages
  showlog      & storepid $!
  showmessages & storepid $!
  exec 1>$Wizardlogfifo 2>&1
  stack_cmd    & storepid $!
  
  check_dependencies
  
  kaptain_update

  # watch signals of kaptain
  while ps -p $Kaptainpid >/dev/null; do
    read -t1 Kaptainsignal <&${Kaptainstdout}
    [ "$Kaptainsignal" ] && {
      echo "Signal from kaptain: $Kaptainsignal"
      grep -q ":on"      <<< "$Kaptainsignal" && Kaptainsignal=""
      grep -q ":off"     <<< "$Kaptainsignal" && Kaptainsignal=""
      grep -q ":pressed" <<< "$Kaptainsignal" && {
        Stackdir="$(askkaptain choosedir)"
        [ "$Stackdir" != "$(storeinfo dump stackshotdir)" ] && {
          check_stackdir "$Stackdir"
          kaptain_update
        }
      }
      Kaptainsignal="${Kaptainsignal%:pressed}"
    }
    [ "$Kaptainsignal" ] && parse_kaptainsignal "$Kaptainsignal"
  done
}

main "$@"
finish

##### ToDo ####
# configuration dialog:
#  - project directory
#  - gallery directory
#  - number of threads
# cli support
# documentation in all functions
# Features:
#  - choice of setting sets
#  - config of fuse settings
#  - checkbutton: "allow invalid directory structure"
#  - stack video
#  - clean entire project home: cache, backup, magick (note in history)
#  - find all gifs
# Fix:
#  - wrong failure-undo with magick -> evaluate, probably with other cross functions, too -> fixed, CHECK
#  ardustack - replace align_image_stack for median with vidstab


animatedgif_bak() {
  # Generate animated GIF from stackshot.
  # Helps to visualize diferent layers and gives some 3D effect
  #
  # Fusemode       See fuse(). ($Functionmode)
  # Distortion     Distortion between lowest and highest layer. ($Functionoption)
  # Delay          Delay between frames
  # Staticlayer    Relative position of static layer that won't move. 0 means lowest layer, 1/2 means middle layer, 1 means top layer
  #
  local $Batchlocal
  local Fusemode Distortion Delay Sequence Staticlayer
  local Distortdir Distortimage Destinationfile Destinationfilebasename Imagebasename
  local Imagewidth Imageheight Cropgeometry
  local Count Iteration Xpos Ypos
  local Image Imagelist
  local Xpos Ypos Offset Border 
  local Position Positionlist Positionnumber
  local Sequence Sequencename Sequencenumber
  
  parse_batchoptions "$@" || return 1
  
  Fusemode="${Functionmode:-1}"
  Distortion="${Functionoption:-10}"
  Delay="10"
  Staticlayer="1/5"
  Raster="4"
  
  # Revert image list to work from bottom to top
  Imagelist="$(fileglob "$Sourcedir/$Sourcefileglob")"
  Imagelist="$(sort -V -r <<< "$Imagelist")"
  Imagenumber="$(grep -c . <<< "$Imagelist")"
  
  # crop lost borders
  Imagewidth=$($Convert  -format '%w'  "$(head -n1 <<< "$Imagelist")" info:)
  Imageheight=$($Convert -format '%h'  "$(head -n1 <<< "$Imagelist")" info:)
  Border="$((Distortion - Distortion * $Staticlayer))"  # wrong result if Staticlayer>1/2 ?
#  Cropgeometry="$((Imagewidth - Border * 2 - 1))x$((Imageheight - Border * 2 - 1))+$Border+$Border"
  Cropgeometry="$((Imagewidth - Border * 2 - 1))x$((Imageheight - Border * 2 - 1))"

  Destinationfilebasename="${Destinationfile:-animated}"
  
  # offset factor, distortion between neighboured layers
  Offset="$(awk "BEGIN {print $Distortion / ( $Imagenumber * $Raster ) }")"
  
  # Position raster
  #
  # -3x-3 -3x-2 -3x-1  -3x0   -3x1  -3x2  -3x3
  #
  # -2x-3 -2x-2 -2x-1  -2x0   -2x1  -2x2  -2x3
  #
  # -1x-3 -1x-2 -1x-1  -1x0   -1x1  -1x2  -1x3
  #
  #  0x-3  0x-2  0x-1   0x0    0x1   0x2   0x3
  #
  #  1x-3  1x-2  1x-1   1x0    1x1   1x2   1x3
  #
  #  2x-3  2x-2  2x-1   2x0    2x1   2x2   2x3
  #
  #  3x-3  3x-2  3x-1   3x0    3x1   3x2   3x3
  
  Sequencenumber="5"
  
  Sequencename[1]="knot_small"
  Sequence[1]="0x0  0x-1 -1x-1 -1x0  
               0x0  1x0   1x1   0x1
               0x0  0x-1  1x-1  1x0
               0x0 -1x0  -1x1   0x1"
            
  Sequencename[2]="dagaz"
  Sequence[2]="0x0  -1x1 -2x2 -3x3
              -2x3  -1x3  0x3  1x3   2x3   3x3
               2x2   1x1  0x0 -1x-1 -2x-2 -3x-3
              -2x-3 -1x-3 0x-3 1x-3  2x-3  3x-3
               2x-2  1x-1"
            
  Sequencename[3]="knot"
  Sequence[3]="0x0 -1x0 -2x0 -3x-1 -3x-2 -2x-3 -1x-3 0x-2 0x-1
               0x0  0x1  0x2  1x3   2x3   3x2   3x1  2x0  1x0
               0x0 -1x0 -2x0 -3x1  -3x2  -2x3  -1x3  0x2  0x1
               0x0  0x-1 0x-2 1x-3  2x-3  3x-2  3x-1 2x0  1x0"
            
  Sequencename[4]="circle_left"
  Sequence[4]="-3x0 -3x1  -2x2  -1x3  0x3  1x3  2x2  3x1  3x0 3x-1 2x-2 1x-3 0x-3 -1x-3 -2x-2 -3x-1"
            
  Sequencename[5]="circle_right"
  Sequence[5]="-3x0 -3x-1 -2x-2 -1x-3 0x-3 1x-3 2x-2 3x-1 3x0 3x1  2x2  1x3  0x3  -1x3  -2x2  -3x1"
  
  for Sequencecount in $(seq $Sequencenumber); do
    for Position in ${Sequence[$Sequencecount]}; do
      Positionlist="$Positionlist
$Position"
    done
  done
  Positionlist="$(grep x <<< "$Positionlist")"
  Positionlist="$(sort <<< "$Positionlist" | uniq)"
  Positionnumber="$(grep -c . <<< "$Positionlist")"
    
  # Distort images
  Iteration=0
  for Position in $Positionlist; do
    Xpos="$(cut -dx -f1 <<< "$Position")"
    Ypos="$(cut -dx -f2 <<< "$Position")"
    worknote "animatedgif: Distorting images for position ${Xpos}x${Ypos}."
      
    Distortdir="$Cachedir/distort.$Position"
    [ -d "$Distortdir" ] || {
      mkdir -p "$Distortdir"
      
      Count=-$((Imagenumber * $Staticlayer))  # negative start value causes movement of lowest layer
      
      for Image in $Imagelist; do
        Count="$((Count +1))"
        Distortimage="$Distortdir/$(basename $Image)"
        multicore "convert $Image -gravity center -crop $Cropgeometry+$(awk "BEGIN {print $Count * $Xpos * $Offset}")+$(awk "BEGIN {print $Count * $Ypos * $Offset}") $Distortimage" "$Distortimage" || return 1
      done

      Iteration=$((Iteration + 1))
      showpercent $Iteration $((Positionnumber*2 +5))
    }
  done
  multicore_wait || return 1
  
  # fuse distorted images
  for Position in $Positionlist; do
    Iteration=$((Iteration + 1))
    Distortdir="$Cachedir/distort.$Position"
    Imagebasename="animate.$Position"
    multicore "fuse -s $Distortdir -g '*' -d $Cachedir -b $Imagebasename -m $Fusemode" || return 1
    showpercent $Iteration $((Positionnumber*2 +5))
  done
  multicore_wait || return 1
  
  for Sequence in "$Sequence_dagaz" "$Sequence_smallknot" "$Sequence_knot" "$Sequence_circleleft" "$Sequence_circleright"; do
    Iteration=$((Iteration + 1))
    Sequencename="$(head -n1 <<< "$Sequence")"
    Sequence="$(tail -n+2 <<< "$Sequence")"
    Imagelist=""
    for Position in $Sequence; do
      Image="$(fileglob "$Cachedir/*.$Position.*")"
      Imagelist="$Imagelist $Image"
    done
    Destinationfile="$Destinationdir/$Destinationfilebasename.$Sequencename.$Fusemode.$Distortion.gif"

    worknote "Generating $(basename $Destinationfile)."
    multicore "convert -delay $Delay -loop 0 $Imagelist $Destinationfile" "$Destinationfile" || return 1
    showpercent $Iteration $((Positionnumber*2 +5))
  done
  multicore_wait || return 1
}
